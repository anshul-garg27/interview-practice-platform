{
  "problem_title": "Median of Two Sorted Arrays - Part 4: Streaming Median with Sorted Arrays",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 handled static K sorted arrays with a K-way merge. Part 4 requires **dynamic streaming updates** - elements are continuously added to two arrays, and we need efficient median queries. This fundamentally changes the approach from 'compute once' to 'maintain incrementally'.",
    "new_requirements": [
      "addToFirst(x): Add element to first array with O(log n) time",
      "addToSecond(x): Add element to second array with O(log n) time",
      "getMedian(): Return current median in O(1) time",
      "Maintain state across multiple operations"
    ],
    "new_constraints": [
      "O(log n) insertion time required - sorted array insertion won't work",
      "O(1) median query time required",
      "Must handle arbitrary interleaving of add/query operations"
    ],
    "key_insight": "The two-heaps pattern is the classic solution for streaming median. A max-heap holds the smaller half, a min-heap holds the larger half. The median is always at the top(s) of the heaps. This gives O(log n) insert and O(1) query - exactly what we need!"
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "O(log n) insertion",
        "how_met": "Heap push/pop operations are O(log n). At most 3 heap operations per insert.",
        "gotchas": [
          "Python heapq is min-heap only - negate values for max-heap"
        ]
      },
      {
        "requirement": "O(1) median query",
        "how_met": "Median is always at heap tops - direct access O(1)",
        "gotchas": [
          "Must handle empty heaps",
          "Must check heap sizes for odd/even total"
        ]
      },
      {
        "requirement": "Maintain two logical arrays",
        "how_met": "API preserves the two-array interface, but internally we combine into heaps since median doesn't depend on which array elements came from",
        "gotchas": [
          "If problem required tracking array membership, would need additional data structures"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "addToFirst",
        "target": "O(log n)",
        "achieved": "O(log n)",
        "why": "At most 3 heap operations: 1 push + potential 2 for rebalance"
      },
      {
        "operation": "addToSecond",
        "target": "O(log n)",
        "achieved": "O(log n)",
        "why": "Same as addToFirst"
      },
      {
        "operation": "getMedian",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct heap top access, no traversal"
      }
    ],
    "non_goals": [
      "Tracking which array each element belongs to",
      "Supporting element deletion (would need different data structure)",
      "Querying percentiles other than median"
    ]
  },
  "assumptions": [
    "Elements are integers (matching Parts 1-3)",
    "No element removal needed - only additions",
    "Median queries can happen at any time (even with 0 elements - return 0.0)",
    "The two arrays don't need to be reconstructed - only median matters"
  ],
  "tradeoffs": [
    {
      "decision": "Two Heaps vs Sorted Array + Binary Insert",
      "chosen": "Two Heaps",
      "why": "O(log n) insert vs O(n) insert. Query is O(1) vs O(1). Clear winner.",
      "alternative": "Sorted Array",
      "when_to_switch": "Never for this problem. Only if random access by index needed."
    },
    {
      "decision": "Two Heaps vs Balanced BST",
      "chosen": "Two Heaps",
      "why": "Simpler implementation, O(1) median vs O(log n) for BST. Python/Java have built-in heaps.",
      "alternative": "TreeMap with order statistics",
      "when_to_switch": "If deletion support needed, or need to find arbitrary percentiles."
    },
    {
      "decision": "Shared heap vs Separate tracking",
      "chosen": "Shared heap",
      "why": "Median of combined elements doesn't depend on which array they came from",
      "alternative": "Track array membership",
      "when_to_switch": "If problem requires separate statistics per array"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1-3 method signatures unchanged",
      "Public streaming API: addToFirst, addToSecond, getMedian",
      "Return types and parameter types"
    ],
    "what_to_change": [
      "Added __init__ to initialize heap data structures",
      "Added _max_heap and _min_heap instance variables",
      "Added private _add_num helper method"
    ],
    "interfaces_and_boundaries": "Streaming methods are independent of static methods. Could be extracted to separate class if needed. Private _add_num encapsulates shared logic.",
    "invariants": [
      "max_heap.top <= min_heap.top (left half \u2264 right half)",
      "|len(max_heap) - len(min_heap)| <= 1 (balanced sizes)",
      "max_heap.size >= min_heap.size (max_heap is equal or 1 larger)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 3): Static K-way merge\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Arrays given upfront \u2192 Compute median  \u2502\n\u2502  [1,5,9] [2,6,10] [3,7,11]              \u2502\n\u2502           \u2193                              \u2502\n\u2502     Min Heap extracts N/2+1             \u2502\n\u2502           \u2193                              \u2502\n\u2502      Return median                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 4): Dynamic streaming\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Stream: add(1) \u2192 add(2) \u2192 median? \u2192... \u2502\n\u2502                                          \u2502\n\u2502   Max Heap         Min Heap              \u2502\n\u2502   (left half)      (right half)          \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502   \u2502 top=2 \u2502   \u2264    \u2502 top=3 \u2502            \u2502\n\u2502   \u2502   1   \u2502        \u2502   5   \u2502            \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                                          \u2502\n\u2502   Median = (2+3)/2 = 2.5 \u2190 O(1)!        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nInsert Flow (addToFirst/addToSecond):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Step 1: Decide which heap                          \u2502\n\u2502                                                    \u2502\n\u2502   if max_heap empty OR x \u2264 max_heap.top:           \u2502\n\u2502       push to max_heap (smaller half)              \u2502\n\u2502   else:                                            \u2502\n\u2502       push to min_heap (larger half)               \u2502\n\u2502                                                    \u2502\n\u2502 Step 2: Rebalance (maintain size invariant)        \u2502\n\u2502                                                    \u2502\n\u2502   if max_heap.size > min_heap.size + 1:            \u2502\n\u2502       move max_heap.top \u2192 min_heap                 \u2502\n\u2502   elif min_heap.size > max_heap.size:              \u2502\n\u2502       move min_heap.top \u2192 max_heap                 \u2502\n\u2502                                                    \u2502\n\u2502 Result: |size diff| \u2264 1, max.top \u2264 min.top        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nGet Median Flow:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 if max_heap.size > min_heap.size:                  \u2502\n\u2502     return max_heap.top        \u2190 Odd total         \u2502\n\u2502 else:                                              \u2502\n\u2502     return (max.top + min.top) / 2  \u2190 Even total   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension: Maintain Sorted Arrays",
      "description": "Keep two sorted lists. On insert, use bisect.insort to maintain order. On median query, use Part 1's binary search partition.",
      "time_complexity": "Insert: O(n), Query: O(log(min(m,n)))",
      "space_complexity": "O(m + n)",
      "why_not_optimal": "O(n) insertion is too slow for streaming. With 10^6 insertions, this becomes 10^12 operations."
    },
    {
      "name": "Optimal: Two Heaps",
      "description": "Max-heap for smaller half, min-heap for larger half. Insert goes to appropriate heap with rebalancing. Median is at heap top(s).",
      "time_complexity": "Insert: O(log n), Query: O(1)",
      "space_complexity": "O(n)",
      "key_insight": "The median divides data into two halves. Heaps naturally give us the max of left half and min of right half in O(1)."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Two Heaps for Streaming Median\n\nThe **key insight** is that we only need:\n1. The **maximum** of the smaller half\n2. The **minimum** of the larger half\n\nA **max-heap** efficiently gives us the maximum of a set, and a **min-heap** gives us the minimum.\n\n### Algorithm\n\n**On Insert:**\n1. If element \u2264 max of left half \u2192 add to left (max-heap)\n2. Otherwise \u2192 add to right (min-heap)\n3. Rebalance so sizes differ by at most 1\n\n**On Query:**\n- **Odd total**: Return top of larger heap\n- **Even total**: Return average of both tops\n\n### Why It Works\n\nAfter rebalancing:\n- `max_heap.top` = largest element in smaller half = **left median candidate**\n- `min_heap.top` = smallest element in larger half = **right median candidate**\n\nThese are exactly what we need for the median!",
    "data_structures": [
      {
        "structure": "Max Heap (via negated Min Heap)",
        "purpose": "Store smaller half, provide max in O(1)"
      },
      {
        "structure": "Min Heap",
        "purpose": "Store larger half, provide min in O(1)"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize two empty heaps (max_heap for left, min_heap for right)",
      "Step 2: On add(x): if x \u2264 max_heap.top, push to max_heap; else push to min_heap",
      "Step 3: Rebalance: if max_heap too large, move its top to min_heap; vice versa",
      "Step 4: On getMedian: if odd total, return max_heap.top; if even, return average of tops"
    ]
  },
  "solution_python_lines": [
    "import heapq",
    "from typing import List",
    "",
    "class Solution:",
    "    def __init__(self):",
    "        \"\"\"Initialize heaps for streaming median.\"\"\"",
    "        self._max_heap = []  # Left half (negated for max-heap behavior)",
    "        self._min_heap = []  # Right half",
    "    ",
    "    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:",
    "        \"\"\"Part 1: Median of two sorted arrays using binary search partitioning.\"\"\"",
    "        if len(nums1) > len(nums2):",
    "            nums1, nums2 = nums2, nums1",
    "        ",
    "        m, n = len(nums1), len(nums2)",
    "        left, right = 0, m",
    "        half = (m + n + 1) // 2",
    "        ",
    "        while left <= right:",
    "            i = (left + right) // 2",
    "            j = half - i",
    "            ",
    "            maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]",
    "            minRight1 = float('inf') if i == m else nums1[i]",
    "            maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]",
    "            minRight2 = float('inf') if j == n else nums2[j]",
    "            ",
    "            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:",
    "                if (m + n) % 2 == 1:",
    "                    return float(max(maxLeft1, maxLeft2))",
    "                else:",
    "                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2",
    "            elif maxLeft1 > minRight2:",
    "                right = i - 1",
    "            else:",
    "                left = i + 1",
    "        return 0.0",
    "    ",
    "    def findKthElement(self, nums1: List[int], nums2: List[int], k: int) -> int:",
    "        \"\"\"Part 2: Find k-th smallest element using binary elimination.\"\"\"",
    "        idx1, idx2 = 0, 0",
    "        m, n = len(nums1), len(nums2)",
    "        ",
    "        while True:",
    "            if idx1 == m:",
    "                return nums2[idx2 + k - 1]",
    "            if idx2 == n:",
    "                return nums1[idx1 + k - 1]",
    "            if k == 1:",
    "                return min(nums1[idx1], nums2[idx2])",
    "            ",
    "            half = k // 2",
    "            newIdx1 = min(idx1 + half, m) - 1",
    "            newIdx2 = min(idx2 + half, n) - 1",
    "            ",
    "            if nums1[newIdx1] <= nums2[newIdx2]:",
    "                k -= (newIdx1 - idx1 + 1)",
    "                idx1 = newIdx1 + 1",
    "            else:",
    "                k -= (newIdx2 - idx2 + 1)",
    "                idx2 = newIdx2 + 1",
    "    ",
    "    def findMedianOfKArrays(self, arrays: List[List[int]]) -> float:",
    "        \"\"\"Part 3: Median of K sorted arrays using K-way merge with min heap.\"\"\"",
    "        arrays = [arr for arr in arrays if arr]",
    "        if not arrays:",
    "            return 0.0",
    "        ",
    "        total = sum(len(arr) for arr in arrays)",
    "        if total == 0:",
    "            return 0.0",
    "        ",
    "        heap = []",
    "        for i, arr in enumerate(arrays):",
    "            heapq.heappush(heap, (arr[0], i, 0))",
    "        ",
    "        prev, curr = 0, 0",
    "        for _ in range(total // 2 + 1):",
    "            prev = curr",
    "            val, arr_idx, elem_idx = heapq.heappop(heap)",
    "            curr = val",
    "            if elem_idx + 1 < len(arrays[arr_idx]):",
    "                next_val = arrays[arr_idx][elem_idx + 1]",
    "                heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))",
    "        ",
    "        if total % 2 == 1:",
    "            return float(curr)",
    "        else:",
    "            return (prev + curr) / 2.0",
    "    ",
    "    # ==================== Part 4: Streaming Median ====================",
    "    ",
    "    def add_to_first(self, x: int) -> None:",
    "        \"\"\"Part 4: Add element to first array (streaming).\"\"\"",
    "        self._add_num(x)",
    "    ",
    "    def add_to_second(self, x: int) -> None:",
    "        \"\"\"Part 4: Add element to second array (streaming).\"\"\"",
    "        self._add_num(x)",
    "    ",
    "    def _add_num(self, x: int) -> None:",
    "        \"\"\"Add number to appropriate heap and rebalance.\"\"\"",
    "        # Add to left half if empty or x belongs in smaller half",
    "        if not self._max_heap or x <= -self._max_heap[0]:",
    "            heapq.heappush(self._max_heap, -x)",
    "        else:",
    "            heapq.heappush(self._min_heap, x)",
    "        ",
    "        # Rebalance: max_heap can have at most 1 more element",
    "        if len(self._max_heap) > len(self._min_heap) + 1:",
    "            val = -heapq.heappop(self._max_heap)",
    "            heapq.heappush(self._min_heap, val)",
    "        elif len(self._min_heap) > len(self._max_heap):",
    "            val = heapq.heappop(self._min_heap)",
    "            heapq.heappush(self._max_heap, -val)",
    "    ",
    "    def get_median(self) -> float:",
    "        \"\"\"Part 4: Return current median of all streamed elements.\"\"\"",
    "        if not self._max_heap:",
    "            return 0.0",
    "        ",
    "        if len(self._max_heap) > len(self._min_heap):",
    "            return float(-self._max_heap[0])",
    "        else:",
    "            return (-self._max_heap[0] + self._min_heap[0]) / 2.0",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"PART 4: Streaming Median with Two Heaps\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Test 1: Example from problem",
    "    sol = Solution()",
    "    print(\"\\nTest 1: Example from problem\")",
    "    sol.add_to_first(1)",
    "    print(f\"After add_to_first(1): heaps ready\")",
    "    sol.add_to_second(2)",
    "    print(f\"After add_to_second(2): heaps = left[-1], right[2]\")",
    "    print(f\"get_median() = {sol.get_median()} (expected: 1.5)\")",
    "    sol.add_to_first(3)",
    "    print(f\"After add_to_first(3): rebalanced\")",
    "    print(f\"get_median() = {sol.get_median()} (expected: 2.0)\")",
    "    ",
    "    # Test 2: Longer sequence",
    "    sol2 = Solution()",
    "    print(\"\\nTest 2: Longer sequence [5,15,1,3]\")",
    "    for val in [5, 15, 1, 3]:",
    "        sol2.add_to_first(val)",
    "        print(f\"  After add({val}): median = {sol2.get_median()}\")",
    "    print(\"Expected sequence: 5.0, 10.0, 5.0, 4.0\")",
    "    ",
    "    # Test 3: Edge case - single element",
    "    sol3 = Solution()",
    "    print(\"\\nTest 3: Single element\")",
    "    sol3.add_to_second(42)",
    "    print(f\"After adding 42: median = {sol3.get_median()} (expected: 42.0)\")",
    "    ",
    "    # Test 4: Empty case",
    "    sol4 = Solution()",
    "    print(\"\\nTest 4: Empty case\")",
    "    print(f\"Empty median = {sol4.get_median()} (expected: 0.0)\")",
    "    ",
    "    # Verify Parts 1-3 still work",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Verification: Parts 1-3 still work\")",
    "    print(\"=\" * 60)",
    "    sol5 = Solution()",
    "    print(f\"Part 1 - Median of [1,3] and [2]: {sol5.findMedianSortedArrays([1,3], [2])}\")",
    "    print(f\"Part 2 - 4th element of [1,3,5] and [2,4,6]: {sol5.findKthElement([1,3,5], [2,4,6], 4)}\")",
    "    print(f\"Part 3 - Median of [[1,5,9],[2,6,10],[3,7,11]]: {sol5.findMedianOfKArrays([[1,5,9],[2,6,10],[3,7,11]])}\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class Solution {",
    "    // Part 4: Streaming median data structures",
    "    private PriorityQueue<Integer> maxHeap;  // Left half (smaller elements)",
    "    private PriorityQueue<Integer> minHeap;  // Right half (larger elements)",
    "    ",
    "    public Solution() {",
    "        maxHeap = new PriorityQueue<>(Collections.reverseOrder());",
    "        minHeap = new PriorityQueue<>();",
    "    }",
    "    ",
    "    /** Part 1: Median of two sorted arrays using binary search partitioning. */",
    "    public double findMedianSortedArrays(int[] nums1, int[] nums2) {",
    "        if (nums1.length > nums2.length) {",
    "            int[] temp = nums1; nums1 = nums2; nums2 = temp;",
    "        }",
    "        int m = nums1.length, n = nums2.length;",
    "        int left = 0, right = m;",
    "        int half = (m + n + 1) / 2;",
    "        ",
    "        while (left <= right) {",
    "            int i = (left + right) / 2;",
    "            int j = half - i;",
    "            int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];",
    "            int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];",
    "            int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];",
    "            int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];",
    "            ",
    "            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {",
    "                if ((m + n) % 2 == 1) {",
    "                    return Math.max(maxLeft1, maxLeft2);",
    "                } else {",
    "                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;",
    "                }",
    "            } else if (maxLeft1 > minRight2) {",
    "                right = i - 1;",
    "            } else {",
    "                left = i + 1;",
    "            }",
    "        }",
    "        return 0.0;",
    "    }",
    "    ",
    "    /** Part 2: Find k-th smallest element using binary elimination. */",
    "    public int findKthElement(int[] nums1, int[] nums2, int k) {",
    "        int idx1 = 0, idx2 = 0;",
    "        int m = nums1.length, n = nums2.length;",
    "        ",
    "        while (true) {",
    "            if (idx1 == m) return nums2[idx2 + k - 1];",
    "            if (idx2 == n) return nums1[idx1 + k - 1];",
    "            if (k == 1) return Math.min(nums1[idx1], nums2[idx2]);",
    "            ",
    "            int half = k / 2;",
    "            int newIdx1 = Math.min(idx1 + half, m) - 1;",
    "            int newIdx2 = Math.min(idx2 + half, n) - 1;",
    "            ",
    "            if (nums1[newIdx1] <= nums2[newIdx2]) {",
    "                k -= (newIdx1 - idx1 + 1);",
    "                idx1 = newIdx1 + 1;",
    "            } else {",
    "                k -= (newIdx2 - idx2 + 1);",
    "                idx2 = newIdx2 + 1;",
    "            }",
    "        }",
    "    }",
    "    ",
    "    /** Part 3: Median of K sorted arrays using K-way merge. */",
    "    public double findMedianOfKArrays(int[][] arrays) {",
    "        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);",
    "        int total = 0;",
    "        ",
    "        for (int i = 0; i < arrays.length; i++) {",
    "            if (arrays[i] != null && arrays[i].length > 0) {",
    "                heap.offer(new int[]{arrays[i][0], i, 0});",
    "                total += arrays[i].length;",
    "            }",
    "        }",
    "        if (total == 0) return 0.0;",
    "        ",
    "        int prev = 0, curr = 0;",
    "        for (int i = 0; i <= total / 2; i++) {",
    "            prev = curr;",
    "            int[] entry = heap.poll();",
    "            curr = entry[0];",
    "            int arrIdx = entry[1], elemIdx = entry[2];",
    "            if (elemIdx + 1 < arrays[arrIdx].length) {",
    "                heap.offer(new int[]{arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1});",
    "            }",
    "        }",
    "        return (total % 2 == 1) ? (double) curr : (prev + curr) / 2.0;",
    "    }",
    "    ",
    "    // ==================== Part 4: Streaming Median ====================",
    "    ",
    "    /** Part 4: Add element to first array (streaming). */",
    "    public void addToFirst(int x) {",
    "        addNum(x);",
    "    }",
    "    ",
    "    /** Part 4: Add element to second array (streaming). */",
    "    public void addToSecond(int x) {",
    "        addNum(x);",
    "    }",
    "    ",
    "    /** Internal: Add number to appropriate heap and rebalance. */",
    "    private void addNum(int x) {",
    "        // Add to left half if empty or x belongs in smaller half",
    "        if (maxHeap.isEmpty() || x <= maxHeap.peek()) {",
    "            maxHeap.offer(x);",
    "        } else {",
    "            minHeap.offer(x);",
    "        }",
    "        ",
    "        // Rebalance: maxHeap can have at most 1 more element",
    "        if (maxHeap.size() > minHeap.size() + 1) {",
    "            minHeap.offer(maxHeap.poll());",
    "        } else if (minHeap.size() > maxHeap.size()) {",
    "            maxHeap.offer(minHeap.poll());",
    "        }",
    "    }",
    "    ",
    "    /** Part 4: Return current median of all streamed elements. */",
    "    public double getMedian() {",
    "        if (maxHeap.isEmpty()) return 0.0;",
    "        ",
    "        if (maxHeap.size() > minHeap.size()) {",
    "            return (double) maxHeap.peek();",
    "        } else {",
    "            return (maxHeap.peek() + minHeap.peek()) / 2.0;",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============ PART 4: Streaming Median ============\");",
    "        ",
    "        // Test 1: Example from problem",
    "        Solution sol = new Solution();",
    "        System.out.println(\"\\nTest 1: Example from problem\");",
    "        sol.addToFirst(1);",
    "        sol.addToSecond(2);",
    "        System.out.println(\"After [1],[2]: median = \" + sol.getMedian() + \" (expected: 1.5)\");",
    "        sol.addToFirst(3);",
    "        System.out.println(\"After [1,3],[2]: median = \" + sol.getMedian() + \" (expected: 2.0)\");",
    "        ",
    "        // Test 2: Longer sequence",
    "        Solution sol2 = new Solution();",
    "        System.out.println(\"\\nTest 2: Adding [5,15,1,3]\");",
    "        for (int val : new int[]{5, 15, 1, 3}) {",
    "            sol2.addToFirst(val);",
    "            System.out.println(\"  After add(\" + val + \"): median = \" + sol2.getMedian());",
    "        }",
    "        ",
    "        // Verify Parts 1-3 still work",
    "        System.out.println(\"\\n============ Verification ============\");",
    "        Solution sol3 = new Solution();",
    "        System.out.println(\"Part 1: \" + sol3.findMedianSortedArrays(new int[]{1,3}, new int[]{2}));",
    "        System.out.println(\"Part 2: \" + sol3.findKthElement(new int[]{1,3,5}, new int[]{2,4,6}, 4));",
    "        System.out.println(\"Part 3: \" + sol3.findMedianOfKArrays(new int[][]{{1,5,9},{2,6,10},{3,7,11}}));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-7 (Python) / 1-10 (Java)",
      "explanation": "Imports and class initialization. Added _max_heap and _min_heap for streaming median state."
    },
    {
      "lines": "95-97 (Python)",
      "explanation": "add_to_first: Simply delegates to _add_num since array identity doesn't affect median."
    },
    {
      "lines": "99-101 (Python)",
      "explanation": "add_to_second: Same delegation - both arrays flow into the same heap structure."
    },
    {
      "lines": "103-115 (Python)",
      "explanation": "_add_num: Core insertion logic. First decides which heap based on value comparison, then rebalances to maintain size invariant."
    },
    {
      "lines": "117-123 (Python)",
      "explanation": "get_median: O(1) lookup. Returns top of larger heap (odd) or average of tops (even)."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "add_to_first": {
          "complexity": "O(log n)",
          "explanation": "At most 3 heap operations: 1 push + up to 2 for rebalance"
        },
        "add_to_second": {
          "complexity": "O(log n)",
          "explanation": "Same as add_to_first"
        },
        "get_median": {
          "complexity": "O(1)",
          "explanation": "Direct access to heap tops via peek()"
        }
      },
      "overall_change": "Part 4 adds streaming with O(log n) insert and O(1) query. Parts 1-3 unchanged."
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "Two heaps store all n streamed elements. No additional overhead beyond element storage."
    }
  },
  "dry_run": {
    "example_input": "addToFirst(1), addToSecond(2), getMedian(), addToFirst(3), getMedian()",
    "steps": [
      {
        "step": 1,
        "action": "addToFirst(1)",
        "state": "maxHeap=[-1], minHeap=[]",
        "explanation": "First element goes to maxHeap (left half)"
      },
      {
        "step": 2,
        "action": "addToSecond(2)",
        "state": "maxHeap=[-1], minHeap=[2]",
        "explanation": "2 > maxHeap.top(1), so goes to minHeap. Sizes equal, no rebalance."
      },
      {
        "step": 3,
        "action": "getMedian()",
        "state": "return (1+2)/2 = 1.5",
        "explanation": "Equal sizes \u2192 average of tops: (1+2)/2 = 1.5"
      },
      {
        "step": 4,
        "action": "addToFirst(3)",
        "state": "maxHeap=[-2,-1], minHeap=[3]",
        "explanation": "3 > 1, goes to minHeap=[2,3]. minHeap larger, so move 2 to maxHeap."
      },
      {
        "step": 5,
        "action": "getMedian()",
        "state": "return 2.0",
        "explanation": "maxHeap larger (2 vs 1) \u2192 return maxHeap.top = 2"
      }
    ],
    "final_output": "[null, null, 1.5, null, 2.0] \u2713"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single element should return that element",
      "Two elements [1,3] should return 2.0"
    ],
    "likely_bugs": [
      "Python heapq is min-heap - forgetting to negate for max-heap",
      "Off-by-one in size comparison for rebalancing",
      "Empty heap check before accessing top"
    ],
    "recommended_logs_or_asserts": [
      "assert len(self._max_heap) >= len(self._min_heap)",
      "assert len(self._max_heap) - len(self._min_heap) <= 1",
      "Log heap states after each add: f'max={[-x for x in _max_heap]}, min={_min_heap}'"
    ],
    "how_to_localize": "1. Print heap states after each add. 2. Verify rebalance condition triggered correctly. 3. Check negation on maxHeap values."
  },
  "edge_cases": [
    {
      "case": "Empty heaps",
      "handling": "Return 0.0 from get_median()",
      "gotcha": "Must check before accessing heap[0]"
    },
    {
      "case": "Single element",
      "handling": "maxHeap has 1, minHeap empty \u2192 return maxHeap.top",
      "gotcha": "Size comparison handles this"
    },
    {
      "case": "All same values",
      "handling": "Works correctly - heap maintains order",
      "gotcha": "None"
    },
    {
      "case": "Alternating large/small",
      "handling": "Rebalancing keeps heaps equal or +1",
      "gotcha": "Test [100,1,99,2,98,3]"
    }
  ],
  "test_cases": [
    {
      "name": "Problem example",
      "input": "add(1), add(2), median(), add(3), median()",
      "expected": "[1.5, 2.0]",
      "explanation": "Two elements: avg=1.5. Three elements sorted [1,2,3]: median=2"
    },
    {
      "name": "Odd sequence",
      "input": "add(5), add(15), add(1), add(3), add(7)",
      "expected": "5.0, 10.0, 5.0, 4.0, 5.0",
      "explanation": "Sequence: [5]\u21925, [5,15]\u219210, [1,5,15]\u21925, [1,3,5,15]\u21924, [1,3,5,7,15]\u21925"
    },
    {
      "name": "Decreasing sequence",
      "input": "add(5), add(4), add(3), add(2), add(1)",
      "expected": "5.0, 4.5, 4.0, 3.5, 3.0",
      "explanation": "Values go to maxHeap first, rebalancing moves some to minHeap"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using min-heap for left half in Python",
      "why_wrong": "Python heapq is min-heap. Left half needs max, requiring negation.",
      "correct_approach": "Store negated values: heappush(maxHeap, -x), access as -maxHeap[0]",
      "code_example_wrong": "heapq.heappush(self.left, x)  # Wrong: gives min, not max",
      "code_example_correct": "heapq.heappush(self.left, -x)  # Correct: negation gives max behavior"
    },
    {
      "mistake": "Wrong rebalance condition",
      "why_wrong": "Allowing max_heap to be 2+ larger causes wrong median",
      "correct_approach": "Ensure |size difference| \u2264 1 after every insert",
      "code_example_wrong": "if len(maxHeap) > len(minHeap) + 2:  # Off by one!",
      "code_example_correct": "if len(maxHeap) > len(minHeap) + 1:"
    },
    {
      "mistake": "Not handling empty heap in get_median",
      "why_wrong": "Accessing heap[0] on empty heap raises IndexError",
      "correct_approach": "Check if heap is empty first, return 0.0",
      "code_example_wrong": "return -self._max_heap[0]  # Crashes if empty",
      "code_example_correct": "if not self._max_heap: return 0.0"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the two-heaps pattern: 'For streaming median, the classic approach is to maintain two heaps - a max-heap for the smaller half and a min-heap for the larger half. This gives us O(log n) insert and O(1) median query.'",
    "what_to_mention": [
      "Why two heaps: 'The median divides data into halves. Heaps give us the boundary elements in O(1).'",
      "The rebalance invariant: 'After each insert, sizes differ by at most 1.'",
      "Python gotcha: 'Python heapq is min-heap only, so I negate values for the max-heap.'"
    ],
    "time_allocation": "3 min: explain approach. 5 min: implement. 2 min: test with example.",
    "if_stuck": [
      "Think about what information you need for median: the middle element(s)",
      "What data structure gives the max or min efficiently?",
      "How do you maintain 'halves' dynamically?"
    ]
  },
  "connection_to_next_part": "If Part 5 adds element deletion, we'd need to upgrade from heaps to a balanced BST (like TreeMap) or use lazy deletion with a secondary heap tracking deleted elements.",
  "communication_script": {
    "transition_from_previous": "Great, Part 3 handles K static arrays. Part 4 is fundamentally different - we need to handle streaming insertions. Let me explain the approach...",
    "explaining_changes": "The key change is that we can't recompute from scratch on each query. I'll use the two-heaps pattern - a max-heap for the smaller half and min-heap for the larger half. This gives O(log n) insert and O(1) query.",
    "while_extending_code": [
      "I'm adding two heaps as instance variables in __init__...",
      "The add methods both delegate to a common _add_num helper...",
      "The rebalance logic ensures sizes stay within 1 of each other..."
    ],
    "after_completing": "This handles Part 4. addToFirst and addToSecond are O(log n) via heap operations. getMedian is O(1) by accessing heap tops. Shall I trace through an example?"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Recognize two-heaps pattern. Explain: 'Max-heap for left, min-heap for right, rebalance after each insert.'",
    "by_5_min": "Have add_num and rebalancing logic written. Start on get_median.",
    "by_10_min": "Complete implementation. Trace through the example to verify.",
    "warning_signs": "If still thinking about data structure choice at 4 min, just pick two-heaps and go."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 4 is independent of Parts 1-3 implementation. The streaming methods don't use the static methods.",
    "if_new_requirement_unclear": "Ask: 'For the streaming part, do I need to track which array each element came from, or just compute the combined median?'",
    "if_running_behind": "Implement add and get_median first. Skip edge cases initially but mention them: 'I'd handle empty heap case here in production.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing the two-heaps pattern",
      "Explaining WHY it works: 'Heaps give boundary elements of each half'",
      "Mentioning the invariants proactively",
      "Discussing trade-offs: 'If we needed deletion, I'd use TreeMap instead'"
    ]
  },
  "pattern_recognition": {
    "pattern": "Two Heaps (Streaming Median)",
    "indicators": [
      "Need to find median dynamically as data streams in",
      "O(1) or O(log n) query requirement",
      "No random access needed, just the middle value(s)"
    ],
    "similar_problems": [
      "LC 295 - Find Median from Data Stream",
      "LC 480 - Sliding Window Median",
      "LC 703 - Kth Largest Element in a Stream"
    ],
    "template": "```python\\n# Two Heaps Template\\nmax_heap = []  # Left half (negate for max)\\nmin_heap = []  # Right half\\n\\ndef add(x):\\n    if not max_heap or x <= -max_heap[0]:\\n        heappush(max_heap, -x)\\n    else:\\n        heappush(min_heap, x)\\n    # Rebalance...\\n\\ndef median():\\n    if len(max_heap) > len(min_heap):\\n        return -max_heap[0]\\n    return (-max_heap[0] + min_heap[0]) / 2\\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'streaming' + 'median', I immediately think two-heaps",
      "why": "It's the canonical pattern for this exact problem"
    },
    {
      "step": 2,
      "thought": "The O(log n) insert and O(1) query requirements confirm two-heaps",
      "why": "Sorted array insert is O(n), BST median is O(log n) - heaps are optimal"
    },
    {
      "step": 3,
      "thought": "The two 'arrays' don't matter for implementation",
      "why": "Median is a global property - we combine into one structure"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you recognize the two-heaps pattern immediately?",
      "Can you explain the invariants clearly?",
      "Do you handle Python's min-heap-only limitation?"
    ],
    "bonus_points": [
      "Mentioning LC 295 as the classic problem",
      "Discussing what changes for sliding window median",
      "Proactively mentioning deletion would need TreeMap"
    ],
    "red_flags": [
      "Trying to maintain sorted arrays with bisect.insort",
      "Not understanding why two heaps work",
      "Forgetting to rebalance after insertion"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to remember heapq syntax if needed",
      "Let it help with the rebalance condition"
    ],
    "what_not_to_do": [
      "Don't let AI suggest sorted array approach",
      "Make sure you understand the negation trick for max-heap"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Staying silent while implementing",
      "Not explaining the two-heaps pattern"
    ],
    "technical": [
      "Using sorted list with O(n) insert",
      "Wrong rebalance logic"
    ],
    "communication": [
      "Not mentioning the O(1) query benefit",
      "Forgetting to trace an example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Is add O(log n)? Yes - at most 3 heap ops",
      "Is get_median O(1)? Yes - direct heap top access",
      "Did I handle empty heap case?",
      "Did I trace the problem example?"
    ],
    "quick_code_review": [
      "Negation used correctly for max_heap in Python",
      "Rebalance condition: max_heap can be 0 or 1 larger",
      "Type hints on new methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Thread safety with locks around heap operations",
      "Metrics for insert latency",
      "Batch insert support for efficiency"
    ],
    "why_not_in_interview": "Focus on core algorithm; heaps are already efficient enough",
    "how_to_mention": "Say: 'In production, I'd add thread-safety if this is accessed concurrently.'"
  },
  "generated_at": "2026-01-19T05:05:50.434524",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}