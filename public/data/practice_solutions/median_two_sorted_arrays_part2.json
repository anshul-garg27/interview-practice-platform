{
  "problem_title": "Median of Two Sorted Arrays - Part 2: Find K-th Element in Two Sorted Arrays",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 1 found the median (a specific position). Part 2 generalizes this to find ANY k-th smallest element. The median is just a special case where k = (m+n+1)/2 for the left median element. This requires a different binary search strategy - instead of partitioning both arrays, we eliminate k/2 elements per iteration.",
    "new_requirements": [
      "Find k-th smallest element (1-indexed) in union of two sorted arrays",
      "Handle arbitrary k values (not just median position)",
      "Achieve O(log(k)) time complexity"
    ],
    "new_constraints": [
      "k is 1-indexed (k=1 means smallest element)",
      "1 <= k <= m + n (valid range)",
      "Must eliminate half of remaining search space each iteration"
    ],
    "key_insight": "Compare elements at k/2 positions in both arrays. The array with the smaller element cannot contain the k-th element in its first k/2 positions - eliminate them and reduce k accordingly."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Find k-th smallest element",
        "how_met": "Binary elimination approach comparing k/2-th elements",
        "gotchas": [
          "k is 1-indexed, not 0-indexed",
          "Must handle when k/2 exceeds array length"
        ]
      },
      {
        "requirement": "O(log(k)) time complexity",
        "how_met": "Each iteration eliminates at least k/2 elements, halving k",
        "gotchas": [
          "Don't use O(k) linear approach",
          "Account for edge cases not breaking logarithmic time"
        ]
      },
      {
        "requirement": "Handle empty/exhausted arrays",
        "how_met": "Base cases check if either array is exhausted, return directly from remaining array",
        "gotchas": [
          "Index out of bounds when array exhausted mid-search"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "findKthElement",
        "target": "O(log(k))",
        "achieved": "O(log(k))",
        "why": "Each iteration eliminates at least floor(k/2) elements, so k is halved each step"
      }
    ],
    "non_goals": [
      "Modifying the original findMedianSortedArrays implementation",
      "Supporting unsorted input arrays",
      "Handling duplicate elements specially (they work fine as-is)"
    ]
  },
  "assumptions": [
    "k is 1-indexed (k=1 returns smallest element) - confirm with interviewer",
    "1 <= k <= m + n is guaranteed - ask if validation needed",
    "Arrays are sorted in non-decreasing order (same as Part 1)",
    "Return type is int (elements are integers, not float like median)"
  ],
  "tradeoffs": [
    {
      "decision": "Iterative vs Recursive approach",
      "chosen": "Iterative",
      "why": "O(1) space vs O(log k) stack space, cleaner state management",
      "alternative": "Recursive",
      "when_to_switch": "If code clarity is prioritized and k is small"
    },
    {
      "decision": "Elimination approach vs Partition approach (Part 1 style)",
      "chosen": "Elimination",
      "why": "More intuitive for arbitrary k, directly reduces search space",
      "alternative": "Partition-based binary search",
      "when_to_switch": "If you need both k-th and (k+1)-th elements (like median)"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "findMedianSortedArrays signature and behavior",
      "Class name Solution",
      "All variable naming conventions from Part 1"
    ],
    "what_to_change": [
      "Add new method findKthElement",
      "No modifications to existing fields or methods needed"
    ],
    "interfaces_and_boundaries": "findKthElement is a standalone method that doesn't share state with findMedianSortedArrays. Could refactor findMedianSortedArrays to use findKthElement internally, but not required.",
    "invariants": [
      "k always decreases by at least 1 each iteration (guaranteed termination)",
      "idx1 + idx2 + k always equals original k (elements eliminated + remaining to find)",
      "At least one of the base cases will eventually trigger"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nFinding k=7 in nums1=[1,3,5,7,9,11], nums2=[2,4,6,8,10,12]\n\nBEFORE (Merged view - conceptual):\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n                   ^-- k=7 is here (value 7)\n\nAFTER (Algorithm finds it in O(log k) without merging):\nStep 1: Eliminate nums1[0..2] (values 1,3,5), k: 7\u21924\nStep 2: Eliminate nums2[0..1] (values 2,4), k: 4\u21922  \nStep 3: Eliminate nums2[0] (value 6), k: 2\u21921\nStep 4: k=1, return min(7, 8) = 7 \u2713\n```",
    "algorithm_flow": "```\nfindKthElement(nums1, nums2, k):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 While k > 1 and both arrays have elements\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  half = k / 2                           \u2502\n\u2502  Compare nums1[half-1] vs nums2[half-1] \u2502\n\u2502         (handling boundary cases)        \u2502\n\u2502                                          \u2502\n\u2502  Smaller element's array:                \u2502\n\u2502    \u2192 Eliminate first 'half' elements     \u2502\n\u2502    \u2192 Reduce k by eliminated count        \u2502\n\u2502                                          \u2502\n\u2502  Repeat until k=1 or array exhausted     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Base cases:                              \u2502\n\u2502  \u2022 Array exhausted \u2192 return from other   \u2502\n\u2502  \u2022 k=1 \u2192 return min of both fronts       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Merge Approach",
      "description": "Merge both arrays and return element at index k-1",
      "time_complexity": "O(k)",
      "space_complexity": "O(1) if using two pointers, O(m+n) if actually merging",
      "why_not_optimal": "Linear in k, doesn't leverage sorted property fully. For large k, this is too slow."
    },
    {
      "name": "Optimal Binary Elimination",
      "description": "Compare k/2-th elements, eliminate half the search space each iteration",
      "time_complexity": "O(log(k))",
      "space_complexity": "O(1) iterative, O(log k) recursive",
      "key_insight": "If nums1[k/2-1] < nums2[k/2-1], then nums1[0..k/2-1] cannot contain the k-th element (at most k/2-1 + k/2-1 = k-2 elements smaller, so position at most k-1)"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Binary Elimination Approach\n\n**Core Insight**: We can safely eliminate elements that are *guaranteed* not to be the k-th element.\n\nWhen we compare `nums1[k/2 - 1]` with `nums2[k/2 - 1]`:\n- If `nums1[k/2 - 1] < nums2[k/2 - 1]`:\n  - The first k/2 elements of nums1 have **at most** `(k/2-1) + (k/2-1) = k-2` elements smaller than them\n  - So they can be at most the (k-1)-th element, **never** the k-th\n  - **Safe to eliminate** these k/2 elements from nums1\n\n**Algorithm**:\n1. Compare elements at position k/2 in both arrays\n2. Eliminate the first portion of the array with smaller element\n3. Reduce k by the number of eliminated elements\n4. Repeat until k=1 or one array exhausted\n\n**Why O(log k)**: Each step eliminates at least \u230ak/2\u230b elements, so k halves each iteration \u2192 O(log k) iterations.",
    "data_structures": [
      {
        "structure": "Two index pointers",
        "purpose": "Track current position in each array after eliminations"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize idx1=0, idx2=0 to track eliminated elements",
      "Step 2: Check base cases - array exhausted or k=1",
      "Step 3: Calculate half = k/2, get indices to compare (handle bounds)",
      "Step 4: Compare elements at calculated indices",
      "Step 5: Eliminate elements from array with smaller value, update k",
      "Step 6: Repeat from Step 2"
    ]
  },
  "solution_python_lines": [
    "from typing import List",
    "",
    "class Solution:",
    "    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:",
    "        \"\"\"",
    "        Find median of two sorted arrays using binary search partitioning.",
    "        Time: O(log(min(m,n))), Space: O(1)",
    "        \"\"\"",
    "        # Ensure nums1 is the smaller array for O(log(min(m,n)))",
    "        if len(nums1) > len(nums2):",
    "            nums1, nums2 = nums2, nums1",
    "        ",
    "        m, n = len(nums1), len(nums2)",
    "        left, right = 0, m",
    "        half = (m + n + 1) // 2",
    "        ",
    "        while left <= right:",
    "            i = (left + right) // 2",
    "            j = half - i",
    "            ",
    "            maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]",
    "            minRight1 = float('inf') if i == m else nums1[i]",
    "            maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]",
    "            minRight2 = float('inf') if j == n else nums2[j]",
    "            ",
    "            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:",
    "                if (m + n) % 2 == 1:",
    "                    return float(max(maxLeft1, maxLeft2))",
    "                else:",
    "                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2",
    "            elif maxLeft1 > minRight2:",
    "                right = i - 1",
    "            else:",
    "                left = i + 1",
    "        ",
    "        return 0.0",
    "    ",
    "    def findKthElement(self, nums1: List[int], nums2: List[int], k: int) -> int:",
    "        \"\"\"",
    "        Find k-th smallest element (1-indexed) in union of two sorted arrays.",
    "        Time: O(log(k)), Space: O(1)",
    "        ",
    "        Key insight: Compare k/2-th elements; eliminate half each iteration.",
    "        \"\"\"",
    "        idx1, idx2 = 0, 0",
    "        m, n = len(nums1), len(nums2)",
    "        ",
    "        while True:",
    "            # Base case 1: nums1 exhausted, take from nums2",
    "            if idx1 == m:",
    "                return nums2[idx2 + k - 1]",
    "            ",
    "            # Base case 2: nums2 exhausted, take from nums1",
    "            if idx2 == n:",
    "                return nums1[idx1 + k - 1]",
    "            ",
    "            # Base case 3: k=1, return minimum of current fronts",
    "            if k == 1:",
    "                return min(nums1[idx1], nums2[idx2])",
    "            ",
    "            # Compare elements at k/2 positions (handle bounds)",
    "            half = k // 2",
    "            newIdx1 = min(idx1 + half, m) - 1",
    "            newIdx2 = min(idx2 + half, n) - 1",
    "            ",
    "            if nums1[newIdx1] <= nums2[newIdx2]:",
    "                # Eliminate elements from nums1[idx1..newIdx1]",
    "                k -= (newIdx1 - idx1 + 1)",
    "                idx1 = newIdx1 + 1",
    "            else:",
    "                # Eliminate elements from nums2[idx2..newIdx2]",
    "                k -= (newIdx2 - idx2 + 1)",
    "                idx2 = newIdx2 + 1",
    "",
    "",
    "if __name__ == '__main__':",
    "    sol = Solution()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"PART 1: Median Tests (unchanged)\")",
    "    print(\"=\" * 60)",
    "    print(f\"Median of [1,3] and [2]: {sol.findMedianSortedArrays([1,3], [2])}\")",
    "    print(\"Expected: 2.0\\n\")",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"PART 2: Find K-th Element Tests\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Test 1: Basic case",
    "    print(\"Test 1: nums1=[1,3,5], nums2=[2,4,6], k=4\")",
    "    print(f\"Result: {sol.findKthElement([1,3,5], [2,4,6], 4)}\")",
    "    print(\"Expected: 4 (Merged: [1,2,3,4,5,6])\\n\")",
    "    ",
    "    # Test 2: k exceeds first array",
    "    print(\"Test 2: nums1=[1,2], nums2=[3,4,5,6,7], k=5\")",
    "    print(f\"Result: {sol.findKthElement([1,2], [3,4,5,6,7], 5)}\")",
    "    print(\"Expected: 5\\n\")",
    "    ",
    "    # Test 3: k=1 (minimum element)",
    "    print(\"Test 3: nums1=[2,3], nums2=[1,4], k=1\")",
    "    print(f\"Result: {sol.findKthElement([2,3], [1,4], 1)}\")",
    "    print(\"Expected: 1\\n\")",
    "    ",
    "    # Test 4: One empty array",
    "    print(\"Test 4: nums1=[], nums2=[1,2,3,4,5], k=3\")",
    "    print(f\"Result: {sol.findKthElement([], [1,2,3,4,5], 3)}\")",
    "    print(\"Expected: 3\\n\")",
    "    ",
    "    # Test 5: Large k (visual example from problem)",
    "    print(\"Test 5: nums1=[1,3,5,7,9,11], nums2=[2,4,6,8,10,12], k=7\")",
    "    print(f\"Result: {sol.findKthElement([1,3,5,7,9,11], [2,4,6,8,10,12], 7)}\")",
    "    print(\"Expected: 7\")"
  ],
  "solution_java_lines": [
    "public class Solution {",
    "    /**",
    "     * Find median of two sorted arrays using binary search partitioning.",
    "     * Time: O(log(min(m,n))), Space: O(1)",
    "     */",
    "    public double findMedianSortedArrays(int[] nums1, int[] nums2) {",
    "        if (nums1.length > nums2.length) {",
    "            int[] temp = nums1;",
    "            nums1 = nums2;",
    "            nums2 = temp;",
    "        }",
    "        ",
    "        int m = nums1.length;",
    "        int n = nums2.length;",
    "        int left = 0, right = m;",
    "        int half = (m + n + 1) / 2;",
    "        ",
    "        while (left <= right) {",
    "            int i = (left + right) / 2;",
    "            int j = half - i;",
    "            ",
    "            int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];",
    "            int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];",
    "            int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];",
    "            int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];",
    "            ",
    "            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {",
    "                if ((m + n) % 2 == 1) {",
    "                    return Math.max(maxLeft1, maxLeft2);",
    "                } else {",
    "                    return (Math.max(maxLeft1, maxLeft2) + ",
    "                            Math.min(minRight1, minRight2)) / 2.0;",
    "                }",
    "            } else if (maxLeft1 > minRight2) {",
    "                right = i - 1;",
    "            } else {",
    "                left = i + 1;",
    "            }",
    "        }",
    "        return 0.0;",
    "    }",
    "    ",
    "    /**",
    "     * Find k-th smallest element (1-indexed) in union of two sorted arrays.",
    "     * Time: O(log(k)), Space: O(1)",
    "     * ",
    "     * Key insight: Compare k/2-th elements; eliminate half each iteration.",
    "     */",
    "    public int findKthElement(int[] nums1, int[] nums2, int k) {",
    "        int idx1 = 0, idx2 = 0;",
    "        int m = nums1.length, n = nums2.length;",
    "        ",
    "        while (true) {",
    "            // Base case 1: nums1 exhausted",
    "            if (idx1 == m) {",
    "                return nums2[idx2 + k - 1];",
    "            }",
    "            ",
    "            // Base case 2: nums2 exhausted",
    "            if (idx2 == n) {",
    "                return nums1[idx1 + k - 1];",
    "            }",
    "            ",
    "            // Base case 3: k=1, return minimum",
    "            if (k == 1) {",
    "                return Math.min(nums1[idx1], nums2[idx2]);",
    "            }",
    "            ",
    "            // Compare elements at k/2 positions",
    "            int half = k / 2;",
    "            int newIdx1 = Math.min(idx1 + half, m) - 1;",
    "            int newIdx2 = Math.min(idx2 + half, n) - 1;",
    "            ",
    "            if (nums1[newIdx1] <= nums2[newIdx2]) {",
    "                k -= (newIdx1 - idx1 + 1);",
    "                idx1 = newIdx1 + 1;",
    "            } else {",
    "                k -= (newIdx2 - idx2 + 1);",
    "                idx2 = newIdx2 + 1;",
    "            }",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        Solution sol = new Solution();",
    "        ",
    "        System.out.println(\"============ PART 1: Median ============\");",
    "        System.out.println(\"Median of [1,3] and [2]: \" + ",
    "            sol.findMedianSortedArrays(new int[]{1, 3}, new int[]{2}));",
    "        System.out.println(\"Expected: 2.0\\n\");",
    "        ",
    "        System.out.println(\"============ PART 2: K-th Element ============\");",
    "        ",
    "        System.out.println(\"Test 1: k=4 in [1,3,5] and [2,4,6]\");",
    "        System.out.println(\"Result: \" + ",
    "            sol.findKthElement(new int[]{1,3,5}, new int[]{2,4,6}, 4));",
    "        System.out.println(\"Expected: 4\\n\");",
    "        ",
    "        System.out.println(\"Test 2: k=5 in [1,2] and [3,4,5,6,7]\");",
    "        System.out.println(\"Result: \" + ",
    "            sol.findKthElement(new int[]{1,2}, new int[]{3,4,5,6,7}, 5));",
    "        System.out.println(\"Expected: 5\\n\");",
    "        ",
    "        System.out.println(\"Test 3: k=1 (minimum)\");",
    "        System.out.println(\"Result: \" + ",
    "            sol.findKthElement(new int[]{2,3}, new int[]{1,4}, 1));",
    "        System.out.println(\"Expected: 1\\n\");",
    "        ",
    "        System.out.println(\"Test 4: Empty array\");",
    "        System.out.println(\"Result: \" + ",
    "            sol.findKthElement(new int[]{}, new int[]{1,2,3,4,5}, 3));",
    "        System.out.println(\"Expected: 3\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-35",
      "explanation": "Part 1 code unchanged - findMedianSortedArrays using partition approach"
    },
    {
      "lines": "37-45",
      "explanation": "findKthElement signature and docstring. Takes two arrays and k (1-indexed). Returns int since we return actual element, not average."
    },
    {
      "lines": "46-47",
      "explanation": "Initialize pointers idx1, idx2 to track 'virtual' start of each array after eliminations. Store lengths for bound checking."
    },
    {
      "lines": "49-57",
      "explanation": "Base cases: If one array exhausted, return k-th element from remaining array directly. Essential for correctness and termination."
    },
    {
      "lines": "59-61",
      "explanation": "Base case k=1: Return minimum of current front elements. This is the termination condition when we've narrowed down to finding the smallest of remaining."
    },
    {
      "lines": "63-72",
      "explanation": "Core elimination logic: Calculate indices to compare (capped at array bounds), compare elements, eliminate from array with smaller element, update k. The min() handles when k/2 exceeds remaining array length."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "findKthElement": {
          "complexity": "O(log(k))",
          "explanation": "Each iteration eliminates at least floor(k/2) elements, so we need at most 2*log(k) iterations to reduce k to 1"
        }
      },
      "overall_change": "Part 1 unchanged at O(log(min(m,n))). Part 2 adds O(log(k)) for findKthElement."
    },
    "space": {
      "additional_space": "O(1)",
      "explanation": "Only uses constant extra space for index pointers and temporary variables. Iterative approach avoids recursion stack."
    }
  },
  "dry_run": {
    "example_input": "nums1=[1,3,5], nums2=[2,4,6], k=4",
    "steps": [
      {
        "step": 1,
        "action": "Initialize",
        "state": "idx1=0, idx2=0, k=4, m=3, n=3",
        "explanation": "Set up pointers at start of both arrays"
      },
      {
        "step": 2,
        "action": "First comparison",
        "state": "half=2, newIdx1=1, newIdx2=1",
        "explanation": "Compare nums1[1]=3 vs nums2[1]=4. 3 <= 4, eliminate from nums1"
      },
      {
        "step": 3,
        "action": "Eliminate from nums1",
        "state": "idx1=2, k=4-2=2",
        "explanation": "Eliminated nums1[0,1] (values 1,3). k reduced by 2."
      },
      {
        "step": 4,
        "action": "Second comparison",
        "state": "half=1, newIdx1=2, newIdx2=0",
        "explanation": "Compare nums1[2]=5 vs nums2[0]=2. 2 < 5, eliminate from nums2"
      },
      {
        "step": 5,
        "action": "Eliminate from nums2",
        "state": "idx2=1, k=2-1=1",
        "explanation": "Eliminated nums2[0] (value 2). k reduced to 1."
      },
      {
        "step": 6,
        "action": "k=1 base case",
        "state": "Return min(nums1[2], nums2[1]) = min(5, 4) = 4",
        "explanation": "k=1 triggers base case, return minimum of remaining fronts"
      }
    ],
    "final_output": "4 (Verified: merged=[1,2,3,4,5,6], 4th element is 4)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "k=1 should return min(nums1[0], nums2[0])",
      "One empty array: findKthElement([], [1,2,3], 2) should return 2",
      "k equals total length should return maximum element"
    ],
    "likely_bugs": [
      "Off-by-one in k (forgetting k is 1-indexed)",
      "Off-by-one in newIdx calculation (should be min(idx+half, len)-1)",
      "Not updating k correctly (should be newIdx-idx+1, not half)",
      "Index out of bounds when one array exhausted"
    ],
    "recommended_logs_or_asserts": [
      "assert 1 <= k <= m + n at start",
      "print(f'Iteration: idx1={idx1}, idx2={idx2}, k={k}')",
      "assert k > 0 at start of each loop iteration"
    ],
    "how_to_localize": "Trace through with k=4, two arrays of length 3 each. Check that eliminated count matches k reduction. Verify indices stay in bounds."
  },
  "edge_cases": [
    {
      "case": "One array empty",
      "handling": "Base case immediately returns nums2[idx2 + k - 1]",
      "gotcha": "Remember k is 1-indexed, so subtract 1 for 0-indexed array"
    },
    {
      "case": "k=1",
      "handling": "Return min of both first elements",
      "gotcha": "Don't try to eliminate anything, just return minimum"
    },
    {
      "case": "k/2 exceeds smaller array length",
      "handling": "min(idx + half, m) - 1 caps index at last valid position",
      "gotcha": "Must eliminate all remaining elements of short array if compared element is smaller"
    },
    {
      "case": "Arrays don't overlap (e.g., [1,2] and [10,20])",
      "handling": "Algorithm still works - will eliminate from first array repeatedly",
      "gotcha": "None, algorithm handles naturally"
    },
    {
      "case": "k equals total length (find max)",
      "handling": "Eventually one array exhausted, returns last element of remaining",
      "gotcha": "Make sure bounds handling works at array ends"
    }
  ],
  "test_cases": [
    {
      "name": "Basic interleaved",
      "input": "nums1=[1,3,5], nums2=[2,4,6], k=4",
      "expected": "4",
      "explanation": "Merged: [1,2,3,4,5,6], 4th element is 4"
    },
    {
      "name": "k exceeds first array",
      "input": "nums1=[1,2], nums2=[3,4,5,6,7], k=5",
      "expected": "5",
      "explanation": "After eliminating all of nums1, need 3rd from nums2"
    },
    {
      "name": "k=1 minimum",
      "input": "nums1=[2,3], nums2=[1,4], k=1",
      "expected": "1",
      "explanation": "Minimum element across both arrays"
    },
    {
      "name": "Empty array",
      "input": "nums1=[], nums2=[1,2,3,4,5], k=3",
      "expected": "3",
      "explanation": "Simply return k-th from non-empty array"
    },
    {
      "name": "Larger example from problem",
      "input": "nums1=[1,3,5,7,9,11], nums2=[2,4,6,8,10,12], k=7",
      "expected": "7",
      "explanation": "Tests multiple elimination rounds"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using 0-indexed k",
      "why_wrong": "Problem specifies 1-indexed, k=1 means smallest element",
      "correct_approach": "When accessing array, use k-1 for indexing",
      "code_example_wrong": "return nums2[idx2 + k]  // Wrong: 0-indexed assumption",
      "code_example_correct": "return nums2[idx2 + k - 1]  // Correct: 1-indexed"
    },
    {
      "mistake": "Always eliminating exactly k/2 elements",
      "why_wrong": "When k/2 exceeds array length, can only eliminate up to array length",
      "correct_approach": "Use min(idx + half, len) - 1 to cap index, then eliminate newIdx - idx + 1",
      "code_example_wrong": "k -= half  // Wrong: might eliminate more than array has",
      "code_example_correct": "k -= (newIdx - idx + 1)  // Correct: actual eliminated count"
    },
    {
      "mistake": "Comparing at idx + half instead of idx + half - 1",
      "why_wrong": "We want to compare k/2-th elements (1-indexed), which is at index k/2-1",
      "correct_approach": "newIdx = min(idx + half, m) - 1",
      "code_example_wrong": "newIdx1 = min(idx1 + half, m)  // Wrong: off by one",
      "code_example_correct": "newIdx1 = min(idx1 + half, m) - 1  // Correct"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the key insight: 'We can eliminate k/2 elements each step because they can't possibly be the k-th element.' Draw the comparison diagram. Then explain the three base cases before writing code.",
    "what_to_mention": [
      "Why this is O(log k) not O(log(m+n))",
      "The connection to binary search (eliminating half each step)",
      "Edge cases: empty array, k=1, k/2 exceeds array",
      "This generalizes median (median is special k value)"
    ],
    "time_allocation": "2 min understand, 3 min explain approach with diagram, 8 min code, 2 min test",
    "if_stuck": [
      "Think about what elements CAN'T be the k-th element",
      "If nums1[k/2-1] < nums2[k/2-1], how many elements are definitely smaller than nums1[k/2-1]?",
      "Draw out the elimination on paper with small example"
    ]
  },
  "connection_to_next_part": "Part 2's findKthElement could be used to reimplement findMedianSortedArrays by calling findKthElement((m+n+1)/2). Part 3 might extend to multiple arrays (k-way merge), range queries, or streaming data.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 works. For Part 2, instead of finding the median (a specific k), I need to find ANY k-th element. The approach changes from partitioning to elimination.",
    "explaining_changes": "The key insight is that we can eliminate k/2 elements each iteration by comparing elements at the k/2 positions. This gives us O(log k) time.",
    "while_extending_code": [
      "I'm adding a new method findKthElement that takes k as parameter...",
      "The base cases handle when one array is empty or k equals 1...",
      "The main loop compares k/2-th elements and eliminates from the smaller one..."
    ],
    "after_completing": "This handles arbitrary k in O(log k) time. Note that median is just k=(m+n+1)/2. Ready for next part?"
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Understand that this generalizes median, identify elimination approach",
    "by_5_min": "Explain algorithm with visual example, identify base cases",
    "by_10_min": "Code complete, starting testing",
    "warning_signs": "If struggling with index math at 8 min, simplify by using recursion first"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 2 is independent of Part 1 implementation. If Part 1 has bugs, mention 'I'll fix Part 1 after, but Part 2 is a separate method.'",
    "if_new_requirement_unclear": "Ask: 'Is k 1-indexed or 0-indexed? Should I validate k is in valid range?'",
    "if_running_behind": "Use recursive version first (cleaner but O(log k) space), mention iterative optimization after"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Explaining why exactly k/2 elements can be eliminated (the counting argument)",
      "Mentioning this can reimplement findMedianSortedArrays",
      "Discussing how to extend to k sorted arrays",
      "Handling edge cases naturally in the algorithm design"
    ]
  },
  "pattern_recognition": {
    "pattern": "Binary Elimination / Divide and Conquer on Sorted Arrays",
    "indicators": [
      "Two sorted arrays",
      "Find k-th element",
      "O(log n) requirement",
      "Elements can be 'eliminated' based on comparisons"
    ],
    "similar_problems": [
      "LC 4 - Median of Two Sorted Arrays (Part 1)",
      "LC 378 - Kth Smallest Element in Sorted Matrix",
      "LC 373 - Find K Pairs with Smallest Sums",
      "Merge K Sorted Lists (different approach but related)"
    ],
    "template": "Compare at k/2 positions \u2192 Eliminate smaller portion \u2192 Reduce k \u2192 Repeat until base case"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'k-th element in sorted arrays', I think of binary search elimination",
      "why": "Linear merge is O(k), but we can do better by eliminating chunks"
    },
    {
      "step": 2,
      "thought": "Compare at k/2 means we can safely eliminate k/2 elements",
      "why": "The smaller element has at most k-2 elements smaller than it, so it can't be k-th"
    },
    {
      "step": 3,
      "thought": "Need iterative approach for O(1) space",
      "why": "Recursive has O(log k) stack depth, iterative avoids that"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you generalize from specific case (median) to general case (k-th)?",
      "Do you understand the elimination principle?",
      "Can you handle off-by-one and boundary cases?",
      "Is your code clean and well-organized?"
    ],
    "bonus_points": [
      "Explaining the counting argument for why elimination is safe",
      "Discussing recursive vs iterative tradeoffs",
      "Mentioning connection to Part 1's median",
      "Proactive edge case handling"
    ],
    "red_flags": [
      "Starting with O(k) linear approach without optimization",
      "Getting lost in index calculations",
      "Not testing edge cases",
      "Overcomplicating the solution"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for syntax of min/max functions",
      "Let it help with boundary condition expressions"
    ],
    "what_not_to_do": [
      "Don't let AI write the core elimination logic without understanding",
      "Verify the index calculations yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining the elimination principle",
      "Not drawing a visual example"
    ],
    "technical": [
      "Using O(k) approach when O(log k) is achievable",
      "Off-by-one errors in index calculations",
      "Not handling array exhaustion"
    ],
    "communication": [
      "Not explaining why k/2 elements can be safely eliminated",
      "Forgetting to test with small examples"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does findKthElement work for k=1?",
      "Does it handle empty array correctly?",
      "Does it handle k/2 exceeding array length?",
      "Is it O(log k) time and O(1) space?",
      "Does Part 1 still work?"
    ],
    "quick_code_review": [
      "Correct index: newIdx = min(idx + half, m) - 1",
      "Correct elimination count: k -= (newIdx - idx + 1)",
      "All three base cases present",
      "Type hint on new method"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Input validation: 1 <= k <= m + n",
      "Null checks on input arrays",
      "Logging for debugging in production"
    ],
    "why_not_in_interview": "Focus on core algorithm; validation can be mentioned verbally",
    "how_to_mention": "Say: 'In production, I'd validate that k is in range [1, m+n] and arrays are non-null.'"
  },
  "generated_at": "2026-01-19T04:44:36.027795",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}