{
  "problem_title": "Song Play Analytics System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic OOP Design + Analytics** problem. At its core, it's about tracking unique listeners per song and producing sorted reports. The 'unique listeners' requirement immediately signals **Set** data structure, while 'sorted by count then name' signals **custom comparator sorting**.",
    "pattern_recognition": "**HashMap** for O(1) song lookup by ID + **Set** for unique listener tracking + **Custom Sorting** with multi-key comparator. This combines LC 347 (Top K Frequent) with LC 355 (Design Twitter) patterns.",
    "key_constraints": [
      "IDs start from 1 (not 0) - common interview gotcha",
      "Same user playing same song multiple times should NOT increase count - requires Set",
      "Tie-breaking: desc by count, then asc by name - tricky sorting logic",
      "Songs with 0 listeners must appear in analytics - don't skip empty sets",
      "Up to 100,000 play events - need O(1) play_song operation"
    ],
    "clarifying_questions": [
      "Should duplicate song names create separate entries? (Yes - per requirements)",
      "What format for error messages? (Exact: 'Error: Song ID X does not exist.')",
      "Are song names case-sensitive for sorting? (Assume yes - standard lexicographic)",
      "Should analytics output include songs with 0 listeners? (Yes - per Example 4)",
      "Is thread-safety required? (Assume no for interview, mention for production)",
      "What's the expected ratio of plays to songs? (Helps optimize data structure choice)"
    ],
    "edge_cases_to_consider": [
      "Song with 0 listeners (never played)",
      "Same user plays same song multiple times",
      "Invalid song_id in play_song",
      "Multiple songs with identical listener counts (tie-breaking)",
      "Empty system - no songs added yet",
      "Same song name added multiple times (separate IDs)"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Auto-incrementing IDs starting from 1",
        "how_met": "Instance variable `next_id` initialized to 1, incremented after each add_song()",
        "gotchas": [
          "Starting from 0 instead of 1",
          "Not incrementing atomically"
        ]
      },
      {
        "requirement": "Unique listeners only (no duplicate counting)",
        "how_met": "Use Set<Integer> for listeners - Set.add() handles duplicates automatically",
        "gotchas": [
          "Using List and checking manually",
          "Counting total plays instead"
        ]
      },
      {
        "requirement": "Error handling for invalid song_id",
        "how_met": "Check if song_id exists in songs HashMap before processing",
        "gotchas": [
          "Throwing exception instead of printing",
          "Wrong error message format"
        ]
      },
      {
        "requirement": "Sort by count DESC, then name ASC",
        "how_met": "Custom comparator: first compare -count (negated for desc), then name",
        "gotchas": [
          "Sorting count ascending",
          "Forgetting name tie-breaker"
        ]
      },
      {
        "requirement": "Include songs with 0 listeners",
        "how_met": "Iterate all songs in HashMap, empty Sets have size() = 0",
        "gotchas": [
          "Filtering out empty sets",
          "Only tracking songs with plays"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "add_song",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap put operation"
      },
      {
        "operation": "play_song",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup + Set add"
      },
      {
        "operation": "print_analytics",
        "target": "O(S log S)",
        "achieved": "O(S log S)",
        "why": "S = songs, sorting dominates"
      }
    ],
    "non_goals": [
      "Persisting data across sessions",
      "Thread-safe concurrent access",
      "Removing songs or users",
      "Querying specific song statistics"
    ]
  },
  "assumptions": [
    "Song names are non-null and non-empty (length 1-100 per constraints)",
    "User IDs are positive integers (1 to 10^6 per constraints)",
    "Operations are called sequentially (no concurrency)",
    "Memory fits all songs and listener sets",
    "Standard lexicographic ordering for string comparison"
  ],
  "tradeoffs": [
    {
      "decision": "Store listeners as Set per song vs. global Map<(songId, userId), Boolean>",
      "chosen": "Set per song",
      "why": "Encapsulates data with Song object, cleaner OOP, easier to get count per song",
      "alternative": "Global map",
      "when_to_switch": "If need to query 'which songs did user X play?' frequently"
    },
    {
      "decision": "Sort on demand vs. maintain sorted structure",
      "chosen": "Sort on demand in print_analytics()",
      "why": "Simpler code, print_analytics likely called less often than play_song",
      "alternative": "TreeSet with custom comparator",
      "when_to_switch": "If print_analytics called after every play (real-time dashboard)"
    },
    {
      "decision": "Song as separate class vs. inline data",
      "chosen": "Separate Song class",
      "why": "Better encapsulation, easier extensibility, cleaner code",
      "alternative": "Map<Integer, String> + Map<Integer, Set<Integer>>",
      "when_to_switch": "Never - always prefer clean OOP in design problems"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "Encapsulate song data in Song class - easy to add fields later",
      "Keep public API minimal - only expose required methods",
      "Store raw data (listeners) not derived (count) - supports new queries"
    ],
    "why_this_design_scales": "The Song class can easily add: play timestamps, total plays, genre, artist. The SongAnalytics class can add: top-K queries, time-range filtering, user-specific analytics. The HashMap + Set foundation supports all these.",
    "expected_followup_hooks": [
      "Song class will add timestamp tracking (Part 2: Recent Plays)",
      "May need to store play events as objects, not just user IDs",
      "print_analytics may need filtering parameters"
    ],
    "invariants": [
      "song_id is always positive and unique",
      "listeners Set never contains duplicates (guaranteed by Set)",
      "All songs in HashMap appear in print_analytics output"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SONG ANALYTICS SYSTEM                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   Song A     \u2502     \u2502   Song B     \u2502     \u2502   Song C     \u2502    \u2502\n\u2502  \u2502   ID: 1      \u2502     \u2502   ID: 2      \u2502     \u2502   ID: 3      \u2502    \u2502\n\u2502  \u2502 Listeners:   \u2502     \u2502 Listeners:   \u2502     \u2502 Listeners:   \u2502    \u2502\n\u2502  \u2502 {101, 102}   \u2502     \u2502 {101}        \u2502     \u2502 {103}        \u2502    \u2502\n\u2502  \u2502 Count: 2     \u2502     \u2502 Count: 1     \u2502     \u2502 Count: 1     \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                                  \u2502\n\u2502  Output (sorted by count DESC, name ASC):                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 Song A (2 unique listeners)    \u2190 Highest count         \u2502    \u2502\n\u2502  \u2502 Song B (1 unique listeners)    \u2190 Tie: B < C            \u2502    \u2502\n\u2502  \u2502 Song C (1 unique listeners)    \u2190 Tie: C > B            \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     DATA STRUCTURES                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  SongAnalytics:                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  next_id: int = 4 (next ID to assign)                \u2502   \u2502\n\u2502  \u2502                                                       \u2502   \u2502\n\u2502  \u2502  songs: HashMap<Integer, Song>                        \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502 Key  \u2502 Value (Song Object)                     \u2502  \u2502   \u2502\n\u2502  \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502   \u2502\n\u2502  \u2502  \u2502  1   \u2502 Song(name=\"A\", listeners={101,102})     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502  2   \u2502 Song(name=\"B\", listeners={101})         \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502  3   \u2502 Song(name=\"C\", listeners={103})         \u2502  \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                              \u2502\n\u2502  Song Class:                                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  name: String                                         \u2502   \u2502\n\u2502  \u2502  listeners: Set<Integer>  \u2190 Auto-handles duplicates  \u2502   \u2502\n\u2502  \u2502                                                       \u2502   \u2502\n\u2502  \u2502  Methods:                                             \u2502   \u2502\n\u2502  \u2502  - add_listener(user_id): listeners.add(user_id)     \u2502   \u2502\n\u2502  \u2502  - get_count(): listeners.size()                     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Initialize SongAnalytics",
        "visualization": "```\nnext_id = 1\nsongs = {} (empty HashMap)\n```",
        "key_point": "ID starts from 1, not 0"
      },
      {
        "step": 2,
        "description": "add_song(\"Song A\")",
        "visualization": "```\nCreate Song(name=\"Song A\", listeners={})\nsongs[1] = song\nnext_id = 2\nReturn: 1\n```",
        "key_point": "Increment AFTER assignment"
      },
      {
        "step": 3,
        "description": "play_song(1, 101)",
        "visualization": "```\nsongs[1].listeners.add(101)\nsongs[1].listeners = {101}\n```",
        "key_point": "Set automatically handles uniqueness"
      },
      {
        "step": 4,
        "description": "play_song(1, 101) AGAIN",
        "visualization": "```\nsongs[1].listeners.add(101)  \u2190 No change!\nsongs[1].listeners = {101}   \u2190 Still just {101}\n```",
        "key_point": "Duplicate user - Set ignores it"
      },
      {
        "step": 5,
        "description": "print_analytics()",
        "visualization": "```\n1. Collect all songs from HashMap\n2. Sort by: (-count, name)\n3. Print each: \"{name} ({count} unique listeners)\"\n```",
        "key_point": "Negate count for descending order"
      }
    ],
    "dry_run_table": "| Step | Operation | songs HashMap | next_id | Output |\n|------|-----------|---------------|---------|--------|\n| 1 | SongAnalytics() | {} | 1 | - |\n| 2 | add_song(\"Song A\") | {1: Song(A, {})} | 2 | 1 |\n| 3 | add_song(\"Song B\") | {1: Song(A, {}), 2: Song(B, {})} | 3 | 2 |\n| 4 | play_song(1, 101) | {1: Song(A, {101}), 2: Song(B, {})} | 3 | - |\n| 5 | play_song(1, 102) | {1: Song(A, {101,102}), 2: Song(B, {})} | 3 | - |\n| 6 | play_song(1, 101) | {1: Song(A, {101,102}), 2: Song(B, {})} | 3 | - (no change!) |\n| 7 | play_song(2, 101) | {1: Song(A, {101,102}), 2: Song(B, {101})} | 3 | - |\n| 8 | play_song(999, 1) | unchanged | 3 | Error msg |\n| 9 | print_analytics() | unchanged | 3 | Song A (2)\\nSong B (1) |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'unique listeners', I immediately think **Set** - it automatically prevents duplicates",
      "When I see 'lookup by ID', I think **HashMap** for O(1) access",
      "The 'auto-incrementing ID starting from 1' suggests a simple counter variable",
      "For sorting by 'count DESC, name ASC', I'll need a **custom comparator** with two keys",
      "The error message format is exact - I need to match it precisely",
      "Songs with 0 listeners must appear - so I iterate ALL songs, not just played ones"
    ],
    "key_insight": "**The Set data structure is the hero here.** It elegantly solves the 'unique listeners only' requirement - `set.add(userId)` is idempotent. Combined with HashMap for O(1) song lookup, all operations become O(1) except print_analytics which requires sorting.",
    "why_this_works": "HashMap gives O(1) song lookup by ID. Set gives O(1) add/contains and automatically handles duplicates. Sorting is O(S log S) where S is number of songs - acceptable since print_analytics is likely called infrequently. The design separates concerns: Song class manages its own data, SongAnalytics orchestrates the system."
  },
  "approaches": [
    {
      "name": "Brute Force: List + Manual Deduplication",
      "description": "Store listeners in a List, check for existence before adding",
      "pseudocode": "class Song:\n    listeners = []  # List\n\ndef play_song(song_id, user_id):\n    if user_id not in song.listeners:  # O(n) check\n        song.listeners.append(user_id)",
      "time_complexity": "O(L) per play_song where L = listeners",
      "space_complexity": "O(L) per song",
      "pros": [
        "Simple to understand",
        "No Set knowledge needed"
      ],
      "cons": [
        "O(L) per play is too slow for 100,000 plays",
        "Manual deduplication is error-prone"
      ],
      "when_to_use": "Never in interviews - shows lack of data structure knowledge"
    },
    {
      "name": "Optimal: HashMap + Set",
      "description": "Use HashMap for song lookup, Set for listener tracking per song",
      "pseudocode": "class Song:\n    listeners = set()  # Set\n\ndef play_song(song_id, user_id):\n    song.listeners.add(user_id)  # O(1), auto-dedupes",
      "time_complexity": "O(1) for add_song and play_song, O(S log S) for print_analytics",
      "space_complexity": "O(S + total_unique_listeners)",
      "pros": [
        "Optimal time complexity",
        "Clean code",
        "Set handles dedup automatically"
      ],
      "cons": [
        "Slightly more memory than needed (Set overhead)"
      ],
      "key_insight": "Let the data structure do the work - Set.add() is idempotent"
    }
  ],
  "optimal_solution": {
    "name": "HashMap + Set with Custom Sorting",
    "explanation_md": "## Approach\n\nThe solution uses a clean OOP design with two classes:\n\n### Song Class\nEncapsulates song data:\n- `name`: The song's display name\n- `listeners`: A **Set** of user IDs who have played this song\n\nUsing a Set is the key insight - `set.add(userId)` automatically handles duplicates. If the same user plays the same song 10 times, the Set still contains just one entry.\n\n### SongAnalytics Class\nManages the system:\n- `songs`: HashMap mapping song_id \u2192 Song object for O(1) lookup\n- `next_id`: Counter for auto-incrementing IDs (starts at 1!)\n\n### Why This Works\n1. **add_song**: O(1) - Create Song, put in HashMap, increment counter\n2. **play_song**: O(1) - HashMap lookup + Set add (both O(1))\n3. **print_analytics**: O(S log S) - Collect songs, sort, print\n\nThe sorting uses a tuple key `(-count, name)` which sorts by count descending (due to negation), then name ascending.",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Song>",
        "purpose": "O(1) song lookup by ID"
      },
      {
        "structure": "Set<Integer> per Song",
        "purpose": "O(1) unique listener tracking, auto-deduplication"
      },
      {
        "structure": "int next_id",
        "purpose": "Auto-incrementing ID assignment"
      }
    ],
    "algorithm_steps": [
      "1. **__init__**: Initialize empty songs HashMap, set next_id = 1",
      "2. **add_song**: Create Song object, store in HashMap with current next_id, increment next_id, return assigned ID",
      "3. **play_song**: Check if song_id exists (error if not), then add user_id to song's listeners Set",
      "4. **print_analytics**: Collect all songs, sort by (-listener_count, name), print formatted output"
    ],
    "why_set": "Set.add() is **idempotent** - adding the same element multiple times has no effect. This perfectly matches 'unique listeners only' requirement without any extra logic."
  },
  "solution_python_lines": [
    "from typing import Set",
    "",
    "",
    "class Song:",
    "    \"\"\"Represents a song with unique listener tracking via Set.\"\"\"",
    "    ",
    "    def __init__(self, name: str) -> None:",
    "        self.name = name",
    "        self.listeners: Set[int] = set()  # Set auto-handles duplicates",
    "    ",
    "    def add_listener(self, user_id: int) -> None:",
    "        \"\"\"Add listener - Set.add() is idempotent.\"\"\"",
    "        self.listeners.add(user_id)",
    "    ",
    "    def get_listener_count(self) -> int:",
    "        return len(self.listeners)",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    Music streaming analytics system.",
    "    Tracks unique listeners per song and generates sorted reports.",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        self.songs: dict[int, Song] = {}  # song_id -> Song",
    "        self.next_id = 1  # IDs start from 1, not 0!",
    "    ",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"Add song with auto-assigned ID. Returns the assigned ID.\"\"\"",
    "        song_id = self.next_id",
    "        self.songs[song_id] = Song(name)",
    "        self.next_id += 1",
    "        return song_id",
    "    ",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"Record a play event. Prints error if song doesn't exist.\"\"\"",
    "        if song_id not in self.songs:",
    "            print(f\"Error: Song ID {song_id} does not exist.\")",
    "            return",
    "        self.songs[song_id].add_listener(user_id)",
    "    ",
    "    def print_analytics(self) -> None:",
    "        \"\"\"Print songs sorted by unique listeners (desc), then name (asc).\"\"\"",
    "        # Sort by: (-count, name) -> count DESC, name ASC",
    "        sorted_songs = sorted(",
    "            self.songs.values(),",
    "            key=lambda s: (-s.get_listener_count(), s.name)",
    "        )",
    "        for song in sorted_songs:",
    "            print(f\"{song.name} ({song.get_listener_count()} unique listeners)\")",
    "",
    "",
    "if __name__ == '__main__':",
    "    # Demo: Basic operations from Example 1",
    "    print(\"=\" * 60)",
    "    print(\"Example 1: Basic Operations\")",
    "    print(\"=\" * 60)",
    "    analytics = SongAnalytics()",
    "    ",
    "    # Add songs",
    "    id1 = analytics.add_song(\"Song A\")  # ID: 1",
    "    id2 = analytics.add_song(\"Song B\")  # ID: 2",
    "    id3 = analytics.add_song(\"Song C\")  # ID: 3",
    "    print(f\"Added songs with IDs: {id1}, {id2}, {id3}\")",
    "    ",
    "    # Play songs - note user 3 plays Song C twice",
    "    analytics.play_song(1, 1)  # Song A: {1}",
    "    analytics.play_song(1, 2)  # Song A: {1, 2}",
    "    analytics.play_song(2, 1)  # Song B: {1}",
    "    analytics.play_song(3, 3)  # Song C: {3}",
    "    analytics.play_song(3, 3)  # Song C: {3} - no change (duplicate!)",
    "    ",
    "    print(\"\\nAnalytics Report:\")",
    "    analytics.print_analytics()",
    "    ",
    "    # Demo: Tie-breaking by name",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 2: Tie-Breaking by Name\")",
    "    print(\"=\" * 60)",
    "    analytics2 = SongAnalytics()",
    "    analytics2.add_song(\"Zebra\")",
    "    analytics2.add_song(\"Apple\")",
    "    analytics2.add_song(\"Mango\")",
    "    analytics2.play_song(1, 100)  # Zebra",
    "    analytics2.play_song(2, 200)  # Apple",
    "    analytics2.play_song(3, 300)  # Mango",
    "    print(\"All have 1 listener - sorted alphabetically:\")",
    "    analytics2.print_analytics()",
    "    ",
    "    # Demo: Error handling",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 3: Error Handling\")",
    "    print(\"=\" * 60)",
    "    analytics3 = SongAnalytics()",
    "    analytics3.add_song(\"Hello\")",
    "    analytics3.play_song(999, 5)  # Invalid ID",
    "    ",
    "    # Demo: Songs with zero listeners",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 4: Zero Listeners\")",
    "    print(\"=\" * 60)",
    "    analytics4 = SongAnalytics()",
    "    analytics4.add_song(\"Popular\")",
    "    analytics4.add_song(\"Unpopular\")",
    "    analytics4.play_song(1, 1)",
    "    print(\"Unpopular song still appears:\")",
    "    analytics4.print_analytics()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Song with unique listener tracking via HashSet.",
    " */",
    "class Song {",
    "    private String name;",
    "    private Set<Integer> listeners;",
    "    ",
    "    public Song(String name) {",
    "        this.name = name;",
    "        this.listeners = new HashSet<>();",
    "    }",
    "    ",
    "    public void addListener(int userId) {",
    "        listeners.add(userId);  // Set handles duplicates",
    "    }",
    "    ",
    "    public int getListenerCount() {",
    "        return listeners.size();",
    "    }",
    "    ",
    "    public String getName() {",
    "        return name;",
    "    }",
    "}",
    "",
    "/**",
    " * Music streaming analytics system.",
    " * Tracks unique listeners per song and generates sorted reports.",
    " */",
    "public class SongAnalytics {",
    "    private Map<Integer, Song> songs;",
    "    private int nextId;",
    "    ",
    "    public SongAnalytics() {",
    "        this.songs = new HashMap<>();",
    "        this.nextId = 1;  // Start from 1, not 0!",
    "    }",
    "    ",
    "    public int addSong(String name) {",
    "        int songId = nextId;",
    "        songs.put(songId, new Song(name));",
    "        nextId++;",
    "        return songId;",
    "    }",
    "    ",
    "    public void playSong(int songId, int userId) {",
    "        if (!songs.containsKey(songId)) {",
    "            System.out.println(\"Error: Song ID \" + songId + \" does not exist.\");",
    "            return;",
    "        }",
    "        songs.get(songId).addListener(userId);",
    "    }",
    "    ",
    "    public void printAnalytics() {",
    "        // Collect and sort: count DESC, then name ASC",
    "        List<Song> sortedSongs = new ArrayList<>(songs.values());",
    "        sortedSongs.sort((a, b) -> {",
    "            int countCompare = Integer.compare(b.getListenerCount(), a.getListenerCount());",
    "            if (countCompare != 0) return countCompare;",
    "            return a.getName().compareTo(b.getName());",
    "        });",
    "        ",
    "        for (Song song : sortedSongs) {",
    "            System.out.println(song.getName() + \" (\" + ",
    "                song.getListenerCount() + \" unique listeners)\");",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Example 1: Basic Operations\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        int id1 = analytics.addSong(\"Song A\");",
    "        int id2 = analytics.addSong(\"Song B\");",
    "        int id3 = analytics.addSong(\"Song C\");",
    "        System.out.println(\"Added songs with IDs: \" + id1 + \", \" + id2 + \", \" + id3);",
    "        ",
    "        analytics.playSong(1, 1);",
    "        analytics.playSong(1, 2);",
    "        analytics.playSong(2, 1);",
    "        analytics.playSong(3, 3);",
    "        analytics.playSong(3, 3);  // Duplicate - no change",
    "        ",
    "        System.out.println(\"\\nAnalytics Report:\");",
    "        analytics.printAnalytics();",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"Example 2: Tie-Breaking\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        SongAnalytics analytics2 = new SongAnalytics();",
    "        analytics2.addSong(\"Zebra\");",
    "        analytics2.addSong(\"Apple\");",
    "        analytics2.addSong(\"Mango\");",
    "        analytics2.playSong(1, 100);",
    "        analytics2.playSong(2, 200);",
    "        analytics2.playSong(3, 300);",
    "        System.out.println(\"Sorted alphabetically (all tied):\");",
    "        analytics2.printAnalytics();",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"Example 3: Error Handling\");",
    "        System.out.println(\"============================================================\");",
    "        SongAnalytics analytics3 = new SongAnalytics();",
    "        analytics3.addSong(\"Hello\");",
    "        analytics3.playSong(999, 5);  // Invalid",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-16 (Python) / 1-24 (Java)",
      "section": "Song Class",
      "explanation": "The Song class encapsulates a song's name and its unique listeners. **Key insight**: Using a Set for listeners means `add()` automatically handles duplicates - if the same user plays the song 10 times, the Set still contains just one entry. `get_listener_count()` simply returns the Set's size."
    },
    {
      "lines": "18-27 (Python) / 26-39 (Java)",
      "section": "SongAnalytics Initialization",
      "explanation": "We maintain a HashMap mapping song_id to Song objects for O(1) lookup, and a counter `next_id` starting at **1** (not 0!) for auto-incrementing IDs. This is a common interview gotcha."
    },
    {
      "lines": "29-34 (Python) / 41-46 (Java)",
      "section": "add_song Method",
      "explanation": "Create a new Song, store it with the current `next_id`, then increment the counter. The key order is: save current ID \u2192 store song \u2192 increment. Return the assigned ID."
    },
    {
      "lines": "36-41 (Python) / 48-54 (Java)",
      "section": "play_song Method",
      "explanation": "First validate the song_id exists - print exact error message if not. Then delegate to the Song's `add_listener()` method. The Set handles duplicate users automatically."
    },
    {
      "lines": "43-50 (Python) / 56-66 (Java)",
      "section": "print_analytics Method",
      "explanation": "The sorting is the trickiest part. We sort by a **tuple key** `(-count, name)` - negating count makes it descending, while name sorts ascending. In Java, we use a custom comparator with `Integer.compare(b, a)` for descending count."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test add_song alone - verify IDs start at 1 and increment. 2. Test play_song with valid ID. 3. Test play_song with invalid ID. 4. Test duplicate plays by same user. 5. Test print_analytics sorting.",
    "what_to_print_or_assert": [
      "print(f'Assigned ID: {song_id}') after add_song",
      "print(f'Listeners after play: {song.listeners}') in play_song",
      "print(f'Sort key: ({-s.get_listener_count()}, {s.name})') before sorting"
    ],
    "common_failure_modes": [
      "ID starting from 0 instead of 1",
      "Count increasing on duplicate plays (using List not Set)",
      "Sorting ascending instead of descending",
      "Missing tie-breaker by name",
      "Wrong error message format"
    ],
    "how_to_fix_fast": "1. Print the listener Set after each play to verify no duplicates. 2. Print sort keys to verify negative count for descending. 3. Add test case with exact duplicate user to catch List vs Set."
  },
  "complexity_analysis": {
    "time": {
      "add_song": {
        "complexity": "O(1)",
        "explanation": "HashMap put + integer increment"
      },
      "play_song": {
        "complexity": "O(1)",
        "explanation": "HashMap containsKey + get + Set add"
      },
      "print_analytics": {
        "complexity": "O(S log S)",
        "explanation": "S = number of songs, dominated by sorting"
      },
      "overall": "O(1) for add/play operations, O(S log S) for analytics"
    },
    "space": {
      "complexity": "O(S + L) where S = songs, L = total unique (song, user) pairs",
      "breakdown": "- HashMap for songs: O(S)\n- Set per song for listeners: O(L) total across all songs\n- Sorting creates a copy: O(S) temporary",
      "note": "We store listener IDs, not play events - space efficient"
    },
    "can_we_do_better": "For print_analytics, we could maintain a sorted structure (TreeSet with custom comparator), but it would complicate play_song since counts change. Current design is optimal for write-heavy workloads."
  },
  "dry_run": {
    "example": "add_song(\"Song A\"), add_song(\"Song B\"), play_song(1, 101), play_song(1, 102), play_song(1, 101), play_song(2, 101), print_analytics()",
    "trace_table": "| Step | Operation | songs Map | next_id | Output |\n|------|-----------|-----------|---------|--------|\n| 1 | SongAnalytics() | {} | 1 | - |\n| 2 | add_song(\"Song A\") | {1: Song(A, {})} | 2 | **1** |\n| 3 | add_song(\"Song B\") | {1: Song(A, {}), 2: Song(B, {})} | 3 | **2** |\n| 4 | play_song(1, 101) | {1: Song(A, {101}), 2: Song(B, {})} | 3 | - |\n| 5 | play_song(1, 102) | {1: Song(A, {101, 102}), 2: Song(B, {})} | 3 | - |\n| 6 | play_song(1, 101) | {1: Song(A, {101, 102}), 2: Song(B, {})} | 3 | - (no change!) |\n| 7 | play_song(2, 101) | {1: Song(A, {101, 102}), 2: Song(B, {101})} | 3 | - |\n| 8 | print_analytics() | Sort: A(2), B(1) | 3 | Song A (2)\\nSong B (1) |",
    "final_answer": "Song A (2 unique listeners)\\nSong B (1 unique listeners)"
  },
  "test_cases": [
    {
      "name": "Basic - Single song, single user",
      "category": "Happy Path",
      "input": "add_song('Hello'), play_song(1, 42), print_analytics()",
      "expected": "Hello (1 unique listeners)",
      "explanation": "Most basic case: one song, one play, one user"
    },
    {
      "name": "Duplicate user - Same user plays same song multiple times",
      "category": "Core Logic",
      "input": "add_song('Test'), play_song(1,1), play_song(1,1), play_song(1,1), print_analytics()",
      "expected": "Test (1 unique listeners)",
      "explanation": "User 1 plays 3 times but count stays at 1 - Set handles this"
    },
    {
      "name": "Tie-breaking by name",
      "category": "Sorting",
      "input": "add_song('Zebra'), add_song('Apple'), play each once, print_analytics()",
      "expected": "Apple (1 unique listeners)\\nZebra (1 unique listeners)",
      "explanation": "Equal counts \u2192 sort alphabetically ascending"
    },
    {
      "name": "Invalid song ID",
      "category": "Error Handling",
      "input": "add_song('Valid'), play_song(999, 1)",
      "expected": "Error: Song ID 999 does not exist.",
      "explanation": "Must match exact error format"
    },
    {
      "name": "Song with zero listeners",
      "category": "Edge Case",
      "input": "add_song('Popular'), add_song('Unpopular'), play_song(1, 1), print_analytics()",
      "expected": "Popular (1 unique listeners)\\nUnpopular (0 unique listeners)",
      "explanation": "Unpopular has 0 listeners but must still appear"
    },
    {
      "name": "Complex sorting",
      "category": "Integration",
      "input": "Echo(3 listeners), Alpha(2), Beta(1), Delta(1), Gamma(1)",
      "expected": "Echo (3)\\nAlpha (2)\\nBeta (1)\\nDelta (1)\\nGamma (1)",
      "explanation": "First by count DESC, then by name ASC for ties"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Starting ID from 0 instead of 1",
      "why_wrong": "Problem explicitly states 'starting from 1'",
      "correct_approach": "Initialize next_id = 1",
      "code_wrong": "self.next_id = 0",
      "code_correct": "self.next_id = 1  # Start from 1!"
    },
    {
      "mistake": "Using List instead of Set for listeners",
      "why_wrong": "Duplicate users will increase count",
      "correct_approach": "Use Set - add() is idempotent",
      "code_wrong": "self.listeners = []  # List\nself.listeners.append(user_id)",
      "code_correct": "self.listeners = set()  # Set\nself.listeners.add(user_id)"
    },
    {
      "mistake": "Sorting count in ascending order",
      "why_wrong": "Problem says 'descending order' for counts",
      "correct_approach": "Negate count or reverse comparison",
      "code_wrong": "key=lambda s: (s.get_listener_count(), s.name)",
      "code_correct": "key=lambda s: (-s.get_listener_count(), s.name)"
    },
    {
      "mistake": "Forgetting name tie-breaker",
      "why_wrong": "Songs with same count will have undefined order",
      "correct_approach": "Add name as secondary sort key",
      "code_wrong": "key=lambda s: -s.get_listener_count()",
      "code_correct": "key=lambda s: (-s.get_listener_count(), s.name)"
    },
    {
      "mistake": "Wrong error message format",
      "why_wrong": "Exact format is specified and often tested",
      "correct_approach": "Match format exactly: 'Error: Song ID X does not exist.'",
      "code_wrong": "print('Song not found')",
      "code_correct": "print(f'Error: Song ID {song_id} does not exist.')"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start, I'd like to clarify a few things to make sure I understand the requirements correctly...",
    "clarifying_questions_to_ask": [
      "Should duplicate song names create separate entries? (Confirm: yes)",
      "What's the exact format for error messages?",
      "Should songs with 0 listeners appear in analytics?",
      "Is thread-safety a concern for this interview?"
    ],
    "what_to_mention_proactively": [
      "I'll use a Set for listeners since we need unique counts only",
      "IDs start from 1 per the requirements",
      "For sorting, I'll use a tuple key: (-count, name) for desc/asc",
      "Let me trace through the example after coding"
    ],
    "communication_during_coding": [
      "I'm creating a Song class to encapsulate the data - good OOP practice",
      "Using Set here because add() is idempotent - handles duplicates automatically",
      "Note the next_id starts at 1, not 0",
      "The key insight for sorting is negating the count for descending order"
    ],
    "if_stuck": [
      "Step back: What data structure prevents duplicates? Set!",
      "For sorting: How do I sort descending? Negate the value!",
      "Draw the data structures and trace through manually"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Explain approach | 10-25min: Code | 25-35min: Test & trace | 35-45min: Discuss follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "HashMap + Set for Unique Counting",
    "indicators": [
      "Track 'unique' X per Y",
      "Same entity counted only once",
      "Need O(1) lookup by ID"
    ],
    "similar_problems": [
      "LC 355 - Design Twitter: Track followed users per user",
      "LC 347 - Top K Frequent Elements: Count unique occurrences",
      "LC 692 - Top K Frequent Words: Similar sorting requirement"
    ],
    "template": "HashMap<ID, Object> where Object contains Set<RelatedID>"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 adds 'recent plays with duplicates' - you'll need to store individual play events with timestamps, likely using a deque or list sorted by time",
    "part_3_hint": "Part 3 asks for 'recent unique plays' - combines Part 2's time-based filtering with Part 1's uniqueness. Consider a LinkedHashSet or timestamp-keyed structure",
    "data_structure_evolution": "Part 1: HashMap + Set (just unique users) \u2192 Part 2: Add List/Deque of timestamps \u2192 Part 3: Combine with OrderedDict/LinkedHashMap"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. It looks like a classic OOP design with some analytics requirements. Before I start coding, let me clarify a few things and share my initial approach...",
    "after_clarification": "Great, so to summarize: I need to track unique listeners per song using a Set, auto-increment IDs starting from 1, handle invalid song IDs with a specific error message, and sort by count descending then name ascending. My approach will use a Song class with a HashSet for listeners, and a SongAnalytics class with a HashMap for song lookup. Sound good?",
    "while_coding": [
      "I'm using a Set for listeners because Set.add() is idempotent - it handles duplicates automatically",
      "Note I'm starting next_id at 1, not 0, per the requirements",
      "For the sort key, I'm using (-count, name) - the negative makes it descending"
    ],
    "after_coding": "Let me trace through Example 1 to verify this works correctly...",
    "when_stuck_verbatim": "I'm thinking about the sorting... Let me consider: I need count descending and name ascending. In Python, I can negate the count in the tuple key...",
    "after_mistake": "Actually, I see I started the ID from 0 - let me fix that to 1 as specified.",
    "before_moving_on": "This handles Part 1 with O(1) for add/play operations and O(S log S) for analytics. The space is O(S + L) for songs and listeners. Ready for the follow-up?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Understanding of Set for uniqueness",
      "Clean OOP design with proper encapsulation",
      "Correct sorting with multi-key comparator",
      "Attention to detail (ID from 1, exact error format)",
      "Testing instinct and edge case awareness"
    ],
    "bonus_points": [
      "Mentioning Set is idempotent unprompted",
      "Explaining the (-count, name) tuple trick for sorting",
      "Asking about edge cases like 0-listener songs",
      "Clean separation of Song and SongAnalytics classes",
      "Discussing thread-safety for production"
    ],
    "red_flags": [
      "Using List instead of Set (shows weak data structure knowledge)",
      "Forgetting the name tie-breaker in sorting",
      "Wrong ID starting point (0 vs 1)",
      "Not validating song_id in play_song",
      "Silent coding without explaining approach"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize Set as the solution for 'unique' counting, explain the sorting tuple trick clearly, handle all edge cases without being reminded, and write clean, well-organized code. They treat the problem as a mini-system design, thinking about extensibility."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions, identify Set for uniqueness and HashMap for lookup",
    "by_10_min": "Explain full approach including sorting strategy, get interviewer buy-in",
    "by_20_min": "Core implementation complete with both classes",
    "by_25_min": "Error handling added, basic testing done",
    "by_30_min": "Dry run complete, edge cases discussed, ready for Part 2",
    "warning_signs": "If still designing at 15 min or still coding at 35 min, simplify or ask for hints"
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'Actually, I see the sort is wrong - I'm sorting ascending instead of descending. Let me fix that by negating the count.' Fix quickly and move on.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact Python sort key syntax, but I need to sort by -count then name. Let me write it as a lambda...' Then look it up or ask.",
    "when_approach_is_wrong": "Say: 'Actually, using a List for listeners won't work for unique counts. I should use a Set instead - let me update that.'",
    "when_completely_stuck": "Say: 'I'm stuck on how to sort by multiple keys. Could you give me a hint on Python's sort key for multi-criteria sorting?'",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on the core logic and skip some edge case handling. I'd add validation for [X, Y, Z] given more time.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Use AI for boilerplate like class structure and imports, but solve the core logic yourself.",
    "what_to_do": [
      "Let AI generate class skeleton and __init__",
      "Use for syntax help (e.g., Python sort key)",
      "Generate test cases with AI"
    ],
    "what_not_to_do": [
      "Don't paste the whole problem and accept solution",
      "Don't accept sorting logic without understanding it",
      "Don't let AI choose data structures for you"
    ],
    "how_to_demonstrate_understanding": "If AI suggests using Set, explain WHY: 'Set is perfect here because add() is idempotent - adding the same user twice has no effect, which is exactly what we need for unique counting.'",
    "expectation_adjustment": "With AI, you should complete all parts faster. If AI is slowing you down, turn it off."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately saying 'Set for unique listeners'",
      "Explaining the (-count, name) tuple trick unprompted",
      "Drawing a quick data structure diagram",
      "Mentioning edge case of 0-listener songs",
      "Discussing how the design extends for follow-ups"
    ],
    "subtle_signals_of_experience": [
      "Using proper encapsulation (Song class owns its listeners)",
      "Consistent naming conventions",
      "Testing incrementally, not just at the end",
      "Considering error message format seriously"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Going silent for more than 30 seconds",
      "Getting defensive when interviewer suggests an issue",
      "Not asking any clarifying questions",
      "Saying 'this is trivial' (it's not as simple as it looks)"
    ],
    "technical": [
      "Using List for unique listener tracking",
      "Hardcoding test values in the class",
      "Ignoring the ID starting point requirement",
      "Writing O(n) play_song by iterating all songs"
    ],
    "communication": [
      "Jumping to code without explaining approach",
      "Not mentioning complexity",
      "Forgetting to trace through an example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "IDs start from 1, not 0? \u2713",
      "Set used for listeners (not List)? \u2713",
      "Error message format exact? \u2713",
      "Sort by count DESC, name ASC? \u2713",
      "0-listener songs included? \u2713",
      "Traced through at least one example? \u2713"
    ],
    "quick_code_review": [
      "No magic numbers (1 is documented)",
      "Consistent naming (snake_case for Python)",
      "Proper indentation",
      "Error handling present"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation (non-empty names, positive IDs)",
      "Logging for play events (for debugging/analytics)",
      "Thread-safety if concurrent access",
      "Persistence layer for durability",
      "Caching for frequently accessed analytics"
    ],
    "why_not_in_interview": "Interview code should focus on the algorithm and data structures. Mention these verbally to show senior thinking.",
    "how_to_mention": "Say: 'In production, I'd add thread-safety with locks, logging for observability, and input validation. But for this interview, I'll focus on the core logic.'"
  },
  "generated_at": "2026-01-19T04:06:40.158504",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}