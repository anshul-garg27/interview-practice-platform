{
  "problem_title": "2D Canvas / Drawing Application - Part 3: Delete Shape and Z-Order Control",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 3 adds shape deletion and z-order manipulation. We need to remove shapes from both data structures (list + HashMap), and reorder shapes within the list to change which shape appears on top.",
    "new_requirements": [
      "deleteShape: Remove shape from canvas entirely",
      "bringToFront: Move shape to top of z-order (end of list)",
      "sendToBack: Move shape to bottom of z-order (beginning of list)"
    ],
    "new_constraints": [
      "Must maintain consistency between shapes list and shapes_by_id HashMap",
      "Invalid shape IDs should be silently ignored",
      "Z-order changes must be reflected immediately in get_shape_at queries"
    ],
    "key_insight": "Z-order is simply list position. Changing order means removing from current position and reinserting at the desired position. The HashMap gives us O(1) access to the Shape object, then we manipulate the list."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "deleteShape removes shape completely",
        "how_met": "Remove from HashMap with pop/remove, then remove from list",
        "gotchas": [
          "Must remove from BOTH data structures",
          "Use pop() to get object for list removal"
        ]
      },
      {
        "requirement": "bringToFront moves shape to top",
        "how_met": "Remove from current list position, append to end",
        "gotchas": [
          "Don't forget shape stays in HashMap",
          "Append goes to END which is TOP in z-order"
        ]
      },
      {
        "requirement": "sendToBack moves shape to bottom",
        "how_met": "Remove from current list position, insert at index 0",
        "gotchas": [
          "Insert at 0 puts at BOTTOM",
          "This is O(n) due to array shift"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "deleteShape",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "List removal requires finding/shifting elements"
      },
      {
        "operation": "bringToFront",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "List removal is O(n), append is O(1)"
      },
      {
        "operation": "sendToBack",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "List removal O(n) + insert at 0 O(n)"
      }
    ],
    "non_goals": [
      "O(1) z-order operations (would need LinkedList with node references)",
      "Undo/redo for delete operations",
      "Batch operations for multiple shapes"
    ]
  },
  "assumptions": [
    "Invalid shape IDs are silently ignored (consistent with Part 2)",
    "Bringing to front a shape already at front is a no-op (valid operation)",
    "Sending to back a shape already at back is a no-op (valid operation)",
    "Deleted shapes cannot be recovered (no undo)"
  ],
  "tradeoffs": [
    {
      "decision": "ArrayList vs LinkedList for shapes",
      "chosen": "ArrayList (keep existing)",
      "why": "Simple implementation, O(n) operations acceptable for this problem",
      "alternative": "LinkedList with node HashMap",
      "when_to_switch": "If z-order operations become the bottleneck with thousands of operations"
    },
    {
      "decision": "Fail silently vs throw exception for invalid IDs",
      "chosen": "Fail silently",
      "why": "Consistent with Part 2 behavior, simpler API",
      "alternative": "Throw IllegalArgumentException",
      "when_to_switch": "If debugging/tracing invalid operations becomes important"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "shapes list as z-order source of truth",
      "shapes_by_id for O(1) lookup",
      "Silent failure on invalid IDs"
    ],
    "what_to_change": [
      "No new data structures needed for Part 3",
      "Only adding new methods that manipulate existing structures"
    ],
    "interfaces_and_boundaries": "The Shape class unchanged. Canvas gains three new public methods. All operations go through the dual data structure pattern.",
    "invariants": [
      "shapes_by_id.keys() == {s.id for s in shapes}",
      "After delete: shape in neither structure",
      "After bringToFront: shape at end of shapes list",
      "After sendToBack: shape at index 0 of shapes list"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE bringToFront(\"rect_1\"):\nshapes = [rect_1, circle_1, rect_2]\n              ^                ^^\n           bottom             top\n\nAFTER:\nshapes = [circle_1, rect_2, rect_1]\n              ^               ^^\n           bottom            top\n\n---\n\nBEFORE deleteShape(\"circle_1\"):\nshapes = [rect_1, circle_1, rect_2]\nshapes_by_id = {rect_1: *, circle_1: *, rect_2: *}\n\nAFTER:\nshapes = [rect_1, rect_2]\nshapes_by_id = {rect_1: *, rect_2: *}\n```",
    "algorithm_flow": "```\nbringToFront(\"rect_1\"):\n1. HashMap lookup: shape = shapes_by_id[\"rect_1\"] \u2192 O(1)\n2. List remove:    shapes.remove(shape)           \u2192 O(n)\n3. List append:    shapes.append(shape)           \u2192 O(1)\n\ndeleteShape(\"rect_1\"):\n1. HashMap remove: shape = shapes_by_id.pop(\"rect_1\") \u2192 O(1)\n2. List remove:    shapes.remove(shape)               \u2192 O(n)\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Loop through list to find shape by ID for each operation",
      "time_complexity": "O(n) for lookup + O(n) for remove = O(n)",
      "space_complexity": "O(1) extra",
      "why_not_optimal": "Actually acceptable here, but wastes the HashMap we already have for O(1) lookup"
    },
    {
      "name": "Optimal Approach (Using HashMap)",
      "description": "Use HashMap for O(1) shape lookup, then manipulate list directly",
      "time_complexity": "O(n) per operation due to list manipulation",
      "space_complexity": "O(1) extra (reusing existing structures)",
      "key_insight": "HashMap gives us the Shape object instantly. List.remove(object) handles finding and removing. We leverage both data structures."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution leverages the **dual data structure** pattern from Part 2:\n\n1. **HashMap** gives O(1) access to Shape object by ID\n2. **List** maintains z-order and we manipulate positions\n\nFor **deleteShape**: Pop from HashMap (returns the shape), then remove that shape from list.\n\nFor **bringToFront**: Get shape from HashMap, remove from list, append to end.\n\nFor **sendToBack**: Get shape from HashMap, remove from list, insert at index 0.\n\nAll operations are **O(n)** due to list manipulation, but this is acceptable and expected given we're using a simple ArrayList.",
    "data_structures": [
      {
        "structure": "List<Shape> shapes",
        "purpose": "Z-order storage, index 0 = bottom, last = top"
      },
      {
        "structure": "Dict[str, Shape] shapes_by_id",
        "purpose": "O(1) lookup by ID for all operations"
      }
    ],
    "algorithm_steps": [
      "Step 1: Check if shape_id exists in shapes_by_id",
      "Step 2: If not found, return immediately (silent ignore)",
      "Step 3: Get/remove shape reference from HashMap",
      "Step 4: Remove shape from list using object reference",
      "Step 5: For z-order ops, reinsert at appropriate position"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List, Dict",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all shapes on the canvas.\"\"\"",
    "    def __init__(self, shape_id: str):",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains(self, x: int, y: int) -> bool:",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    def __init__(self, shape_id: str, x: int, y: int, width: int, height: int):",
    "        super().__init__(shape_id)",
    "        self.x, self.y = x, y",
    "        self.width, self.height = width, height",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        self.x, self.y = new_x, new_y",
    "",
    "",
    "class Circle(Shape):",
    "    def __init__(self, shape_id: str, center_x: int, center_y: int, radius: int):",
    "        super().__init__(shape_id)",
    "        self.cx, self.cy = center_x, center_y",
    "        self.radius = radius",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        dx, dy = px - self.cx, py - self.cy",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        self.cx, self.cy = new_x, new_y",
    "",
    "",
    "class Canvas:",
    "    \"\"\"2D canvas with shape creation, hit testing, movement, and z-order control.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.shapes: List[Shape] = []           # Z-order: index 0 = bottom",
    "        self.shapes_by_id: Dict[str, Shape] = {}  # O(1) lookup by ID",
    "        self.rect_count = 0",
    "        self.circle_count = 0",
    "    ",
    "    def create_rectangle(self, x: int, y: int, width: int, height: int) -> str:",
    "        self.rect_count += 1",
    "        shape_id = f\"rect_{self.rect_count}\"",
    "        shape = Rectangle(shape_id, x, y, width, height)",
    "        self.shapes.append(shape)",
    "        self.shapes_by_id[shape_id] = shape",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: int, center_y: int, radius: int) -> str:",
    "        self.circle_count += 1",
    "        shape_id = f\"circle_{self.circle_count}\"",
    "        shape = Circle(shape_id, center_x, center_y, radius)",
    "        self.shapes.append(shape)",
    "        self.shapes_by_id[shape_id] = shape",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: int, y: int) -> Optional[str]:",
    "        \"\"\"Return topmost shape at point, or None. O(n).\"\"\"",
    "        for shape in reversed(self.shapes):",
    "            if shape.contains(x, y):",
    "                return shape.id",
    "        return None",
    "    ",
    "    def move_shape(self, shape_id: str, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move shape to new position. Z-order preserved. O(1).\"\"\"",
    "        if shape_id in self.shapes_by_id:",
    "            self.shapes_by_id[shape_id].move_to(new_x, new_y)",
    "    ",
    "    # ==================== PART 3: New Methods ====================",
    "    ",
    "    def delete_shape(self, shape_id: str) -> None:",
    "        \"\"\"Remove shape from canvas. O(n) for list removal.\"\"\"",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id.pop(shape_id)  # Remove from HashMap",
    "            self.shapes.remove(shape)                 # Remove from list",
    "    ",
    "    def bring_to_front(self, shape_id: str) -> None:",
    "        \"\"\"Move shape to top of z-order (drawn last). O(n).\"\"\"",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id[shape_id]",
    "            self.shapes.remove(shape)   # Remove from current position",
    "            self.shapes.append(shape)   # Add to end (top)",
    "    ",
    "    def send_to_back(self, shape_id: str) -> None:",
    "        \"\"\"Move shape to bottom of z-order (drawn first). O(n).\"\"\"",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id[shape_id]",
    "            self.shapes.remove(shape)      # Remove from current position",
    "            self.shapes.insert(0, shape)   # Insert at beginning (bottom)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"TEST 1: Delete Shape\")",
    "    print(\"=\" * 60)",
    "    canvas = Canvas()",
    "    canvas.create_rectangle(0, 0, 50, 50)   # rect_1 (bottom)",
    "    canvas.create_rectangle(25, 25, 50, 50) # rect_2 (top)",
    "    print(f\"Before delete: getShapeAt(30,30) = {canvas.get_shape_at(30, 30)}\")",
    "    canvas.delete_shape(\"rect_2\")",
    "    print(f\"After delete:  getShapeAt(30,30) = {canvas.get_shape_at(30, 30)}\")",
    "    print(f\"Deleted shape gone: 'rect_2' in shapes_by_id = {'rect_2' in canvas.shapes_by_id}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 2: Bring to Front\")",
    "    print(\"=\" * 60)",
    "    canvas2 = Canvas()",
    "    canvas2.create_rectangle(0, 0, 50, 50)   # rect_1 (bottom)",
    "    canvas2.create_rectangle(25, 25, 50, 50) # rect_2 (top)",
    "    print(f\"Before: getShapeAt(30,30) = {canvas2.get_shape_at(30, 30)} (rect_2 on top)\")",
    "    canvas2.bring_to_front(\"rect_1\")",
    "    print(f\"After bringToFront(rect_1): getShapeAt(30,30) = {canvas2.get_shape_at(30, 30)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 3: Send to Back\")",
    "    print(\"=\" * 60)",
    "    canvas3 = Canvas()",
    "    canvas3.create_rectangle(0, 0, 50, 50)   # rect_1",
    "    canvas3.create_rectangle(25, 25, 50, 50) # rect_2",
    "    canvas3.create_circle(40, 40, 20)        # circle_1 (top)",
    "    print(f\"Before: getShapeAt(40,40) = {canvas3.get_shape_at(40, 40)} (circle on top)\")",
    "    canvas3.send_to_back(\"circle_1\")",
    "    print(f\"After sendToBack(circle_1): getShapeAt(40,40) = {canvas3.get_shape_at(40, 40)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 4: Invalid ID Handling\")",
    "    print(\"=\" * 60)",
    "    canvas4 = Canvas()",
    "    canvas4.create_rectangle(10, 10, 30, 30)",
    "    canvas4.delete_shape(\"invalid_id\")      # Should not crash",
    "    canvas4.bring_to_front(\"invalid_id\")    # Should not crash",
    "    canvas4.send_to_back(\"invalid_id\")      # Should not crash",
    "    print(f\"No errors. Shape count = {len(canvas4.shapes)}\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "abstract class Shape {",
    "    protected String id;",
    "    ",
    "    public Shape(String id) { this.id = id; }",
    "    public String getId() { return id; }",
    "    public abstract boolean contains(int x, int y);",
    "    public abstract void moveTo(int newX, int newY);",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private int x, y, width, height;",
    "    ",
    "    public Rectangle(String id, int x, int y, int width, int height) {",
    "        super(id);",
    "        this.x = x; this.y = y;",
    "        this.width = width; this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        return x <= px && px <= x + width && y <= py && py <= y + height;",
    "    }",
    "    ",
    "    @Override",
    "    public void moveTo(int newX, int newY) {",
    "        this.x = newX;",
    "        this.y = newY;",
    "    }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private int cx, cy, radius;",
    "    ",
    "    public Circle(String id, int cx, int cy, int radius) {",
    "        super(id);",
    "        this.cx = cx; this.cy = cy; this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        long dx = px - cx, dy = py - cy;",
    "        return dx * dx + dy * dy <= (long) radius * radius;",
    "    }",
    "    ",
    "    @Override",
    "    public void moveTo(int newX, int newY) {",
    "        this.cx = newX;",
    "        this.cy = newY;",
    "    }",
    "}",
    "",
    "public class Canvas {",
    "    private List<Shape> shapes = new ArrayList<>();",
    "    private Map<String, Shape> shapesById = new HashMap<>();",
    "    private int rectCount = 0, circleCount = 0;",
    "    ",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        String id = \"rect_\" + (++rectCount);",
    "        Shape shape = new Rectangle(id, x, y, width, height);",
    "        shapes.add(shape);",
    "        shapesById.put(id, shape);",
    "        return id;",
    "    }",
    "    ",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        String id = \"circle_\" + (++circleCount);",
    "        Shape shape = new Circle(id, centerX, centerY, radius);",
    "        shapes.add(shape);",
    "        shapesById.put(id, shape);",
    "        return id;",
    "    }",
    "    ",
    "    public String getShapeAt(int x, int y) {",
    "        for (int i = shapes.size() - 1; i >= 0; i--) {",
    "            if (shapes.get(i).contains(x, y)) {",
    "                return shapes.get(i).getId();",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    public void moveShape(String shapeId, int newX, int newY) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            shape.moveTo(newX, newY);",
    "        }",
    "    }",
    "    ",
    "    // ==================== PART 3: New Methods ====================",
    "    ",
    "    /** Remove shape from canvas. O(n) for list removal. */",
    "    public void deleteShape(String shapeId) {",
    "        Shape shape = shapesById.remove(shapeId);",
    "        if (shape != null) {",
    "            shapes.remove(shape);",
    "        }",
    "    }",
    "    ",
    "    /** Move shape to top of z-order. O(n). */",
    "    public void bringToFront(String shapeId) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            shapes.remove(shape);",
    "            shapes.add(shape);",
    "        }",
    "    }",
    "    ",
    "    /** Move shape to bottom of z-order. O(n). */",
    "    public void sendToBack(String shapeId) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            shapes.remove(shape);",
    "            shapes.add(0, shape);",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"TEST 1: Delete Shape\");",
    "        Canvas canvas = new Canvas();",
    "        canvas.createRectangle(0, 0, 50, 50);",
    "        canvas.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"Before: getShapeAt(30,30) = \" + canvas.getShapeAt(30, 30));",
    "        canvas.deleteShape(\"rect_2\");",
    "        System.out.println(\"After delete: getShapeAt(30,30) = \" + canvas.getShapeAt(30, 30));",
    "        ",
    "        System.out.println(\"\\nTEST 2: Bring to Front\");",
    "        Canvas canvas2 = new Canvas();",
    "        canvas2.createRectangle(0, 0, 50, 50);",
    "        canvas2.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"Before: getShapeAt(30,30) = \" + canvas2.getShapeAt(30, 30));",
    "        canvas2.bringToFront(\"rect_1\");",
    "        System.out.println(\"After bringToFront: getShapeAt(30,30) = \" + canvas2.getShapeAt(30, 30));",
    "        ",
    "        System.out.println(\"\\nTEST 3: Send to Back\");",
    "        Canvas canvas3 = new Canvas();",
    "        canvas3.createRectangle(0, 0, 50, 50);",
    "        canvas3.createCircle(25, 25, 30);",
    "        System.out.println(\"Before: getShapeAt(25,25) = \" + canvas3.getShapeAt(25, 25));",
    "        canvas3.sendToBack(\"circle_1\");",
    "        System.out.println(\"After sendToBack: getShapeAt(25,25) = \" + canvas3.getShapeAt(25, 25));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-45",
      "explanation": "Shape hierarchy from Part 1-2, unchanged"
    },
    {
      "lines": "48-58",
      "explanation": "Canvas class with dual data structures from Part 2"
    },
    {
      "lines": "60-81",
      "explanation": "Existing methods: create, get_shape_at, move_shape"
    },
    {
      "lines": "83-86",
      "explanation": "delete_shape: Pop from HashMap, remove from list. O(n)"
    },
    {
      "lines": "88-92",
      "explanation": "bring_to_front: Remove from list, append to end. Shape stays in HashMap."
    },
    {
      "lines": "94-98",
      "explanation": "send_to_back: Remove from list, insert at index 0."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "delete_shape": {
          "complexity": "O(n)",
          "explanation": "HashMap remove O(1) + list.remove(object) O(n)"
        },
        "bring_to_front": {
          "complexity": "O(n)",
          "explanation": "HashMap lookup O(1) + list.remove(object) O(n) + append O(1)"
        },
        "send_to_back": {
          "complexity": "O(n)",
          "explanation": "HashMap lookup O(1) + list.remove O(n) + insert(0) O(n)"
        }
      },
      "overall_change": "New methods are O(n). Existing methods unchanged."
    },
    "space": {
      "additional_space": "O(1)",
      "explanation": "No new data structures. We reuse existing shapes list and shapes_by_id HashMap."
    }
  },
  "dry_run": {
    "example_input": "createRectangle(0,0,50,50) \u2192 rect_1, createRectangle(25,25,50,50) \u2192 rect_2, bringToFront(\"rect_1\")",
    "steps": [
      {
        "step": 1,
        "action": "createRectangle(0,0,50,50)",
        "state": "shapes=[rect_1], shapes_by_id={rect_1:*}",
        "explanation": "First rectangle created at bottom"
      },
      {
        "step": 2,
        "action": "createRectangle(25,25,50,50)",
        "state": "shapes=[rect_1, rect_2], shapes_by_id={rect_1:*, rect_2:*}",
        "explanation": "Second rectangle on top"
      },
      {
        "step": 3,
        "action": "bringToFront(\"rect_1\")",
        "state": "shapes=[rect_2, rect_1], shapes_by_id={rect_1:*, rect_2:*}",
        "explanation": "rect_1 removed from index 0, appended to end. Now on top."
      },
      {
        "step": 4,
        "action": "getShapeAt(30, 30)",
        "state": "Returns 'rect_1'",
        "explanation": "Point (30,30) is in both shapes' overlap. rect_1 is now topmost."
      }
    ],
    "final_output": "rect_1 (was rect_2 before bringToFront)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create 1 shape, delete it, verify getShapeAt returns None",
      "Create 2 shapes, bringToFront the bottom one, verify it's now on top"
    ],
    "likely_bugs": [
      "Forgetting to remove from BOTH structures in deleteShape",
      "Forgetting that list index 0 is BOTTOM, end is TOP",
      "Not handling invalid shape_id gracefully"
    ],
    "recommended_logs_or_asserts": [
      "assert len(shapes) == len(shapes_by_id)",
      "After delete: assert shape_id not in shapes_by_id"
    ],
    "how_to_localize": "Print shapes list order before and after z-order operations. Check both structures after delete."
  },
  "edge_cases": [
    {
      "case": "Delete non-existent shape",
      "handling": "Check if shape_id in shapes_by_id first, return silently if not",
      "gotcha": "Don't try to remove from list if shape doesn't exist"
    },
    {
      "case": "bringToFront shape already at front",
      "handling": "Works fine - removes and re-appends to same position",
      "gotcha": "Could optimize to check if already at end, but not necessary"
    },
    {
      "case": "sendToBack shape already at back",
      "handling": "Works fine - removes and re-inserts at 0",
      "gotcha": "Same as above, no optimization needed"
    },
    {
      "case": "Operations on empty canvas",
      "handling": "All methods check shapes_by_id first, so no error",
      "gotcha": "Ensure HashMap check comes before list manipulation"
    }
  ],
  "test_cases": [
    {
      "name": "Delete reveals shape underneath",
      "input": "create(0,0,50,50), create(25,25,50,50), getShapeAt(30,30), delete(rect_2), getShapeAt(30,30)",
      "expected": "rect_2, rect_1",
      "explanation": "After deleting top shape, bottom shape becomes visible"
    },
    {
      "name": "bringToFront changes hit test result",
      "input": "create(0,0,50,50), create(25,25,50,50), bringToFront(rect_1), getShapeAt(30,30)",
      "expected": "rect_1",
      "explanation": "Bottom rect moved to top, now wins hit test"
    },
    {
      "name": "sendToBack changes hit test result",
      "input": "create(0,0,50,50), create(25,25,50,50), sendToBack(rect_2), getShapeAt(30,30)",
      "expected": "rect_1",
      "explanation": "Top rect moved to bottom, rect_1 now wins"
    },
    {
      "name": "Delete then try operations on deleted ID",
      "input": "create(0,0,50,50), delete(rect_1), bringToFront(rect_1)",
      "expected": "No error, no-op",
      "explanation": "Operations on non-existent IDs are ignored"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Only removing from one data structure",
      "why_wrong": "Leaves inconsistent state - shape appears in queries but not in HashMap or vice versa",
      "correct_approach": "Always update BOTH shapes list AND shapes_by_id",
      "code_example_wrong": "def delete_shape(self, id):\\n    self.shapes_by_id.pop(id)  # Forgot list!",
      "code_example_correct": "def delete_shape(self, id):\\n    if id in self.shapes_by_id:\\n        shape = self.shapes_by_id.pop(id)\\n        self.shapes.remove(shape)"
    },
    {
      "mistake": "Confusing z-order direction",
      "why_wrong": "index 0 = bottom (drawn first), end = top (drawn last)",
      "correct_approach": "Remember: append() = top, insert(0) = bottom",
      "code_example_wrong": "def bring_to_front(self, id):\\n    self.shapes.insert(0, shape)  # This is sendToBack!",
      "code_example_correct": "def bring_to_front(self, id):\\n    self.shapes.append(shape)  # End of list = top"
    },
    {
      "mistake": "Not checking if shape exists before operations",
      "why_wrong": "list.remove() throws ValueError if object not in list",
      "correct_approach": "Check shapes_by_id first",
      "code_example_wrong": "def delete_shape(self, id):\\n    self.shapes.remove(self.shapes_by_id[id])  # KeyError if missing",
      "code_example_correct": "def delete_shape(self, id):\\n    if id in self.shapes_by_id:\\n        shape = self.shapes_by_id.pop(id)\\n        self.shapes.remove(shape)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by stating what each operation needs to do conceptually (delete = remove everywhere, bringToFront = move to end of list). Then explain why O(n) is acceptable and unavoidable with ArrayList.",
    "what_to_mention": [
      "Dual data structure consistency must be maintained",
      "O(n) is optimal for ArrayList-based z-order",
      "Could achieve O(1) with LinkedList + node references, but adds complexity"
    ],
    "time_allocation": "5 min understand + 5 min implement + 2 min test",
    "if_stuck": [
      "Think about what 'z-order' means - it's just list position",
      "HashMap gives you the object, list manipulation changes order"
    ]
  },
  "connection_to_next_part": "Part 4 might add more complex operations like grouping shapes, undo/redo, or collision detection. The current dual data structure pattern scales well for these extensions.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 handles movement. For Part 3, I need to add deletion and z-order control. Let me explain the approach...",
    "explaining_changes": "The key insight is that z-order is just list position. To bring to front, I remove from current position and append to end. The HashMap already gives me O(1) lookup of the shape object.",
    "while_extending_code": [
      "I'm adding delete_shape which removes from BOTH structures...",
      "For bringToFront, I get the shape via HashMap, then manipulate the list...",
      "All three methods follow the same pattern: check existence, then modify list"
    ],
    "after_completing": "Part 3 done. All three new operations are O(n) due to list manipulation. The HashMap lookup is O(1), but moving elements in an ArrayList is O(n). Ready for Part 4?"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Understand that z-order = list position, identify the three operations",
    "by_5_min": "Explain approach, start implementing delete_shape",
    "by_10_min": "All three methods done, testing with examples",
    "warning_signs": "If confused about which end is 'top', draw it out immediately"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 has bugs, fix them first. Say: 'Let me verify the HashMap is working correctly before adding deletion.'",
    "if_new_requirement_unclear": "Ask: 'For bringToFront, should it do nothing if the shape is already at front, or is it okay to just reinsert it?'",
    "if_running_behind": "Implement delete_shape first (most critical), then bringToFront. sendToBack is just a variation."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing that z-order is list position",
      "Explaining why O(n) is unavoidable with ArrayList",
      "Mentioning LinkedList alternative for O(1) operations",
      "Noting the invariant that both structures must stay in sync"
    ]
  },
  "pattern_recognition": {
    "pattern": "Dual Data Structure (List + HashMap)",
    "indicators": [
      "Need both O(1) lookup by ID and ordered traversal",
      "Need to maintain order while allowing random access modifications"
    ],
    "similar_problems": [
      "LRU Cache (HashMap + Doubly Linked List)",
      "Design Twitter (user posts ordered by time)",
      "All O(1) Data Structure"
    ],
    "template": "HashMap for O(1) lookup, List for ordering. Always update both structures together to maintain consistency."
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'bring to front', I think about what 'front' means in our data structure",
      "why": "We established index 0 = bottom, end = top. So 'front' means append to end."
    },
    {
      "step": 2,
      "thought": "Delete needs to update both structures",
      "why": "The invariant is shapes_by_id.keys() == {s.id for s in shapes}. Breaking this causes bugs."
    },
    {
      "step": 3,
      "thought": "O(n) is acceptable here",
      "why": "ArrayList remove is O(n). We could use LinkedList for O(1) but that's over-engineering for typical canvas sizes."
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you maintain consistency between two data structures?",
      "Do you understand what z-order means and how it maps to list operations?",
      "Can you extend existing code cleanly?"
    ],
    "bonus_points": [
      "Discussing LinkedList alternative for O(1)",
      "Proactively testing edge cases",
      "Clear explanation of why O(n) is unavoidable with ArrayList"
    ],
    "red_flags": [
      "Forgetting to update both structures",
      "Confusion about which direction is 'top'",
      "Not handling invalid IDs"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to quickly generate the method stubs",
      "Let it help with Python list methods (remove, insert)"
    ],
    "what_not_to_do": [
      "Don't blindly accept - verify the z-order logic is correct",
      "Make sure it updates BOTH data structures"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about edge cases",
      "Implementing without explaining approach first"
    ],
    "technical": [
      "Creating a new data structure when modifying existing one works",
      "Forgetting that list.remove() finds and removes by object reference"
    ],
    "communication": [
      "Not mentioning that O(n) is expected for ArrayList operations",
      "Forgetting to trace through an example after implementing"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does delete_shape update BOTH shapes and shapes_by_id?",
      "Does bringToFront move shape to END (top)?",
      "Does sendToBack move shape to INDEX 0 (bottom)?",
      "Do all methods handle invalid IDs gracefully?"
    ],
    "quick_code_review": [
      "Consistent naming with Parts 1-2",
      "Type hints on new methods",
      "Brief docstrings explaining complexity"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Event callbacks for shape deletion (observer pattern)",
      "Validation that deleted shapes aren't referenced elsewhere",
      "Batch operations for z-order changes"
    ],
    "why_not_in_interview": "Focus on core algorithm and data structure consistency",
    "how_to_mention": "Say: 'In production, I'd add event callbacks so the UI can react to z-order changes.'"
  },
  "generated_at": "2026-01-19T04:27:01.213044",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}