{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 2: Authentication and Authorization",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 adds a security layer on top of the existing booking functionality. We need user management, token-based authentication, and role-based authorization. The key insight is that auth checks happen BEFORE any business logic - like a security guard at the door. We're not changing HOW events/bookings work, just WHO can access them.",
    "new_requirements": [
      "User authentication via login with username/password",
      "JWT-like token generation and validation",
      "Role-based access control (ADMIN, USER, GUEST)",
      "Authorization checks on create_event (ADMIN only), book_tickets (USER+), cancel_booking (owner or ADMIN)",
      "Rate limiting for failed login attempts",
      "New endpoints: login, get_current_user, get_user_bookings"
    ],
    "new_constraints": [
      "Max 5 login attempts before 15-minute lockout",
      "Tokens expire after 24 hours",
      "Users can only access their own bookings (unless ADMIN)",
      "Event creation restricted to ADMIN role"
    ],
    "key_insight": "Authentication (WHO are you?) comes before Authorization (WHAT can you do?). Layered security: validate token first, then check role permissions, then execute business logic. This separation makes the code clean and testable."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "User login with credentials",
        "how_met": "login() method validates username/password, returns token",
        "gotchas": [
          "Must hash passwords, never store plaintext",
          "Return same error for wrong user vs wrong password (timing attacks)"
        ]
      },
      {
        "requirement": "Role-based access control",
        "how_met": "_authorize() helper checks token validity and role permissions",
        "gotchas": [
          "Check auth BEFORE business logic",
          "GUEST can read, USER can book, ADMIN can do all"
        ]
      },
      {
        "requirement": "Users can only cancel own bookings",
        "how_met": "cancel_booking checks if token's user_id matches booking's user_id OR role is ADMIN",
        "gotchas": [
          "Don't forget ADMIN override",
          "Null check on token"
        ]
      },
      {
        "requirement": "Rate limiting",
        "how_met": "Track failed attempts per username in login_attempts dict, lockout after 5 failures",
        "gotchas": [
          "Clean up old attempts",
          "Use sliding window, not fixed window"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "login",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict lookup for user, hash comparison"
      },
      {
        "operation": "_validate_token",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict lookup for token"
      },
      {
        "operation": "get_user_bookings",
        "target": "O(b)",
        "achieved": "O(b)",
        "why": "Must scan all bookings to filter by user_id"
      }
    ],
    "non_goals": [
      "Distributed session management (Part 3)",
      "OAuth/SSO integration",
      "Password reset flow",
      "Email verification"
    ]
  },
  "assumptions": [
    "Simple token format is acceptable (not real JWT) - ask interviewer if crypto library usage is expected",
    "In-memory user storage is fine for interview - mention database in production",
    "Pre-seeded admin/user accounts for testing - in production, would have registration flow",
    "Token expiry check happens on each request - no background cleanup needed for interview"
  ],
  "tradeoffs": [
    {
      "decision": "Simple token vs JWT",
      "chosen": "Simple token (random string mapped to user info)",
      "why": "No external library needed, sufficient for demonstration",
      "alternative": "Real JWT with signing",
      "when_to_switch": "Production system needing stateless auth across services"
    },
    {
      "decision": "Auth as optional param vs required",
      "chosen": "Optional parameter with enforcement",
      "why": "Backward compatible with Part 1 tests, shows defensive coding",
      "alternative": "Strict auth on all endpoints",
      "when_to_switch": "Real production API"
    },
    {
      "decision": "Rate limit storage",
      "chosen": "In-memory dict with timestamps",
      "why": "Simple, works for single server",
      "alternative": "Redis with TTL",
      "when_to_switch": "Distributed deployment"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1 method signatures (with optional token param)",
      "Response format",
      "Error codes",
      "BookingStatus and Event/Booking classes"
    ],
    "what_to_change": [
      "Added User class and UserRole enum",
      "Added users, tokens, login_attempts dicts",
      "Added auth helper methods"
    ],
    "interfaces_and_boundaries": "Auth logic is encapsulated in _validate_token() and _authorize() helpers. Business logic unchanged. Part 3 can add distributed tokens by replacing token storage.",
    "invariants": [
      "Token must be valid AND have correct role to proceed",
      "Failed logins increment counter before returning",
      "Expired tokens are cleaned up on validation",
      "ADMIN can always override ownership checks"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 1):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Request \u2502\u2500\u2500\u2500\u25ba\u2502 Validation  \u2502\u2500\u2500\u2500\u25ba Business Logic \u2500\u2500\u2500\u25ba Response\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 2):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Request \u2502\u2500\u2500\u2500\u25ba\u2502 Auth     \u2502\u2500\u2500\u2500\u25ba\u2502 Authorize   \u2502\u2500\u2500\u2500\u25ba\u2502 Validation  \u2502\u2500\u2500\u2500\u25ba Business Logic\n\u2502 + Token \u2502    \u2502 (valid?) \u2502    \u2502 (role ok?)  \u2502    \u2502 (data ok?)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502                 \u2502\n                   \u25bc                 \u25bc\n               401 Unauth        403 Forbidden",
    "algorithm_flow": "LOGIN FLOW:\n1. Check rate limit \u2500\u2500\u25ba if blocked \u2500\u2500\u25ba 429 Too Many Requests\n2. Find user by username \u2500\u2500\u25ba if not found \u2500\u2500\u25ba 401 (generic error)\n3. Compare password hash \u2500\u2500\u25ba if mismatch \u2500\u2500\u25ba record failure, 401\n4. Generate token \u2500\u2500\u25ba store in tokens dict\n5. Return token + role\n\nAUTH CHECK FLOW (for protected endpoints):\n1. Extract token from request\n2. _validate_token(token) \u2500\u2500\u25ba check exists & not expired\n3. _authorize(token, required_role) \u2500\u2500\u25ba check role hierarchy\n4. If owner-only: check token.user_id == resource.user_id OR role==ADMIN\n5. Proceed to business logic"
  },
  "approaches": [
    {
      "name": "Naive Extension - Check Auth in Each Method",
      "description": "Copy-paste auth check code at the start of each method that needs protection",
      "time_complexity": "O(1) for auth",
      "space_complexity": "O(u + t) for users and tokens",
      "why_not_optimal": "Code duplication, easy to forget auth in new methods, hard to update auth logic globally"
    },
    {
      "name": "Optimal Approach - Centralized Auth Helpers",
      "description": "Create _validate_token() and _authorize() helpers. Each protected method calls helpers first. Clean separation of concerns.",
      "time_complexity": "O(1) for all auth operations",
      "space_complexity": "O(u + t + a) where u=users, t=tokens, a=login attempts",
      "key_insight": "Auth is cross-cutting concern. Centralize it in reusable helpers. Layer: Token Valid? \u2192 Role OK? \u2192 Owner OK? \u2192 Business Logic"
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Key Design Decisions:**\n\n1. **Layered Auth Checks**: `_validate_token()` verifies token exists and not expired. `_authorize()` checks role permissions. Separation allows reuse.\n\n2. **Password Hashing**: Never store plaintext. Use SHA256 (in production, use bcrypt with salt).\n\n3. **Rate Limiting**: Track timestamps of failed attempts per username. Sliding window of 15 minutes. After 5 failures, block until oldest attempt expires.\n\n4. **Token Storage**: Dict maps token string \u2192 {user_id, role, exp}. On each request, check expiry. Clean up expired tokens lazily.\n\n5. **Backward Compatibility**: Token parameter is optional. When None, auth is skipped (for Part 1 tests). When provided, full auth enforced.",
    "data_structures": [
      {
        "structure": "Dict[str, User] users",
        "purpose": "Map username \u2192 User for login lookup"
      },
      {
        "structure": "Dict[str, dict] tokens",
        "purpose": "Map token string \u2192 {user_id, role, exp} for validation"
      },
      {
        "structure": "Dict[str, List[datetime]] login_attempts",
        "purpose": "Track failed logins per username for rate limiting"
      }
    ],
    "algorithm_steps": [
      "Step 1: login() - Validate rate limit, then credentials, then generate token",
      "Step 2: _validate_token() - Check token exists and not expired",
      "Step 3: _authorize() - Verify role meets minimum required level",
      "Step 4: For owner-only operations, additionally check user_id match or ADMIN role",
      "Step 5: Only after all checks pass, execute original Part 1 business logic"
    ]
  },
  "solution_python_lines": [
    "from decimal import Decimal",
    "from datetime import datetime, timedelta",
    "from typing import Dict, List, Optional, Any",
    "from enum import Enum",
    "from dataclasses import dataclass",
    "import threading",
    "import hashlib",
    "import secrets",
    "",
    "",
    "class BookingStatus(Enum):",
    "    CONFIRMED = 'CONFIRMED'",
    "    CANCELLED = 'CANCELLED'",
    "",
    "",
    "class UserRole(Enum):",
    "    ADMIN = 'ADMIN'",
    "    USER = 'USER'",
    "    GUEST = 'GUEST'",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: Decimal",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    total_amount: Decimal",
    "    status: BookingStatus",
    "    created_at: datetime",
    "",
    "",
    "@dataclass",
    "class User:",
    "    id: str",
    "    username: str",
    "    password_hash: str",
    "    role: UserRole",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    status: int",
    "    body: dict",
    "",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Ticket Booking API with Authentication & Authorization.",
    "    Part 2: Adds login, role-based access, rate limiting.",
    "    \"\"\"",
    "    MAX_LOGIN_ATTEMPTS = 5",
    "    LOCKOUT_MINUTES = 15",
    "",
    "    def __init__(self):",
    "        # Part 1 state",
    "        self.events: Dict[str, Event] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "        self._lock = threading.Lock()",
    "        ",
    "        # Part 2 state - Auth",
    "        self.users: Dict[str, User] = {}",
    "        self.tokens: Dict[str, dict] = {}",
    "        self.login_attempts: Dict[str, List[datetime]] = {}",
    "        self._user_counter = 0",
    "        self._seed_users()",
    "",
    "    def _seed_users(self):",
    "        \"\"\"Create default test accounts.\"\"\"",
    "        self._add_user('admin', 'admin123', UserRole.ADMIN)",
    "        self._add_user('user', 'user123', UserRole.USER)",
    "",
    "    def _add_user(self, username: str, password: str, role: UserRole) -> User:",
    "        self._user_counter += 1",
    "        user = User(",
    "            id=f'usr_{self._user_counter:03d}',",
    "            username=username,",
    "            password_hash=hashlib.sha256(password.encode()).hexdigest(),",
    "            role=role",
    "        )",
    "        self.users[username] = user",
    "        return user",
    "",
    "    def _generate_event_id(self) -> str:",
    "        self._event_counter += 1",
    "        return f'evt_{self._event_counter:03d}'",
    "",
    "    def _generate_booking_id(self) -> str:",
    "        self._booking_counter += 1",
    "        return f'bkg_{self._booking_counter:03d}'",
    "",
    "    def _error_response(self, status: int, code: str, message: str,",
    "                        details: List[dict] = None) -> Response:",
    "        body = {'success': False, 'error': {'code': code, 'message': message}}",
    "        if details:",
    "            body['error']['details'] = details",
    "        return Response(status=status, body=body)",
    "",
    "    # ========== Part 2: Auth Methods ==========",
    "",
    "    def _check_rate_limit(self, username: str) -> bool:",
    "        \"\"\"Returns True if login allowed, False if rate-limited.\"\"\"",
    "        if username not in self.login_attempts:",
    "            return True",
    "        cutoff = datetime.now() - timedelta(minutes=self.LOCKOUT_MINUTES)",
    "        recent = [t for t in self.login_attempts[username] if t > cutoff]",
    "        self.login_attempts[username] = recent",
    "        return len(recent) < self.MAX_LOGIN_ATTEMPTS",
    "",
    "    def _record_failed_login(self, username: str):",
    "        if username not in self.login_attempts:",
    "            self.login_attempts[username] = []",
    "        self.login_attempts[username].append(datetime.now())",
    "",
    "    def _validate_token(self, token: str) -> Optional[dict]:",
    "        \"\"\"Validate token. Returns user info dict or None if invalid.\"\"\"",
    "        if not token or token not in self.tokens:",
    "            return None",
    "        info = self.tokens[token]",
    "        if datetime.now() > info['exp']:",
    "            del self.tokens[token]",
    "            return None",
    "        return info",
    "",
    "    def _authorize(self, token: str, required_role: str = 'USER') -> tuple:",
    "        \"\"\"Check token and role. Returns (auth_info, error_response).\"\"\"",
    "        auth = self._validate_token(token)",
    "        if not auth:",
    "            return None, self._error_response(401, 'UNAUTHORIZED', 'Invalid or expired token')",
    "        ",
    "        role_hierarchy = {'GUEST': 0, 'USER': 1, 'ADMIN': 2}",
    "        if role_hierarchy.get(auth['role'], 0) < role_hierarchy.get(required_role, 1):",
    "            return None, self._error_response(403, 'FORBIDDEN', f'{required_role} role required')",
    "        ",
    "        return auth, None",
    "",
    "    def login(self, request: dict) -> Response:",
    "        \"\"\"Authenticate user and return token.\"\"\"",
    "        username = request.get('username', '')",
    "        password = request.get('password', '')",
    "        ",
    "        # Rate limit check",
    "        if not self._check_rate_limit(username):",
    "            return self._error_response(429, 'RATE_LIMITED', 'Too many login attempts. Try again later.')",
    "        ",
    "        # Validate credentials",
    "        user = self.users.get(username)",
    "        if not user or user.password_hash != hashlib.sha256(password.encode()).hexdigest():",
    "            self._record_failed_login(username)",
    "            return self._error_response(401, 'UNAUTHORIZED', 'Invalid credentials')",
    "        ",
    "        # Generate token",
    "        token = f'tok_{secrets.token_hex(16)}'",
    "        self.tokens[token] = {",
    "            'user_id': user.id,",
    "            'username': user.username,",
    "            'role': user.role.value,",
    "            'exp': datetime.now() + timedelta(hours=24)",
    "        }",
    "        ",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'token': token, 'userId': user.id, 'role': user.role.value}",
    "        })",
    "",
    "    def get_current_user(self, token: str) -> Response:",
    "        \"\"\"Get current user info from token.\"\"\"",
    "        auth = self._validate_token(token)",
    "        if not auth:",
    "            return self._error_response(401, 'UNAUTHORIZED', 'Invalid or expired token')",
    "        ",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'userId': auth['user_id'], 'username': auth['username'], 'role': auth['role']}",
    "        })",
    "",
    "    def get_user_bookings(self, token: str, user_id: str) -> Response:",
    "        \"\"\"Get bookings for a user. Users can only see own, admins can see all.\"\"\"",
    "        auth, err = self._authorize(token, 'USER')",
    "        if err:",
    "            return err",
    "        ",
    "        # Check ownership (unless admin)",
    "        if auth['role'] != 'ADMIN' and auth['user_id'] != user_id:",
    "            return self._error_response(403, 'FORBIDDEN', 'Cannot view other users bookings')",
    "        ",
    "        user_bookings = [",
    "            {'bookingId': b.id, 'eventId': b.event_id, 'tickets': b.number_of_tickets,",
    "             'status': b.status.value}",
    "            for b in self.bookings.values() if b.user_id == user_id",
    "        ]",
    "        ",
    "        return Response(status=200, body={'success': True, 'data': {'bookings': user_bookings}})",
    "",
    "    # ========== Part 1 Methods (with auth added) ==========",
    "",
    "    def _validate_event_request(self, request: dict) -> List[dict]:",
    "        errors = []",
    "        required = ['name', 'date', 'venue', 'totalTickets', 'pricePerTicket']",
    "        for field in required:",
    "            if field not in request or request[field] is None:",
    "                errors.append({'field': field, 'issue': 'required'})",
    "        if errors:",
    "            return errors",
    "        if not isinstance(request['totalTickets'], int) or not (1 <= request['totalTickets'] <= 100000):",
    "            errors.append({'field': 'totalTickets', 'issue': 'must be 1-100000'})",
    "        return errors",
    "",
    "    def _validate_booking_request(self, request: dict) -> List[dict]:",
    "        errors = []",
    "        required = ['eventId', 'userId', 'numberOfTickets']",
    "        for field in required:",
    "            if field not in request or request[field] is None:",
    "                errors.append({'field': field, 'issue': 'required'})",
    "        if errors:",
    "            return errors",
    "        tickets = request['numberOfTickets']",
    "        if not isinstance(tickets, int) or not (1 <= tickets <= 10):",
    "            errors.append({'field': 'numberOfTickets', 'issue': 'must be 1-10'})",
    "        return errors",
    "",
    "    def create_event(self, request: dict, token: str = None) -> Response:",
    "        \"\"\"Create event. Requires ADMIN role.\"\"\"",
    "        if token:",
    "            auth, err = self._authorize(token, 'ADMIN')",
    "            if err:",
    "                return err",
    "        ",
    "        errors = self._validate_event_request(request)",
    "        if errors:",
    "            return self._error_response(400, 'VALIDATION_ERROR', f\"Validation error: {errors[0]['issue']}\", errors)",
    "        ",
    "        event_id = self._generate_event_id()",
    "        event = Event(",
    "            id=event_id,",
    "            name=request['name'],",
    "            date=datetime.fromisoformat(request['date'].replace('Z', '+00:00')),",
    "            venue=request['venue'],",
    "            total_tickets=request['totalTickets'],",
    "            available_tickets=request['totalTickets'],",
    "            price_per_ticket=Decimal(str(request['pricePerTicket']))",
    "        )",
    "        self.events[event_id] = event",
    "        ",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {'eventId': event_id, 'name': event.name, 'availableTickets': event.available_tickets}",
    "        })",
    "",
    "    def get_event(self, event_id: str) -> Response:",
    "        \"\"\"Get event by ID. Public access (no auth required).\"\"\"",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        e = self.events[event_id]",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'eventId': e.id, 'name': e.name, 'availableTickets': e.available_tickets,",
    "                     'pricePerTicket': float(e.price_per_ticket)}",
    "        })",
    "",
    "    def list_events(self, filters: dict = None) -> Response:",
    "        \"\"\"List events with pagination. Public access.\"\"\"",
    "        filters = filters or {}",
    "        limit = min(filters.get('limit', 10), 100)",
    "        offset = max(filters.get('offset', 0), 0)",
    "        all_events = list(self.events.values())",
    "        paginated = all_events[offset:offset + limit]",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {",
    "                'events': [{'eventId': e.id, 'name': e.name, 'availableTickets': e.available_tickets} for e in paginated],",
    "                'total': len(all_events), 'limit': limit, 'offset': offset",
    "            }",
    "        })",
    "",
    "    def book_tickets(self, request: dict, token: str = None) -> Response:",
    "        \"\"\"Book tickets. Requires USER role.\"\"\"",
    "        if token:",
    "            auth, err = self._authorize(token, 'USER')",
    "            if err:",
    "                return err",
    "        ",
    "        errors = self._validate_booking_request(request)",
    "        if errors:",
    "            return self._error_response(400, 'VALIDATION_ERROR', errors[0]['issue'], errors)",
    "        ",
    "        event_id = request['eventId']",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        ",
    "        with self._lock:",
    "            event = self.events[event_id]",
    "            num_tickets = request['numberOfTickets']",
    "            if event.available_tickets < num_tickets:",
    "                return self._error_response(409, 'INSUFFICIENT_TICKETS',",
    "                    f'Only {event.available_tickets} ticket(s) available')",
    "            ",
    "            booking_id = self._generate_booking_id()",
    "            total = event.price_per_ticket * num_tickets",
    "            booking = Booking(",
    "                id=booking_id, event_id=event_id, user_id=request['userId'],",
    "                number_of_tickets=num_tickets, total_amount=total,",
    "                status=BookingStatus.CONFIRMED, created_at=datetime.now()",
    "            )",
    "            event.available_tickets -= num_tickets",
    "            self.bookings[booking_id] = booking",
    "        ",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {'bookingId': booking_id, 'eventId': event_id,",
    "                     'numberOfTickets': num_tickets, 'totalAmount': float(total), 'status': 'CONFIRMED'}",
    "        })",
    "",
    "    def cancel_booking(self, booking_id: str, token: str = None) -> Response:",
    "        \"\"\"Cancel booking. Users can cancel own, admins can cancel any.\"\"\"",
    "        if booking_id not in self.bookings:",
    "            return self._error_response(404, 'NOT_FOUND', f'Booking {booking_id} not found')",
    "        ",
    "        if token:",
    "            auth, err = self._authorize(token, 'USER')",
    "            if err:",
    "                return err",
    "            # Check ownership",
    "            if auth['role'] != 'ADMIN' and auth['user_id'] != self.bookings[booking_id].user_id:",
    "                return self._error_response(403, 'FORBIDDEN', 'Cannot cancel other users bookings')",
    "        ",
    "        with self._lock:",
    "            booking = self.bookings[booking_id]",
    "            if booking.status == BookingStatus.CANCELLED:",
    "                return self._error_response(409, 'ALREADY_CANCELLED', 'Booking already cancelled')",
    "            self.events[booking.event_id].available_tickets += booking.number_of_tickets",
    "            booking.status = BookingStatus.CANCELLED",
    "        ",
    "        return Response(status=200, body={'success': True, 'data': {'bookingId': booking_id, 'status': 'CANCELLED'}})",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('\\n' + '=' * 60)",
    "    print('TICKET API - PART 2: AUTH DEMO')",
    "    print('=' * 60)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # Test 1: Login as admin",
    "    print('\\n[1] Admin login...')",
    "    resp = api.login({'username': 'admin', 'password': 'admin123'})",
    "    print(f'    Status: {resp.status}, Role: {resp.body[\"data\"][\"role\"]}')",
    "    admin_token = resp.body['data']['token']",
    "    ",
    "    # Test 2: Admin creates event",
    "    print('\\n[2] Admin creates event...')",
    "    resp = api.create_event({",
    "        'name': 'Tech Conference', 'date': '2024-12-15T09:00:00Z',",
    "        'venue': 'Convention Center', 'totalTickets': 100, 'pricePerTicket': 50",
    "    }, admin_token)",
    "    print(f'    Status: {resp.status}, Event: {resp.body[\"data\"][\"eventId\"]}')",
    "    event_id = resp.body['data']['eventId']",
    "    ",
    "    # Test 3: User login",
    "    print('\\n[3] User login...')",
    "    resp = api.login({'username': 'user', 'password': 'user123'})",
    "    user_token = resp.body['data']['token']",
    "    user_id = resp.body['data']['userId']",
    "    print(f'    Status: {resp.status}, User: {user_id}')",
    "    ",
    "    # Test 4: User tries to create event (should fail)",
    "    print('\\n[4] User tries to create event (forbidden)...')",
    "    resp = api.create_event({",
    "        'name': 'Hacker Event', 'date': '2024-12-20T10:00:00Z',",
    "        'venue': 'Nowhere', 'totalTickets': 10, 'pricePerTicket': 100",
    "    }, user_token)",
    "    print(f'    Status: {resp.status}, Error: {resp.body[\"error\"][\"code\"]}')",
    "    ",
    "    # Test 5: User books tickets",
    "    print('\\n[5] User books 2 tickets...')",
    "    resp = api.book_tickets({",
    "        'eventId': event_id, 'userId': user_id, 'numberOfTickets': 2",
    "    }, user_token)",
    "    print(f'    Status: {resp.status}, Booking: {resp.body[\"data\"][\"bookingId\"]}')",
    "    booking_id = resp.body['data']['bookingId']",
    "    ",
    "    # Test 6: User views own bookings",
    "    print('\\n[6] User views own bookings...')",
    "    resp = api.get_user_bookings(user_token, user_id)",
    "    print(f'    Status: {resp.status}, Count: {len(resp.body[\"data\"][\"bookings\"])}')",
    "    ",
    "    # Test 7: Invalid login (rate limit test)",
    "    print('\\n[7] Testing rate limiting (5 bad logins)...')",
    "    for i in range(6):",
    "        resp = api.login({'username': 'admin', 'password': 'wrong'})",
    "        if i == 5:",
    "            print(f'    Attempt 6: Status {resp.status} ({resp.body[\"error\"][\"code\"]})')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('PART 2 DEMO COMPLETE!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.security.MessageDigest;",
    "import java.time.Instant;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "",
    "public class TicketAPI {",
    "    ",
    "    enum BookingStatus { CONFIRMED, CANCELLED }",
    "    enum UserRole { ADMIN, USER, GUEST }",
    "    ",
    "    static class Event {",
    "        String id, name, venue;",
    "        Instant date;",
    "        int totalTickets, availableTickets;",
    "        BigDecimal pricePerTicket;",
    "        Event(String id, String name, Instant date, String venue, int total, BigDecimal price) {",
    "            this.id = id; this.name = name; this.date = date; this.venue = venue;",
    "            this.totalTickets = total; this.availableTickets = total; this.pricePerTicket = price;",
    "        }",
    "    }",
    "    ",
    "    static class Booking {",
    "        String id, eventId, userId;",
    "        int numberOfTickets;",
    "        BigDecimal totalAmount;",
    "        BookingStatus status;",
    "        Instant createdAt;",
    "        Booking(String id, String eventId, String userId, int tickets, BigDecimal total) {",
    "            this.id = id; this.eventId = eventId; this.userId = userId;",
    "            this.numberOfTickets = tickets; this.totalAmount = total;",
    "            this.status = BookingStatus.CONFIRMED; this.createdAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    static class User {",
    "        String id, username, passwordHash;",
    "        UserRole role;",
    "        User(String id, String username, String passwordHash, UserRole role) {",
    "            this.id = id; this.username = username; this.passwordHash = passwordHash; this.role = role;",
    "        }",
    "    }",
    "    ",
    "    static class Response {",
    "        int status;",
    "        Map<String, Object> body;",
    "        Response(int status, Map<String, Object> body) { this.status = status; this.body = body; }",
    "    }",
    "    ",
    "    // State",
    "    private final Map<String, Event> events = new HashMap<>();",
    "    private final Map<String, Booking> bookings = new HashMap<>();",
    "    private final Map<String, User> users = new HashMap<>();",
    "    private final Map<String, Map<String, Object>> tokens = new HashMap<>();",
    "    private final Map<String, List<Instant>> loginAttempts = new HashMap<>();",
    "    private int eventCounter = 0, bookingCounter = 0, userCounter = 0;",
    "    private final ReentrantLock lock = new ReentrantLock();",
    "    private static final int MAX_ATTEMPTS = 5;",
    "    private static final int LOCKOUT_MINUTES = 15;",
    "    ",
    "    public TicketAPI() { seedUsers(); }",
    "    ",
    "    private void seedUsers() {",
    "        addUser(\"admin\", \"admin123\", UserRole.ADMIN);",
    "        addUser(\"user\", \"user123\", UserRole.USER);",
    "    }",
    "    ",
    "    private void addUser(String username, String password, UserRole role) {",
    "        String id = String.format(\"usr_%03d\", ++userCounter);",
    "        users.put(username, new User(id, username, hashPassword(password), role));",
    "    }",
    "    ",
    "    private String hashPassword(String password) {",
    "        try {",
    "            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");",
    "            byte[] hash = md.digest(password.getBytes());",
    "            StringBuilder sb = new StringBuilder();",
    "            for (byte b : hash) sb.append(String.format(\"%02x\", b));",
    "            return sb.toString();",
    "        } catch (Exception e) { return password; }",
    "    }",
    "    ",
    "    private Response errorResponse(int status, String code, String message) {",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", false);",
    "        Map<String, Object> error = new HashMap<>();",
    "        error.put(\"code\", code); error.put(\"message\", message);",
    "        body.put(\"error\", error);",
    "        return new Response(status, body);",
    "    }",
    "    ",
    "    private boolean checkRateLimit(String username) {",
    "        if (!loginAttempts.containsKey(username)) return true;",
    "        Instant cutoff = Instant.now().minus(LOCKOUT_MINUTES, ChronoUnit.MINUTES);",
    "        List<Instant> recent = new ArrayList<>();",
    "        for (Instant t : loginAttempts.get(username)) if (t.isAfter(cutoff)) recent.add(t);",
    "        loginAttempts.put(username, recent);",
    "        return recent.size() < MAX_ATTEMPTS;",
    "    }",
    "    ",
    "    private Map<String, Object> validateToken(String token) {",
    "        if (token == null || !tokens.containsKey(token)) return null;",
    "        Map<String, Object> info = tokens.get(token);",
    "        if (Instant.now().isAfter((Instant) info.get(\"exp\"))) {",
    "            tokens.remove(token); return null;",
    "        }",
    "        return info;",
    "    }",
    "    ",
    "    public Response login(Map<String, Object> request) {",
    "        String username = (String) request.getOrDefault(\"username\", \"\");",
    "        String password = (String) request.getOrDefault(\"password\", \"\");",
    "        ",
    "        if (!checkRateLimit(username))",
    "            return errorResponse(429, \"RATE_LIMITED\", \"Too many attempts\");",
    "        ",
    "        User user = users.get(username);",
    "        if (user == null || !user.passwordHash.equals(hashPassword(password))) {",
    "            loginAttempts.computeIfAbsent(username, k -> new ArrayList<>()).add(Instant.now());",
    "            return errorResponse(401, \"UNAUTHORIZED\", \"Invalid credentials\");",
    "        }",
    "        ",
    "        String token = \"tok_\" + UUID.randomUUID().toString().replace(\"-\", \"\").substring(0, 32);",
    "        Map<String, Object> tokenInfo = new HashMap<>();",
    "        tokenInfo.put(\"user_id\", user.id);",
    "        tokenInfo.put(\"username\", user.username);",
    "        tokenInfo.put(\"role\", user.role.name());",
    "        tokenInfo.put(\"exp\", Instant.now().plus(24, ChronoUnit.HOURS));",
    "        tokens.put(token, tokenInfo);",
    "        ",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"token\", token); data.put(\"userId\", user.id); data.put(\"role\", user.role.name());",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response getCurrentUser(String token) {",
    "        Map<String, Object> auth = validateToken(token);",
    "        if (auth == null) return errorResponse(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"userId\", auth.get(\"user_id\")); data.put(\"role\", auth.get(\"role\"));",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response getUserBookings(String token, String userId) {",
    "        Map<String, Object> auth = validateToken(token);",
    "        if (auth == null) return errorResponse(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        if (!\"ADMIN\".equals(auth.get(\"role\")) && !auth.get(\"user_id\").equals(userId))",
    "            return errorResponse(403, \"FORBIDDEN\", \"Cannot view other users bookings\");",
    "        ",
    "        List<Map<String, Object>> result = new ArrayList<>();",
    "        for (Booking b : bookings.values()) {",
    "            if (b.userId.equals(userId)) {",
    "                Map<String, Object> item = new HashMap<>();",
    "                item.put(\"bookingId\", b.id); item.put(\"eventId\", b.eventId);",
    "                item.put(\"tickets\", b.numberOfTickets); item.put(\"status\", b.status.name());",
    "                result.add(item);",
    "            }",
    "        }",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"bookings\", result);",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response createEvent(Map<String, Object> request, String token) {",
    "        if (token != null) {",
    "            Map<String, Object> auth = validateToken(token);",
    "            if (auth == null) return errorResponse(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "            if (!\"ADMIN\".equals(auth.get(\"role\"))) return errorResponse(403, \"FORBIDDEN\", \"Admin role required\");",
    "        }",
    "        ",
    "        String[] required = {\"name\", \"date\", \"venue\", \"totalTickets\", \"pricePerTicket\"};",
    "        for (String field : required)",
    "            if (!request.containsKey(field)) return errorResponse(400, \"VALIDATION_ERROR\", \"Missing: \" + field);",
    "        ",
    "        String eventId = String.format(\"evt_%03d\", ++eventCounter);",
    "        Event event = new Event(eventId, (String) request.get(\"name\"),",
    "            Instant.parse((String) request.get(\"date\")), (String) request.get(\"venue\"),",
    "            (Integer) request.get(\"totalTickets\"), new BigDecimal(request.get(\"pricePerTicket\").toString()));",
    "        events.put(eventId, event);",
    "        ",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", eventId);",
    "        body.put(\"data\", data);",
    "        return new Response(201, body);",
    "    }",
    "    ",
    "    public Response getEvent(String eventId) {",
    "        if (!events.containsKey(eventId)) return errorResponse(404, \"NOT_FOUND\", \"Event not found\");",
    "        Event e = events.get(eventId);",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", e.id); data.put(\"name\", e.name); data.put(\"availableTickets\", e.availableTickets);",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response bookTickets(Map<String, Object> request, String token) {",
    "        if (token != null) {",
    "            Map<String, Object> auth = validateToken(token);",
    "            if (auth == null) return errorResponse(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "            if (\"GUEST\".equals(auth.get(\"role\"))) return errorResponse(403, \"FORBIDDEN\", \"User role required\");",
    "        }",
    "        ",
    "        String eventId = (String) request.get(\"eventId\");",
    "        if (!events.containsKey(eventId)) return errorResponse(404, \"NOT_FOUND\", \"Event not found\");",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Event event = events.get(eventId);",
    "            int num = (Integer) request.get(\"numberOfTickets\");",
    "            if (event.availableTickets < num) return errorResponse(409, \"INSUFFICIENT_TICKETS\", \"Not enough tickets\");",
    "            ",
    "            String bookingId = String.format(\"bkg_%03d\", ++bookingCounter);",
    "            BigDecimal total = event.pricePerTicket.multiply(new BigDecimal(num));",
    "            Booking booking = new Booking(bookingId, eventId, (String) request.get(\"userId\"), num, total);",
    "            event.availableTickets -= num;",
    "            bookings.put(bookingId, booking);",
    "            ",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId); data.put(\"status\", \"CONFIRMED\");",
    "            body.put(\"data\", data);",
    "            return new Response(201, body);",
    "        } finally { lock.unlock(); }",
    "    }",
    "    ",
    "    public Response cancelBooking(String bookingId, String token) {",
    "        if (!bookings.containsKey(bookingId)) return errorResponse(404, \"NOT_FOUND\", \"Booking not found\");",
    "        ",
    "        if (token != null) {",
    "            Map<String, Object> auth = validateToken(token);",
    "            if (auth == null) return errorResponse(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "            Booking b = bookings.get(bookingId);",
    "            if (!\"ADMIN\".equals(auth.get(\"role\")) && !auth.get(\"user_id\").equals(b.userId))",
    "                return errorResponse(403, \"FORBIDDEN\", \"Cannot cancel others bookings\");",
    "        }",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Booking booking = bookings.get(bookingId);",
    "            if (booking.status == BookingStatus.CANCELLED) return errorResponse(409, \"ALREADY_CANCELLED\", \"Already cancelled\");",
    "            events.get(booking.eventId).availableTickets += booking.numberOfTickets;",
    "            booking.status = BookingStatus.CANCELLED;",
    "            ",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId); data.put(\"status\", \"CANCELLED\");",
    "            body.put(\"data\", data);",
    "            return new Response(200, body);",
    "        } finally { lock.unlock(); }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\\n\" + \"=\".repeat(50));",
    "        System.out.println(\"TICKET API - PART 2: AUTH DEMO\");",
    "        System.out.println(\"=\".repeat(50));",
    "        ",
    "        TicketAPI api = new TicketAPI();",
    "        ",
    "        // Admin login and create event",
    "        Map<String, Object> login = new HashMap<>();",
    "        login.put(\"username\", \"admin\"); login.put(\"password\", \"admin123\");",
    "        Response resp = api.login(login);",
    "        String adminToken = (String) ((Map) resp.body.get(\"data\")).get(\"token\");",
    "        System.out.println(\"\\nAdmin login: \" + resp.status);",
    "        ",
    "        Map<String, Object> eventReq = new HashMap<>();",
    "        eventReq.put(\"name\", \"Java Conf\"); eventReq.put(\"date\", \"2024-12-15T09:00:00Z\");",
    "        eventReq.put(\"venue\", \"Hall A\"); eventReq.put(\"totalTickets\", 100); eventReq.put(\"pricePerTicket\", 50);",
    "        resp = api.createEvent(eventReq, adminToken);",
    "        System.out.println(\"Create event: \" + resp.status + \" - \" + resp.body.get(\"data\"));",
    "        ",
    "        // User login, try create event (should fail)",
    "        login.put(\"username\", \"user\"); login.put(\"password\", \"user123\");",
    "        resp = api.login(login);",
    "        String userToken = (String) ((Map) resp.body.get(\"data\")).get(\"token\");",
    "        ",
    "        resp = api.createEvent(eventReq, userToken);",
    "        System.out.println(\"User creates event: \" + resp.status + \" (expected 403)\");",
    "        ",
    "        System.out.println(\"\\nDemo complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Imports: hashlib for password hashing, secrets for token generation, timedelta for expiry"
    },
    {
      "lines": "15-25",
      "explanation": "UserRole enum defines the three access levels: ADMIN, USER, GUEST"
    },
    {
      "lines": "60-75",
      "explanation": "New state: users dict, tokens dict, login_attempts dict for tracking failed logins"
    },
    {
      "lines": "85-95",
      "explanation": "_check_rate_limit: sliding window rate limiter - keeps only attempts from last 15 minutes"
    },
    {
      "lines": "97-107",
      "explanation": "_validate_token: checks token exists and not expired, cleans up if expired"
    },
    {
      "lines": "109-118",
      "explanation": "_authorize: two-step check - first validate token, then check role hierarchy"
    },
    {
      "lines": "120-145",
      "explanation": "login method: rate limit check \u2192 credential validation \u2192 token generation"
    },
    {
      "lines": "180-195",
      "explanation": "create_event modified: auth check at start, only proceeds if ADMIN or no token (backward compat)"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "login": {
          "complexity": "O(a) where a = login attempts for user",
          "explanation": "Filtering old attempts is O(a), hash comparison is O(1)"
        },
        "get_current_user": {
          "complexity": "O(1)",
          "explanation": "Single dict lookup for token"
        },
        "get_user_bookings": {
          "complexity": "O(b) where b = total bookings",
          "explanation": "Must scan all bookings to filter by user_id"
        },
        "_validate_token": {
          "complexity": "O(1)",
          "explanation": "Dict lookup and timestamp comparison"
        },
        "_authorize": {
          "complexity": "O(1)",
          "explanation": "Token validation + role comparison"
        }
      },
      "overall_change": "Auth adds O(1) overhead to each protected operation. get_user_bookings is O(b) but could be optimized with user_id index."
    },
    "space": {
      "additional_space": "O(u + t + a) where u=users, t=active tokens, a=login attempt records",
      "explanation": "New dicts for users (small, fixed), tokens (bounded by active sessions), and login attempts (bounded by rate limit window)"
    }
  },
  "dry_run": {
    "example_input": "Admin login, create event, user login, user tries to create event, user books tickets",
    "steps": [
      {
        "step": 1,
        "action": "login({username: 'admin', password: 'admin123'})",
        "state": "users has admin, login_attempts empty",
        "explanation": "Rate limit passes (no attempts), password hash matches, generate token tok_xxx"
      },
      {
        "step": 2,
        "action": "create_event({...}, admin_token)",
        "state": "tokens has admin token",
        "explanation": "_authorize checks token valid \u2713, role=ADMIN \u2713, proceed to create event"
      },
      {
        "step": 3,
        "action": "login({username: 'user', password: 'user123'})",
        "state": "Generate user token tok_yyy",
        "explanation": "Regular user login, gets USER role"
      },
      {
        "step": 4,
        "action": "create_event({...}, user_token)",
        "state": "Token valid but role=USER",
        "explanation": "_authorize returns 403 FORBIDDEN because role < ADMIN"
      },
      {
        "step": 5,
        "action": "book_tickets({eventId: evt_001, ...}, user_token)",
        "state": "USER role >= USER required",
        "explanation": "Auth passes, booking created successfully"
      }
    ],
    "final_output": "Admin can create events, user cannot. User can book tickets."
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "login with seeded admin/user credentials should return 200",
      "createEvent without token should work (backward compat)"
    ],
    "likely_bugs": [
      "Forgetting to hash password before comparison",
      "Checking auth AFTER business logic instead of BEFORE",
      "Not returning early after auth failure",
      "Using wrong user_id (from request vs from token)"
    ],
    "recommended_logs_or_asserts": [
      "assert token in self.tokens after login",
      "log auth['role'] before role comparison",
      "log rate limit count on failed login"
    ],
    "how_to_localize": "1. Check login returns token, 2. Check _validate_token returns auth info, 3. Check _authorize returns correct role, 4. Print auth dict before role comparison"
  },
  "edge_cases": [
    {
      "case": "Expired token",
      "handling": "validateToken removes token and returns None \u2192 401",
      "gotcha": "Must clean up expired tokens to prevent memory leak"
    },
    {
      "case": "Rate limit exactly at boundary",
      "handling": "5 attempts allowed, 6th blocked",
      "gotcha": "Use < not <= in comparison"
    },
    {
      "case": "Admin cancels user's booking",
      "handling": "Check role==ADMIN OR user_id matches",
      "gotcha": "Must check ADMIN override first"
    },
    {
      "case": "User tries to view other's bookings",
      "handling": "403 Forbidden unless ADMIN",
      "gotcha": "Compare user_id from token, not from request"
    },
    {
      "case": "No token provided (backward compat)",
      "handling": "Skip auth checks if token is None",
      "gotcha": "Allows Part 1 tests to still pass"
    }
  ],
  "test_cases": [
    {
      "name": "Admin creates event successfully",
      "input": "login(admin/admin123), create_event({...}, admin_token)",
      "expected": "201 Created with eventId",
      "explanation": "ADMIN role has permission to create events"
    },
    {
      "name": "User denied event creation",
      "input": "login(user/user123), create_event({...}, user_token)",
      "expected": "403 Forbidden with 'Admin role required'",
      "explanation": "USER role cannot create events"
    },
    {
      "name": "Rate limiting after 5 failures",
      "input": "5x login(admin/wrong), 6th login(admin/wrong)",
      "expected": "First 5: 401, 6th: 429 Rate Limited",
      "explanation": "Lockout activates after MAX_LOGIN_ATTEMPTS"
    },
    {
      "name": "User can only see own bookings",
      "input": "user1 books, user2 calls get_user_bookings(user2_token, user1_id)",
      "expected": "403 Forbidden",
      "explanation": "Users cannot access other users' bookings"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking authorization AFTER performing the action",
      "why_wrong": "Side effects happen before permission is verified",
      "correct_approach": "Always check auth at the START of the method, return early if unauthorized",
      "code_example_wrong": "# WRONG\\nevent = create_event(...)  # Action happens\\nif not is_admin: return 403  # Too late!",
      "code_example_correct": "# CORRECT\\nif not is_admin: return 403  # Check first\\nevent = create_event(...)  # Then act"
    },
    {
      "mistake": "Comparing plaintext password with stored hash",
      "why_wrong": "Always fails because hash != plaintext",
      "correct_approach": "Hash the input password before comparing",
      "code_example_wrong": "if user.password_hash == password:  # Wrong!",
      "code_example_correct": "if user.password_hash == hash(password):  # Correct"
    },
    {
      "mistake": "Using request.userId for ownership check instead of token.user_id",
      "why_wrong": "Client can forge request body, token is server-verified",
      "correct_approach": "Always use user_id from validated token",
      "code_example_wrong": "if request['userId'] == booking.user_id:  # Forgeable!",
      "code_example_correct": "if auth['user_id'] == booking.user_id:  # From token"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by drawing the auth flow diagram. Explain the layered approach: authenticate (WHO) \u2192 authorize (WHAT) \u2192 validate (DATA) \u2192 execute. Then show the code changes.",
    "what_to_mention": [
      "Security principle: defense in depth",
      "Why we hash passwords",
      "Token expiry for session management",
      "Rate limiting prevents brute force",
      "Role hierarchy simplifies permission checks"
    ],
    "time_allocation": "2 min: understand requirements, 3 min: design auth flow, 10 min: implement, 3 min: test",
    "if_stuck": [
      "Ask: 'Should I use real JWT or is a simple token OK?'",
      "Ask: 'Can I assume in-memory user storage?'",
      "Mention: 'I'd use a decorator/middleware pattern in production'"
    ]
  },
  "connection_to_next_part": "Part 3 likely adds distributed systems concerns: distributed rate limiting (Redis), session management across servers, or event sourcing for audit logs. The token storage abstraction makes it easy to swap in Redis. The auth helper pattern allows adding middleware for logging/monitoring.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 gives us the core booking functionality. For Part 2, I need to add authentication and authorization. The key insight is that auth is a cross-cutting concern - I'll add helper methods rather than duplicating code.",
    "explaining_changes": "I'm adding three new data structures: users dict for credentials, tokens dict for session management, and login_attempts for rate limiting. The _authorize helper encapsulates the auth logic so each endpoint just calls it.",
    "while_extending_code": [
      "I'm adding User class with role field...",
      "This _validate_token method will be reused by all protected endpoints...",
      "Here I'm checking auth BEFORE the business logic to fail fast..."
    ],
    "after_completing": "Now the API has proper security. Login returns a token, protected endpoints check the token and role. Rate limiting prevents brute force attacks. All auth operations are O(1). Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Identify: need User class, token management, role checks on existing methods",
    "by_5_min": "Draw auth flow, explain _authorize helper approach",
    "by_10_min": "login() and _validate_token implemented, test with admin login",
    "by_15_min": "All protected methods updated, get_user_bookings done",
    "warning_signs": "If still designing at 7 min, start coding. Get login working first, then add to other methods."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Auth is independent layer - if Part 1 has bugs, they won't affect auth logic. Fix Part 1 bugs only if they prevent testing auth.",
    "if_new_requirement_unclear": "Ask: 'For role hierarchy, is ADMIN > USER > GUEST, or are they independent permissions?'",
    "if_running_behind": "Implement login() and createEvent with auth first - these demonstrate the pattern. Mention you'd apply same pattern to other methods."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning bcrypt/argon2 for production password hashing",
      "Discussing refresh tokens for better UX",
      "Suggesting audit logging for security events",
      "Mentioning OWASP top 10 considerations",
      "Discussing how to make this stateless for horizontal scaling"
    ]
  },
  "pattern_recognition": {
    "pattern": "Chain of Responsibility / Middleware Pattern",
    "indicators": [
      "Multiple validation steps in sequence",
      "Early exit on any failure",
      "Cross-cutting concerns like auth/logging"
    ],
    "similar_problems": [
      "Web framework middleware",
      "Request validation pipelines",
      "API gateway auth"
    ],
    "template": "def protected_method(self, request, token):\\n    auth, err = self._authorize(token, required_role)\\n    if err: return err\\n    # ... business logic"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'role-based access', I think permission matrix",
      "why": "Each role has specific allowed operations - need to map this clearly"
    },
    {
      "step": 2,
      "thought": "Token validation is called repeatedly - extract to helper",
      "why": "DRY principle, single point of change for auth logic"
    },
    {
      "step": 3,
      "thought": "Rate limiting needs timestamp tracking",
      "why": "Sliding window approach is more fair than fixed window"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you add security without breaking existing functionality?",
      "Do you understand auth vs authz distinction?",
      "Is the code organized and testable?"
    ],
    "bonus_points": [
      "Mentioning security best practices (hash, rate limit)",
      "Clean separation of auth logic",
      "Backward compatibility consideration"
    ],
    "red_flags": [
      "Storing plaintext passwords",
      "Checking auth after action",
      "Copy-pasting auth code everywhere",
      "Not understanding token expiry"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for boilerplate like hash function syntax",
      "Ask AI to generate test cases for edge conditions"
    ],
    "what_not_to_do": [
      "Don't let AI generate auth logic without understanding it",
      "Verify any security-related code carefully"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about password storage requirements",
      "Assuming everyone knows JWT"
    ],
    "technical": [
      "Comparing unhashed passwords",
      "No rate limiting mentioned",
      "Storing tokens without expiry"
    ],
    "communication": [
      "Not explaining the auth flow before coding",
      "Not testing the happy path first"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Can admin create events? \u2713",
      "Is user blocked from creating events? \u2713",
      "Does rate limiting kick in after 5 failures? \u2713",
      "Can users only see their own bookings? \u2713",
      "Do Part 1 tests still pass (backward compat)? \u2713"
    ],
    "quick_code_review": [
      "Password is hashed before comparison",
      "Token expiry is checked",
      "Auth check happens BEFORE business logic",
      "Role check uses hierarchy not exact match"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "bcrypt with salt for passwords",
      "Redis for distributed token storage",
      "Audit logging for auth events",
      "HTTPS enforcement",
      "CORS configuration"
    ],
    "why_not_in_interview": "Focus on demonstrating the pattern; security libraries add complexity without teaching concepts",
    "how_to_mention": "Say: 'In production, I'd use bcrypt for passwords and Redis for token storage to support horizontal scaling.'"
  },
  "generated_at": "2026-01-19T04:50:04.948750",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}