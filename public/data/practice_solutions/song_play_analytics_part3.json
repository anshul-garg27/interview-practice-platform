{
  "problem_title": "Song Play Analytics System - Part 3: Recent Unique Plays",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 returns recent plays WITH duplicates. Part 3 must return recent plays WITHOUT duplicates - only the most recent occurrence of each song counts. This requires deduplication while preserving recency order.",
    "new_requirements": [
      "New method get_recent_unique_plays(count) that returns unique songs only",
      "Skip duplicate occurrences, keeping only the most recent play of each song",
      "Return up to 'count' unique songs in reverse chronological order"
    ],
    "new_constraints": [
      "Must traverse history to find unique songs",
      "May need to scan more than 'count' elements to find enough unique songs",
      "O(n) worst case is acceptable where n = total plays"
    ],
    "key_insight": "Iterate backwards through play history. Use a Set to track seen songs. Add each unseen song to result. Stop when result has 'count' songs or history is exhausted. This naturally preserves most-recent-first order."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Return unique songs only",
        "how_met": "Set tracks seen songs, skip if already in set",
        "gotchas": [
          "Don't confuse with unique listeners - this is unique song names"
        ]
      },
      {
        "requirement": "Most recent first ordering",
        "how_met": "Traverse from end of list backward",
        "gotchas": [
          "Don't sort - maintain discovery order"
        ]
      },
      {
        "requirement": "Return at most 'count' songs",
        "how_met": "Early termination when result.size() == count",
        "gotchas": [
          "May return fewer if not enough unique songs exist"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "get_recent_unique_plays",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Worst case scans entire history if many duplicates or count exceeds unique songs"
      }
    ],
    "non_goals": [
      "Optimizing for O(count) time - impossible without additional data structures",
      "Maintaining a separate unique-plays structure",
      "Modifying existing play_song behavior"
    ]
  },
  "assumptions": [
    "Play history can grow unbounded (same as Part 2)",
    "count parameter is non-negative",
    "Song names are case-sensitive (same as previous parts)",
    "No need for thread safety"
  ],
  "tradeoffs": [
    {
      "decision": "Scan history on-demand vs maintain separate unique list",
      "chosen": "Scan on-demand",
      "why": "Simple implementation, O(n) query is acceptable per problem hints",
      "alternative": "LinkedHashSet for O(1) updates + O(count) query",
      "when_to_switch": "If get_recent_unique_plays is called very frequently"
    },
    {
      "decision": "Use existing recent_plays list vs duplicate storage",
      "chosen": "Reuse existing list",
      "why": "No additional space overhead, maintains single source of truth",
      "alternative": "Maintain parallel unique structure",
      "when_to_switch": "If both unique and non-unique queries are frequent"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "recent_plays list structure from Part 2",
      "All existing method signatures and behaviors",
      "Song class unchanged"
    ],
    "what_to_change": [
      "Add new get_recent_unique_plays method to SongAnalytics"
    ],
    "interfaces_and_boundaries": "New method is purely additive - queries existing data without mutation",
    "invariants": [
      "recent_plays order unchanged by new method",
      "All Part 2 invariants preserved",
      "Result length <= count",
      "Result length <= number of unique songs in history"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nPlay History: [A, B, A, C, A, B]\n              0  1  2  3  4  5\n\nget_recent_plays(4):        [B, A, C, A]  (positions 5,4,3,2)\nget_recent_unique_plays(4): [B, A, C]     (positions 5,4,3 - skip duplicate A)\n```",
    "algorithm_flow": "```\nStep 1: i=5, song=B, seen={}, result=[]  \u2192 Add B \u2192 seen={B}, result=[B]\nStep 2: i=4, song=A, seen={B}, result=[B] \u2192 Add A \u2192 seen={B,A}, result=[B,A]\nStep 3: i=3, song=C, seen={B,A}           \u2192 Add C \u2192 seen={B,A,C}, result=[B,A,C]\n        count=3 reached, DONE!\n\n(Positions 2,1,0 never visited due to early termination)\n```"
  },
  "approaches": [
    {
      "name": "Naive: Collect all then dedupe",
      "description": "Get all recent plays, then remove duplicates keeping first occurrence",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "why_not_optimal": "Creates unnecessary intermediate list, doesn't leverage early termination"
    },
    {
      "name": "Optimal: Single pass with early termination",
      "description": "Traverse backwards, track seen in set, stop when count reached",
      "time_complexity": "O(min(n, k*d)) where d=duplicate factor",
      "space_complexity": "O(count)",
      "key_insight": "Early termination means average case is much better than O(n)"
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Algorithm:** Iterate through `recent_plays` from **end to start** (most recent first). Use a **HashSet** to track songs already added to result. For each song: if **not seen**, add to result and mark as seen. Stop when result has **count** songs or we've exhausted history.\n\n**Why this works:** By traversing backwards, the first occurrence of each song we encounter IS its most recent play. The set ensures we skip all older occurrences. Building result in discovery order gives us newest-first automatically.",
    "data_structures": [
      {
        "structure": "Set<String> seen",
        "purpose": "O(1) duplicate detection during traversal"
      },
      {
        "structure": "List<String> result",
        "purpose": "Collect unique songs in discovery (most-recent-first) order"
      }
    ],
    "algorithm_steps": [
      "1. If count <= 0, return empty list",
      "2. Initialize empty result list and seen set",
      "3. Iterate i from len(recent_plays)-1 down to 0",
      "4. For each song at position i: if not in seen, add to seen and append to result",
      "5. If result has count elements, break early",
      "6. Return result"
    ]
  },
  "solution_python_lines": [
    "from typing import Set, List",
    "",
    "",
    "class Song:",
    "    \"\"\"Song with unique listener tracking via Set.\"\"\"",
    "    ",
    "    def __init__(self, name: str) -> None:",
    "        self.name = name",
    "        self.listeners: Set[int] = set()",
    "    ",
    "    def add_listener(self, user_id: int) -> None:",
    "        self.listeners.add(user_id)",
    "    ",
    "    def get_listener_count(self) -> int:",
    "        return len(self.listeners)",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    Music streaming analytics system.",
    "    Tracks unique listeners, recent plays (with duplicates), and unique recent plays.",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        self.songs: dict[int, Song] = {}",
    "        self.next_id = 1",
    "        self.recent_plays: List[str] = []  # Part 2: chronological play history",
    "    ",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"Add song with auto-assigned ID. Returns the assigned ID.\"\"\"",
    "        song_id = self.next_id",
    "        self.songs[song_id] = Song(name)",
    "        self.next_id += 1",
    "        return song_id",
    "    ",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"Record a play event. Updates unique listeners AND play history.\"\"\"",
    "        if song_id not in self.songs:",
    "            print(f\"Error: Song ID {song_id} does not exist.\")",
    "            return",
    "        song = self.songs[song_id]",
    "        song.add_listener(user_id)",
    "        self.recent_plays.append(song.name)  # Part 2: track every play",
    "    ",
    "    def print_analytics(self) -> None:",
    "        \"\"\"Print songs sorted by unique listeners (desc), then name (asc).\"\"\"",
    "        sorted_songs = sorted(",
    "            self.songs.values(),",
    "            key=lambda s: (-s.get_listener_count(), s.name)",
    "        )",
    "        for song in sorted_songs:",
    "            print(f\"{song.name} ({song.get_listener_count()} unique listeners)\")",
    "    ",
    "    def get_recent_plays(self, count: int) -> List[str]:",
    "        \"\"\"Return most recent 'count' plays in reverse chronological order.\"\"\"",
    "        if count <= 0:",
    "            return []",
    "        return self.recent_plays[-count:][::-1]",
    "    ",
    "    def get_recent_unique_plays(self, count: int) -> List[str]:",
    "        \"\"\"",
    "        Return most recent 'count' UNIQUE plays in reverse chronological order.",
    "        Algorithm: Traverse backwards, skip duplicates using a set.",
    "        \"\"\"",
    "        if count <= 0:",
    "            return []",
    "        ",
    "        result = []",
    "        seen = set()",
    "        ",
    "        # Traverse from most recent to oldest",
    "        for i in range(len(self.recent_plays) - 1, -1, -1):",
    "            song_name = self.recent_plays[i]",
    "            if song_name not in seen:",
    "                seen.add(song_name)",
    "                result.append(song_name)",
    "                if len(result) == count:",
    "                    break",
    "        ",
    "        return result",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 3 Example 1: Recent Unique Plays\")",
    "    print(\"=\" * 60)",
    "    analytics = SongAnalytics()",
    "    ",
    "    analytics.add_song(\"A\")  # ID: 1",
    "    analytics.add_song(\"B\")  # ID: 2",
    "    analytics.add_song(\"C\")  # ID: 3",
    "    ",
    "    # Play sequence: A -> B -> A -> C -> A -> B",
    "    analytics.play_song(1, 1)  # A",
    "    analytics.play_song(2, 1)  # B",
    "    analytics.play_song(1, 2)  # A",
    "    analytics.play_song(3, 1)  # C",
    "    analytics.play_song(1, 3)  # A",
    "    analytics.play_song(2, 2)  # B",
    "    ",
    "    print(f\"Play history: {analytics.recent_plays}\")",
    "    print(f\"Recent 4 (with dups):    {analytics.get_recent_plays(4)}\")",
    "    print(f\"Recent 3 unique:         {analytics.get_recent_unique_plays(3)}\")",
    "    # Expected: ['B', 'A', 'C']",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Part 3 Example 2: Request more than unique songs exist\")",
    "    print(\"=\" * 60)",
    "    print(f\"Recent 5 unique (only 3 exist): {analytics.get_recent_unique_plays(5)}\")",
    "    # Expected: ['B', 'A', 'C']",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Part 3 Example 3: Same song repeated\")",
    "    print(\"=\" * 60)",
    "    analytics2 = SongAnalytics()",
    "    analytics2.add_song(\"Only\")",
    "    analytics2.play_song(1, 1)",
    "    analytics2.play_song(1, 2)",
    "    analytics2.play_song(1, 3)",
    "    print(f\"3 plays of same song, request 5: {analytics2.get_recent_unique_plays(5)}\")",
    "    # Expected: ['Only']",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Edge cases\")",
    "    print(\"=\" * 60)",
    "    analytics3 = SongAnalytics()",
    "    print(f\"No plays, request 3: {analytics3.get_recent_unique_plays(3)}\")",
    "    print(f\"Request 0: {analytics.get_recent_unique_plays(0)}\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Song with unique listener tracking via HashSet.",
    " */",
    "class Song {",
    "    private String name;",
    "    private Set<Integer> listeners;",
    "    ",
    "    public Song(String name) {",
    "        this.name = name;",
    "        this.listeners = new HashSet<>();",
    "    }",
    "    ",
    "    public void addListener(int userId) {",
    "        listeners.add(userId);",
    "    }",
    "    ",
    "    public int getListenerCount() {",
    "        return listeners.size();",
    "    }",
    "    ",
    "    public String getName() {",
    "        return name;",
    "    }",
    "}",
    "",
    "/**",
    " * Music streaming analytics system.",
    " * Tracks unique listeners, recent plays, and unique recent plays.",
    " */",
    "public class SongAnalytics {",
    "    private Map<Integer, Song> songs;",
    "    private int nextId;",
    "    private List<String> recentPlays;  // Part 2: chronological play history",
    "    ",
    "    public SongAnalytics() {",
    "        this.songs = new HashMap<>();",
    "        this.nextId = 1;",
    "        this.recentPlays = new ArrayList<>();",
    "    }",
    "    ",
    "    public int addSong(String name) {",
    "        int songId = nextId;",
    "        songs.put(songId, new Song(name));",
    "        nextId++;",
    "        return songId;",
    "    }",
    "    ",
    "    public void playSong(int songId, int userId) {",
    "        if (!songs.containsKey(songId)) {",
    "            System.out.println(\"Error: Song ID \" + songId + \" does not exist.\");",
    "            return;",
    "        }",
    "        Song song = songs.get(songId);",
    "        song.addListener(userId);",
    "        recentPlays.add(song.getName());  // Part 2: track every play",
    "    }",
    "    ",
    "    public void printAnalytics() {",
    "        List<Song> sortedSongs = new ArrayList<>(songs.values());",
    "        sortedSongs.sort((a, b) -> {",
    "            int countCompare = Integer.compare(b.getListenerCount(), a.getListenerCount());",
    "            if (countCompare != 0) return countCompare;",
    "            return a.getName().compareTo(b.getName());",
    "        });",
    "        ",
    "        for (Song song : sortedSongs) {",
    "            System.out.println(song.getName() + \" (\" +",
    "                song.getListenerCount() + \" unique listeners)\");",
    "        }",
    "    }",
    "    ",
    "    public List<String> getRecentPlays(int count) {",
    "        List<String> result = new ArrayList<>();",
    "        int size = recentPlays.size();",
    "        int start = Math.max(0, size - count);",
    "        for (int i = size - 1; i >= start; i--) {",
    "            result.add(recentPlays.get(i));",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Return most recent 'count' UNIQUE plays in reverse chronological order.",
    "     * Algorithm: Traverse backwards, skip duplicates using a set.",
    "     */",
    "    public List<String> getRecentUniquePlays(int count) {",
    "        List<String> result = new ArrayList<>();",
    "        if (count <= 0) {",
    "            return result;",
    "        }",
    "        ",
    "        Set<String> seen = new HashSet<>();",
    "        ",
    "        // Traverse from most recent to oldest",
    "        for (int i = recentPlays.size() - 1; i >= 0; i--) {",
    "            String songName = recentPlays.get(i);",
    "            if (!seen.contains(songName)) {",
    "                seen.add(songName);",
    "                result.add(songName);",
    "                if (result.size() == count) {",
    "                    break;",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return result;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Part 3 Example 1: Recent Unique Plays\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        analytics.addSong(\"A\");  // ID: 1",
    "        analytics.addSong(\"B\");  // ID: 2",
    "        analytics.addSong(\"C\");  // ID: 3",
    "        ",
    "        // Play sequence: A -> B -> A -> C -> A -> B",
    "        analytics.playSong(1, 1);",
    "        analytics.playSong(2, 1);",
    "        analytics.playSong(1, 2);",
    "        analytics.playSong(3, 1);",
    "        analytics.playSong(1, 3);",
    "        analytics.playSong(2, 2);",
    "        ",
    "        System.out.println(\"Recent 4 (with dups): \" + analytics.getRecentPlays(4));",
    "        System.out.println(\"Recent 3 unique: \" + analytics.getRecentUniquePlays(3));",
    "        // Expected: [B, A, C]",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"Part 3 Example 2: Same song repeated\");",
    "        System.out.println(\"============================================================\");",
    "        SongAnalytics analytics2 = new SongAnalytics();",
    "        analytics2.addSong(\"Only\");",
    "        analytics2.playSong(1, 1);",
    "        analytics2.playSong(1, 2);",
    "        analytics2.playSong(1, 3);",
    "        System.out.println(\"3 plays, request 5: \" + analytics2.getRecentUniquePlays(5));",
    "        // Expected: [Only]",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15 (Python) / 1-25 (Java)",
      "explanation": "Song class unchanged from Part 2 - tracks name and unique listeners"
    },
    {
      "lines": "17-42 (Python) / 27-55 (Java)",
      "explanation": "SongAnalytics core methods unchanged - add_song, play_song, print_analytics work exactly as before"
    },
    {
      "lines": "44-48 (Python) / 57-65 (Java)",
      "explanation": "get_recent_plays from Part 2 unchanged - returns plays with duplicates"
    },
    {
      "lines": "50-66 (Python) / 67-88 (Java)",
      "explanation": "NEW: get_recent_unique_plays - traverses backwards, uses set for O(1) duplicate detection, early termination when count reached"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_recent_unique_plays": {
          "complexity": "O(n) worst case",
          "explanation": "Must scan entire history if many duplicates or count exceeds unique songs. Average case is O(count * d) where d is duplicate factor."
        }
      },
      "overall_change": "No change to existing methods. New method is O(n) worst case but typically faster due to early termination."
    },
    "space": {
      "additional_space": "O(count) temporary",
      "explanation": "The seen set and result list grow at most to 'count' elements. No persistent storage added beyond Part 2."
    }
  },
  "dry_run": {
    "example_input": "Play sequence: A\u2192B\u2192A\u2192C\u2192A\u2192B, getRecentUniquePlays(3)",
    "steps": [
      {
        "step": 1,
        "action": "Initialize",
        "state": "recent_plays=[A,B,A,C,A,B], result=[], seen={}",
        "explanation": "Starting state with 6 plays"
      },
      {
        "step": 2,
        "action": "i=5, song='B'",
        "state": "B not in seen \u2192 add to seen and result",
        "explanation": "result=[B], seen={B}"
      },
      {
        "step": 3,
        "action": "i=4, song='A'",
        "state": "A not in seen \u2192 add to seen and result",
        "explanation": "result=[B,A], seen={B,A}"
      },
      {
        "step": 4,
        "action": "i=3, song='C'",
        "state": "C not in seen \u2192 add to seen and result",
        "explanation": "result=[B,A,C], seen={B,A,C}"
      },
      {
        "step": 5,
        "action": "Check count",
        "state": "len(result)==3==count",
        "explanation": "Early termination - don't process positions 2,1,0"
      }
    ],
    "final_output": "['B', 'A', 'C']"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single play \u2192 returns that song",
      "count=0 \u2192 returns empty list",
      "count > total plays \u2192 returns all unique songs"
    ],
    "likely_bugs": [
      "Traversing forward instead of backward (gives oldest-first)",
      "Not using set (returns duplicates)",
      "Off-by-one in loop bounds"
    ],
    "recommended_logs_or_asserts": [
      "print(f'Checking index {i}, song={song_name}, seen={seen}')",
      "assert len(result) <= count",
      "assert len(set(result)) == len(result)  # no dups in result"
    ],
    "how_to_localize": "Print the traversal step by step: index, song name, whether skipped or added"
  },
  "edge_cases": [
    {
      "case": "count = 0",
      "handling": "Return empty list immediately",
      "gotcha": "Don't forget this check before loop"
    },
    {
      "case": "count > number of unique songs",
      "handling": "Loop exhausts naturally, return all unique songs found",
      "gotcha": "Don't throw error - gracefully return fewer"
    },
    {
      "case": "No plays yet",
      "handling": "Loop doesn't execute, return empty list",
      "gotcha": "range(len([]) - 1, -1, -1) is empty in Python"
    },
    {
      "case": "All plays are same song",
      "handling": "Set detects all as duplicates, return single-element list",
      "gotcha": "Works correctly due to set deduplication"
    }
  ],
  "test_cases": [
    {
      "name": "Basic unique filtering",
      "input": "Plays: A,B,A,C,A,B; getRecentUniquePlays(3)",
      "expected": "['B', 'A', 'C']",
      "explanation": "B(pos 5), A(pos 4), C(pos 3) - skips older A and B"
    },
    {
      "name": "Request exceeds unique count",
      "input": "Same plays; getRecentUniquePlays(10)",
      "expected": "['B', 'A', 'C']",
      "explanation": "Only 3 unique songs exist"
    },
    {
      "name": "Single song many times",
      "input": "Plays: Only,Only,Only; getRecentUniquePlays(5)",
      "expected": "['Only']",
      "explanation": "Only 1 unique song despite 3 plays"
    },
    {
      "name": "Comparison with Part 2",
      "input": "Same plays; getRecentPlays(3) vs getRecentUniquePlays(3)",
      "expected": "['B','A','C'] vs ['B','A','C'] - same for this case but different generally",
      "explanation": "Part 2 includes duplicates, Part 3 doesn't"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Traversing forward and reversing at end",
      "why_wrong": "Finds oldest occurrences instead of most recent",
      "correct_approach": "Traverse backward from start to get most recent first",
      "code_example_wrong": "for song in recent_plays: if song not in seen: ...",
      "code_example_correct": "for i in range(len(recent_plays) - 1, -1, -1): ..."
    },
    {
      "mistake": "Using list instead of set for seen tracking",
      "why_wrong": "O(n) lookup per song instead of O(1)",
      "correct_approach": "HashSet for O(1) contains check",
      "code_example_wrong": "if song not in result_list:",
      "code_example_correct": "if song not in seen_set:"
    },
    {
      "mistake": "Forgetting early termination",
      "why_wrong": "Always scans entire history even when count is small",
      "correct_approach": "Break when result has count elements",
      "code_example_wrong": "# missing break",
      "code_example_correct": "if len(result) == count: break"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the difference from Part 2 (unique vs duplicates). Describe the backward traversal + set approach before coding. Mention early termination as an optimization.",
    "what_to_mention": [
      "Why backward traversal gives most-recent-first order naturally",
      "Set for O(1) duplicate detection",
      "Early termination optimization",
      "Worst case O(n) but average case much better"
    ],
    "time_allocation": "1 min understand, 2 min explain approach, 5 min code, 2 min test",
    "if_stuck": [
      "Think about how you'd manually find unique recent songs",
      "What data structure gives O(1) 'have I seen this before'?",
      "Which direction should you traverse to get most recent first?"
    ]
  },
  "connection_to_next_part": "Part 4 might add time-windowed queries (recent unique in last N hours) or deletion of songs. The current structure supports extensions well - play history is preserved, we can add timestamps per play if needed.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2's get_recent_plays returns duplicates. For Part 3, I need to return unique songs only, keeping just the most recent occurrence of each.",
    "explaining_changes": "The key insight is to traverse the play history backwards. This way, the first time I see a song IS its most recent play. I'll use a set to skip duplicates and early-terminate when I have enough.",
    "while_extending_code": [
      "I'm adding a new method, no changes to existing code",
      "Using a set 'seen' for O(1) duplicate detection",
      "Iterating backwards to get newest-first order"
    ],
    "after_completing": "This handles Part 3. Time is O(n) worst case but usually faster due to early termination. Space is O(count) for the temporary structures."
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Understand unique vs duplicate requirement, recognize backward traversal pattern",
    "by_5_min": "Have explained approach, started coding the new method",
    "by_10_min": "Method complete, running through test case to verify",
    "warning_signs": "If struggling with traversal direction after 3 min, draw out the example"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 3 only reads recent_plays, doesn't modify it. If Part 2 is broken, fix it first.",
    "if_new_requirement_unclear": "Ask: 'So if A is played 3 times, getRecentUniquePlays should return A only once at its most recent position?'",
    "if_running_behind": "Code the core loop first, handle count=0 edge case verbally"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing backward traversal gives correct order",
      "Mentioning early termination optimization",
      "Noting that existing code is untouched - purely additive",
      "Discussing average vs worst case complexity"
    ]
  },
  "pattern_recognition": {
    "pattern": "Backward traversal with deduplication",
    "indicators": [
      "'Most recent' suggests starting from end",
      "'Unique' suggests set-based tracking",
      "'First occurrence when scanning backwards' = most recent overall"
    ],
    "similar_problems": [
      "LC 316 - Remove Duplicate Letters",
      "LC 1209 - Remove All Adjacent Duplicates II",
      "First unique character problems"
    ],
    "template": "for i in range(len(arr)-1, -1, -1): if arr[i] not in seen: seen.add(arr[i]); result.append(arr[i])"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'most recent unique', I think about traversal direction",
      "why": "Starting from end means first occurrence of each song IS its most recent"
    },
    {
      "step": 2,
      "thought": "Need to track 'already seen' efficiently",
      "why": "Set gives O(1) lookup - perfect for duplicate detection"
    },
    {
      "step": 3,
      "thought": "Can stop early when count is reached",
      "why": "No need to scan entire history if we found enough unique songs"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you identify the backward traversal insight?",
      "Do you use appropriate data structures (set for dedup)?",
      "Do you handle edge cases gracefully?"
    ],
    "bonus_points": [
      "Mentioning early termination optimization",
      "Discussing average vs worst case",
      "Clean integration with existing code"
    ],
    "red_flags": [
      "Modifying Part 2's code unnecessarily",
      "Using list for duplicate checking (O(n) per check)",
      "Traversing forward then reversing"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use for loop syntax help",
      "Let it auto-complete the set operations"
    ],
    "what_not_to_do": [
      "Don't let it suggest sorting (wrong approach)",
      "Understand why backward traversal before accepting"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not clarifying unique vs duplicate distinction",
      "Jumping to code without explaining approach"
    ],
    "technical": [
      "Using O(n\u00b2) approach with list.contains in loop",
      "Forgetting the early termination"
    ],
    "communication": [
      "Not mentioning complexity",
      "Not tracing through an example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does backward traversal give newest-first order?",
      "Does set prevent duplicates in result?",
      "Does early termination work when count is reached?",
      "Are edge cases (count=0, no plays) handled?"
    ],
    "quick_code_review": [
      "Loop bounds correct (len-1 down to 0 inclusive)",
      "Set and result both updated atomically",
      "Return type matches signature"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging when scanning large history",
      "Metrics for cache hit rate if results are cached",
      "Consider caching unique list if called frequently"
    ],
    "why_not_in_interview": "Focus on core algorithm; caching is a follow-up discussion",
    "how_to_mention": "Say: 'In production, if this is called frequently, I might cache the unique list and invalidate on new plays.'"
  },
  "generated_at": "2026-01-19T05:05:17.947622",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}