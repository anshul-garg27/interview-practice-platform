{
  "problem_title": "Travel Expense Calculation System - Part 3: Per-Diem Calculations by Location",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 introduces trip-based expense management with location-specific reimbursement limits. Instead of global caps ($200/night hotel, $50/day meals), each location can have custom per-diem rates. Trips group expenses together and use the trip's location to determine applicable limits.",
    "new_requirements": [
      "Store location-specific per-diem rates (hotel and meal limits)",
      "Create trips with employee, location, and date range",
      "Add expenses directly to trips (amount is TOTAL, not per-unit)",
      "Calculate trip reimbursement using location-specific caps",
      "Fall back to default limits if location not configured"
    ],
    "new_constraints": [
      "Trip expenses use TOTAL amount semantics (divide by nights/days to get per-unit)",
      "Only HOTEL and MEAL use location-specific limits; FLIGHT/TRANSPORT use global strategies",
      "Meal 50% rule applies BEFORE the location cap check"
    ],
    "key_insight": "Trip expenses have different semantics: amount is TOTAL (e.g., $1200 for 3 nights), while regular expenses use per-unit (e.g., $180/night). Calculate per-unit by dividing, apply location cap, then multiply back."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Set location per-diem rates",
        "how_met": "set_location_per_diem stores LocationPerDiem(hotel_limit, meal_limit) in dict keyed by location",
        "gotchas": [
          "Remember to convert to Decimal for precision"
        ]
      },
      {
        "requirement": "Create trips with date ranges",
        "how_met": "create_trip creates Trip object with unique ID, stores in _trips dict",
        "gotchas": [
          "Trip ID format must match expected output (trip_1, trip_2, etc.)"
        ]
      },
      {
        "requirement": "Add expenses to trips",
        "how_met": "add_expense_to_trip appends Expense to trip.expenses list",
        "gotchas": [
          "Amount is TOTAL, not per-unit - this differs from Part 1/2"
        ]
      },
      {
        "requirement": "Calculate with location limits",
        "how_met": "calculate_trip_reimbursement looks up location limits, calculates per-unit, applies cap",
        "gotchas": [
          "Meal cap applies to the 50% amount, not the original"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "set_location_per_diem",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict insertion"
      },
      {
        "operation": "create_trip",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict insertion"
      },
      {
        "operation": "add_expense_to_trip",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "List append"
      },
      {
        "operation": "calculate_trip_reimbursement",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Iterate over trip expenses"
      }
    ],
    "non_goals": [
      "Currency conversion for trip expenses (assume USD)",
      "Partial day calculations",
      "Multiple locations per trip"
    ]
  },
  "assumptions": [
    "Trip expenses are in USD (no currency conversion needed)",
    "Days/nights are provided in expense details, not calculated from trip dates",
    "If location not configured, use default limits ($200 hotel, $50 meals)",
    "Trip dates are for auditing; actual days/nights come from expense details",
    "Meal 50% rule applies before location cap (consistent with Part 1)"
  ],
  "tradeoffs": [
    {
      "decision": "Store trips separately vs integrate with employee expenses",
      "chosen": "Separate _trips dict",
      "why": "Clear separation of concerns, trips have different semantics",
      "alternative": "Add trip_id field to Expense",
      "when_to_switch": "If need unified expense queries across trips and non-trips"
    },
    {
      "decision": "Calculate per-unit on-demand vs store both",
      "chosen": "Calculate on-demand",
      "why": "Simpler storage, single source of truth (total amount)",
      "alternative": "Store per_unit_amount",
      "when_to_switch": "If calculate_trip_reimbursement is called frequently"
    },
    {
      "decision": "Inline calculation vs LocationAwareStrategy",
      "chosen": "Inline in calculate_trip_reimbursement",
      "why": "Simpler for interview, avoids modifying existing strategies",
      "alternative": "Decorator pattern wrapping strategies",
      "when_to_switch": "If many expense types need location-aware logic"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1/2 methods unchanged",
      "Expense dataclass",
      "Existing strategy classes",
      "exchange rate handling"
    ],
    "what_to_change": [
      "Add LocationPerDiem and Trip classes",
      "Add _location_per_diems and _trips storage",
      "Add four new methods"
    ],
    "interfaces_and_boundaries": "Trip system is parallel to employee expenses - they don't interact. Future parts could add: trip expenses affecting employee totals, multi-currency trips, partial day calculations",
    "invariants": [
      "Trip expenses: amount is TOTAL",
      "Regular expenses: amount is PER-UNIT",
      "Meal 50% applied before cap check",
      "Default limits used when location not configured"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2):                    AFTER (Part 3):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   ExpenseManager    \u2502            \u2502   ExpenseManager    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 _employee_expenses  \u2502            \u2502 _employee_expenses  \u2502\n\u2502 _strategies         \u2502            \u2502 _strategies         \u2502\n\u2502 _exchange_rates     \u2502            \u2502 _exchange_rates     \u2502\n\u2502                     \u2502            \u2502 _location_per_diems \u2502 \u2190 NEW\n\u2502                     \u2502            \u2502 _trips              \u2502 \u2190 NEW\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\ncalculate_trip_reimbursement(trip_id):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Lookup trip by ID                         \u2502\n\u2502 2. Get location per-diem (or use defaults)   \u2502\n\u2502 3. For each expense in trip:                 \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502    \u2502 HOTEL:                                 \u2502\u2502\n\u2502    \u2502   per_night = amount / nights          \u2502\u2502\n\u2502    \u2502   capped = min(per_night, hotel_cap)   \u2502\u2502\n\u2502    \u2502   total += capped \u00d7 nights             \u2502\u2502\n\u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502\n\u2502    \u2502 MEAL:                                  \u2502\u2502\n\u2502    \u2502   per_day = amount / days              \u2502\u2502\n\u2502    \u2502   half = per_day \u00d7 0.5                 \u2502\u2502\n\u2502    \u2502   capped = min(half, meal_cap)         \u2502\u2502\n\u2502    \u2502   total += capped \u00d7 days               \u2502\u2502\n\u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502\n\u2502    \u2502 FLIGHT/TRANSPORT: use standard strategy\u2502\u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2502 4. Return total                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Modify Existing Strategies",
      "description": "Pass location limits into existing strategy classes, modify calculate() signature",
      "time_complexity": "O(n)",
      "space_complexity": "O(L) for locations",
      "why_not_optimal": "Breaks existing Part 1/2 API, strategies don't need to know about locations for non-trip expenses"
    },
    {
      "name": "Optimal Approach - Parallel Trip System",
      "description": "Create separate Trip entity with its own expense list. Calculate trip reimbursement inline using location limits, keeping existing strategies for non-trip expenses",
      "time_complexity": "O(n) for trip calculation",
      "space_complexity": "O(L + T + E) for locations, trips, trip expenses",
      "key_insight": "Trip expenses have different semantics (total vs per-unit), so handle them separately rather than forcing them into existing strategy pattern"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Solution Strategy\n\n**Core Insight**: Trip expenses use **TOTAL amount** semantics (e.g., $1200 for 3 nights), unlike regular expenses which use **per-unit** (e.g., $180/night). This fundamental difference means we need to:\n\n1. **Divide** total by units to get per-unit rate\n2. **Apply** location-specific cap\n3. **Multiply** back by units\n\n### Key Formula Differences\n\n**Regular Hotel** (Part 1/2):\n```\ncapped = min(expense.amount, $200)  # amount IS per-night\nreimbursement = capped \u00d7 nights\n```\n\n**Trip Hotel** (Part 3):\n```\nper_night = expense.amount / nights  # amount is TOTAL\ncapped = min(per_night, location_cap)\nreimbursement = capped \u00d7 nights\n```\n\n### Implementation\n\n1. **LocationPerDiem**: Simple data holder for (hotel_limit, meal_limit)\n2. **Trip**: Entity holding employee, location, dates, and expense list\n3. **Inline calculation**: In `calculate_trip_reimbursement`, handle HOTEL/MEAL with location caps, delegate FLIGHT/TRANSPORT to existing strategies",
    "data_structures": [
      {
        "structure": "Dict[str, LocationPerDiem]",
        "purpose": "O(1) lookup of location-specific per-diem limits"
      },
      {
        "structure": "Dict[str, Trip]",
        "purpose": "O(1) lookup of trips by ID"
      },
      {
        "structure": "List[Expense] per Trip",
        "purpose": "Store expenses associated with each trip"
      }
    ],
    "algorithm_steps": [
      "Step 1: set_location_per_diem - Store LocationPerDiem(hotel_limit, meal_limit) in dict",
      "Step 2: create_trip - Create Trip with unique ID, store in _trips dict",
      "Step 3: add_expense_to_trip - Create Expense (amount=TOTAL), append to trip.expenses",
      "Step 4: calculate_trip_reimbursement - Look up location limits, iterate expenses, apply per-unit logic with caps"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from decimal import Decimal, ROUND_HALF_UP",
    "from typing import Dict, List, Any, Optional, Union",
    "from enum import Enum",
    "from dataclasses import dataclass, field",
    "",
    "",
    "class ExpenseType(Enum):",
    "    FLIGHT = \"FLIGHT\"",
    "    HOTEL = \"HOTEL\"",
    "    MEAL = \"MEAL\"",
    "    TRANSPORT = \"TRANSPORT\"",
    "",
    "",
    "@dataclass",
    "class Expense:",
    "    \"\"\"Expense record with multi-currency support.\"\"\"",
    "    id: str",
    "    expense_type: ExpenseType",
    "    amount: Decimal",
    "    date: str",
    "    details: Dict[str, Any]",
    "    original_currency: str = \"USD\"",
    "    original_amount: Optional[Decimal] = None",
    "",
    "",
    "@dataclass",
    "class LocationPerDiem:",
    "    \"\"\"Per-diem limits for a location.\"\"\"",
    "    hotel_limit: Decimal",
    "    meal_limit: Decimal",
    "",
    "",
    "@dataclass",
    "class Trip:",
    "    \"\"\"Trip with location, dates, and expenses.\"\"\"",
    "    id: str",
    "    employee_id: str",
    "    location: str",
    "    start_date: str",
    "    end_date: str",
    "    expenses: List[Expense] = field(default_factory=list)",
    "",
    "",
    "class ReimbursementStrategy(ABC):",
    "    @abstractmethod",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        pass",
    "",
    "",
    "class FlightReimbursementStrategy(ReimbursementStrategy):",
    "    LIMIT = Decimal('1000')",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return min(expense.amount, self.LIMIT)",
    "",
    "",
    "class HotelReimbursementStrategy(ReimbursementStrategy):",
    "    NIGHTLY_CAP = Decimal('200')",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        nights = Decimal(str(expense.details.get('nights', 1)))",
    "        capped_rate = min(expense.amount, self.NIGHTLY_CAP)",
    "        return capped_rate * nights",
    "",
    "",
    "class MealReimbursementStrategy(ReimbursementStrategy):",
    "    DAILY_CAP = Decimal('50')",
    "    REIMBURSEMENT_RATE = Decimal('0.5')",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        days = Decimal(str(expense.details.get('days', 1)))",
    "        per_day = min(expense.amount * self.REIMBURSEMENT_RATE, self.DAILY_CAP)",
    "        return per_day * days",
    "",
    "",
    "class TransportReimbursementStrategy(ReimbursementStrategy):",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return expense.amount",
    "",
    "",
    "class ExpenseFactory:",
    "    \"\"\"Factory with currency conversion support.\"\"\"",
    "    _counter = 0",
    "",
    "    @classmethod",
    "    def create(cls, expense_type: str, amount: float, date: str,",
    "               details: Dict[str, Any], currency: str = \"USD\",",
    "               usd_amount: Optional[Decimal] = None) -> Expense:",
    "        cls._counter += 1",
    "        original = Decimal(str(amount))",
    "        converted = usd_amount if usd_amount is not None else original",
    "        return Expense(",
    "            id=f\"exp_{cls._counter}\",",
    "            expense_type=ExpenseType(expense_type),",
    "            amount=converted,",
    "            date=date,",
    "            details=details or {},",
    "            original_currency=currency,",
    "            original_amount=original",
    "        )",
    "",
    "",
    "class ExpenseManager:",
    "    \"\"\"Expense manager with multi-currency and trip support.\"\"\"",
    "",
    "    # Default per-diem limits (used when location not configured)",
    "    DEFAULT_HOTEL_CAP = Decimal('200')",
    "    DEFAULT_MEAL_CAP = Decimal('50')",
    "    MEAL_RATE = Decimal('0.5')",
    "",
    "    def __init__(self) -> None:",
    "        self._employee_expenses: Dict[str, List[Expense]] = {}",
    "        self._strategies: Dict[ExpenseType, ReimbursementStrategy] = {",
    "            ExpenseType.FLIGHT: FlightReimbursementStrategy(),",
    "            ExpenseType.HOTEL: HotelReimbursementStrategy(),",
    "            ExpenseType.MEAL: MealReimbursementStrategy(),",
    "            ExpenseType.TRANSPORT: TransportReimbursementStrategy(),",
    "        }",
    "        self._exchange_rates: Dict[str, Decimal] = {}",
    "        # Part 3: Location per-diems and trips",
    "        self._location_per_diems: Dict[str, LocationPerDiem] = {}",
    "        self._trips: Dict[str, Trip] = {}",
    "        self._trip_counter = 0",
    "",
    "    # ============ Part 2 Methods (unchanged) ============",
    "",
    "    def set_exchange_rate(self, currency: str, rate_to_usd: float) -> None:",
    "        self._exchange_rates[currency] = Decimal(str(rate_to_usd))",
    "",
    "    def _get_rate(self, currency: str) -> Decimal:",
    "        if currency == \"USD\":",
    "            return Decimal(\"1.0\")",
    "        if currency not in self._exchange_rates:",
    "            raise ValueError(f\"Unknown currency: {currency}\")",
    "        return self._exchange_rates[currency]",
    "",
    "    def add_expense(self, employee_id: str, expense_type: str, amount: float,",
    "                    arg4: str, arg5: Union[str, dict] = None,",
    "                    arg6: dict = None) -> str:",
    "        if arg6 is not None or (arg5 is not None and isinstance(arg5, str)):",
    "            currency, date = arg4, arg5",
    "            details = arg6 or {}",
    "        else:",
    "            currency, date = \"USD\", arg4",
    "            details = arg5 if isinstance(arg5, dict) else {}",
    "        rate = self._get_rate(currency)",
    "        usd_amount = Decimal(str(amount)) * rate",
    "        expense = ExpenseFactory.create(",
    "            expense_type, amount, date, details,",
    "            currency=currency, usd_amount=usd_amount",
    "        )",
    "        if employee_id not in self._employee_expenses:",
    "            self._employee_expenses[employee_id] = []",
    "        self._employee_expenses[employee_id].append(expense)",
    "        return expense.id",
    "",
    "    def calculate_reimbursement(self, employee_id: str) -> float:",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        total = Decimal('0')",
    "        for expense in expenses:",
    "            strategy = self._strategies[expense.expense_type]",
    "            total += strategy.calculate(expense)",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "",
    "    def get_expenses_by_type(self, employee_id: str, expense_type: str) -> List[Expense]:",
    "        target_type = ExpenseType(expense_type)",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        return [e for e in expenses if e.expense_type == target_type]",
    "",
    "    def get_total_expenses(self, employee_id: str) -> float:",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        total = Decimal('0')",
    "        for expense in expenses:",
    "            if expense.expense_type == ExpenseType.HOTEL:",
    "                nights = Decimal(str(expense.details.get('nights', 1)))",
    "                total += expense.amount * nights",
    "            elif expense.expense_type == ExpenseType.MEAL:",
    "                days = Decimal(str(expense.details.get('days', 1)))",
    "                total += expense.amount * days",
    "            else:",
    "                total += expense.amount",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "",
    "    # ============ Part 3: Location-Based Per-Diem ============",
    "",
    "    def set_location_per_diem(self, location: str, hotel_limit: float, meal_limit: float) -> None:",
    "        \"\"\"Set per-diem limits for a location.\"\"\"",
    "        self._location_per_diems[location] = LocationPerDiem(",
    "            hotel_limit=Decimal(str(hotel_limit)),",
    "            meal_limit=Decimal(str(meal_limit))",
    "        )",
    "",
    "    def create_trip(self, employee_id: str, location: str, start_date: str, end_date: str) -> str:",
    "        \"\"\"Create a trip and return its unique ID.\"\"\"",
    "        self._trip_counter += 1",
    "        trip_id = f\"trip_{self._trip_counter}\"",
    "        self._trips[trip_id] = Trip(",
    "            id=trip_id,",
    "            employee_id=employee_id,",
    "            location=location,",
    "            start_date=start_date,",
    "            end_date=end_date",
    "        )",
    "        return trip_id",
    "",
    "    def add_expense_to_trip(self, trip_id: str, expense_type: str, amount: float, details: dict) -> None:",
    "        \"\"\"Add expense to trip. Note: amount is TOTAL, not per-unit.\"\"\"",
    "        trip = self._trips[trip_id]",
    "        expense = Expense(",
    "            id=f\"{trip_id}_exp_{len(trip.expenses) + 1}\",",
    "            expense_type=ExpenseType(expense_type),",
    "            amount=Decimal(str(amount)),",
    "            date=trip.start_date,",
    "            details=details or {}",
    "        )",
    "        trip.expenses.append(expense)",
    "",
    "    def calculate_trip_reimbursement(self, trip_id: str) -> float:",
    "        \"\"\"Calculate total reimbursement using location-specific per-diems.",
    "        ",
    "        Key difference from regular expenses: trip expense.amount is TOTAL,",
    "        so we divide by nights/days to get per-unit before applying caps.",
    "        \"\"\"",
    "        trip = self._trips[trip_id]",
    "        per_diem = self._location_per_diems.get(trip.location)",
    "",
    "        # Get location limits or use defaults",
    "        hotel_cap = per_diem.hotel_limit if per_diem else self.DEFAULT_HOTEL_CAP",
    "        meal_cap = per_diem.meal_limit if per_diem else self.DEFAULT_MEAL_CAP",
    "",
    "        total = Decimal('0')",
    "        for expense in trip.expenses:",
    "            if expense.expense_type == ExpenseType.HOTEL:",
    "                # amount is TOTAL, calculate per-night, apply cap, multiply back",
    "                nights = Decimal(str(expense.details.get('nights', 1)))",
    "                per_night = expense.amount / nights if nights else expense.amount",
    "                capped = min(per_night, hotel_cap)",
    "                total += capped * nights",
    "",
    "            elif expense.expense_type == ExpenseType.MEAL:",
    "                # amount is TOTAL, calculate per-day, apply 50% then cap",
    "                days = Decimal(str(expense.details.get('days', 1)))",
    "                per_day = expense.amount / days if days else expense.amount",
    "                half_rate = per_day * self.MEAL_RATE",
    "                capped = min(half_rate, meal_cap)",
    "                total += capped * days",
    "",
    "            else:",
    "                # FLIGHT, TRANSPORT: use standard strategies (amount=total works)",
    "                strategy = self._strategies[expense.expense_type]",
    "                total += strategy.calculate(expense)",
    "",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"PART 3: Location-Based Per-Diem Demo\")",
    "    print(\"=\" * 60)",
    "",
    "    manager = ExpenseManager()",
    "",
    "    # Test 1: NYC example from problem",
    "    print(\"\\n--- NYC Trip Example ---\")",
    "    manager.set_location_per_diem(\"NYC\", 350, 80)",
    "    trip_id = manager.create_trip(\"emp001\", \"NYC\", \"2024-03-15\", \"2024-03-18\")",
    "    print(f\"Created trip: {trip_id}\")",
    "    manager.add_expense_to_trip(trip_id, \"HOTEL\", 1200, {\"nights\": 3})",
    "    manager.add_expense_to_trip(trip_id, \"MEAL\", 400, {\"days\": 4})",
    "    result = manager.calculate_trip_reimbursement(trip_id)",
    "    print(f\"Hotel: $1200/3nights=$400/n, cap $350 -> $350\u00d73=$1050\")",
    "    print(f\"Meal: $400/4days=$100/d, 50%=$50, cap $80 -> $50\u00d74=$200\")",
    "    print(f\"Result: ${result} (expected: $1250)\")",
    "",
    "    # Test 2: Default limits (no location configured)",
    "    print(\"\\n--- Trip with Default Limits ---\")",
    "    manager._trip_counter = 0  # Reset for clean output",
    "    trip2 = manager.create_trip(\"emp002\", \"Unknown City\", \"2024-04-01\", \"2024-04-03\")",
    "    manager.add_expense_to_trip(trip2, \"HOTEL\", 750, {\"nights\": 3})  # $250/n",
    "    result2 = manager.calculate_trip_reimbursement(trip2)",
    "    print(f\"$750/3nights=$250/n, default cap $200 -> $200\u00d73=$600\")",
    "    print(f\"Result: ${result2} (expected: $600)\")",
    "",
    "    # Test 3: Trip with flight",
    "    print(\"\\n--- Trip with Flight ---\")",
    "    manager.set_location_per_diem(\"SF\", 300, 75)",
    "    manager._trip_counter = 0",
    "    trip3 = manager.create_trip(\"emp003\", \"SF\", \"2024-05-01\", \"2024-05-03\")",
    "    manager.add_expense_to_trip(trip3, \"FLIGHT\", 850, {})",
    "    manager.add_expense_to_trip(trip3, \"HOTEL\", 600, {\"nights\": 2})  # $300/n",
    "    result3 = manager.calculate_trip_reimbursement(trip3)",
    "    print(f\"Flight $850: capped at $1000 -> $850\")",
    "    print(f\"Hotel $600/2n=$300/n, SF cap $300 -> $300\u00d72=$600\")",
    "    print(f\"Result: ${result3} (expected: $1450)\")",
    "",
    "    # Test 4: Verify Part 2 still works",
    "    print(\"\\n--- Part 2 Backward Compatibility ---\")",
    "    manager.set_exchange_rate(\"EUR\", 1.10)",
    "    manager.add_expense(\"emp004\", \"HOTEL\", 180, \"EUR\", \"2024-03-15\", {\"nights\": 2})",
    "    reimb = manager.calculate_reimbursement(\"emp004\")",
    "    print(f\"\u20ac180\u00d71.10=$198/n, cap $200 -> $198\u00d72=${reimb}\")",
    "",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed!\")"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "enum ExpenseType {",
    "    FLIGHT, HOTEL, MEAL, TRANSPORT",
    "}",
    "",
    "class Expense {",
    "    private final String id;",
    "    private final ExpenseType type;",
    "    private final BigDecimal amount;",
    "    private final String date;",
    "    private final Map<String, Object> details;",
    "    private final String originalCurrency;",
    "    private final BigDecimal originalAmount;",
    "",
    "    public Expense(String id, ExpenseType type, BigDecimal amount, String date,",
    "                   Map<String, Object> details, String currency, BigDecimal original) {",
    "        this.id = id;",
    "        this.type = type;",
    "        this.amount = amount;",
    "        this.date = date;",
    "        this.details = details != null ? details : new HashMap<>();",
    "        this.originalCurrency = currency;",
    "        this.originalAmount = original;",
    "    }",
    "",
    "    public String getId() { return id; }",
    "    public ExpenseType getType() { return type; }",
    "    public BigDecimal getAmount() { return amount; }",
    "    public Map<String, Object> getDetails() { return details; }",
    "}",
    "",
    "// Part 3: Location per-diem configuration",
    "class LocationPerDiem {",
    "    private final BigDecimal hotelLimit;",
    "    private final BigDecimal mealLimit;",
    "",
    "    public LocationPerDiem(BigDecimal hotelLimit, BigDecimal mealLimit) {",
    "        this.hotelLimit = hotelLimit;",
    "        this.mealLimit = mealLimit;",
    "    }",
    "",
    "    public BigDecimal getHotelLimit() { return hotelLimit; }",
    "    public BigDecimal getMealLimit() { return mealLimit; }",
    "}",
    "",
    "// Part 3: Trip entity",
    "class Trip {",
    "    private final String id;",
    "    private final String employeeId;",
    "    private final String location;",
    "    private final String startDate;",
    "    private final String endDate;",
    "    private final List<Expense> expenses = new ArrayList<>();",
    "",
    "    public Trip(String id, String employeeId, String location, String startDate, String endDate) {",
    "        this.id = id;",
    "        this.employeeId = employeeId;",
    "        this.location = location;",
    "        this.startDate = startDate;",
    "        this.endDate = endDate;",
    "    }",
    "",
    "    public String getId() { return id; }",
    "    public String getLocation() { return location; }",
    "    public String getStartDate() { return startDate; }",
    "    public List<Expense> getExpenses() { return expenses; }",
    "    public void addExpense(Expense e) { expenses.add(e); }",
    "}",
    "",
    "interface ReimbursementStrategy {",
    "    BigDecimal calculate(Expense expense);",
    "}",
    "",
    "class FlightReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal LIMIT = new BigDecimal(\"1000\");",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount().min(LIMIT);",
    "    }",
    "}",
    "",
    "class HotelReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal NIGHTLY_CAP = new BigDecimal(\"200\");",
    "    public BigDecimal calculate(Expense expense) {",
    "        int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "        BigDecimal capped = expense.getAmount().min(NIGHTLY_CAP);",
    "        return capped.multiply(BigDecimal.valueOf(nights));",
    "    }",
    "}",
    "",
    "class MealReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal DAILY_CAP = new BigDecimal(\"50\");",
    "    private static final BigDecimal RATE = new BigDecimal(\"0.5\");",
    "    public BigDecimal calculate(Expense expense) {",
    "        int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "        BigDecimal perDay = expense.getAmount().multiply(RATE).min(DAILY_CAP);",
    "        return perDay.multiply(BigDecimal.valueOf(days));",
    "    }",
    "}",
    "",
    "class TransportReimbursementStrategy implements ReimbursementStrategy {",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount();",
    "    }",
    "}",
    "",
    "class ExpenseFactory {",
    "    private static int counter = 0;",
    "    public static Expense create(String type, double amount, String date,",
    "                                  Map<String, Object> details, String currency,",
    "                                  BigDecimal usdAmount) {",
    "        counter++;",
    "        BigDecimal original = BigDecimal.valueOf(amount);",
    "        BigDecimal converted = usdAmount != null ? usdAmount : original;",
    "        return new Expense(\"exp_\" + counter, ExpenseType.valueOf(type),",
    "                          converted, date, details, currency, original);",
    "    }",
    "    public static void resetCounter() { counter = 0; }",
    "}",
    "",
    "public class ExpenseManager {",
    "    private static final BigDecimal DEFAULT_HOTEL_CAP = new BigDecimal(\"200\");",
    "    private static final BigDecimal DEFAULT_MEAL_CAP = new BigDecimal(\"50\");",
    "    private static final BigDecimal MEAL_RATE = new BigDecimal(\"0.5\");",
    "",
    "    private Map<String, List<Expense>> employeeExpenses = new HashMap<>();",
    "    private Map<ExpenseType, ReimbursementStrategy> strategies = new HashMap<>();",
    "    private Map<String, BigDecimal> exchangeRates = new HashMap<>();",
    "    // Part 3 additions",
    "    private Map<String, LocationPerDiem> locationPerDiems = new HashMap<>();",
    "    private Map<String, Trip> trips = new HashMap<>();",
    "    private int tripCounter = 0;",
    "",
    "    public ExpenseManager() {",
    "        strategies.put(ExpenseType.FLIGHT, new FlightReimbursementStrategy());",
    "        strategies.put(ExpenseType.HOTEL, new HotelReimbursementStrategy());",
    "        strategies.put(ExpenseType.MEAL, new MealReimbursementStrategy());",
    "        strategies.put(ExpenseType.TRANSPORT, new TransportReimbursementStrategy());",
    "    }",
    "",
    "    // Part 2 methods (unchanged)",
    "    public void setExchangeRate(String currency, double rateToUSD) {",
    "        exchangeRates.put(currency, BigDecimal.valueOf(rateToUSD));",
    "    }",
    "",
    "    private BigDecimal getRate(String currency) {",
    "        if (\"USD\".equals(currency)) return BigDecimal.ONE;",
    "        BigDecimal rate = exchangeRates.get(currency);",
    "        if (rate == null) throw new IllegalArgumentException(\"Unknown currency: \" + currency);",
    "        return rate;",
    "    }",
    "",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String date, Map<String, Object> details) {",
    "        return addExpense(employeeId, type, amount, \"USD\", date, details);",
    "    }",
    "",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String currency, String date, Map<String, Object> details) {",
    "        BigDecimal rate = getRate(currency);",
    "        BigDecimal usdAmount = BigDecimal.valueOf(amount).multiply(rate);",
    "        Expense expense = ExpenseFactory.create(type, amount, date, details, currency, usdAmount);",
    "        employeeExpenses.computeIfAbsent(employeeId, k -> new ArrayList<>()).add(expense);",
    "        return expense.getId();",
    "    }",
    "",
    "    public double calculateReimbursement(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            total = total.add(strategies.get(expense.getType()).calculate(expense));",
    "        }",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "",
    "    // Part 3: Location-based per-diem methods",
    "",
    "    public void setLocationPerDiem(String location, double hotelLimit, double mealLimit) {",
    "        locationPerDiems.put(location, new LocationPerDiem(",
    "            BigDecimal.valueOf(hotelLimit),",
    "            BigDecimal.valueOf(mealLimit)",
    "        ));",
    "    }",
    "",
    "    public String createTrip(String employeeId, String location, String startDate, String endDate) {",
    "        tripCounter++;",
    "        String tripId = \"trip_\" + tripCounter;",
    "        trips.put(tripId, new Trip(tripId, employeeId, location, startDate, endDate));",
    "        return tripId;",
    "    }",
    "",
    "    public void addExpenseToTrip(String tripId, String type, double amount, Map<String, Object> details) {",
    "        Trip trip = trips.get(tripId);",
    "        Expense expense = new Expense(",
    "            tripId + \"_exp_\" + (trip.getExpenses().size() + 1),",
    "            ExpenseType.valueOf(type),",
    "            BigDecimal.valueOf(amount),",
    "            trip.getStartDate(),",
    "            details != null ? details : new HashMap<>(),",
    "            \"USD\",",
    "            BigDecimal.valueOf(amount)",
    "        );",
    "        trip.addExpense(expense);",
    "    }",
    "",
    "    public double calculateTripReimbursement(String tripId) {",
    "        Trip trip = trips.get(tripId);",
    "        LocationPerDiem perDiem = locationPerDiems.get(trip.getLocation());",
    "",
    "        BigDecimal hotelCap = perDiem != null ? perDiem.getHotelLimit() : DEFAULT_HOTEL_CAP;",
    "        BigDecimal mealCap = perDiem != null ? perDiem.getMealLimit() : DEFAULT_MEAL_CAP;",
    "",
    "        BigDecimal total = BigDecimal.ZERO;",
    "",
    "        for (Expense expense : trip.getExpenses()) {",
    "            if (expense.getType() == ExpenseType.HOTEL) {",
    "                int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "                BigDecimal perNight = expense.getAmount().divide(",
    "                    BigDecimal.valueOf(nights), 10, RoundingMode.HALF_UP);",
    "                BigDecimal capped = perNight.min(hotelCap);",
    "                total = total.add(capped.multiply(BigDecimal.valueOf(nights)));",
    "",
    "            } else if (expense.getType() == ExpenseType.MEAL) {",
    "                int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "                BigDecimal perDay = expense.getAmount().divide(",
    "                    BigDecimal.valueOf(days), 10, RoundingMode.HALF_UP);",
    "                BigDecimal halfRate = perDay.multiply(MEAL_RATE);",
    "                BigDecimal capped = halfRate.min(mealCap);",
    "                total = total.add(capped.multiply(BigDecimal.valueOf(days)));",
    "",
    "            } else {",
    "                total = total.add(strategies.get(expense.getType()).calculate(expense));",
    "            }",
    "        }",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"PART 3: Location-Based Per-Diem Demo (Java)\");",
    "        System.out.println(\"=\".repeat(60));",
    "",
    "        ExpenseManager manager = new ExpenseManager();",
    "",
    "        // Test 1: NYC example",
    "        System.out.println(\"\\n--- NYC Trip Example ---\");",
    "        manager.setLocationPerDiem(\"NYC\", 350, 80);",
    "        String tripId = manager.createTrip(\"emp001\", \"NYC\", \"2024-03-15\", \"2024-03-18\");",
    "        System.out.println(\"Created trip: \" + tripId);",
    "        manager.addExpenseToTrip(tripId, \"HOTEL\", 1200, Map.of(\"nights\", 3));",
    "        manager.addExpenseToTrip(tripId, \"MEAL\", 400, Map.of(\"days\", 4));",
    "        double result = manager.calculateTripReimbursement(tripId);",
    "        System.out.printf(\"Result: $%.2f (expected: $1250)%n\", result);",
    "",
    "        // Test 2: Verify backward compatibility",
    "        System.out.println(\"\\n--- Part 2 Backward Compatibility ---\");",
    "        manager.setExchangeRate(\"EUR\", 1.10);",
    "        manager.addExpense(\"emp002\", \"HOTEL\", 180, \"EUR\", \"2024-03-15\", Map.of(\"nights\", 2));",
    "        System.out.printf(\"EUR Hotel: $%.2f%n\", manager.calculateReimbursement(\"emp002\"));",
    "",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Standard imports including dataclasses for Part 3's new data structures"
    },
    {
      "lines": "24-33",
      "explanation": "NEW: LocationPerDiem dataclass stores hotel_limit and meal_limit for a location"
    },
    {
      "lines": "36-44",
      "explanation": "NEW: Trip dataclass holds employee, location, dates, and a list of associated expenses"
    },
    {
      "lines": "92-99",
      "explanation": "ExpenseManager init now includes _location_per_diems dict and _trips dict"
    },
    {
      "lines": "146-152",
      "explanation": "set_location_per_diem: stores LocationPerDiem with Decimal-converted limits"
    },
    {
      "lines": "154-165",
      "explanation": "create_trip: increments counter, creates Trip object, returns trip_X ID"
    },
    {
      "lines": "167-177",
      "explanation": "add_expense_to_trip: creates Expense with TOTAL amount (not per-unit), appends to trip"
    },
    {
      "lines": "179-211",
      "explanation": "calculate_trip_reimbursement: the core logic - divides total by units, applies location cap, multiplies back"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "set_location_per_diem": {
          "complexity": "O(1)",
          "explanation": "Simple dict insertion"
        },
        "create_trip": {
          "complexity": "O(1)",
          "explanation": "Dict insertion with ID generation"
        },
        "add_expense_to_trip": {
          "complexity": "O(1)",
          "explanation": "List append operation"
        },
        "calculate_trip_reimbursement": {
          "complexity": "O(E)",
          "explanation": "Linear in number of trip expenses"
        }
      },
      "overall_change": "All new operations are O(1) except calculate_trip_reimbursement which is O(E). Overall system complexity unchanged."
    },
    "space": {
      "additional_space": "O(L + T + E)",
      "explanation": "L = locations stored, T = trips stored, E = expenses per trip. In practice, minimal overhead - LocationPerDiem is ~64 bytes, Trip is ~100 bytes plus expenses."
    }
  },
  "dry_run": {
    "example_input": "NYC trip with $1200 hotel (3 nights) and $400 meals (4 days)",
    "steps": [
      {
        "step": 1,
        "action": "setLocationPerDiem('NYC', 350, 80)",
        "state": "_location_per_diems={'NYC': LocationPerDiem(350, 80)}",
        "explanation": "Store NYC limits"
      },
      {
        "step": 2,
        "action": "createTrip('emp001', 'NYC', '2024-03-15', '2024-03-18')",
        "state": "_trips={'trip_1': Trip(...)}",
        "explanation": "Create trip, return 'trip_1'"
      },
      {
        "step": 3,
        "action": "addExpenseToTrip('trip_1', 'HOTEL', 1200, {nights: 3})",
        "state": "trip.expenses has 1 expense",
        "explanation": "Add hotel expense (TOTAL=1200)"
      },
      {
        "step": 4,
        "action": "addExpenseToTrip('trip_1', 'MEAL', 400, {days: 4})",
        "state": "trip.expenses has 2 expenses",
        "explanation": "Add meal expense (TOTAL=400)"
      },
      {
        "step": 5,
        "action": "calculateTripReimbursement('trip_1')",
        "state": "Processing HOTEL",
        "explanation": "per_night=1200/3=400, capped=min(400,350)=350, contrib=350\u00d73=1050"
      },
      {
        "step": 6,
        "action": "Continue calculation",
        "state": "Processing MEAL",
        "explanation": "per_day=400/4=100, half=50, capped=min(50,80)=50, contrib=50\u00d74=200"
      },
      {
        "step": 7,
        "action": "Return total",
        "state": "total=1250",
        "explanation": "1050 + 200 = 1250"
      }
    ],
    "final_output": "1250.00"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single hotel expense with no cap exceeded",
      "Location not configured - should use defaults"
    ],
    "likely_bugs": [
      "Using expense.amount as per-unit instead of total",
      "Forgetting 50% rule for meals",
      "Wrong order: cap before vs after 50%"
    ],
    "recommended_logs_or_asserts": [
      "assert per_night == expense.amount / nights",
      "log per-unit and capped values",
      "assert total >= 0"
    ],
    "how_to_localize": "Print per_unit, capped, and contribution for each expense. Compare with manual calculation."
  },
  "edge_cases": [
    {
      "case": "Location not configured",
      "handling": "Use default limits ($200 hotel, $50 meals)",
      "gotcha": "Don't throw error, just use defaults"
    },
    {
      "case": "Zero nights/days in details",
      "handling": "Treat as 1 to avoid division by zero",
      "gotcha": "Could also throw error, clarify with interviewer"
    },
    {
      "case": "Trip with only FLIGHT expense",
      "handling": "Use standard FlightStrategy (100% up to $1000)",
      "gotcha": "Flight doesn't use location per-diem"
    },
    {
      "case": "Meal under 50% cap",
      "handling": "$80/day \u00d7 50% = $40 < $75 SF cap \u2192 reimburse $40",
      "gotcha": "Cap applies to the 50% amount, not original"
    }
  ],
  "test_cases": [
    {
      "name": "NYC Example (from problem)",
      "input": "NYC trip: $1200 hotel (3 nights), $400 meals (4 days)",
      "expected": "1250.00",
      "explanation": "Hotel: 350\u00d73=1050, Meal: 50\u00d74=200"
    },
    {
      "name": "Default limits",
      "input": "Unknown city: $750 hotel (3 nights)",
      "expected": "600.00",
      "explanation": "$250/n capped at default $200/n \u2192 200\u00d73=600"
    },
    {
      "name": "Mixed expense types",
      "input": "SF trip: $850 flight, $600 hotel (2 nights)",
      "expected": "1450.00",
      "explanation": "Flight: min(850,1000)=850, Hotel: 300\u00d72=600"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Treating trip expense.amount as per-unit",
      "why_wrong": "Trip semantics: amount is TOTAL ($1200 for 3 nights, not $1200/night)",
      "correct_approach": "Divide by nights/days to get per-unit before applying cap",
      "code_example_wrong": "capped = min(expense.amount, hotel_cap)  # Wrong: 1200 vs 350",
      "code_example_correct": "per_night = expense.amount / nights  # 400\ncapped = min(per_night, hotel_cap)  # 350"
    },
    {
      "mistake": "Applying meal cap before 50% rule",
      "why_wrong": "Cap should apply to the reimbursable amount (after 50%), not original",
      "correct_approach": "Calculate 50% first, then cap",
      "code_example_wrong": "capped = min(per_day, meal_cap)  # 100 vs 80 = 80\nreimb = capped * 0.5  # 40 (wrong)",
      "code_example_correct": "half = per_day * 0.5  # 50\ncapped = min(half, meal_cap)  # 50 (correct)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by noting the key semantic difference: trip expenses use TOTAL amounts. Draw the formula: total \u2192 per-unit \u2192 cap \u2192 multiply back. Then implement.",
    "what_to_mention": [
      "Trip vs regular expense amount semantics",
      "Default fallback for unknown locations",
      "50% rule order for meals",
      "FLIGHT/TRANSPORT don't use location limits"
    ],
    "time_allocation": "2 min understand, 2 min design Trip/LocationPerDiem, 6 min implement, 2 min test",
    "if_stuck": [
      "Draw out the calculation manually first",
      "Focus on one expense type (HOTEL) before generalizing"
    ]
  },
  "connection_to_next_part": "Part 4 could add: approval workflows for trips over threshold, multi-leg trips with different locations, prorated partial days, or budget tracking per department.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 handles multi-currency. For Part 3, I need to add location-based per-diems. The key insight is that trip expenses have different semantics - amount is TOTAL, not per-unit.",
    "explaining_changes": "I'll add LocationPerDiem and Trip classes. The main logic change is in calculate_trip_reimbursement where I divide total by units, apply the location-specific cap, then multiply back.",
    "while_extending_code": [
      "Adding LocationPerDiem dataclass to store limits...",
      "Trip holds expenses separately from employee_expenses...",
      "For hotel: per_night = total/nights, cap it, multiply back..."
    ],
    "after_completing": "Part 3 now handles location-based limits. All new operations are O(1) except trip calculation which is O(E). Part 2 backward compatibility is maintained."
  },
  "time_milestones": {
    "time_budget": "10-15 minutes for this part",
    "by_2_min": "Understand trip expense semantics (TOTAL vs per-unit), identify new data structures",
    "by_5_min": "Have LocationPerDiem and Trip defined, start on create_trip",
    "by_10_min": "All methods implemented, starting to test",
    "warning_signs": "If confused about amount semantics at 3 min, re-read example carefully"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Trip system is independent - Part 2 bugs shouldn't affect it. If they do, fix Part 2 first.",
    "if_new_requirement_unclear": "Ask: 'For trip expenses, is amount the total ($1200 for 3 nights) or per-unit ($400/night)?'",
    "if_running_behind": "Focus on HOTEL calculation first, mention MEAL follows same pattern, skip edge cases but mention them"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing TOTAL vs per-unit semantic difference",
      "Explaining why 50% applies before cap for meals",
      "Noting that FLIGHT/TRANSPORT don't need location awareness",
      "Mentioning default fallback without being asked"
    ]
  },
  "pattern_recognition": {
    "pattern": "Entity-based aggregation with configuration lookup",
    "indicators": [
      "Multiple items grouped under an entity (Trip)",
      "Config determines calculation parameters (LocationPerDiem)",
      "Different types processed differently"
    ],
    "similar_problems": [
      "Order with line items and tax by region",
      "Project with tasks and rates by skill level",
      "Invoice with items and discounts by customer tier"
    ],
    "template": "1. Create entity to group items\n2. Create config to store parameters\n3. Process each item using entity's config\n4. Aggregate results"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'location-based limits', I immediately think config lookup pattern",
      "why": "Different locations = different parameters = need a lookup table"
    },
    {
      "step": 2,
      "thought": "The example shows amount=1200 for 3 nights with $400/night calculation",
      "why": "This tells me amount is TOTAL, must derive per-unit"
    },
    {
      "step": 3,
      "thought": "Trips need their own expense list",
      "why": "Separate from employee_expenses because semantics differ"
    },
    {
      "step": 4,
      "thought": "Default limits needed for unknown locations",
      "why": "System must be robust to unconfigured locations"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you recognize semantic differences between systems?",
      "Do you handle configuration lookup with defaults?",
      "Can you extend without breaking existing code?"
    ],
    "bonus_points": [
      "Noting the TOTAL vs per-unit difference immediately",
      "Asking about edge cases (unknown location)",
      "Clean separation of trip vs employee expense systems"
    ],
    "red_flags": [
      "Modifying existing strategies unnecessarily",
      "Missing the amount semantic difference",
      "No default handling for unknown locations"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI generate boilerplate dataclasses",
      "Use for syntax of dict operations"
    ],
    "what_not_to_do": [
      "Don't let AI assume expense.amount is per-unit",
      "Verify the 50% before cap logic"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without understanding the TOTAL amount semantics",
      "Not testing with the provided example"
    ],
    "technical": [
      "Using expense.amount directly as per-night rate",
      "Forgetting meal 50% rule in trip context"
    ],
    "communication": [
      "Not explaining why trips are separate from employee expenses",
      "Not mentioning backward compatibility"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does NYC example return 1250?",
      "Does unknown location use defaults?",
      "Is Part 2 (currency) still working?",
      "Is meal 50% applied before cap?"
    ],
    "quick_code_review": [
      "LocationPerDiem and Trip classes defined",
      "_location_per_diems and _trips initialized in __init__",
      "Division by nights/days in calculate_trip_reimbursement"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Validate trip dates (start <= end)",
      "Check trip exists before adding expense",
      "Logging for audit trail",
      "Support for multi-currency trip expenses"
    ],
    "why_not_in_interview": "Focus on core algorithm; mention these verbally",
    "how_to_mention": "Say: 'In production, I'd validate dates and add logging for the audit trail.'"
  },
  "generated_at": "2026-01-19T05:11:48.351488",
  "_meta": {
    "problem_id": "travel_expense_calculation",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}