{
  "problem_title": "Stack Overflow API Design - Part 2: Voting and Reputation System",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 provides CRUD for users, questions, and answers. Part 2 adds a voting system where users can upvote/downvote content, affecting both the content's score and the author's reputation. Key additions: (1) Vote tracking per user per item, (2) Reputation incremental updates, (3) Vote change handling (switching from upvote to downvote), (4) Self-voting prevention.",
    "new_requirements": [
      "Track votes per user per item (question or answer)",
      "Update scores when votes are cast or changed",
      "Update author reputation based on vote changes",
      "Support vote toggling (upvote\u2192downvote)",
      "Prevent users from voting on their own content",
      "Allow question authors to accept answers for +15 rep"
    ],
    "new_constraints": [
      "One vote per user per item (but can change)",
      "Cannot vote on own content",
      "Only question author can accept answers",
      "All vote operations must be O(1)"
    ],
    "key_insight": "Use a nested HashMap (item_id \u2192 voter_id \u2192 vote_value) to track votes. Store votes as +1 (upvote) or -1 (downvote). When a vote changes, calculate the DELTA to update both score and reputation incrementally\u2014don't recalculate from scratch."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Upvote/downvote questions",
        "how_met": "upvote_question/downvote_question methods with vote tracking",
        "gotchas": [
          "Must handle vote changes, not just new votes"
        ]
      },
      {
        "requirement": "Upvote/downvote answers",
        "how_met": "upvote_answer/downvote_answer methods reusing vote logic",
        "gotchas": [
          "Same gotchas as questions"
        ]
      },
      {
        "requirement": "Reputation tracking",
        "how_met": "Incremental updates to user.reputation on vote/accept",
        "gotchas": [
          "Don't forget to reverse reputation when vote changes"
        ]
      },
      {
        "requirement": "Self-vote prevention",
        "how_met": "Check voter_id != author_id before processing",
        "gotchas": [
          "Return -1, not 0, for invalid operations"
        ]
      },
      {
        "requirement": "Accept answer",
        "how_met": "accept_answer validates question ownership",
        "gotchas": [
          "Make idempotent\u2014don't award rep twice"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "upvote_question",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookups only"
      },
      {
        "operation": "downvote_question",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookups only"
      },
      {
        "operation": "accept_answer",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct lookup by answer_id"
      },
      {
        "operation": "get_user_reputation",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "User object stores reputation"
      }
    ],
    "non_goals": [
      "Removing votes entirely",
      "Vote history/audit trail",
      "Reputation caps",
      "Decay or time-based reputation"
    ]
  },
  "assumptions": [
    "Reputation can go negative (no floor at 0)",
    "A user can accept only one answer per question (not enforced here\u2014could ask interviewer)",
    "Accepting an already-accepted answer is idempotent (no additional rep)",
    "Vote values are only +1 or -1 (no weighted votes)",
    "Invalid operations return -1 for score, False for accept"
  ],
  "tradeoffs": [
    {
      "decision": "Nested HashMap vs Vote objects",
      "chosen": "Nested HashMap (item_id \u2192 voter_id \u2192 int)",
      "why": "Simpler, O(1) lookup for existing vote, minimal memory overhead",
      "alternative": "Vote class with voter, item, value",
      "when_to_switch": "If we need vote metadata (timestamp, IP) or audit trail"
    },
    {
      "decision": "Incremental vs recalculated reputation",
      "chosen": "Incremental (update on each vote)",
      "why": "O(1) updates and O(1) retrieval",
      "alternative": "Recalculate by summing all votes",
      "when_to_switch": "If reputation rules change frequently or we need historical snapshots"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1 method signatures",
      "User/Question/Answer class structure",
      "Primary storage HashMaps"
    ],
    "what_to_change": [
      "Added question_votes and answer_votes dictionaries",
      "Added reputation constants"
    ],
    "interfaces_and_boundaries": "Vote logic is centralized in _apply_vote helper, making it easy to add new voteable content types in future parts",
    "invariants": [
      "Sum of votes for an item equals item.score",
      "User reputation equals sum of all reputation-affecting events",
      "vote_value is always 1, -1, or 0 (not voted)",
      "Accepted answer's author has +15 rep (counted once)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1):                    AFTER (Part 2):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User                \u2502             \u2502 User                \u2502\n\u2502 - id                \u2502             \u2502 - id                \u2502\n\u2502 - username          \u2502             \u2502 - username          \u2502\n\u2502 - reputation (=0)   \u2502             \u2502 - reputation (=10)  \u2502 \u25c4\u2500\u2500 Updated by votes\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Question            \u2502             \u2502 Question            \u2502\n\u2502 - score: 0          \u2502             \u2502 - score: 1          \u2502 \u25c4\u2500\u2500 Updated by votes\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                                    NEW DATA STRUCTURE:\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502 question_votes:             \u2502\n                                    \u2502  \"q_1\" \u2192 {\"u2\": 1, \"u3\": -1}\u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n            Vote Flow (upvote_question)\n            \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  Input: voter_id=\"u2\", question_id=\"q_1\"\n         \u2502\n         \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 1. Validate: question exists?    \u2502\u2500\u2500No\u2500\u2500\u25ba return -1\n  \u2502    user exists?                  \u2502\n  \u2502    voter \u2260 author?               \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502 Yes\n               \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 2. Get previous vote             \u2502\n  \u2502    prev = votes[q_1].get(u2, 0)  \u2502\n  \u2502    prev = 0 (never voted)        \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 3. Calculate deltas              \u2502\n  \u2502    new_vote = 1 (upvote)         \u2502\n  \u2502    score_delta = 1 - 0 = +1      \u2502\n  \u2502    rep_delta = +10 (upvote)      \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 4. Apply changes                 \u2502\n  \u2502    question.score += 1  \u2192 1     \u2502\n  \u2502    author.rep += 10     \u2192 10    \u2502\n  \u2502    votes[q_1][u2] = 1           \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n           return 1 (new score)\n```"
  },
  "approaches": [
    {
      "name": "Naive: Recalculate Everything",
      "description": "Store all votes as objects. On each vote operation, iterate through all votes to recalculate score. Recalculate reputation by summing all votes on user's content.",
      "time_complexity": "O(V) per vote operation, O(V*Q) for reputation",
      "space_complexity": "O(V) for vote storage",
      "why_not_optimal": "Doesn't scale\u2014every vote requires O(V) recalculation. We need O(1) operations."
    },
    {
      "name": "Optimal: Incremental Updates with Vote Tracking",
      "description": "Store votes in HashMap (item_id \u2192 voter_id \u2192 vote_value). On vote: (1) look up previous vote O(1), (2) compute delta, (3) update score and reputation incrementally. Reputation stored on User object for O(1) retrieval.",
      "time_complexity": "O(1) for all vote operations",
      "space_complexity": "O(V) for vote tracking where V = total votes",
      "key_insight": "By tracking the previous vote, we can compute exact delta for both score and reputation without recalculating from scratch."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution adds **two new HashMaps** (`question_votes`, `answer_votes`) that map `item_id \u2192 (voter_id \u2192 vote_value)`. This enables O(1) lookup of any previous vote.\n\n**Core Algorithm** (`_apply_vote`):\n1. **Validate** - Check item exists, voter exists, voter \u2260 author\n2. **Get previous vote** - `prev = votes[item].get(voter, 0)` returns 0 if never voted\n3. **Calculate score delta** - `new_vote - prev` gives exact score change\n4. **Update reputation** - Reverse previous rep effect, apply new rep effect\n5. **Record vote** - `votes[item][voter] = new_vote`\n\n**Vote Change Handling**: When changing from upvote (+1) to downvote (-1):\n- Score delta = -1 - 1 = -2 (correct!)\n- Reputation: reverse +10, apply -2 = net -12 for author\n\n**Accept Answer**: Simple validation that caller is question author, then set `is_accepted = True` and award +15 rep (idempotent\u2014only once).",
    "data_structures": [
      {
        "structure": "Dict[str, Dict[str, int]] question_votes",
        "purpose": "Track votes on questions: question_id \u2192 {voter_id \u2192 vote_value}"
      },
      {
        "structure": "Dict[str, Dict[str, int]] answer_votes",
        "purpose": "Track votes on answers: answer_id \u2192 {voter_id \u2192 vote_value}"
      },
      {
        "structure": "User.reputation",
        "purpose": "Store cumulative reputation for O(1) retrieval"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate inputs (item exists, user exists, not self-vote)",
      "Step 2: Look up previous vote (0 if none)",
      "Step 3: If vote unchanged, return current score (no-op)",
      "Step 4: Calculate score_delta = new_vote - prev_vote",
      "Step 5: Update item.score += score_delta",
      "Step 6: Reverse previous reputation effect on author",
      "Step 7: Apply new reputation effect on author",
      "Step 8: Record new vote in tracking HashMap",
      "Step 9: Return new score"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 2: Voting and Reputation System",
    "Extends Part 1 with voting and incremental reputation tracking.",
    "\"\"\"",
    "import time",
    "from typing import List, Optional, Dict",
    "from collections import defaultdict",
    "",
    "",
    "class User:",
    "    def __init__(self, id: str, username: str):",
    "        self.id = id",
    "        self.username = username",
    "        self.reputation = 0",
    "",
    "",
    "class Question:",
    "    def __init__(self, id: str, author_id: str, title: str, body: str, tags: List[str]):",
    "        self.id = id",
    "        self.author_id = author_id",
    "        self.title = title",
    "        self.body = body",
    "        self.tags = tags",
    "        self.score = 0",
    "        self.created_at = time.time()",
    "",
    "",
    "class Answer:",
    "    def __init__(self, id: str, question_id: str, author_id: str, body: str):",
    "        self.id = id",
    "        self.question_id = question_id",
    "        self.author_id = author_id",
    "        self.body = body",
    "        self.score = 0",
    "        self.is_accepted = False",
    "        self.created_at = time.time()",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"Stack Overflow API with voting and reputation system.\"\"\"",
    "    ",
    "    REP_UPVOTE = 10",
    "    REP_DOWNVOTE = -2",
    "    REP_ACCEPTED = 15",
    "    ",
    "    def __init__(self):",
    "        # Primary storage",
    "        self.users: Dict[str, User] = {}",
    "        self.questions: Dict[str, Question] = {}",
    "        self.answers: Dict[str, Answer] = {}",
    "        ",
    "        # Secondary indexes (from Part 1)",
    "        self.user_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self.tag_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self.question_answers: Dict[str, List[str]] = defaultdict(list)",
    "        ",
    "        # Vote tracking: item_id -> {voter_id -> vote_value (1 or -1)}",
    "        self.question_votes: Dict[str, Dict[str, int]] = defaultdict(dict)",
    "        self.answer_votes: Dict[str, Dict[str, int]] = defaultdict(dict)",
    "        ",
    "        self.question_counter = 1",
    "        self.answer_counter = 1",
    "    ",
    "    # ============ Part 1 Methods (unchanged) ============",
    "    ",
    "    def create_user(self, user_id: str, username: str) -> User:",
    "        if user_id in self.users:",
    "            return self.users[user_id]",
    "        user = User(user_id, username)",
    "        self.users[user_id] = user",
    "        return user",
    "    ",
    "    def post_question(self, user_id: str, title: str, body: str, tags: List[str]) -> Optional[Question]:",
    "        if user_id not in self.users:",
    "            return None",
    "        q_id = f\"q_{self.question_counter}\"",
    "        self.question_counter += 1",
    "        question = Question(q_id, user_id, title, body, tags)",
    "        self.questions[q_id] = question",
    "        self.user_questions[user_id].append(q_id)",
    "        for tag in tags:",
    "            self.tag_questions[tag].append(q_id)",
    "        return question",
    "    ",
    "    def post_answer(self, user_id: str, question_id: str, body: str) -> Optional[Answer]:",
    "        if question_id not in self.questions or user_id not in self.users:",
    "            return None",
    "        a_id = f\"a_{self.answer_counter}\"",
    "        self.answer_counter += 1",
    "        answer = Answer(a_id, question_id, user_id, body)",
    "        self.answers[a_id] = answer",
    "        self.question_answers[question_id].append(a_id)",
    "        return answer",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        return self.questions.get(question_id)",
    "    ",
    "    def get_answers_for_question(self, question_id: str) -> List[Answer]:",
    "        return [self.answers[aid] for aid in self.question_answers.get(question_id, [])]",
    "    ",
    "    def get_questions_by_user(self, user_id: str) -> List[Question]:",
    "        qids = self.user_questions.get(user_id, [])",
    "        return sorted([self.questions[qid] for qid in qids], key=lambda q: q.created_at, reverse=True)",
    "    ",
    "    def get_questions_by_tag(self, tag: str) -> List[Question]:",
    "        qids = self.tag_questions.get(tag, [])",
    "        return sorted([self.questions[qid] for qid in qids], key=lambda q: q.score, reverse=True)",
    "    ",
    "    # ============ Part 2: Voting System ============",
    "    ",
    "    def _apply_vote(self, voter_id: str, item_id: str, new_vote: int,",
    "                    votes_map: Dict, items_map: Dict) -> int:",
    "        \"\"\"Generic vote logic. Returns new score or -1 if invalid.\"\"\"",
    "        if item_id not in items_map or voter_id not in self.users:",
    "            return -1",
    "        ",
    "        item = items_map[item_id]",
    "        if voter_id == item.author_id:  # Can't vote on own content",
    "            return -1",
    "        ",
    "        prev_vote = votes_map[item_id].get(voter_id, 0)",
    "        if prev_vote == new_vote:  # No change",
    "            return item.score",
    "        ",
    "        # Update score",
    "        item.score += (new_vote - prev_vote)",
    "        ",
    "        # Update author reputation: reverse old effect, apply new",
    "        author = self.users[item.author_id]",
    "        if prev_vote == 1:",
    "            author.reputation -= self.REP_UPVOTE",
    "        elif prev_vote == -1:",
    "            author.reputation -= self.REP_DOWNVOTE",
    "        ",
    "        if new_vote == 1:",
    "            author.reputation += self.REP_UPVOTE",
    "        elif new_vote == -1:",
    "            author.reputation += self.REP_DOWNVOTE",
    "        ",
    "        votes_map[item_id][voter_id] = new_vote",
    "        return item.score",
    "    ",
    "    def upvote_question(self, voter_id: str, question_id: str) -> int:",
    "        return self._apply_vote(voter_id, question_id, 1, self.question_votes, self.questions)",
    "    ",
    "    def downvote_question(self, voter_id: str, question_id: str) -> int:",
    "        return self._apply_vote(voter_id, question_id, -1, self.question_votes, self.questions)",
    "    ",
    "    def upvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        return self._apply_vote(voter_id, answer_id, 1, self.answer_votes, self.answers)",
    "    ",
    "    def downvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        return self._apply_vote(voter_id, answer_id, -1, self.answer_votes, self.answers)",
    "    ",
    "    def accept_answer(self, question_author_id: str, answer_id: str) -> bool:",
    "        \"\"\"Accept answer. Only question author can accept. Awards +15 rep.\"\"\"",
    "        if answer_id not in self.answers:",
    "            return False",
    "        answer = self.answers[answer_id]",
    "        question = self.questions.get(answer.question_id)",
    "        if not question or question.author_id != question_author_id:",
    "            return False",
    "        if answer.is_accepted:  # Idempotent",
    "            return True",
    "        answer.is_accepted = True",
    "        self.users[answer.author_id].reputation += self.REP_ACCEPTED",
    "        return True",
    "    ",
    "    def get_user_reputation(self, user_id: str) -> int:",
    "        return self.users[user_id].reputation if user_id in self.users else 0",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 2: Voting and Reputation Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    so = StackOverflow()",
    "    alice = so.create_user('u1', 'alice')",
    "    bob = so.create_user('u2', 'bob')",
    "    ",
    "    # Test 1: Basic voting",
    "    print(\"\\n--- Test 1: Basic upvote ---\")",
    "    q1 = so.post_question('u1', 'How to reverse string?', 'Body', ['python'])",
    "    score = so.upvote_question('u2', 'q_1')",
    "    print(f\"Bob upvotes Alice's question: score={score}\")",
    "    print(f\"Alice's reputation: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Test 2: Self-vote prevention",
    "    print(\"\\n--- Test 2: Self-vote prevention ---\")",
    "    result = so.upvote_question('u1', 'q_1')",
    "    print(f\"Alice tries to upvote own question: {result} (should be -1)\")",
    "    ",
    "    # Test 3: Vote change",
    "    print(\"\\n--- Test 3: Change vote upvote -> downvote ---\")",
    "    new_score = so.downvote_question('u2', 'q_1')",
    "    print(f\"Bob changes to downvote: score={new_score}\")",
    "    print(f\"Alice's rep after change: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Test 4: Accept answer",
    "    print(\"\\n--- Test 4: Accept answer ---\")",
    "    a1 = so.post_answer('u2', 'q_1', 'Use [::-1]')",
    "    so.accept_answer('u1', 'a_1')",
    "    print(f\"Alice accepts Bob's answer. Bob's rep: {so.get_user_reputation('u2')}\")",
    "    ",
    "    # Test 5: Answer voting",
    "    print(\"\\n--- Test 5: Answer voting ---\")",
    "    so.upvote_answer('u1', 'a_1')",
    "    print(f\"Alice upvotes Bob's answer. Bob's rep: {so.get_user_reputation('u2')}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 2 tests passed!\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class StackOverflow {",
    "    ",
    "    // Reputation constants",
    "    private static final int REP_UPVOTE = 10;",
    "    private static final int REP_DOWNVOTE = -2;",
    "    private static final int REP_ACCEPTED = 15;",
    "    ",
    "    static class User {",
    "        String id, username;",
    "        int reputation = 0;",
    "        User(String id, String username) { this.id = id; this.username = username; }",
    "    }",
    "    ",
    "    static class Question {",
    "        String id, authorId, title, body;",
    "        List<String> tags;",
    "        int score = 0;",
    "        long createdAt;",
    "        Question(String id, String authorId, String title, String body, List<String> tags) {",
    "            this.id = id; this.authorId = authorId; this.title = title;",
    "            this.body = body; this.tags = new ArrayList<>(tags); this.createdAt = System.currentTimeMillis();",
    "        }",
    "    }",
    "    ",
    "    static class Answer {",
    "        String id, questionId, authorId, body;",
    "        int score = 0;",
    "        boolean isAccepted = false;",
    "        long createdAt;",
    "        Answer(String id, String questionId, String authorId, String body) {",
    "            this.id = id; this.questionId = questionId; this.authorId = authorId;",
    "            this.body = body; this.createdAt = System.currentTimeMillis();",
    "        }",
    "    }",
    "    ",
    "    // Primary storage",
    "    private Map<String, User> users = new HashMap<>();",
    "    private Map<String, Question> questions = new HashMap<>();",
    "    private Map<String, Answer> answers = new HashMap<>();",
    "    ",
    "    // Secondary indexes",
    "    private Map<String, List<String>> userQuestions = new HashMap<>();",
    "    private Map<String, List<String>> tagQuestions = new HashMap<>();",
    "    private Map<String, List<String>> questionAnswers = new HashMap<>();",
    "    ",
    "    // Vote tracking: itemId -> (voterId -> voteValue)",
    "    private Map<String, Map<String, Integer>> questionVotes = new HashMap<>();",
    "    private Map<String, Map<String, Integer>> answerVotes = new HashMap<>();",
    "    ",
    "    private int questionCounter = 1, answerCounter = 1;",
    "    ",
    "    // ============ Part 1 Methods ============",
    "    ",
    "    public User createUser(String userId, String username) {",
    "        return users.computeIfAbsent(userId, k -> new User(userId, username));",
    "    }",
    "    ",
    "    public Question postQuestion(String userId, String title, String body, List<String> tags) {",
    "        if (!users.containsKey(userId)) return null;",
    "        String qId = \"q_\" + questionCounter++;",
    "        Question q = new Question(qId, userId, title, body, tags);",
    "        questions.put(qId, q);",
    "        userQuestions.computeIfAbsent(userId, k -> new ArrayList<>()).add(qId);",
    "        for (String tag : tags) tagQuestions.computeIfAbsent(tag, k -> new ArrayList<>()).add(qId);",
    "        return q;",
    "    }",
    "    ",
    "    public Answer postAnswer(String userId, String questionId, String body) {",
    "        if (!questions.containsKey(questionId) || !users.containsKey(userId)) return null;",
    "        String aId = \"a_\" + answerCounter++;",
    "        Answer a = new Answer(aId, questionId, userId, body);",
    "        answers.put(aId, a);",
    "        questionAnswers.computeIfAbsent(questionId, k -> new ArrayList<>()).add(aId);",
    "        return a;",
    "    }",
    "    ",
    "    public Question getQuestion(String questionId) { return questions.get(questionId); }",
    "    ",
    "    public List<Answer> getAnswersForQuestion(String questionId) {",
    "        List<String> ids = questionAnswers.getOrDefault(questionId, new ArrayList<>());",
    "        List<Answer> result = new ArrayList<>();",
    "        for (String id : ids) result.add(answers.get(id));",
    "        return result;",
    "    }",
    "    ",
    "    public List<Question> getQuestionsByUser(String userId) {",
    "        List<String> ids = userQuestions.getOrDefault(userId, new ArrayList<>());",
    "        List<Question> result = new ArrayList<>();",
    "        for (String id : ids) result.add(questions.get(id));",
    "        result.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        return result;",
    "    }",
    "    ",
    "    public List<Question> getQuestionsByTag(String tag) {",
    "        List<String> ids = tagQuestions.getOrDefault(tag, new ArrayList<>());",
    "        List<Question> result = new ArrayList<>();",
    "        for (String id : ids) result.add(questions.get(id));",
    "        result.sort((a, b) -> Integer.compare(b.score, a.score));",
    "        return result;",
    "    }",
    "    ",
    "    // ============ Part 2: Voting System ============",
    "    ",
    "    private int applyVote(String voterId, String itemId, int newVote,",
    "                          Map<String, Map<String, Integer>> votesMap,",
    "                          Map<String, ?> itemsMap, boolean isQuestion) {",
    "        if (!itemsMap.containsKey(itemId) || !users.containsKey(voterId)) return -1;",
    "        ",
    "        String authorId = isQuestion ? ((Question)itemsMap.get(itemId)).authorId",
    "                                     : ((Answer)itemsMap.get(itemId)).authorId;",
    "        if (voterId.equals(authorId)) return -1;",
    "        ",
    "        Map<String, Integer> votes = votesMap.computeIfAbsent(itemId, k -> new HashMap<>());",
    "        int prevVote = votes.getOrDefault(voterId, 0);",
    "        if (prevVote == newVote) {",
    "            return isQuestion ? ((Question)itemsMap.get(itemId)).score",
    "                              : ((Answer)itemsMap.get(itemId)).score;",
    "        }",
    "        ",
    "        // Update score",
    "        int scoreDelta = newVote - prevVote;",
    "        if (isQuestion) ((Question)itemsMap.get(itemId)).score += scoreDelta;",
    "        else ((Answer)itemsMap.get(itemId)).score += scoreDelta;",
    "        ",
    "        // Update reputation",
    "        User author = users.get(authorId);",
    "        if (prevVote == 1) author.reputation -= REP_UPVOTE;",
    "        else if (prevVote == -1) author.reputation -= REP_DOWNVOTE;",
    "        if (newVote == 1) author.reputation += REP_UPVOTE;",
    "        else if (newVote == -1) author.reputation += REP_DOWNVOTE;",
    "        ",
    "        votes.put(voterId, newVote);",
    "        return isQuestion ? ((Question)itemsMap.get(itemId)).score",
    "                          : ((Answer)itemsMap.get(itemId)).score;",
    "    }",
    "    ",
    "    public int upvoteQuestion(String voterId, String questionId) {",
    "        return applyVote(voterId, questionId, 1, questionVotes, questions, true);",
    "    }",
    "    ",
    "    public int downvoteQuestion(String voterId, String questionId) {",
    "        return applyVote(voterId, questionId, -1, questionVotes, questions, true);",
    "    }",
    "    ",
    "    public int upvoteAnswer(String voterId, String answerId) {",
    "        return applyVote(voterId, answerId, 1, answerVotes, answers, false);",
    "    }",
    "    ",
    "    public int downvoteAnswer(String voterId, String answerId) {",
    "        return applyVote(voterId, answerId, -1, answerVotes, answers, false);",
    "    }",
    "    ",
    "    public void acceptAnswer(String questionAuthorId, String answerId) {",
    "        if (!answers.containsKey(answerId)) return;",
    "        Answer answer = answers.get(answerId);",
    "        Question question = questions.get(answer.questionId);",
    "        if (question == null || !question.authorId.equals(questionAuthorId)) return;",
    "        if (answer.isAccepted) return;",
    "        answer.isAccepted = true;",
    "        users.get(answer.authorId).reputation += REP_ACCEPTED;",
    "    }",
    "    ",
    "    public int getUserReputation(String userId) {",
    "        return users.containsKey(userId) ? users.get(userId).reputation : 0;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Part 2: Voting and Reputation Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        so.createUser(\"u1\", \"alice\");",
    "        so.createUser(\"u2\", \"bob\");",
    "        ",
    "        System.out.println(\"\\n--- Test 1: Basic upvote ---\");",
    "        so.postQuestion(\"u1\", \"How to reverse?\", \"Body\", Arrays.asList(\"python\"));",
    "        int score = so.upvoteQuestion(\"u2\", \"q_1\");",
    "        System.out.println(\"Bob upvotes: score=\" + score + \", Alice rep=\" + so.getUserReputation(\"u1\"));",
    "        ",
    "        System.out.println(\"\\n--- Test 2: Self-vote prevention ---\");",
    "        System.out.println(\"Alice self-vote: \" + so.upvoteQuestion(\"u1\", \"q_1\") + \" (should be -1)\");",
    "        ",
    "        System.out.println(\"\\n--- Test 3: Vote change ---\");",
    "        score = so.downvoteQuestion(\"u2\", \"q_1\");",
    "        System.out.println(\"Bob changes to downvote: score=\" + score + \", Alice rep=\" + so.getUserReputation(\"u1\"));",
    "        ",
    "        System.out.println(\"\\n--- Test 4: Accept answer ---\");",
    "        so.postAnswer(\"u2\", \"q_1\", \"Use reverse()\");",
    "        so.acceptAnswer(\"u1\", \"a_1\");",
    "        System.out.println(\"Alice accepts Bob's answer. Bob rep=\" + so.getUserReputation(\"u2\"));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Imports and reputation constants. Using constants makes rules easy to modify."
    },
    {
      "lines": "50-57",
      "explanation": "New vote tracking HashMaps added to __init__. Using defaultdict(dict) for auto-initialization."
    },
    {
      "lines": "97-119",
      "explanation": "_apply_vote: Core voting logic. Validates inputs, calculates deltas, updates score and reputation incrementally."
    },
    {
      "lines": "121-132",
      "explanation": "Public vote methods delegate to _apply_vote with appropriate parameters."
    },
    {
      "lines": "134-145",
      "explanation": "accept_answer validates ownership, sets flag, awards reputation. Made idempotent."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "upvote_question": {
          "complexity": "O(1)",
          "explanation": "HashMap lookups and updates only"
        },
        "downvote_question": {
          "complexity": "O(1)",
          "explanation": "Same as upvote"
        },
        "upvote_answer": {
          "complexity": "O(1)",
          "explanation": "Same as upvote_question"
        },
        "downvote_answer": {
          "complexity": "O(1)",
          "explanation": "Same as upvote"
        },
        "accept_answer": {
          "complexity": "O(1)",
          "explanation": "Two HashMap lookups, one update"
        },
        "get_user_reputation": {
          "complexity": "O(1)",
          "explanation": "Direct field access on User object"
        }
      },
      "overall_change": "All new operations are O(1). Existing Part 1 operations unchanged."
    },
    "space": {
      "additional_space": "O(V) where V = total votes",
      "explanation": "question_votes and answer_votes each store at most one entry per (item, voter) pair. In worst case, every user votes on every item: O(U * (Q + A))."
    }
  },
  "dry_run": {
    "example_input": "createUser(u1, alice), createUser(u2, bob), postQuestion(u1, 'Q', 'Body', [tag]), upvoteQuestion(u2, q_1), downvoteQuestion(u2, q_1)",
    "steps": [
      {
        "step": 1,
        "action": "createUser(u1, alice)",
        "state": "users={u1: User(rep=0)}",
        "explanation": "Alice created with 0 reputation"
      },
      {
        "step": 2,
        "action": "createUser(u2, bob)",
        "state": "users={u1: User(rep=0), u2: User(rep=0)}",
        "explanation": "Bob created"
      },
      {
        "step": 3,
        "action": "postQuestion(u1, Q, Body, [tag])",
        "state": "questions={q_1: Question(score=0, authorId=u1)}",
        "explanation": "Alice posts question, score starts at 0"
      },
      {
        "step": 4,
        "action": "upvoteQuestion(u2, q_1)",
        "state": "question_votes={q_1: {u2: 1}}, q_1.score=1, u1.rep=10",
        "explanation": "Bob upvotes. prev_vote=0, new_vote=1, delta=+1. Alice gets +10 rep."
      },
      {
        "step": 5,
        "action": "downvoteQuestion(u2, q_1)",
        "state": "question_votes={q_1: {u2: -1}}, q_1.score=-1, u1.rep=-2",
        "explanation": "Bob changes to downvote. prev_vote=1, new_vote=-1, score_delta=-2. Rep: reverse +10, apply -2 = -12 net change. 10-10+(-2)=-2"
      }
    ],
    "final_output": "Question score: -1, Alice reputation: -2"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Upvote non-existent question returns -1",
      "Self-vote returns -1",
      "First upvote gives score=1"
    ],
    "likely_bugs": [
      "Forgetting to reverse previous reputation when vote changes",
      "Not handling the 'no previous vote' case (prev=0)",
      "Checking wrong user ID for self-vote (using voter instead of author)"
    ],
    "recommended_logs_or_asserts": [
      "assert item.score == sum(votes[item_id].values())",
      "log(f'Vote change: {prev_vote} -> {new_vote}, rep_delta={rep_delta}')"
    ],
    "how_to_localize": "Trace a vote change scenario step by step. Print prev_vote, new_vote, score before/after, reputation before/after. Usually the bug is in delta calculation."
  },
  "edge_cases": [
    {
      "case": "Vote on non-existent question",
      "handling": "Return -1",
      "gotcha": "Check BEFORE any state modification"
    },
    {
      "case": "Self-vote",
      "handling": "Return -1, no state change",
      "gotcha": "Compare voter_id with author_id, not question_id"
    },
    {
      "case": "Same vote twice",
      "handling": "Return current score, no change",
      "gotcha": "Don't double-count reputation"
    },
    {
      "case": "Vote change (up\u2192down)",
      "handling": "Score changes by -2, rep reversed then reapplied",
      "gotcha": "Order matters: reverse old, apply new"
    },
    {
      "case": "Accept already-accepted answer",
      "handling": "Return True but don't award rep again",
      "gotcha": "Check is_accepted flag first"
    },
    {
      "case": "Non-author tries to accept",
      "handling": "Return False",
      "gotcha": "Validate question.author_id matches caller"
    }
  ],
  "test_cases": [
    {
      "name": "Basic upvote increases score and reputation",
      "input": "createUser(u1), createUser(u2), postQuestion(u1), upvoteQuestion(u2, q_1)",
      "expected": "score=1, u1.reputation=10",
      "explanation": "Single upvote: +1 score, +10 rep to author"
    },
    {
      "name": "Self-vote rejected",
      "input": "createUser(u1), postQuestion(u1), upvoteQuestion(u1, q_1)",
      "expected": "returns -1, score remains 0",
      "explanation": "Cannot vote on own content"
    },
    {
      "name": "Vote change updates correctly",
      "input": "upvoteQuestion(u2, q_1) then downvoteQuestion(u2, q_1)",
      "expected": "score=-1, reputation=-2",
      "explanation": "Score: 1-2=-1. Rep: 10-10+(-2)=-2"
    },
    {
      "name": "Accept answer awards +15",
      "input": "postAnswer(u2, q_1), acceptAnswer(u1, a_1)",
      "expected": "u2.reputation=15, answer.is_accepted=True",
      "explanation": "Question author accepts, answer author gets rep"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Forgetting to reverse reputation on vote change",
      "why_wrong": "If user changes from upvote to downvote, author keeps the +10 AND gets -2",
      "correct_approach": "Always reverse previous effect before applying new",
      "code_example_wrong": "if new_vote == 1: author.rep += 10  # Missing reversal",
      "code_example_correct": "if prev_vote == 1: author.rep -= 10\\nif new_vote == -1: author.rep += (-2)"
    },
    {
      "mistake": "Using entity.score instead of calculating delta",
      "why_wrong": "Leads to incorrect score when vote changes",
      "correct_approach": "score_delta = new_vote - prev_vote; item.score += score_delta",
      "code_example_wrong": "item.score = sum(votes.values())  # O(n), wrong approach",
      "code_example_correct": "item.score += (new_vote - prev_vote)  # O(1), correct"
    },
    {
      "mistake": "Not making accept_answer idempotent",
      "why_wrong": "Accepting twice would award +30 reputation",
      "correct_approach": "Check is_accepted before awarding reputation",
      "code_example_wrong": "answer.is_accepted = True; author.rep += 15  // Always awards",
      "code_example_correct": "if (!answer.is_accepted) { answer.is_accepted = true; author.rep += 15; }"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the data structure choice (nested HashMap for O(1) vote lookup), then walk through the vote change algorithm showing how deltas are calculated.",
    "what_to_mention": [
      "Vote tracking enables O(1) lookup of previous vote",
      "Incremental updates avoid O(n) recalculation",
      "Constants for reputation values make rules configurable",
      "Idempotency in accept_answer prevents double-counting"
    ],
    "time_allocation": "~15 minutes: 3 min understanding, 10 min coding, 2 min testing",
    "if_stuck": [
      "Think about what data you need to store to handle vote changes",
      "Consider: what happens when upvote becomes downvote? What's the score delta?",
      "Draw out the reputation flow for one vote change"
    ]
  },
  "connection_to_next_part": "Part 3 likely adds search functionality or more complex queries. The vote/score infrastructure enables sorting by score in search results. Consider: will you need to maintain sorted lists of questions by score?",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 gives us the basic CRUD operations. For Part 2, I need to add voting with two key challenges: (1) tracking who voted on what, and (2) updating reputation incrementally when votes change.",
    "explaining_changes": "The key insight is using a nested HashMap\u2014item_id maps to another map of voter_id to vote_value. This lets me look up any previous vote in O(1), which I need to calculate the delta when someone changes their vote.",
    "while_extending_code": [
      "I'm adding two vote tracking maps\u2014one for questions, one for answers",
      "The _apply_vote helper centralizes the logic so I don't duplicate it four times",
      "For reputation, I reverse the previous effect then apply the new one"
    ],
    "after_completing": "This handles all voting scenarios in O(1). The reputation is tracked incrementally on the User object, so get_user_reputation is also O(1). Ready for Part 3."
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Understand voting rules, identify need for vote tracking structure",
    "by_5_min": "Explain approach: nested HashMap, incremental updates",
    "by_10_min": "Core _apply_vote method implemented",
    "by_15_min": "All methods done, testing edge cases",
    "warning_signs": "If stuck on data structure choice at 5 min, draw out an example. If still debugging at 15 min, check delta calculation."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has bugs (e.g., users dict not populated), fix those first. Say: 'Let me verify Part 1 is working before adding votes.'",
    "if_new_requirement_unclear": "Ask: 'When a user changes their vote, does that mean they can go from upvote to downvote directly, or must they remove the vote first?'",
    "if_running_behind": "Focus on upvote_question first. Once that works, the other three vote methods are identical. Skip accept_answer if needed\u2014mention you'd handle it similarly."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing the need for vote change handling",
      "Explaining the delta-based approach without prompting",
      "Mentioning the space tradeoff (storing all votes vs. just counts)",
      "Discussing idempotency for accept_answer",
      "Proactively adding helper method to avoid code duplication"
    ]
  },
  "pattern_recognition": {
    "pattern": "State Tracking with Incremental Updates",
    "indicators": [
      "Need to track per-user state",
      "Operations that modify existing state",
      "Requirements mention 'change' or 'update'"
    ],
    "similar_problems": [
      "LC 146 - LRU Cache (tracking access)",
      "LC 981 - Time Based Key-Value Store",
      "Design Hit Counter"
    ],
    "template": "Store state in HashMap, on update: (1) get previous state, (2) calculate delta, (3) apply delta, (4) record new state"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Votes can change, so I can't just store the count",
      "why": "Need to know previous vote to calculate correct delta"
    },
    {
      "step": 2,
      "thought": "Nested HashMap is the natural structure",
      "why": "item_id \u2192 voter_id \u2192 vote gives O(1) lookup for any previous vote"
    },
    {
      "step": 3,
      "thought": "Reputation must be updated incrementally",
      "why": "Recalculating from all votes would be O(votes) per operation"
    },
    {
      "step": 4,
      "thought": "Need to prevent self-voting",
      "why": "Business rule\u2014check author_id before processing"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you handle state changes correctly (not just additions)?",
      "Do you recognize the O(1) requirement and design accordingly?",
      "Do you handle edge cases like self-voting and vote changes?",
      "Is your code well-organized (DRY principle with helper method)?"
    ],
    "bonus_points": [
      "Discussing the space-time tradeoff of storing all votes",
      "Making accept_answer idempotent",
      "Using constants for reputation values",
      "Mentioning thread-safety concerns"
    ],
    "red_flags": [
      "Recalculating totals from scratch on each operation",
      "Not handling vote changes (assuming only new votes)",
      "Forgetting to reverse reputation when vote changes",
      "Duplicating vote logic four times instead of using helper"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help generate the boilerplate vote methods after you write _apply_vote",
      "Use AI to generate test cases for edge cases"
    ],
    "what_not_to_do": [
      "Don't let AI design the vote tracking structure\u2014explain your reasoning",
      "Don't accept AI's reputation logic without verifying the delta calculation"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping into code without explaining the vote tracking approach",
      "Not asking about vote change semantics"
    ],
    "technical": [
      "Storing only vote counts (can't handle changes)",
      "Using O(n) operations for reputation calculation",
      "Modifying Part 1 code unnecessarily"
    ],
    "communication": [
      "Not explaining why nested HashMap is the right choice",
      "Forgetting to trace through a vote change example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "upvote/downvote returns -1 for invalid operations",
      "Self-voting is prevented",
      "Vote changes update score AND reputation correctly",
      "accept_answer is idempotent",
      "All operations are O(1)"
    ],
    "quick_code_review": [
      "Vote maps initialized (defaultdict or computeIfAbsent)",
      "prev_vote defaults to 0, not None",
      "Reputation constants used consistently"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Rate limiting on votes (prevent vote manipulation)",
      "Audit log for vote changes",
      "Transaction support (vote + reputation should be atomic)",
      "Input validation (check for empty strings)"
    ],
    "why_not_in_interview": "Focus on core algorithm; these are infrastructure concerns",
    "how_to_mention": "Say: 'In production, I'd add rate limiting to prevent vote manipulation, and wrap the vote+reputation updates in a transaction.'"
  },
  "generated_at": "2026-01-19T04:49:28.448697",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}