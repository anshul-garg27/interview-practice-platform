{
  "problem_title": "Production-Ready Event Ticket Booking API",
  "difficulty": "hard",
  "category": "LLD/API Design",
  "estimated_time": "60-90 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic API design problem** testing CRUD operations, input validation, proper HTTP semantics, and concurrency awareness. The 'production-ready' emphasis signals the interviewer wants to see mature engineering practices: validation, error handling, proper status codes, and thread-safety considerations.",
    "pattern_recognition": "**Repository Pattern** for data storage + **Validation Layer** + **Service Layer** + **Response DTO Pattern**. Similar to designing OrderService, InventoryService, or any e-commerce backend. The atomic ticket booking is essentially the 'inventory reservation' pattern seen in Amazon/Uber/Doordash systems.",
    "key_constraints": [
      "Tickets per booking: 1-10 - prevents abuse, simplifies validation",
      "Price uses Decimal - CRITICAL: floating-point will cause precision errors",
      "Event IDs are UUIDs - expect string-based lookups, not integer",
      "Up to 10k requests/sec - hints at Part 3 concurrency requirements",
      "Atomic updates required - double-booking is a critical bug"
    ],
    "clarifying_questions": [
      "Should I use in-memory storage or design for a real database? - Clarifies complexity expectations",
      "How strict should date validation be? Must be in future, but how far? - Reveals business rules",
      "What precision for currency? 2 decimal places? - Critical for Decimal implementation",
      "Can the same user book multiple times for same event? - Business rule clarification",
      "Should I implement idempotency keys to prevent duplicate submissions? - Shows senior thinking",
      "What's the expected response format? Standard envelope with success/error? - Confirms output structure",
      "For Part 1, should I focus on correctness or also prepare threading hooks? - Scope clarification"
    ],
    "edge_cases_to_consider": [
      "Booking exactly remaining tickets (boundary condition)",
      "Booking 1 more than available (off-by-one)",
      "Cancelling already-cancelled booking (idempotency)",
      "Event not found vs booking not found (different 404s)",
      "Empty string vs missing field validation",
      "Price of 0 (free events are valid)",
      "Very long event names at boundary (200 chars)"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "createEvent with name, date, venue, totalTickets, price",
        "how_met": "create_event() validates all fields, stores in events dict, returns 201 with eventId",
        "gotchas": [
          "Must validate ALL required fields",
          "Price must use Decimal not float"
        ]
      },
      {
        "requirement": "getEvent returns details including available tickets",
        "how_met": "get_event() returns full event data with availableTickets computed from bookings",
        "gotchas": [
          "Return 404 not 400 for missing event",
          "Include all fields mentioned in spec"
        ]
      },
      {
        "requirement": "listEvents with pagination",
        "how_met": "list_events() accepts limit/offset, returns paginated results with total count",
        "gotchas": [
          "Default pagination values needed",
          "Return empty list not error for no results"
        ]
      },
      {
        "requirement": "bookTickets validates availability",
        "how_met": "book_tickets() checks availability atomically with lock, decrements tickets",
        "gotchas": [
          "409 Conflict not 400 for insufficient tickets",
          "Must be atomic - check AND decrement together"
        ]
      },
      {
        "requirement": "cancelBooking returns tickets to inventory",
        "how_met": "cancel_booking() increments available tickets, sets status to CANCELLED",
        "gotchas": [
          "Handle already-cancelled gracefully",
          "Update booking status AND event tickets atomically"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "createEvent",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict insertion is O(1), validation is O(field_count)"
      },
      {
        "operation": "getEvent",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict lookup by ID is O(1)"
      },
      {
        "operation": "listEvents",
        "target": "O(n) worst, O(limit) returned",
        "achieved": "O(n)",
        "why": "Need to slice list, but return limited items"
      },
      {
        "operation": "bookTickets",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict lookups + arithmetic, lock is contention-bounded"
      },
      {
        "operation": "cancelBooking",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Dict lookup + update"
      }
    ],
    "non_goals": [
      "Persistent database integration (in-memory is fine for interview)",
      "Full authentication/authorization (Part 2)",
      "Distributed locks / database transactions (Part 3)",
      "Rate limiting implementation (Part 4)",
      "Payment processing integration"
    ]
  },
  "assumptions": [
    "In-memory storage is acceptable for Part 1 (ask interviewer to confirm)",
    "Event IDs can be sequential for simplicity vs true UUIDs (mention tradeoff)",
    "Single-server deployment - threading.Lock is sufficient (Part 3 adds distributed)",
    "Dates are provided in ISO 8601 format with timezone",
    "Currency is USD with 2 decimal place precision",
    "User authentication is handled upstream (userId is trusted)"
  ],
  "tradeoffs": [
    {
      "decision": "In-memory Dict vs Database",
      "chosen": "In-memory Dict",
      "why": "Interview scope - simple, fast, demonstrates logic",
      "alternative": "Real DB with transactions",
      "when_to_switch": "Production system or Part 3"
    },
    {
      "decision": "Decimal vs Float for money",
      "chosen": "Decimal",
      "why": "Precision: 0.1 + 0.1 + 0.1 = 0.3 exactly",
      "alternative": "Integer cents",
      "when_to_switch": "If performance-critical and precision handled carefully"
    },
    {
      "decision": "Validation in API vs separate layer",
      "chosen": "Separate validation methods",
      "why": "Clean separation, testable, reusable",
      "alternative": "Inline validation",
      "when_to_switch": "Never - separation is always better"
    },
    {
      "decision": "Lock granularity: global vs per-event",
      "chosen": "Global lock for Part 1",
      "why": "Simple, correct, Part 1 focus is correctness",
      "alternative": "Per-event locks",
      "when_to_switch": "Part 3 / high concurrency"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "Keep public API exactly as specified",
      "Separate validation from business logic",
      "Encapsulate state behind service methods",
      "Use immutable data where possible"
    ],
    "why_this_design_scales": "The layered design (API -> Validation -> Service -> Store) means Part 2 adds auth at API layer, Part 3 replaces Lock with distributed lock, Part 4 adds rate limiting at API gateway. Each layer is replaceable without affecting others.",
    "expected_followup_hooks": [
      "Lock mechanism will be replaced with DB transactions or distributed locks",
      "Validation will add auth/authorization checks",
      "Event service might add caching layer",
      "Booking service might add payment integration"
    ],
    "invariants": [
      "available_tickets >= 0 always",
      "available_tickets + booked_tickets = total_tickets",
      "Cancelled booking cannot be cancelled again",
      "Booking references valid event"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n                    TICKET BOOKING SYSTEM ARCHITECTURE\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                    CLIENT REQUESTS                      \u2502\n    \u2502   POST /events      GET /events/123    POST /bookings   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502              VALIDATION LAYER                           \u2502\n    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n    \u2502  \u2502 \u2022 Required fields present?                       \u2502   \u2502\n    \u2502  \u2502 \u2022 Correct data types?                           \u2502   \u2502\n    \u2502  \u2502 \u2022 Values within constraints?                    \u2502   \u2502\n    \u2502  \u2502 \u2022 Business rules satisfied?                     \u2502   \u2502\n    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n    \u2502           \u274c Invalid \u2192 400 Bad Request                  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502 \u2713 Valid\n                               \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502              BUSINESS LOGIC LAYER                       \u2502\n    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n    \u2502  \u2502   EventService    \u2502  \u2502    BookingService      \u2502     \u2502\n    \u2502  \u2502 \u2022 create/get/list \u2502  \u2502 \u2022 book (atomic!)       \u2502     \u2502\n    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502 \u2022 cancel               \u2502     \u2502\n    \u2502                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n    \u2502           \u274c Not Found \u2192 404                            \u2502\n    \u2502           \u274c Conflict \u2192 409                             \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502 \u2713 Success\n                               \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502              DATA STORE                                 \u2502\n    \u2502  events: {evt_001: Event, evt_002: Event, ...}         \u2502\n    \u2502  bookings: {bkg_001: Booking, bkg_002: Booking, ...}   \u2502\n    \u2502                                                         \u2502\n    \u2502  \ud83d\udd12 ATOMIC: Check availability + Decrement + Create    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n    EVENTS DICTIONARY                    BOOKINGS DICTIONARY\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                   \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    evt_001 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  bkg_001 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502 Event             \u2502                \u2502 Booking            \u2502\n           \u2502 \u251c\u2500 id: evt_001    \u2502                \u2502 \u251c\u2500 id: bkg_001     \u2502\n           \u2502 \u251c\u2500 name: \"Tech...\"\u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 \u251c\u2500 event_id: evt_001\n           \u2502 \u251c\u2500 total: 100     \u2502                \u2502 \u251c\u2500 user_id: usr_123\u2502\n           \u2502 \u251c\u2500 available: 98  \u2502  \u25c4\u2500\u2500 updated   \u2502 \u251c\u2500 tickets: 2      \u2502\n           \u2502 \u2514\u2500 price: $75.00  \u2502     by booking \u2502 \u251c\u2500 total: $150.00  \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502 \u2514\u2500 status: CONFIRMED\n                                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    INVARIANT: available + sum(bookings.tickets) = total\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Request arrives at API endpoint",
        "visualization": "```\nPOST /bookings\n{eventId: evt_001, userId: usr_123, numberOfTickets: 2}\n```",
        "key_point": "Raw user input - never trust it!"
      },
      {
        "step": 2,
        "description": "Validate input format and constraints",
        "visualization": "```\n\u2713 eventId: string, present\n\u2713 userId: string, present  \n\u2713 numberOfTickets: int, 1-10 range\n\u2192 Validation PASSED\n```",
        "key_point": "Return 400 with details if invalid"
      },
      {
        "step": 3,
        "description": "Check event exists",
        "visualization": "```\nevents.get('evt_001') \u2192 Event found \u2713\nOR\nevents.get('evt_999') \u2192 None \u2192 404\n```",
        "key_point": "Business validation separate from input validation"
      },
      {
        "step": 4,
        "description": "ACQUIRE LOCK - Atomic section begins",
        "visualization": "```\n\ud83d\udd12 LOCK ACQUIRED\n\u2502\n\u251c\u2500\u2500 Check: available_tickets >= requested?\n\u2502   100 >= 2 \u2192 YES \u2713\n\u2502\n\u251c\u2500\u2500 Decrement: available = 100 - 2 = 98\n\u2502\n\u251c\u2500\u2500 Create: Booking(id=bkg_001, ...)\n\u2502\n\u2514\u2500\u2500 Store: bookings[bkg_001] = booking\n\u2502\n\ud83d\udd13 LOCK RELEASED\n```",
        "key_point": "CRITICAL: Check + Update must be atomic!"
      },
      {
        "step": 5,
        "description": "Return success response",
        "visualization": "```\nHTTP 201 Created\n{\n  \"success\": true,\n  \"data\": {\n    \"bookingId\": \"bkg_001\",\n    \"totalAmount\": 150.00,\n    \"status\": \"CONFIRMED\"\n  }\n}\n```",
        "key_point": "201 for creation, include booking confirmation"
      }
    ],
    "dry_run_table": "| Step | Operation | Events State | Bookings State | Response |\n|------|-----------|--------------|----------------|----------|\n| 0 | init | {} | {} | - |\n| 1 | createEvent(Tech Conf, 100 tix) | {evt_001: avail=100} | {} | 201, eventId=evt_001 |\n| 2 | getEvent(evt_001) | {evt_001: avail=100} | {} | 200, avail=100 |\n| 3 | bookTickets(evt_001, 2 tix) | {evt_001: avail=98} | {bkg_001: 2 tix} | 201, $150 |\n| 4 | bookTickets(evt_001, 99 tix) | {evt_001: avail=98} | {bkg_001: 2 tix} | 409, only 98 avail |\n| 5 | cancelBooking(bkg_001) | {evt_001: avail=100} | {bkg_001: CANCELLED} | 200, CANCELLED |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'production-ready API', I think of layered architecture: Validation \u2192 Business Logic \u2192 Data Store, because this separates concerns and makes each layer testable",
      "When I see 'tickets cannot be oversold', I immediately think ATOMICITY - the check and decrement must happen together under a lock",
      "When I see 'pricePerTicket' with money, I MUST use Decimal/BigDecimal - this is a common interview trap",
      "When I see HTTP status codes listed, I know the interviewer expects specific codes: 201 for create, 404 for not found, 409 for business conflicts",
      "The constraint 'tickets per booking 1-10' tells me to validate this range - it's explicit for a reason",
      "When I see 'cancelled bookings return tickets', I know cancellation must also be atomic with the event update"
    ],
    "key_insight": "**The core insight is that booking is a TWO-PHASE operation that must be ATOMIC**: (1) verify availability, (2) decrement and create booking. If these are separate, two concurrent requests could both pass verification but create overbooking. This is the classic 'check-then-act' race condition.",
    "why_this_works": "By using a lock around the critical section (check + decrement + create), we ensure that only one booking can modify availability at a time. The lock serializes concurrent access, preventing race conditions. For Part 1, a simple threading.Lock suffices; Part 3 will need database transactions or distributed locks."
  },
  "approaches": [
    {
      "name": "Naive: Separate Check and Update",
      "description": "First check if tickets available, then decrement in separate operation",
      "pseudocode": "def book_tickets(request):\n    event = get_event(request.event_id)\n    if event.available >= request.tickets:  # CHECK\n        # \u26a0\ufe0f RACE CONDITION HERE - another thread could book!\n        event.available -= request.tickets   # UPDATE\n        create_booking(...)\n    else:\n        return 409 Conflict",
      "time_complexity": "O(1) per operation",
      "space_complexity": "O(n) for n events/bookings",
      "pros": [
        "Simple to understand",
        "Easy to implement"
      ],
      "cons": [
        "CRITICAL BUG: Race condition allows overbooking",
        "Not production-safe",
        "Will fail under concurrent load"
      ],
      "when_to_use": "Never in production - only for understanding the problem"
    },
    {
      "name": "Optimal: Atomic Check-and-Update with Lock",
      "description": "Use a lock to make check + decrement + create booking atomic",
      "pseudocode": "def book_tickets(request):\n    with self.lock:  # ATOMIC SECTION\n        event = get_event(request.event_id)\n        if event.available < request.tickets:\n            return 409 Conflict\n        event.available -= request.tickets\n        booking = create_booking(...)\n    return 201 Created, booking",
      "time_complexity": "O(1) per operation (lock acquisition is constant for low contention)",
      "space_complexity": "O(n) for n events/bookings",
      "pros": [
        "Thread-safe",
        "Prevents overbooking",
        "Clear critical section"
      ],
      "cons": [
        "Global lock limits concurrency",
        "Not distributed-system ready"
      ],
      "key_insight": "Check-then-act must be atomic. Lock ensures serialization of critical section."
    },
    {
      "name": "Production: Database Transactions with Row Locking",
      "description": "Use database transactions with SELECT FOR UPDATE",
      "pseudocode": "def book_tickets(request):\n    with db.transaction():\n        event = db.query('SELECT * FROM events WHERE id = ? FOR UPDATE', event_id)\n        if event.available < tickets:\n            db.rollback()\n            return 409\n        db.execute('UPDATE events SET available = available - ? WHERE id = ?', tickets, event_id)\n        db.execute('INSERT INTO bookings ...')\n        db.commit()\n    return 201 Created",
      "time_complexity": "O(1) with proper indexes",
      "space_complexity": "O(1) per operation (DB handles storage)",
      "pros": [
        "Distributed-system ready",
        "ACID guarantees",
        "Scales horizontally"
      ],
      "cons": [
        "More complex",
        "Requires DB setup",
        "Beyond Part 1 scope"
      ],
      "when_to_use": "Part 3 and production systems"
    }
  ],
  "optimal_solution": {
    "name": "Layered API with Atomic Booking using Threading Lock",
    "explanation_md": "## Approach\n\nWe implement a **layered architecture** with clear separation:\n\n### Layer 1: Request Validation\nValidate all inputs BEFORE any business logic. Check:\n- Required fields present\n- Correct data types\n- Values within constraints (1-10 tickets, price 0-10000, etc.)\n\n### Layer 2: Business Logic\n- **Event Service**: CRUD for events, simple dict operations\n- **Booking Service**: Atomic booking with lock protection\n\n### Layer 3: Data Store\n- In-memory dictionaries for events and bookings\n- Lock protects critical sections\n\n### Why Lock is Essential\n```\nThread A: available=5, wants 3     Thread B: available=5, wants 3\n        \u2502                                   \u2502\n        \u25bc                                   \u25bc\n    CHECK: 5>=3 \u2713                      CHECK: 5>=3 \u2713\n        \u2502                                   \u2502\n        \u25bc                                   \u25bc\n    DECREMENT: 5-3=2                   DECREMENT: 5-3=2\n        \u2502                                   \u2502\n        \u25bc                                   \u25bc\n    BOOK 3 tickets                     BOOK 3 tickets\n    \n    RESULT: 6 tickets sold, only 5 existed! \ud83d\udca5\n```\n\nWith lock:\n```\nThread A acquires lock \u2192 Thread B waits\nA: CHECK 5>=3 \u2713 \u2192 DECREMENT \u2192 BOOK \u2192 release lock\nB: acquires lock \u2192 CHECK 2>=3 \u2717 \u2192 409 Conflict\n```",
    "data_structures": [
      {
        "structure": "Dict[str, Event]",
        "purpose": "O(1) event lookup by ID"
      },
      {
        "structure": "Dict[str, Booking]",
        "purpose": "O(1) booking lookup by ID"
      },
      {
        "structure": "threading.Lock",
        "purpose": "Serialize access to critical sections"
      },
      {
        "structure": "Decimal",
        "purpose": "Precise currency calculations without floating-point errors"
      }
    ],
    "algorithm_steps": [
      "1. **Validate input**: Check required fields, types, ranges \u2192 400 if invalid",
      "2. **Check event exists**: Dict lookup \u2192 404 if not found",
      "3. **Acquire lock**: Begin atomic section",
      "4. **Re-check availability**: Must check INSIDE lock (state may have changed)",
      "5. **Decrement tickets**: event.available_tickets -= requested",
      "6. **Create booking**: Store in bookings dict",
      "7. **Release lock**: End atomic section",
      "8. **Return response**: 201 Created with booking details"
    ],
    "why_decimal": "## Why Decimal Matters\n\n```python\n# WRONG - Float arithmetic\n>>> 0.1 + 0.1 + 0.1\n0.30000000000000004  # NOT 0.3!\n\n>>> 75.50 * 3\n226.49999999999997  # Lost a fraction of a cent!\n\n# CORRECT - Decimal\n>>> from decimal import Decimal\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1')\nDecimal('0.3')  # Exactly 0.3\n\n>>> Decimal('75.50') * 3\nDecimal('226.50')  # Exact!\n```\n\nFor financial systems, this precision is CRITICAL. A tiny error per transaction \u00d7 millions of transactions = significant money discrepancy."
  },
  "solution_python_lines": [
    "from decimal import Decimal",
    "from datetime import datetime",
    "from typing import Dict, List, Optional, Any",
    "from enum import Enum",
    "from dataclasses import dataclass",
    "import threading",
    "",
    "",
    "class BookingStatus(Enum):",
    "    CONFIRMED = 'CONFIRMED'",
    "    CANCELLED = 'CANCELLED'",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    \"\"\"Event entity with ticket inventory.\"\"\"",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: Decimal",
    "",
    "",
    "@dataclass ",
    "class Booking:",
    "    \"\"\"Booking entity linking user to event tickets.\"\"\"",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    total_amount: Decimal",
    "    status: BookingStatus",
    "    created_at: datetime",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    \"\"\"Standard API response wrapper.\"\"\"",
    "    status: int",
    "    body: dict",
    "",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-ready Event Ticket Booking API.",
    "    ",
    "    Key design decisions:",
    "    - Decimal for currency precision",
    "    - Lock for atomic booking operations",
    "    - Layered validation (input \u2192 business)",
    "    - Proper HTTP status codes",
    "    \"\"\"",
    "",
    "    def __init__(self):",
    "        self.events: Dict[str, Event] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "        self._lock = threading.Lock()  # For atomic operations",
    "",
    "    def _generate_event_id(self) -> str:",
    "        self._event_counter += 1",
    "        return f\"evt_{self._event_counter:03d}\"",
    "",
    "    def _generate_booking_id(self) -> str:",
    "        self._booking_counter += 1",
    "        return f\"bkg_{self._booking_counter:03d}\"",
    "",
    "    def _validate_event_request(self, request: dict) -> List[dict]:",
    "        \"\"\"Validate event creation. Returns list of errors (empty if valid).\"\"\"",
    "        errors = []",
    "        required = ['name', 'date', 'venue', 'totalTickets', 'pricePerTicket']",
    "        ",
    "        # Check required fields first",
    "        for field in required:",
    "            if field not in request or request[field] is None:",
    "                errors.append({'field': field, 'issue': 'required'})",
    "        ",
    "        if errors:",
    "            return errors  # Return early if missing required fields",
    "        ",
    "        # Type and range validation",
    "        if not isinstance(request['name'], str) or len(request['name']) < 1:",
    "            errors.append({'field': 'name', 'issue': 'must be non-empty string'})",
    "        elif len(request['name']) > 200:",
    "            errors.append({'field': 'name', 'issue': 'max 200 characters'})",
    "        ",
    "        if not isinstance(request['totalTickets'], int):",
    "            errors.append({'field': 'totalTickets', 'issue': 'must be an integer'})",
    "        elif not (1 <= request['totalTickets'] <= 100000):",
    "            errors.append({'field': 'totalTickets', 'issue': 'must be 1-100000'})",
    "        ",
    "        price = request['pricePerTicket']",
    "        if not isinstance(price, (int, float, Decimal)):",
    "            errors.append({'field': 'pricePerTicket', 'issue': 'must be a number'})",
    "        elif not (0 <= float(price) <= 10000):",
    "            errors.append({'field': 'pricePerTicket', 'issue': 'must be 0-10000'})",
    "        ",
    "        return errors",
    "",
    "    def _validate_booking_request(self, request: dict) -> List[dict]:",
    "        \"\"\"Validate booking request. Returns list of errors.\"\"\"",
    "        errors = []",
    "        required = ['eventId', 'userId', 'numberOfTickets']",
    "        ",
    "        for field in required:",
    "            if field not in request or request[field] is None:",
    "                errors.append({'field': field, 'issue': 'required'})",
    "        ",
    "        if errors:",
    "            return errors",
    "        ",
    "        tickets = request['numberOfTickets']",
    "        if not isinstance(tickets, int):",
    "            errors.append({'field': 'numberOfTickets', 'issue': 'must be integer'})",
    "        elif not (1 <= tickets <= 10):",
    "            errors.append({'field': 'numberOfTickets', 'issue': 'must be 1-10'})",
    "        ",
    "        return errors",
    "",
    "    def _error_response(self, status: int, code: str, message: str, ",
    "                        details: List[dict] = None) -> Response:",
    "        \"\"\"Build standardized error response.\"\"\"",
    "        body = {'success': False, 'error': {'code': code, 'message': message}}",
    "        if details:",
    "            body['error']['details'] = details",
    "        return Response(status=status, body=body)",
    "",
    "    def create_event(self, request: dict) -> Response:",
    "        \"\"\"Create new event with full validation.\"\"\"",
    "        errors = self._validate_event_request(request)",
    "        if errors:",
    "            msg = f\"Missing required field: {errors[0]['field']}\" if errors[0]['issue'] == 'required' else f\"Validation error: {errors[0]['issue']}\"",
    "            return self._error_response(400, 'VALIDATION_ERROR', msg, errors)",
    "        ",
    "        event_id = self._generate_event_id()",
    "        event = Event(",
    "            id=event_id,",
    "            name=request['name'],",
    "            date=datetime.fromisoformat(request['date'].replace('Z', '+00:00')),",
    "            venue=request['venue'],",
    "            total_tickets=request['totalTickets'],",
    "            available_tickets=request['totalTickets'],",
    "            price_per_ticket=Decimal(str(request['pricePerTicket']))  # Always Decimal!",
    "        )",
    "        self.events[event_id] = event",
    "        ",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {'eventId': event_id, 'name': event.name, ",
    "                     'availableTickets': event.available_tickets}",
    "        })",
    "",
    "    def get_event(self, event_id: str) -> Response:",
    "        \"\"\"Get event by ID. Returns 404 if not found.\"\"\"",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        ",
    "        e = self.events[event_id]",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {",
    "                'eventId': e.id, 'name': e.name, 'date': e.date.isoformat(),",
    "                'venue': e.venue, 'totalTickets': e.total_tickets,",
    "                'availableTickets': e.available_tickets,",
    "                'pricePerTicket': float(e.price_per_ticket)",
    "            }",
    "        })",
    "",
    "    def list_events(self, filters: dict = None) -> Response:",
    "        \"\"\"List events with pagination.\"\"\"",
    "        filters = filters or {}",
    "        limit = min(filters.get('limit', 10), 100)  # Cap at 100",
    "        offset = max(filters.get('offset', 0), 0)",
    "        ",
    "        all_events = list(self.events.values())",
    "        paginated = all_events[offset:offset + limit]",
    "        ",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {",
    "                'events': [{'eventId': e.id, 'name': e.name, ",
    "                           'availableTickets': e.available_tickets} for e in paginated],",
    "                'total': len(all_events), 'limit': limit, 'offset': offset",
    "            }",
    "        })",
    "",
    "    def book_tickets(self, request: dict) -> Response:",
    "        \"\"\"",
    "        Book tickets atomically.",
    "        CRITICAL: Uses lock to prevent race conditions and overbooking.",
    "        \"\"\"",
    "        errors = self._validate_booking_request(request)",
    "        if errors:",
    "            msg = f\"Missing required field: {errors[0]['field']}\" if errors[0]['issue'] == 'required' else errors[0]['issue']",
    "            return self._error_response(400, 'VALIDATION_ERROR', msg, errors)",
    "        ",
    "        event_id = request['eventId']",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        ",
    "        # ATOMIC SECTION - check and book must be together",
    "        with self._lock:",
    "            event = self.events[event_id]",
    "            num_tickets = request['numberOfTickets']",
    "            ",
    "            if event.available_tickets < num_tickets:",
    "                return self._error_response(",
    "                    409, 'INSUFFICIENT_TICKETS',",
    "                    f\"Only {event.available_tickets} ticket(s) available, requested {num_tickets}\"",
    "                )",
    "            ",
    "            # Create booking and update inventory",
    "            booking_id = self._generate_booking_id()",
    "            total = event.price_per_ticket * num_tickets",
    "            ",
    "            booking = Booking(",
    "                id=booking_id,",
    "                event_id=event_id,",
    "                user_id=request['userId'],",
    "                number_of_tickets=num_tickets,",
    "                total_amount=total,",
    "                status=BookingStatus.CONFIRMED,",
    "                created_at=datetime.now()",
    "            )",
    "            ",
    "            event.available_tickets -= num_tickets",
    "            self.bookings[booking_id] = booking",
    "        ",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {",
    "                'bookingId': booking_id, 'eventId': event_id,",
    "                'numberOfTickets': num_tickets, 'totalAmount': float(total),",
    "                'status': 'CONFIRMED'",
    "            }",
    "        })",
    "",
    "    def cancel_booking(self, booking_id: str) -> Response:",
    "        \"\"\"Cancel booking and return tickets to inventory.\"\"\"",
    "        if booking_id not in self.bookings:",
    "            return self._error_response(404, 'NOT_FOUND', f'Booking {booking_id} not found')",
    "        ",
    "        with self._lock:",
    "            booking = self.bookings[booking_id]",
    "            ",
    "            if booking.status == BookingStatus.CANCELLED:",
    "                return self._error_response(409, 'ALREADY_CANCELLED', 'Booking already cancelled')",
    "            ",
    "            # Return tickets and update status",
    "            self.events[booking.event_id].available_tickets += booking.number_of_tickets",
    "            booking.status = BookingStatus.CANCELLED",
    "        ",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'bookingId': booking_id, 'status': 'CANCELLED'}",
    "        })",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"EVENT TICKET BOOKING API - DEMO\")",
    "    print(\"=\" * 60)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # Test 1: Create event",
    "    print(\"\\n[1] Creating event...\")",
    "    resp = api.create_event({",
    "        'name': 'Tech Conference 2024',",
    "        'date': '2024-12-15T09:00:00Z',",
    "        'venue': 'Convention Center',",
    "        'totalTickets': 100,",
    "        'pricePerTicket': 75.00",
    "    })",
    "    print(f\"    Status: {resp.status}, Body: {resp.body}\")",
    "    event_id = resp.body['data']['eventId']",
    "    ",
    "    # Test 2: Get event",
    "    print(\"\\n[2] Getting event...\")",
    "    resp = api.get_event(event_id)",
    "    print(f\"    Available: {resp.body['data']['availableTickets']}\")",
    "    ",
    "    # Test 3: Book tickets",
    "    print(\"\\n[3] Booking 2 tickets...\")",
    "    resp = api.book_tickets({",
    "        'eventId': event_id,",
    "        'userId': 'usr_123',",
    "        'numberOfTickets': 2",
    "    })",
    "    print(f\"    Status: {resp.status}, Total: ${resp.body['data']['totalAmount']}\")",
    "    booking_id = resp.body['data']['bookingId']",
    "    ",
    "    # Test 4: Verify availability decreased",
    "    resp = api.get_event(event_id)",
    "    print(f\"    Remaining tickets: {resp.body['data']['availableTickets']}\")",
    "    ",
    "    # Test 5: Validation error - missing field",
    "    print(\"\\n[4] Testing validation (missing name)...\")",
    "    resp = api.create_event({'date': '2024-12-20T10:00:00Z', 'venue': 'Hall'})",
    "    print(f\"    Status: {resp.status}, Error: {resp.body['error']['message']}\")",
    "    ",
    "    # Test 6: Overbooking attempt",
    "    print(\"\\n[5] Testing overbooking (requesting 200 tickets)...\")",
    "    resp = api.book_tickets({'eventId': event_id, 'userId': 'usr_456', 'numberOfTickets': 10})",
    "    # Book more to deplete",
    "    for _ in range(9):",
    "        api.book_tickets({'eventId': event_id, 'userId': 'usr_456', 'numberOfTickets': 10})",
    "    resp = api.book_tickets({'eventId': event_id, 'userId': 'usr_456', 'numberOfTickets': 10})",
    "    print(f\"    Status: {resp.status}, Error: {resp.body.get('error', {}).get('message', 'N/A')}\")",
    "    ",
    "    # Test 7: Cancel booking",
    "    print(\"\\n[6] Cancelling original booking...\")",
    "    resp = api.cancel_booking(booking_id)",
    "    print(f\"    Status: {resp.status}, New Status: {resp.body['data']['status']}\")",
    "    ",
    "    # Test 8: Verify tickets returned",
    "    resp = api.get_event(event_id)",
    "    print(f\"    Tickets after cancel: {resp.body['data']['availableTickets']}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"DEMO COMPLETE - All core functionality verified!\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.time.Instant;",
    "import java.util.*;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "",
    "public class TicketAPI {",
    "    ",
    "    // Enums and Data Classes",
    "    enum BookingStatus { CONFIRMED, CANCELLED }",
    "    ",
    "    static class Event {",
    "        String id, name, venue;",
    "        Instant date;",
    "        int totalTickets, availableTickets;",
    "        BigDecimal pricePerTicket;",
    "        ",
    "        Event(String id, String name, Instant date, String venue,",
    "              int totalTickets, BigDecimal price) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.availableTickets = totalTickets;",
    "            this.pricePerTicket = price;",
    "        }",
    "    }",
    "    ",
    "    static class Booking {",
    "        String id, eventId, userId;",
    "        int numberOfTickets;",
    "        BigDecimal totalAmount;",
    "        BookingStatus status;",
    "        Instant createdAt;",
    "        ",
    "        Booking(String id, String eventId, String userId, int tickets,",
    "                BigDecimal total, BookingStatus status) {",
    "            this.id = id;",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.numberOfTickets = tickets;",
    "            this.totalAmount = total;",
    "            this.status = status;",
    "            this.createdAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    static class Response {",
    "        int status;",
    "        Map<String, Object> body;",
    "        Response(int status, Map<String, Object> body) {",
    "            this.status = status;",
    "            this.body = body;",
    "        }",
    "    }",
    "    ",
    "    // State",
    "    private final Map<String, Event> events = new HashMap<>();",
    "    private final Map<String, Booking> bookings = new HashMap<>();",
    "    private int eventCounter = 0;",
    "    private int bookingCounter = 0;",
    "    private final ReentrantLock lock = new ReentrantLock();",
    "    ",
    "    private String generateEventId() {",
    "        return String.format(\"evt_%03d\", ++eventCounter);",
    "    }",
    "    ",
    "    private String generateBookingId() {",
    "        return String.format(\"bkg_%03d\", ++bookingCounter);",
    "    }",
    "    ",
    "    private Response errorResponse(int status, String code, String message) {",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", false);",
    "        Map<String, Object> error = new HashMap<>();",
    "        error.put(\"code\", code);",
    "        error.put(\"message\", message);",
    "        body.put(\"error\", error);",
    "        return new Response(status, body);",
    "    }",
    "    ",
    "    public Response createEvent(Map<String, Object> request) {",
    "        // Validate required fields",
    "        String[] required = {\"name\", \"date\", \"venue\", \"totalTickets\", \"pricePerTicket\"};",
    "        for (String field : required) {",
    "            if (!request.containsKey(field) || request.get(field) == null) {",
    "                return errorResponse(400, \"VALIDATION_ERROR\", ",
    "                    \"Missing required field: \" + field);",
    "            }",
    "        }",
    "        ",
    "        String eventId = generateEventId();",
    "        Event event = new Event(",
    "            eventId,",
    "            (String) request.get(\"name\"),",
    "            Instant.parse((String) request.get(\"date\")),",
    "            (String) request.get(\"venue\"),",
    "            (Integer) request.get(\"totalTickets\"),",
    "            new BigDecimal(request.get(\"pricePerTicket\").toString())",
    "        );",
    "        events.put(eventId, event);",
    "        ",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", eventId);",
    "        data.put(\"name\", event.name);",
    "        data.put(\"availableTickets\", event.availableTickets);",
    "        body.put(\"data\", data);",
    "        return new Response(201, body);",
    "    }",
    "    ",
    "    public Response getEvent(String eventId) {",
    "        if (!events.containsKey(eventId)) {",
    "            return errorResponse(404, \"NOT_FOUND\", \"Event \" + eventId + \" not found\");",
    "        }",
    "        ",
    "        Event e = events.get(eventId);",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", e.id);",
    "        data.put(\"name\", e.name);",
    "        data.put(\"availableTickets\", e.availableTickets);",
    "        data.put(\"pricePerTicket\", e.pricePerTicket.doubleValue());",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response listEvents(Map<String, Object> filters) {",
    "        if (filters == null) filters = new HashMap<>();",
    "        int limit = (Integer) filters.getOrDefault(\"limit\", 10);",
    "        int offset = (Integer) filters.getOrDefault(\"offset\", 0);",
    "        ",
    "        List<Event> all = new ArrayList<>(events.values());",
    "        List<Map<String, Object>> result = new ArrayList<>();",
    "        for (int i = offset; i < Math.min(offset + limit, all.size()); i++) {",
    "            Event e = all.get(i);",
    "            Map<String, Object> item = new HashMap<>();",
    "            item.put(\"eventId\", e.id);",
    "            item.put(\"name\", e.name);",
    "            item.put(\"availableTickets\", e.availableTickets);",
    "            result.add(item);",
    "        }",
    "        ",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"events\", result);",
    "        data.put(\"total\", all.size());",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response bookTickets(Map<String, Object> request) {",
    "        // Validate",
    "        String[] required = {\"eventId\", \"userId\", \"numberOfTickets\"};",
    "        for (String field : required) {",
    "            if (!request.containsKey(field)) {",
    "                return errorResponse(400, \"VALIDATION_ERROR\",",
    "                    \"Missing required field: \" + field);",
    "            }",
    "        }",
    "        ",
    "        String eventId = (String) request.get(\"eventId\");",
    "        if (!events.containsKey(eventId)) {",
    "            return errorResponse(404, \"NOT_FOUND\", \"Event \" + eventId + \" not found\");",
    "        }",
    "        ",
    "        // ATOMIC BOOKING",
    "        lock.lock();",
    "        try {",
    "            Event event = events.get(eventId);",
    "            int numTickets = (Integer) request.get(\"numberOfTickets\");",
    "            ",
    "            if (event.availableTickets < numTickets) {",
    "                return errorResponse(409, \"INSUFFICIENT_TICKETS\",",
    "                    \"Only \" + event.availableTickets + \" ticket(s) available, requested \" + numTickets);",
    "            }",
    "            ",
    "            String bookingId = generateBookingId();",
    "            BigDecimal total = event.pricePerTicket.multiply(new BigDecimal(numTickets));",
    "            ",
    "            Booking booking = new Booking(bookingId, eventId,",
    "                (String) request.get(\"userId\"), numTickets, total, BookingStatus.CONFIRMED);",
    "            ",
    "            event.availableTickets -= numTickets;",
    "            bookings.put(bookingId, booking);",
    "            ",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"eventId\", eventId);",
    "            data.put(\"numberOfTickets\", numTickets);",
    "            data.put(\"totalAmount\", total.doubleValue());",
    "            data.put(\"status\", \"CONFIRMED\");",
    "            body.put(\"data\", data);",
    "            return new Response(201, body);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "    ",
    "    public Response cancelBooking(String bookingId) {",
    "        if (!bookings.containsKey(bookingId)) {",
    "            return errorResponse(404, \"NOT_FOUND\", \"Booking \" + bookingId + \" not found\");",
    "        }",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Booking booking = bookings.get(bookingId);",
    "            if (booking.status == BookingStatus.CANCELLED) {",
    "                return errorResponse(409, \"ALREADY_CANCELLED\", \"Booking already cancelled\");",
    "            }",
    "            ",
    "            events.get(booking.eventId).availableTickets += booking.numberOfTickets;",
    "            booking.status = BookingStatus.CANCELLED;",
    "            ",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"status\", \"CANCELLED\");",
    "            body.put(\"data\", data);",
    "            return new Response(200, body);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\\n\" + \"=\".repeat(50));",
    "        System.out.println(\"TICKET API DEMO\");",
    "        System.out.println(\"=\".repeat(50));",
    "        ",
    "        TicketAPI api = new TicketAPI();",
    "        ",
    "        // Create event",
    "        Map<String, Object> eventReq = new HashMap<>();",
    "        eventReq.put(\"name\", \"Java Conference\");",
    "        eventReq.put(\"date\", \"2024-12-15T09:00:00Z\");",
    "        eventReq.put(\"venue\", \"Convention Center\");",
    "        eventReq.put(\"totalTickets\", 100);",
    "        eventReq.put(\"pricePerTicket\", 75.00);",
    "        Response resp = api.createEvent(eventReq);",
    "        System.out.println(\"\\nCreate: \" + resp.status + \" - \" + resp.body);",
    "        ",
    "        // Book tickets",
    "        Map<String, Object> bookReq = new HashMap<>();",
    "        bookReq.put(\"eventId\", \"evt_001\");",
    "        bookReq.put(\"userId\", \"usr_123\");",
    "        bookReq.put(\"numberOfTickets\", 2);",
    "        resp = api.bookTickets(bookReq);",
    "        System.out.println(\"Book: \" + resp.status + \" - \" + resp.body);",
    "        ",
    "        // Get event (check availability)",
    "        resp = api.getEvent(\"evt_001\");",
    "        System.out.println(\"Get: \" + resp.body.get(\"data\"));",
    "        ",
    "        System.out.println(\"\\nDemo complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-7",
      "section": "Imports",
      "explanation": "Import **Decimal** for precise currency math, **datetime** for event dates, **threading** for atomic operations. The Decimal import is CRITICAL - using float would cause precision errors like `75.50 * 3 = 226.49999...`"
    },
    {
      "lines": "9-11",
      "section": "BookingStatus Enum",
      "explanation": "Use Enum for type-safe status values. This prevents typos like 'Confirmed' vs 'CONFIRMED' and makes code self-documenting."
    },
    {
      "lines": "14-32",
      "section": "Data Classes (Event, Booking)",
      "explanation": "Using @dataclass for clean entity definitions. Key design: Event tracks both `total_tickets` and `available_tickets` - the invariant is `available + sum(booked) = total`."
    },
    {
      "lines": "42-56",
      "section": "TicketAPI.__init__",
      "explanation": "Initialize two dicts for O(1) lookups, counters for ID generation, and **threading.Lock** for atomic operations. The lock is the key to preventing race conditions in bookings."
    },
    {
      "lines": "63-96",
      "section": "Validation Methods",
      "explanation": "Separate validation returns errors as list - allows multiple error messages. Check required fields FIRST (return early), then validate types/ranges. This layered approach is clean and testable."
    },
    {
      "lines": "119-138",
      "section": "create_event",
      "explanation": "Pattern: validate \u2192 create entity \u2192 store \u2192 return success. Note `Decimal(str(request['pricePerTicket']))` - converting to string first ensures precision isn't lost from float."
    },
    {
      "lines": "165-201",
      "section": "book_tickets - THE CRITICAL METHOD",
      "explanation": "This is the heart of the system. Note the **`with self._lock:`** block - everything inside is atomic. The check `if event.available_tickets < num_tickets` MUST be inside the lock, not before it, to prevent race conditions."
    },
    {
      "lines": "203-220",
      "section": "cancel_booking",
      "explanation": "Also uses lock because we're updating both booking status AND event availability. Idempotency check: if already cancelled, return 409 not error - this is a business conflict."
    },
    {
      "lines": "223-270",
      "section": "Demo/Main",
      "explanation": "Comprehensive test demonstrating: creation, booking, availability updates, validation errors, overbooking rejection, and cancellation with ticket restoration. This shows the interviewer you test your code."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. First test createEvent alone - verify it returns 201 and stores event\n2. Then test getEvent - verify round-trip of data\n3. Then bookTickets with valid input - verify tickets decrement\n4. Then bookTickets with invalid inputs (missing field, too many tickets)\n5. Then cancel and verify tickets restored\n6. Finally, test edge cases like exact boundary booking",
    "what_to_print_or_assert": [
      "print(f'Events: {list(self.events.keys())}') after each operation",
      "print(f'Available: {event.available_tickets}') after booking",
      "assert resp.status == expected_status for each test case",
      "assert event.available_tickets >= 0, 'Invariant violated!'"
    ],
    "common_failure_modes": [
      "Check-then-act race condition - availability check outside lock",
      "Wrong status code - using 400 instead of 404 or 409",
      "Float precision - using float instead of Decimal",
      "Forgot to return tickets on cancel",
      "Validation order - checking ranges before checking presence"
    ],
    "how_to_fix_fast": "1. Add print statements at start/end of each method\n2. Run the demo and watch the flow\n3. If status code wrong, check error handling order\n4. If tickets wrong, trace the availability through each operation\n5. If race condition suspected, add print inside lock to verify atomicity"
  },
  "complexity_analysis": {
    "time": {
      "create_event": {
        "complexity": "O(1)",
        "explanation": "Dict insertion, constant-time operations"
      },
      "get_event": {
        "complexity": "O(1)",
        "explanation": "Dict lookup by key"
      },
      "list_events": {
        "complexity": "O(n) for n events",
        "explanation": "Need to convert dict values to list for pagination"
      },
      "book_tickets": {
        "complexity": "O(1)",
        "explanation": "Dict lookups + arithmetic. Lock acquisition is O(1) for low contention"
      },
      "cancel_booking": {
        "complexity": "O(1)",
        "explanation": "Dict lookups + updates"
      },
      "overall": "All core operations are O(1). list_events is O(n) but returns O(limit) items."
    },
    "space": {
      "complexity": "O(E + B) where E = events, B = bookings",
      "breakdown": "- Events dict: O(E) for E events\n- Bookings dict: O(B) for B bookings\n- Each entity is O(1) fixed-size fields\n- Lock is O(1)",
      "note": "This is optimal - we need to store all events and bookings."
    },
    "can_we_do_better": "Time is already O(1) for all operations. Space is minimal. For production, we'd add:\n- Database with indexes for O(log n) lookups at scale\n- Caching layer for frequently accessed events\n- Event partitioning for distributed systems"
  },
  "dry_run": {
    "example": "createEvent(100 tickets, $75) \u2192 bookTickets(2) \u2192 bookTickets(99) \u2192 cancelBooking \u2192 getEvent",
    "trace_table": "| Step | Operation | Events | Bookings | available_tickets | Response |\n|------|-----------|--------|----------|-------------------|----------|\n| 0 | init | {} | {} | - | - |\n| 1 | createEvent(100, $75) | {evt_001} | {} | 100 | 201, evt_001 |\n| 2 | bookTickets(evt_001, 2) | {evt_001} | {bkg_001: 2 tix} | 98 | 201, $150.00 |\n| 3 | bookTickets(evt_001, 99) | {evt_001} | {bkg_001: 2 tix} | 98 | **409 Conflict** (only 98 avail) |\n| 4 | cancelBooking(bkg_001) | {evt_001} | {bkg_001: CANCELLED} | 100 | 200, CANCELLED |\n| 5 | getEvent(evt_001) | {evt_001} | {bkg_001: CANCELLED} | 100 | 200, avail=100 |",
    "final_answer": "System correctly prevents overbooking (step 3) and restores tickets on cancellation (steps 4-5)"
  },
  "test_cases": [
    {
      "name": "Create event - all fields valid",
      "category": "Happy Path",
      "input": "createEvent({name: 'Conference', date: '2024-12-15', venue: 'Hall', totalTickets: 100, pricePerTicket: 75})",
      "expected": "201 Created, eventId returned",
      "explanation": "Basic successful creation with all required fields"
    },
    {
      "name": "Missing required field",
      "category": "Validation",
      "input": "createEvent({date: '2024-12-15', venue: 'Hall'})",
      "expected": "400 Bad Request, error details list name and pricePerTicket as missing",
      "explanation": "Validation should catch all missing fields, not just first"
    },
    {
      "name": "Book tickets - success",
      "category": "Happy Path",
      "input": "bookTickets({eventId: 'evt_001', userId: 'usr_123', numberOfTickets: 2})",
      "expected": "201 Created, totalAmount = 150.00",
      "explanation": "2 tickets at $75 = $150, availability decreases by 2"
    },
    {
      "name": "Book exactly remaining tickets",
      "category": "Boundary",
      "input": "100 tickets available, book 100",
      "expected": "201 Created, available becomes 0",
      "explanation": "Boundary condition - should succeed, not off-by-one"
    },
    {
      "name": "Overbooking by 1",
      "category": "Boundary",
      "input": "1 ticket available, request 2",
      "expected": "409 Conflict, message: 'Only 1 ticket(s) available, requested 2'",
      "explanation": "Off-by-one protection - message should be clear"
    },
    {
      "name": "Event not found",
      "category": "Error Handling",
      "input": "getEvent('nonexistent_id')",
      "expected": "404 Not Found, not 400",
      "explanation": "Not found is 404, not validation error"
    },
    {
      "name": "Cancel and verify tickets restored",
      "category": "State Management",
      "input": "Book 5, cancel, getEvent",
      "expected": "Available tickets restored to original",
      "explanation": "Cancellation must atomically update both booking and event"
    },
    {
      "name": "Cancel already-cancelled booking",
      "category": "Idempotency",
      "input": "cancelBooking(already_cancelled_id)",
      "expected": "409 Conflict, ALREADY_CANCELLED",
      "explanation": "Idempotency check - don't double-restore tickets"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float for currency",
      "why_wrong": "75.50 * 3 = 226.49999999... in float arithmetic",
      "correct_approach": "Use Decimal (Python) or BigDecimal (Java)",
      "code_wrong": "total = price * quantity  # float",
      "code_correct": "total = Decimal(str(price)) * quantity"
    },
    {
      "mistake": "Check-then-act race condition",
      "why_wrong": "Checking availability BEFORE acquiring lock allows concurrent overbooking",
      "correct_approach": "Check availability INSIDE the lock",
      "code_wrong": "if event.available >= requested:  # NOT LOCKED\n    with self.lock:\n        event.available -= requested",
      "code_correct": "with self.lock:  # LOCK FIRST\n    if event.available >= requested:\n        event.available -= requested"
    },
    {
      "mistake": "Wrong HTTP status codes",
      "why_wrong": "400 for not-found, 200 for created, 500 for business errors",
      "correct_approach": "404 for not found, 201 for created, 409 for business conflicts",
      "code_wrong": "if not found: return Response(400, ...)",
      "code_correct": "if not found: return Response(404, ...)"
    },
    {
      "mistake": "Not validating before business logic",
      "why_wrong": "TypeError/KeyError on missing fields crashes the system",
      "correct_approach": "Validate all input first, return 400 with details",
      "code_wrong": "event.name = request['name']  # May throw KeyError",
      "code_correct": "if 'name' not in request:\n    return error_response(400, 'name required')"
    },
    {
      "mistake": "Forgetting to return tickets on cancel",
      "why_wrong": "Tickets disappear forever, breaking invariant",
      "correct_approach": "Atomically update booking status AND increment available",
      "code_wrong": "booking.status = CANCELLED  # Forgot to restore tickets!",
      "code_correct": "event.available += booking.tickets\nbooking.status = CANCELLED"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to clarify a few things and share my high-level approach...",
    "clarifying_questions_to_ask": [
      "Should I use in-memory storage or design for a real database?",
      "What precision for currency? I'm planning to use Decimal for precision.",
      "For Part 1, should I implement thread-safety or just design for it?",
      "Are event IDs user-provided or system-generated?",
      "Should I handle timezone conversion for dates?"
    ],
    "what_to_mention_proactively": [
      "I'll use Decimal/BigDecimal for currency to avoid precision errors",
      "I'll structure this in layers: validation \u2192 business logic \u2192 data store",
      "Booking will use a lock to prevent race conditions and overbooking",
      "I'll use proper HTTP status codes: 201 for create, 404 for not found, 409 for conflicts"
    ],
    "communication_during_coding": [
      "I'm starting with the data models to establish the domain...",
      "Now the validation layer - I want to catch all errors before business logic...",
      "This is the critical section - the lock ensures atomic check-and-book...",
      "Notice I'm using Decimal(str(price)) to avoid float precision issues..."
    ],
    "if_stuck": [
      "Let me step back and list the operations I need to implement...",
      "What's the key constraint here? Oh right, atomic booking...",
      "Let me trace through an example to find the bug...",
      "Can I simplify and get the happy path working first?"
    ],
    "time_management": "0-7min: Clarify & approach | 7-15min: Data models | 15-35min: Core methods | 35-45min: Test & edge cases"
  },
  "pattern_recognition": {
    "pattern_name": "API Design with Atomic State Mutations",
    "indicators": [
      "CRUD operations",
      "Inventory/stock management",
      "Concurrent access possible",
      "Business rule enforcement"
    ],
    "similar_problems": [
      "Design a Parking Lot - similar slot booking with availability tracking",
      "Design LRU Cache - state management with O(1) operations",
      "Design Rate Limiter - atomic counter updates",
      "Meeting Scheduler - resource (room) booking with conflicts"
    ],
    "template": "1. Define entities with clear invariants\n2. Separate validation from business logic\n3. Use locks/transactions for atomic operations\n4. Return proper status codes for each error type"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 adds Authentication and Authorization. You'll need to:\n- Add user token validation before processing\n- Check user permissions (can user X book event Y?)\n- Add rate limiting per user\n\n**Hook in current design**: Add auth check at start of each public method, before validation.",
    "part_3_hint": "Part 3 is Concurrency and Race Conditions. You'll need:\n- Replace threading.Lock with database transactions\n- Handle distributed locking (Redis/ZooKeeper)\n- Test with concurrent load\n\n**Hook in current design**: The `with self._lock:` sections are exactly where you'd swap in distributed locks.",
    "data_structure_evolution": "Part 1: Dict + Lock (in-memory)\n\u2192 Part 2: Add User entity, permission checks\n\u2192 Part 3: Replace Lock with DB transactions, add event log\n\u2192 Part 4: Add metrics, circuit breakers, retry logic"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. This is a ticket booking API with CRUD operations and atomic booking. Before I code, I want to clarify: should I use in-memory storage for Part 1, and do you want me to implement thread-safety now or just design for it?",
    "after_clarification": "Great, so I'll use in-memory dicts with a threading lock for atomicity. My approach is: define entities first, then a validation layer, then the API methods with proper status codes. The key insight is that booking must be atomic to prevent overbooking. Sound good?",
    "while_coding": [
      "I'm using a dataclass for Event - clean and immutable fields...",
      "This validation returns a list so we can report multiple errors...",
      "Notice the lock here - check AND decrement must be together...",
      "Using Decimal for the price to avoid 75.50 * 3 = 226.499999..."
    ],
    "after_coding": "Let me trace through the demo to verify. Create event with 100 tickets... book 2... available should be 98... try to book 99... should get 409 Conflict... cancel... tickets restored to 100. All working.",
    "when_stuck_verbatim": "I'm thinking about how to handle the concurrent case... Let me draw out the race condition scenario... Ah, I see - the check needs to be inside the lock, not outside.",
    "after_mistake": "Oh wait, I'm returning 400 for not-found but it should be 404. Let me fix that. 400 is for validation errors, 404 is for missing resources.",
    "before_moving_on": "Part 1 is complete. Complexity is O(1) for all operations, O(n) for list with pagination. Space is O(events + bookings). Ready for Part 2 - auth and authorization?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Clean separation of concerns",
      "Correct HTTP semantics",
      "Thread-safety awareness",
      "Decimal for money",
      "Input validation",
      "Edge case handling",
      "Clear communication"
    ],
    "bonus_points": [
      "Mentioning Decimal before being asked",
      "Drawing the race condition scenario",
      "Proactively testing edge cases",
      "Clean variable names and structure",
      "Asking about production concerns (logging, monitoring)"
    ],
    "red_flags": [
      "Using float for money",
      "Check-then-act without lock",
      "Wrong status codes (400 for everything)",
      "No input validation",
      "Silent coding without explanation",
      "Hardcoded test values in production code"
    ],
    "what_differentiates_strong_candidates": "Strong candidates explain WHY they make design choices, not just WHAT they're doing. They mention tradeoffs (global lock is fine for Part 1, need per-event locks for scale). They test their own code and fix bugs gracefully."
  },
  "time_milestones": {
    "by_5_min": "Problem understood, clarifying questions asked, approach decided",
    "by_10_min": "Data models defined (Event, Booking, Response), validation approach clear",
    "by_20_min": "createEvent and getEvent implemented and tested",
    "by_30_min": "bookTickets with lock implemented, tested overbooking case",
    "by_40_min": "cancelBooking done, all tests passing, edge cases verified",
    "by_45_min": "Complexity discussed, ready for Part 2",
    "warning_signs": "Still designing at 15 min? Too slow. Not testing by 35 min? Won't find bugs. Part 1 not done by 45 min? Won't complete the interview."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Say: 'Actually, I see an issue - I'm using float here but should use Decimal for currency precision. Let me fix that.' Fix it cleanly and move on. Bugs are expected; recovery is evaluated.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact Decimal syntax - let me check' or 'I'll write it as Decimal(str(value)) which I know works'. Never pretend.",
    "when_approach_is_wrong": "Say: 'Wait, I just realized checking availability outside the lock creates a race condition. Let me restructure this.' The ability to self-correct is a STRONG signal.",
    "when_completely_stuck": "Say: 'I'm stuck on how to make this atomic. Could you confirm whether a simple lock is acceptable for Part 1, or should I design for distributed transactions?'",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on getting book and cancel working correctly, and I'll mention what I'd add for edge cases.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them WISELY - they're evaluating YOU, not the AI.",
    "what_to_do": [
      "Let AI generate boilerplate (dataclass, imports)",
      "Use for syntax you forgot (Decimal conversion)",
      "Generate test cases from your logic",
      "Autocomplete obvious code"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and accept the solution",
      "Don't accept suggestions without understanding them",
      "Don't rely on AI for the key insight (atomicity, Decimal)",
      "Don't let AI write the critical lock section without verification"
    ],
    "how_to_demonstrate_understanding": "If AI suggests code, explain WHY it works: 'This uses a lock because we need atomic check-and-update.' The interviewer is testing YOUR knowledge.",
    "expectation_adjustment": "With AI, you should complete MORE parts and have cleaner code. If you're slower with AI, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately mentioning Decimal for currency precision",
      "Drawing the race condition scenario on first mention of booking",
      "Using proper HTTP status codes without being reminded",
      "Proactively handling edge cases (already-cancelled, boundary conditions)",
      "Clean layered architecture with validation separate from logic"
    ],
    "subtle_signals_of_experience": [
      "Checking validation BEFORE business logic (fail fast)",
      "Using _private methods for internal helpers",
      "Error responses with structured details (code + message + details)",
      "Thinking about what Part 2/3 might need",
      "Testing incrementally, not just at the end"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Silent coding for more than 60 seconds",
      "Defensive when bug is pointed out",
      "Not asking any clarifying questions",
      "Rushing to code without thinking"
    ],
    "technical": [
      "Using float for money (CRITICAL)",
      "Check-then-act without lock (CRITICAL)",
      "Wrong status codes",
      "No input validation",
      "Hardcoding values",
      "Not testing"
    ],
    "communication": [
      "Using jargon without explaining",
      "Not summarizing approach before coding",
      "Not mentioning complexity",
      "Not walking through test cases"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2713 createEvent validates all required fields, returns 201",
      "\u2713 getEvent returns 404 for missing event, not 400",
      "\u2713 bookTickets uses lock for atomic check-and-decrement",
      "\u2713 bookTickets returns 409 for insufficient tickets",
      "\u2713 cancelBooking restores tickets AND sets status",
      "\u2713 Using Decimal for all money calculations",
      "\u2713 Traced through at least one example",
      "\u2713 Mentioned time/space complexity"
    ],
    "quick_code_review": [
      "No magic numbers",
      "Consistent naming (snake_case for Python)",
      "Lock used correctly (with statement)",
      "Proper error messages",
      "No unused variables"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input sanitization for XSS/injection attacks",
      "Request ID for tracing across logs",
      "Metrics: booking count, latency, error rates",
      "Database transactions instead of in-memory lock",
      "Retry logic with exponential backoff",
      "Circuit breaker for downstream dependencies",
      "Structured logging with correlation IDs"
    ],
    "why_not_in_interview": "Interview code should focus on core algorithm and design. Mention these verbally to show senior thinking, but implementing them wastes precious time.",
    "how_to_mention": "Say: 'In production, I'd add request tracing, metrics, and database transactions. For this interview, I'm focusing on the core logic and proper status codes.'"
  },
  "generated_at": "2026-01-19T04:09:18.255575",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}