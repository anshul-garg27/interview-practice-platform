{
  "problem_title": "Task Scheduling with Dependencies - Part 2: Limited Workers",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 assumed unlimited workers (infinite parallelism). Part 2 introduces a resource constraint: exactly k workers are available. Tasks may be 'ready' (dependencies satisfied) but must wait if all workers are busy. This transforms from a pure critical-path problem to a scheduling simulation problem.",
    "new_requirements": [
      "Track worker availability with a min-heap",
      "Task start time = max(dependencies_done, worker_available)",
      "Simulate time progression rather than just computing critical path"
    ],
    "new_constraints": [
      "1 \u2264 k \u2264 n (number of tasks)",
      "Each worker handles exactly one task at a time",
      "Cannot start task until worker is free AND dependencies are done"
    ],
    "key_insight": "Use a min-heap to track when each worker becomes free. Process tasks in topological order, but each task's start time is max(prereqs_done, earliest_worker_free). This elegantly handles both dependency and resource constraints."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Handle limited workers",
        "how_met": "Min-heap tracks k worker free times",
        "gotchas": [
          "Must heappush after heappop even if same time"
        ]
      },
      {
        "requirement": "Respect dependencies",
        "how_met": "Topological sort ensures prereqs processed first",
        "gotchas": [
          "Don't forget to track completion_time for prereq lookup"
        ]
      },
      {
        "requirement": "Return minimum total time",
        "how_met": "max(completion_time.values()) after simulation",
        "gotchas": [
          "With k workers, total time \u2265 Part 1 result"
        ]
      },
      {
        "requirement": "Detect cycles",
        "how_met": "Same check: len(order) != len(tasks)",
        "gotchas": [
          "Return -1 for cycles, same as Part 1"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "scheduleTasksWithWorkers",
        "target": "O((V+E) + V log k)",
        "achieved": "O((V+E) + V log k)",
        "why": "Topo sort is O(V+E), each task does one heap push/pop at O(log k)"
      }
    ],
    "non_goals": [
      "Optimal task ordering within same priority level",
      "Preemption (tasks run to completion)",
      "Worker assignment optimization"
    ]
  },
  "assumptions": [
    "k \u2265 1 (at least one worker)",
    "k \u2264 n is typical but algorithm works for k > n too",
    "All task IDs in dependencies exist in taskList",
    "No duplicate tasks"
  ],
  "tradeoffs": [
    {
      "decision": "Min-heap vs array for workers",
      "chosen": "Min-heap",
      "why": "O(log k) per operation vs O(k) scan",
      "alternative": "Array with linear scan",
      "when_to_switch": "If k is very small (k \u2264 3)"
    },
    {
      "decision": "Reuse Part 1 graph building",
      "chosen": "Duplicate code",
      "why": "Clear separation, no side effects",
      "alternative": "Extract to helper method",
      "when_to_switch": "If adding Part 3 with same graph"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "schedule_tasks method signature",
      "Graph building approach",
      "Cycle detection logic"
    ],
    "what_to_change": [
      "Added worker_heap for tracking worker availability",
      "Modified completion_time calculation"
    ],
    "interfaces_and_boundaries": "New method is independent - could add worker priorities, task priorities, or preemption in future parts",
    "invariants": [
      "completion_time[task] \u2265 duration[task] always",
      "completion_time[task] \u2265 completion_time[prereq] + duration[task] for all prereqs",
      "Worker heap always has exactly k elements"
    ]
  },
  "visual_explanation": {
    "before_after": "Part 1 (Unlimited):          Part 2 (k=2):\n                               \nt=0  t=5                      t=0  t=5  t=10\n|----|-                       |----|----|----|\n\u2588\u2588\u2588 Task1 (5)                 \u2588\u2588\u2588 Task1\u2502     \u2502\n\u2588\u2588\u2588 Task2 (5)                 \u2588\u2588\u2588 Task2\u2502     \u2502\n\u2588\u2588\u2588 Task3 (5)                      \u2502\u2588\u2588\u2588 Task3\u2502\n                                   \u2502         \u2502\nTotal: 5                      Total: 10\n(all parallel)                (Task3 waits for worker)",
    "algorithm_flow": "1. Initialize k workers at t=0: heap = [0, 0, ..., 0]\n2. BFS queue with in_degree=0 tasks\n3. For each task in topo order:\n   a. prereq_done = max(completion_time[p] for p in prereqs)\n   b. worker_free = heappop(worker_heap)\n   c. start = max(prereq_done, worker_free)\n   d. completion = start + duration\n   e. heappush(worker_heap, completion)\n4. Return max(completion_time.values())"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Try all possible task assignments to workers (brute force scheduling)",
      "time_complexity": "O(k^n) or worse",
      "space_complexity": "O(n)",
      "why_not_optimal": "Exponential - doesn't leverage that topological order gives valid schedule"
    },
    {
      "name": "Optimal Approach: Topo Sort + Worker Heap",
      "description": "Process tasks in topological order, using min-heap to track earliest available worker. Each task starts at max(dependencies_done, worker_free).",
      "time_complexity": "O((V+E) + V log k)",
      "space_complexity": "O(V + E + k)",
      "key_insight": "Topological order guarantees prereqs are done when we process a task. The heap gives earliest worker. max() of both gives correct start time."
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Core Insight**: With limited workers, we need a **simulation** rather than just critical path calculation.\n\n**Why it works**:\n1. **Topological order** ensures when we process task T, all its prerequisites have known completion times\n2. **Min-heap** efficiently finds the earliest available worker in O(log k)\n3. **max(prereq_done, worker_free)** correctly handles both constraints:\n   - If prereqs finish late, task waits for them\n   - If all prereqs done but workers busy, task waits for worker\n\n**Key Formula**: `start_time[task] = max(max(completion[prereq]), min(worker_free_times))`",
    "data_structures": [
      {
        "structure": "Min-Heap (worker_heap)",
        "purpose": "Track when each of k workers becomes free. Pop gives earliest available."
      },
      {
        "structure": "HashMap (completion_time)",
        "purpose": "Store completion time of each task for prereq lookups"
      },
      {
        "structure": "Deque (queue)",
        "purpose": "BFS queue for topological sort"
      }
    ],
    "algorithm_steps": [
      "Step 1: Build graph structures (same as Part 1)",
      "Step 2: Initialize worker_heap with k zeros (all workers free at t=0)",
      "Step 3: Start BFS with tasks having in_degree=0",
      "Step 4: For each task: calculate prereq_done time from reverse_graph",
      "Step 5: Pop earliest free worker from heap",
      "Step 6: Task starts at max(prereq_done, worker_free)",
      "Step 7: Push new worker free time (completion) back to heap",
      "Step 8: Update dependents' in_degrees, add ready tasks to queue",
      "Step 9: Return max completion time (or -1 if cycle)"
    ]
  },
  "solution_python_lines": [
    "from collections import defaultdict, deque",
    "from typing import List, Tuple",
    "import heapq",
    "",
    "class TaskScheduler:",
    "    \"\"\"Task scheduling with dependencies and limited workers.\"\"\"",
    "    ",
    "    def schedule_tasks(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "        \"\"\"Part 1: Unlimited workers. Returns (min_time, order) or (-1, []) if cycle.\"\"\"",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            max_prereq_time = max((completion_time[p] for p in reverse_graph[task]), default=0)",
    "            completion_time[task] = max_prereq_time + duration[task]",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return (-1, [])",
    "        return (max(completion_time.values()), order)",
    "    ",
    "    def schedule_tasks_with_workers(self, task_list: List[List[int]], dependency_list: List[List[int]], k: int) -> int:",
    "        \"\"\"",
    "        Part 2: Schedule with k limited workers.",
    "        Uses topo sort + min-heap for worker tracking.",
    "        Time: O(V+E + V log k), Space: O(V+E)",
    "        \"\"\"",
    "        if not task_list:",
    "            return 0",
    "        ",
    "        # Build graph (same as Part 1)",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        # Topo sort with worker simulation",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        ",
    "        # Min-heap: worker free times (k workers, all free at t=0)",
    "        worker_heap = [0] * k",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            ",
    "            # When are all prereqs done?",
    "            prereq_done = max((completion_time[p] for p in reverse_graph[task]), default=0)",
    "            ",
    "            # When is earliest worker free?",
    "            worker_free = heapq.heappop(worker_heap)",
    "            ",
    "            # Task starts when BOTH conditions met",
    "            start_time = max(prereq_done, worker_free)",
    "            completion_time[task] = start_time + duration[task]",
    "            ",
    "            # Worker busy until task completes",
    "            heapq.heappush(worker_heap, completion_time[task])",
    "            ",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return -1",
    "        return max(completion_time.values())",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 2: Limited Workers Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    scheduler = TaskScheduler()",
    "    ",
    "    # Example 1: Independent tasks with k=2",
    "    tasks1 = [[1, 5], [2, 5], [3, 5]]",
    "    deps1 = []",
    "    print(\"\\nIndependent Tasks (k=2):\")",
    "    print(f\"  Tasks: {tasks1}\")",
    "    print(f\"  Unlimited: {scheduler.schedule_tasks(tasks1, deps1)[0]}\")",
    "    print(f\"  With k=2:  {scheduler.schedule_tasks_with_workers(tasks1, deps1, 2)}\")",
    "    print(\"  Expected: 5 unlimited, 10 with k=2\")",
    "    ",
    "    # Example 2: Diamond pattern",
    "    tasks2 = [[1, 3], [2, 2], [3, 5], [4, 3]]",
    "    deps2 = [[1, 2], [1, 3], [2, 4], [3, 4]]",
    "    print(\"\\nDiamond Pattern (k=2):\")",
    "    print(f\"  Unlimited: {scheduler.schedule_tasks(tasks2, deps2)[0]}\")",
    "    print(f\"  With k=2:  {scheduler.schedule_tasks_with_workers(tasks2, deps2, 2)}\")",
    "    print(\"  Expected: 11 for both (critical path dominates)\")",
    "    ",
    "    # Example 3: Many tasks, few workers",
    "    tasks3 = [[i, 2] for i in range(1, 6)]  # 5 tasks, 2 units each",
    "    deps3 = []",
    "    print(\"\\n5 Independent Tasks (k=1 vs k=3):\")",
    "    print(f\"  Unlimited: {scheduler.schedule_tasks(tasks3, deps3)[0]}\")",
    "    print(f\"  With k=1:  {scheduler.schedule_tasks_with_workers(tasks3, deps3, 1)}\")",
    "    print(f\"  With k=3:  {scheduler.schedule_tasks_with_workers(tasks3, deps3, 3)}\")",
    "    print(\"  Expected: 2 unlimited, 10 with k=1, 4 with k=3\")",
    "    ",
    "    # Example 4: Cycle detection",
    "    tasks4 = [[1, 2], [2, 3], [3, 1]]",
    "    deps4 = [[1, 2], [2, 3], [3, 1]]",
    "    print(\"\\nCycle Detection:\")",
    "    print(f\"  Result: {scheduler.schedule_tasks_with_workers(tasks4, deps4, 2)}\")",
    "    print(\"  Expected: -1 (cycle)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class TaskScheduler {",
    "    ",
    "    /** Part 1: Unlimited workers. Returns [totalTime, order...] or [-1] if cycle. */",
    "    public int[] scheduleTasks(int[][] taskList, int[][] dependencyList) {",
    "        if (taskList == null || taskList.length == 0) return new int[]{0};",
    "        ",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            int maxPrereq = reverseGraph.get(task).stream()",
    "                .mapToInt(completionTime::get).max().orElse(0);",
    "            completionTime.put(task, maxPrereq + duration.get(task));",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        if (order.size() != duration.size()) return new int[]{-1};",
    "        int total = Collections.max(completionTime.values());",
    "        int[] result = new int[order.size() + 1];",
    "        result[0] = total;",
    "        for (int i = 0; i < order.size(); i++) result[i + 1] = order.get(i);",
    "        return result;",
    "    }",
    "    ",
    "    /** Part 2: Schedule with k limited workers. Returns min time or -1 if cycle. */",
    "    public int scheduleTasksWithWorkers(int[][] taskList, int[][] dependencyList, int k) {",
    "        if (taskList == null || taskList.length == 0) return 0;",
    "        ",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        ",
    "        // Min-heap: worker free times",
    "        PriorityQueue<Integer> workerHeap = new PriorityQueue<>();",
    "        for (int i = 0; i < k; i++) workerHeap.offer(0);",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            ",
    "            // When are prereqs done?",
    "            int prereqDone = reverseGraph.get(task).stream()",
    "                .mapToInt(completionTime::get).max().orElse(0);",
    "            ",
    "            // When is earliest worker free?",
    "            int workerFree = workerHeap.poll();",
    "            ",
    "            // Task starts when both conditions met",
    "            int startTime = Math.max(prereqDone, workerFree);",
    "            completionTime.put(task, startTime + duration.get(task));",
    "            workerHeap.offer(completionTime.get(task));",
    "            ",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        if (order.size() != duration.size()) return -1;",
    "        return Collections.max(completionTime.values());",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        TaskScheduler s = new TaskScheduler();",
    "        ",
    "        // Independent tasks",
    "        int[][] t1 = {{1,5}, {2,5}, {3,5}};",
    "        int[][] d1 = {};",
    "        System.out.println(\"Independent (k=2): \" + s.scheduleTasksWithWorkers(t1, d1, 2));",
    "        System.out.println(\"Expected: 10\");",
    "        ",
    "        // Diamond pattern",
    "        int[][] t2 = {{1,3}, {2,2}, {3,5}, {4,3}};",
    "        int[][] d2 = {{1,2}, {1,3}, {2,4}, {3,4}};",
    "        System.out.println(\"Diamond (k=2): \" + s.scheduleTasksWithWorkers(t2, d2, 2));",
    "        System.out.println(\"Expected: 11\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-4",
      "explanation": "Imports: collections for graph structures, heapq for worker min-heap"
    },
    {
      "lines": "6-35",
      "explanation": "Part 1 schedule_tasks - unchanged from original, provides baseline comparison"
    },
    {
      "lines": "37-44",
      "explanation": "Part 2 docstring and edge case handling for empty input"
    },
    {
      "lines": "46-57",
      "explanation": "Graph building - identical to Part 1, creates forward/reverse edges and in_degree"
    },
    {
      "lines": "59-63",
      "explanation": "Initialize BFS queue and worker_heap with k zeros (all workers free at t=0)"
    },
    {
      "lines": "65-80",
      "explanation": "Main simulation loop: for each task, calculate prereq_done, get worker, compute start/completion times"
    },
    {
      "lines": "72-76",
      "explanation": "KEY INSIGHT: start_time = max(prereq_done, worker_free) - handles both constraints"
    },
    {
      "lines": "82-84",
      "explanation": "Cycle detection and return max completion time"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "scheduleTasksWithWorkers": {
          "complexity": "O((V+E) + V log k)",
          "explanation": "Topo sort is O(V+E). Each of V tasks does one heappop and heappush at O(log k) each."
        }
      },
      "overall_change": "Adds O(V log k) to Part 1's O(V+E). For k << V, this is negligible. For k \u2248 V, still O(V log V)."
    },
    "space": {
      "additional_space": "O(k)",
      "explanation": "Worker heap stores k elements. All other structures same as Part 1: O(V+E)."
    }
  },
  "dry_run": {
    "example_input": "tasks=[[1,5],[2,5],[3,5]], deps=[], k=2",
    "steps": [
      {
        "step": 1,
        "action": "Initialize",
        "state": "worker_heap=[0,0], queue=[1,2,3], completion_time={}",
        "explanation": "All workers free at t=0, all tasks have in_degree=0"
      },
      {
        "step": 2,
        "action": "Process task 1",
        "state": "prereq_done=0, worker_free=0\u2192heappop",
        "explanation": "No prereqs, first worker available at t=0"
      },
      {
        "step": 3,
        "action": "Complete task 1",
        "state": "start=0, completion[1]=5, worker_heap=[0,5]",
        "explanation": "Worker 1 busy until t=5"
      },
      {
        "step": 4,
        "action": "Process task 2",
        "state": "prereq_done=0, worker_free=0\u2192heappop",
        "explanation": "Second worker still free at t=0"
      },
      {
        "step": 5,
        "action": "Complete task 2",
        "state": "start=0, completion[2]=5, worker_heap=[5,5]",
        "explanation": "Worker 2 busy until t=5"
      },
      {
        "step": 6,
        "action": "Process task 3",
        "state": "prereq_done=0, worker_free=5\u2192heappop",
        "explanation": "Both workers busy until t=5"
      },
      {
        "step": 7,
        "action": "Complete task 3",
        "state": "start=5, completion[3]=10, worker_heap=[5,10]",
        "explanation": "Task 3 waits for worker, starts at t=5"
      },
      {
        "step": 8,
        "action": "Return",
        "state": "max(5,5,10)=10",
        "explanation": "Total time = 10"
      }
    ],
    "final_output": "10"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single task with k=1 should return its duration",
      "n tasks, k=n, no deps should return max(durations)"
    ],
    "likely_bugs": [
      "Forgetting to heappush after heappop",
      "Using queue.pop() instead of popleft()",
      "Not initializing heap with k zeros"
    ],
    "recommended_logs_or_asserts": [
      "assert len(worker_heap) == k after each iteration",
      "print task, prereq_done, worker_free, completion for debugging"
    ],
    "how_to_localize": "1) Verify topo order is valid. 2) Check worker_heap has k elements. 3) Trace one task manually."
  },
  "edge_cases": [
    {
      "case": "k=1 (single worker)",
      "handling": "All tasks sequential, total = sum(durations) along longest chain",
      "gotcha": "Heap still works, just always has one element"
    },
    {
      "case": "k >= n (more workers than tasks)",
      "handling": "Degenerates to Part 1 (unlimited)",
      "gotcha": "Algorithm still correct, just heap larger than needed"
    },
    {
      "case": "Empty task list",
      "handling": "Return 0",
      "gotcha": "Check before building graph"
    },
    {
      "case": "Cycle in dependencies",
      "handling": "Return -1 when len(order) != len(tasks)",
      "gotcha": "Same as Part 1"
    }
  ],
  "test_cases": [
    {
      "name": "Basic - workers limit throughput",
      "input": "tasks=[[1,5],[2,5],[3,5]], deps=[], k=2",
      "expected": "10",
      "explanation": "3 tasks, 2 workers. Tasks 1,2 parallel (0-5), Task 3 waits (5-10)."
    },
    {
      "name": "Critical path dominates",
      "input": "tasks=[[1,3],[2,2],[3,5],[4,3]], deps=[[1,2],[1,3],[2,4],[3,4]], k=2",
      "expected": "11",
      "explanation": "Critical path 1\u21923\u21924 = 11. Having 2 workers doesn't help."
    },
    {
      "name": "Single worker",
      "input": "tasks=[[1,2],[2,3],[3,4]], deps=[], k=1",
      "expected": "9",
      "explanation": "All sequential: 2+3+4=9."
    },
    {
      "name": "Cycle detection",
      "input": "tasks=[[1,1],[2,1]], deps=[[1,2],[2,1]], k=2",
      "expected": "-1",
      "explanation": "Cycle 1\u21942, impossible to schedule."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not using max() for start time",
      "why_wrong": "Task must wait for BOTH prereqs AND worker. Using just worker_free ignores prereqs.",
      "correct_approach": "start = max(prereq_done, worker_free)",
      "code_example_wrong": "start = worker_free  # Wrong!",
      "code_example_correct": "start = max(prereq_done, worker_free)"
    },
    {
      "mistake": "Forgetting to push back to heap",
      "why_wrong": "Heap loses a worker, eventually empty causing crash",
      "correct_approach": "Always heappush after heappop",
      "code_example_wrong": "worker_free = heappop(heap)\\n# missing heappush",
      "code_example_correct": "worker_free = heappop(heap)\\n# ... compute completion\\nheappush(heap, completion)"
    },
    {
      "mistake": "Wrong heap initialization",
      "why_wrong": "Starting with empty heap or wrong size",
      "correct_approach": "Initialize with k zeros",
      "code_example_wrong": "heap = []",
      "code_example_correct": "heap = [0] * k"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining: 'The key insight is that Part 1's topo sort still works, but now task start time is max(prereqs_done, worker_available). I'll use a min-heap to efficiently track workers.'",
    "what_to_mention": [
      "O(log k) per task for heap operations",
      "Algorithm degrades gracefully to Part 1 when k \u2265 n",
      "Same cycle detection works"
    ],
    "time_allocation": "2 min: explain approach. 8 min: code. 2 min: test/trace.",
    "if_stuck": [
      "Draw the worker heap state over time",
      "Trace through the 3-task k=2 example manually",
      "Ask: 'Can I assume k \u2265 1?'"
    ]
  },
  "connection_to_next_part": "Part 3 might add: task priorities, worker specialization, preemption, or real-time scheduling constraints. The heap-based simulation framework extends naturally to these.",
  "communication_script": {
    "transition_from_previous": "Part 1 assumed unlimited workers. Now with k workers, a ready task might wait for a worker. I'll extend the solution by adding a min-heap to track worker availability.",
    "explaining_changes": "The key change is: instead of starting a task immediately when prereqs are done, we now wait for BOTH prereqs AND an available worker. I'm adding a min-heap of worker free times.",
    "while_extending_code": [
      "Adding worker_heap = [0] * k to track k workers starting at time 0",
      "Popping earliest free worker, computing start time as max of constraints",
      "Pushing new completion time back to maintain heap"
    ],
    "after_completing": "This handles k workers in O(V+E + V log k) time. The heap add O(log k) per task. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "10-15 minutes for this part",
    "by_2_min": "Understand the change: limited workers means tasks may wait even when ready",
    "by_5_min": "Explain heap-based simulation, start coding",
    "by_10_min": "Implementation done, tracing through example",
    "warning_signs": "If stuck on how to integrate heap with topo sort at 5 min, ask for hint"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "The new method is largely independent. If Part 1 has a bug, mention it but proceed with Part 2.",
    "if_new_requirement_unclear": "Ask: 'Does k workers mean exactly k available, or up to k?'",
    "if_running_behind": "Skip optimizations, focus on getting the heap simulation working correctly."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing min-heap for worker scheduling",
      "Explaining why max(prereq, worker) handles both constraints",
      "Noting that algorithm reduces to Part 1 when k \u2265 n",
      "Mentioning this is similar to process scheduling in OS"
    ]
  },
  "pattern_recognition": {
    "pattern": "Simulation with Priority Queue",
    "indicators": [
      "Limited resources (k workers)",
      "Events at different times",
      "Need to track 'next available'"
    ],
    "similar_problems": [
      "LC 1882 - Process Tasks Using Servers",
      "LC 621 - Task Scheduler",
      "LC 358 - Rearrange String k Distance Apart"
    ],
    "template": "heap = [initial_states]\\nwhile tasks_remain:\\n    resource = heappop(heap)\\n    assign_task_to_resource()\\n    heappush(heap, new_resource_state)"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Limited resources (k workers) \u2192 need to track availability",
      "why": "Classic resource scheduling pattern"
    },
    {
      "step": 2,
      "thought": "Finding 'earliest available' efficiently \u2192 min-heap",
      "why": "O(log k) vs O(k) linear scan"
    },
    {
      "step": 3,
      "thought": "Dependencies still matter \u2192 keep topo sort",
      "why": "Can't start task until prereqs done"
    },
    {
      "step": 4,
      "thought": "Combine constraints with max()",
      "why": "Task starts when BOTH conditions satisfied"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you identify min-heap as the right data structure?",
      "Do you understand how to combine dependency and resource constraints?",
      "Clean extension of existing code?"
    ],
    "bonus_points": [
      "Analyzing when workers vs critical path is the bottleneck",
      "Mentioning this models real build systems",
      "Discussing when k workers equals unlimited"
    ],
    "red_flags": [
      "Rewriting topo sort from scratch",
      "Using O(k) scan instead of heap",
      "Forgetting to handle cycles"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with heapq syntax if unsure",
      "Use AI for boilerplate like graph building"
    ],
    "what_not_to_do": [
      "Don't let AI change the approach to event-driven simulation (overkill)",
      "Verify heap operations are correct"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining the heap insight",
      "Not tracing through an example"
    ],
    "technical": [
      "O(k) linear scan instead of O(log k) heap",
      "Wrong heap direction (max-heap instead of min-heap)"
    ],
    "communication": [
      "Not explaining why max(prereq, worker) is correct",
      "Forgetting to mention complexity improvement"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I initialize heap with k zeros?",
      "Am I using max(prereq_done, worker_free)?",
      "Do I push back to heap after popping?",
      "Does cycle detection still work?"
    ],
    "quick_code_review": [
      "heapq imported",
      "worker_heap = [0] * k",
      "heappush after heappop in every iteration"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging which worker handles which task",
      "Return full schedule not just time",
      "Handle worker failures/recovery"
    ],
    "why_not_in_interview": "Focus on core algorithm; these are mentioned verbally",
    "how_to_mention": "Say: 'In production, I'd return the full schedule with task-to-worker assignments for debugging.'"
  },
  "generated_at": "2026-01-19T04:49:50.936098",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}