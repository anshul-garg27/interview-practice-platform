{
  "problem_title": "Design a Hotel Booking/Reservation System - Part 2: Handling Concurrent Bookings",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 adds explicit support for different concurrency control strategies. While Part 1 used a simple NOWAIT pessimistic approach, Part 2 requires implementing and comparing three distinct strategies: PESSIMISTIC (with configurable timeout), OPTIMISTIC (with version checking), and CONSTRAINT-based (relying on database uniqueness). This allows the system to choose the appropriate strategy based on expected contention levels.",
    "new_requirements": [
      "Support three locking strategies: PESSIMISTIC, OPTIMISTIC, CONSTRAINT",
      "PESSIMISTIC: Wait up to timeout for lock, fail with LOCK_TIMEOUT if exceeded",
      "OPTIMISTIC: Read version, process, verify version unchanged at commit, fail with VERSION_CONFLICT if changed",
      "CONSTRAINT: No explicit locking, rely on database UNIQUE constraint to prevent duplicates",
      "Each strategy must still guarantee no double-bookings"
    ],
    "new_constraints": [
      "Lock timeout should be configurable (default ~2 seconds)",
      "Optimistic approach must track versions per room",
      "All strategies must maintain the same invariants from Part 1",
      "Must handle distributed server scenario conceptually"
    ],
    "key_insight": "Database constraints are the ultimate source of truth - use distributed locks or application-level locking as an OPTIMIZATION to fail fast, but always have the constraint as backup. The choice between pessimistic and optimistic depends on contention level: high contention favors pessimistic (avoid wasted work), low contention favors optimistic (better throughput)."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "PESSIMISTIC with timeout",
        "how_met": "_book_pessimistic uses lock.acquire(timeout=X), returns LOCK_TIMEOUT on failure",
        "gotchas": [
          "Timeout too short = many failures, too long = poor UX"
        ]
      },
      {
        "requirement": "OPTIMISTIC with version check",
        "how_met": "_book_optimistic reads room_versions, processes, then verifies version unchanged before commit",
        "gotchas": [
          "Must still acquire lock during commit phase to update version atomically"
        ]
      },
      {
        "requirement": "CONSTRAINT-based",
        "how_met": "_book_constraint attempts insert without locking, checks for existing keys (simulates UNIQUE violation)",
        "gotchas": [
          "In-memory simulation still needs some sync, but demonstrates the concept"
        ]
      },
      {
        "requirement": "No double-bookings",
        "how_met": "All three strategies check availability before insert, constraint acts as final safety net",
        "gotchas": [
          "Optimistic needs double-check within lock to catch races"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "create_booking_with_lock (PESSIMISTIC)",
        "target": "O(D)",
        "achieved": "O(D)",
        "why": "D nights to check/insert, lock acquisition O(1)"
      },
      {
        "operation": "create_booking_with_lock (OPTIMISTIC)",
        "target": "O(D)",
        "achieved": "O(D)",
        "why": "Read O(D), version check O(1), write O(D)"
      },
      {
        "operation": "create_booking_with_lock (CONSTRAINT)",
        "target": "O(D)",
        "achieved": "O(D)",
        "why": "Single pass insert attempt for D dates"
      }
    ],
    "non_goals": [
      "Distributed locking implementation (Redis/ZK) - discussed conceptually only",
      "Automatic retry logic - caller's responsibility",
      "Deadlock detection - single resource locking avoids deadlocks"
    ]
  },
  "assumptions": [
    "Lock timeout of 2 seconds is acceptable for user experience (ask interviewer to confirm)",
    "Optimistic locking version is per-room, not per-date (simpler, sufficient for demo)",
    "In production, CONSTRAINT would use PostgreSQL EXCLUDE constraint or ON CONFLICT handling",
    "Caller handles retries for optimistic conflicts (exponential backoff recommended)"
  ],
  "tradeoffs": [
    {
      "decision": "Timeout vs NOWAIT for pessimistic",
      "chosen": "Configurable timeout",
      "why": "More flexible - NOWAIT (Part 1) is actually timeout=0",
      "alternative": "Always NOWAIT",
      "when_to_switch": "If immediate feedback more important than fairness"
    },
    {
      "decision": "Version per room vs per room-date",
      "chosen": "Per room",
      "why": "Simpler, any change to room's availability increments version",
      "alternative": "Per room-date",
      "when_to_switch": "If partial updates are common and we want finer granularity"
    },
    {
      "decision": "Lock during optimistic commit",
      "chosen": "Yes, acquire lock briefly",
      "why": "Ensures atomic version check + update in memory simulation",
      "alternative": "CAS operation",
      "when_to_switch": "In real DB, use atomic UPDATE WHERE version=X"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public method signatures from Part 1",
      "BookingRequest/BookingResponse data classes",
      "Availability dictionary structure"
    ],
    "what_to_change": [
      "Add room_versions dict for optimistic locking",
      "Add lock_timeout configuration",
      "Add LockStrategy enum"
    ],
    "interfaces_and_boundaries": "create_booking_with_lock delegates to private _book_* methods per strategy, keeping strategy logic isolated. Original createBooking unchanged for backward compatibility.",
    "invariants": [
      "INV1-4 from Part 1 still hold",
      "INV5: room_versions[r] monotonically increases",
      "INV6: After VERSION_CONFLICT, no state was modified"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1 only):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 createBooking:                      \u2502\n\u2502   Lock \u2192 Check \u2192 Insert \u2192 Release   \u2502\n\u2502   (NOWAIT - fail immediately)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 2 added):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 createBooking: (unchanged)          \u2502\n\u2502   Lock(NOWAIT) \u2192 Check \u2192 Insert     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 create_booking_with_lock:           \u2502\n\u2502                                     \u2502\n\u2502   PESSIMISTIC:                      \u2502\n\u2502     Lock(timeout=2s) \u2192 Check \u2192      \u2502\n\u2502     Insert \u2192 Release                \u2502\n\u2502                                     \u2502\n\u2502   OPTIMISTIC:                       \u2502\n\u2502     Read v1 \u2192 Check \u2192 Lock \u2192        \u2502\n\u2502     Verify v1==v2 \u2192 Insert \u2192        \u2502\n\u2502     Bump version \u2192 Release          \u2502\n\u2502                                     \u2502\n\u2502   CONSTRAINT:                       \u2502\n\u2502     (minimal lock) \u2192 Try Insert \u2192   \u2502\n\u2502     Handle conflict                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    LOCKING STRATEGY FLOWS                            \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551  PESSIMISTIC (High Contention Recommended):                          \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                           \u2551\n\u2551  User A: \u2500\u2500\u25b6 LOCK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 CHECK \u2500\u2500\u25b6 INSERT \u2500\u2500\u25b6 UNLOCK          \u2551\n\u2551               \u2502                                                      \u2551\n\u2551  User B: \u2500\u2500\u25b6 LOCK \u2500\u2500[wait]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 timeout \u2500\u2500\u25b6 LOCK_TIMEOUT   \u2551\n\u2551                                                                      \u2551\n\u2551  OPTIMISTIC (Low Contention Recommended):                            \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                           \u2551\n\u2551  User A: \u2500\u2500\u25b6 READ(v=1) \u2500\u2500\u25b6 CHECK \u2500\u2500\u25b6 LOCK \u2500\u2500\u25b6 v==1? \u2500\u2500\u25b6 INSERT(v=2)  \u2551\n\u2551                                         \u2502                            \u2551\n\u2551  User B: \u2500\u2500\u25b6 READ(v=1) \u2500\u2500\u25b6 CHECK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 v==2! \u2500\u2500\u25b6 VERSION_CONFLICT\u2551\n\u2551                                                                      \u2551\n\u2551  CONSTRAINT (Database-Centric):                                      \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                           \u2551\n\u2551  User A: \u2500\u2500\u25b6 INSERT \u2500\u2500\u25b6 \u2705 Success                                   \u2551\n\u2551  User B: \u2500\u2500\u25b6 INSERT \u2500\u2500\u25b6 \u274c UNIQUE VIOLATION                          \u2551\n\u2551                                                                      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Single Strategy Only",
      "description": "Just add timeout to existing pessimistic lock, don't implement other strategies",
      "time_complexity": "O(D) for booking",
      "space_complexity": "O(1) additional",
      "why_not_optimal": "Doesn't meet requirement to support multiple strategies. Pessimistic doesn't scale well for high-throughput low-contention scenarios."
    },
    {
      "name": "Optimal - Strategy Pattern with Three Implementations",
      "description": "Implement all three strategies, allowing caller to choose based on use case. Use delegation pattern to keep code clean.",
      "time_complexity": "O(D) for all strategies",
      "space_complexity": "O(R) for room versions where R = rooms",
      "key_insight": "Each strategy has tradeoffs. Pessimistic = simple, predictable latency, blocks. Optimistic = high throughput, but wasted work on conflict. Constraint = simplest code, DB handles it, but only catches at insert time."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution implements a **strategy pattern** where `create_booking_with_lock` accepts a `LockStrategy` enum and delegates to the appropriate implementation.\n\n**Key Implementation Details:**\n\n1. **PESSIMISTIC** (`_book_pessimistic`):\n   - Uses `lock.acquire(timeout=self.lock_timeout)`\n   - If timeout expires, returns `LOCK_TIMEOUT` error\n   - Once lock acquired, checks availability and inserts atomically\n\n2. **OPTIMISTIC** (`_book_optimistic`):\n   - Reads `room_versions[room_id]` before processing\n   - Checks availability **without holding lock** (allows parallelism)\n   - Acquires lock only for commit phase\n   - Verifies version unchanged; if changed \u2192 `VERSION_CONFLICT`\n   - Increments version after successful insert\n\n3. **CONSTRAINT** (`_book_constraint`):\n   - Minimal locking (only for in-memory thread safety)\n   - Checks if keys exist (simulates UNIQUE constraint check)\n   - Returns `CONSTRAINT_VIOLATION` on conflict\n   - In production, would use `INSERT ... ON CONFLICT` or `EXCLUDE`\n\n**Production Considerations:**\n- Add Redis distributed lock before DB operation for multi-server\n- Constraint is the **safety net** - even if distributed lock fails, DB catches it\n- Monitor which strategy has better success rate and adapt",
    "data_structures": [
      {
        "structure": "LockStrategy enum",
        "purpose": "Type-safe strategy selection"
      },
      {
        "structure": "room_versions: Dict[str, int]",
        "purpose": "Track version per room for optimistic locking"
      },
      {
        "structure": "lock_timeout: float",
        "purpose": "Configurable timeout for pessimistic locking"
      }
    ],
    "algorithm_steps": [
      "Step 1: Common validation (idempotency, room exists, valid dates)",
      "Step 2: Dispatch to strategy-specific method based on LockStrategy",
      "Step 3a (PESSIMISTIC): Try acquire lock with timeout \u2192 check availability \u2192 insert \u2192 release",
      "Step 3b (OPTIMISTIC): Read version \u2192 check availability (no lock) \u2192 acquire lock \u2192 verify version \u2192 insert \u2192 bump version \u2192 release",
      "Step 3c (CONSTRAINT): Acquire minimal lock \u2192 check existence (constraint) \u2192 insert or fail",
      "Step 4: Return appropriate BookingResponse with strategy-specific error codes"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Hotel Booking System - Part 2: Concurrent Booking Strategies",
    "Extends Part 1 with PESSIMISTIC, OPTIMISTIC, and CONSTRAINT locking.",
    "\"\"\"",
    "from dataclasses import dataclass, field",
    "from datetime import date, timedelta",
    "from enum import Enum",
    "from typing import List, Optional, Dict, Any",
    "import threading",
    "import uuid",
    "import time",
    "",
    "",
    "class BookingStatus(Enum):",
    "    PENDING = 'PENDING'",
    "    CONFIRMED = 'CONFIRMED'",
    "    CANCELLED = 'CANCELLED'",
    "    COMPLETED = 'COMPLETED'",
    "",
    "",
    "class LockStrategy(Enum):",
    "    \"\"\"Concurrency control strategies for booking.\"\"\"",
    "    PESSIMISTIC = 'PESSIMISTIC'  # SELECT FOR UPDATE with timeout",
    "    OPTIMISTIC = 'OPTIMISTIC'    # Version check at commit",
    "    CONSTRAINT = 'CONSTRAINT'    # Rely on DB UNIQUE constraint",
    "",
    "",
    "@dataclass",
    "class Hotel:",
    "    id: str",
    "    name: str",
    "    city: str",
    "    rating: float",
    "    amenities: List[str] = field(default_factory=list)",
    "",
    "",
    "@dataclass",
    "class Room:",
    "    id: str",
    "    hotel_id: str",
    "    room_type: str",
    "    capacity: int",
    "    price_cents: int",
    "    amenities: List[str] = field(default_factory=list)",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    id: str",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    status: BookingStatus",
    "    total_price_cents: int",
    "",
    "",
    "@dataclass",
    "class SearchRequest:",
    "    location: str",
    "    check_in: date",
    "    check_out: date",
    "    guests: int",
    "    price_max: Optional[int] = None",
    "",
    "",
    "@dataclass",
    "class SearchResponse:",
    "    rooms: List[Dict[str, Any]]",
    "    total_results: int",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    idempotency_key: str",
    "",
    "",
    "@dataclass",
    "class BookingResponse:",
    "    status: str",
    "    booking_id: Optional[str] = None",
    "    total_price: Optional[float] = None",
    "    error: Optional[str] = None",
    "    message: Optional[str] = None",
    "",
    "",
    "class HotelBookingSystem:",
    "    \"\"\"",
    "    Hotel Booking System with multiple concurrency control strategies.",
    "    Part 2 adds: PESSIMISTIC (timeout), OPTIMISTIC (version), CONSTRAINT.",
    "    \"\"\"",
    "",
    "    def __init__(self):",
    "        # Part 1 data structures",
    "        self.hotels: Dict[str, Hotel] = {}",
    "        self.rooms: Dict[str, Room] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        self.availability: Dict[tuple, str] = {}  # (room_id, date) -> booking_id",
    "        self.processed_keys: Dict[str, str] = {}",
    "        self.room_locks: Dict[str, threading.Lock] = {}",
    "        self.global_lock = threading.Lock()",
    "        ",
    "        # Part 2 additions",
    "        self.room_versions: Dict[str, int] = {}  # For optimistic locking",
    "        self.lock_timeout: float = 2.0  # Configurable timeout (seconds)",
    "",
    "    def _get_room_lock(self, room_id: str) -> threading.Lock:",
    "        if room_id not in self.room_locks:",
    "            with self.global_lock:",
    "                if room_id not in self.room_locks:",
    "                    self.room_locks[room_id] = threading.Lock()",
    "        return self.room_locks[room_id]",
    "",
    "    def _get_date_range(self, check_in: date, check_out: date) -> List[date]:",
    "        nights = []",
    "        current = check_in",
    "        while current < check_out:",
    "            nights.append(current)",
    "            current += timedelta(days=1)",
    "        return nights",
    "",
    "    def _get_room_version(self, room_id: str) -> int:",
    "        return self.room_versions.get(room_id, 0)",
    "",
    "    def _increment_room_version(self, room_id: str) -> None:",
    "        self.room_versions[room_id] = self.room_versions.get(room_id, 0) + 1",
    "",
    "    def add_hotel(self, hotel: Hotel) -> None:",
    "        self.hotels[hotel.id] = hotel",
    "",
    "    def add_room(self, room: Room) -> None:",
    "        self.rooms[room.id] = room",
    "",
    "    def searchRooms(self, request: SearchRequest) -> SearchResponse:",
    "        \"\"\"Search for available rooms (unchanged from Part 1).\"\"\"",
    "        available_rooms = []",
    "        nights = self._get_date_range(request.check_in, request.check_out)",
    "        for room in self.rooms.values():",
    "            hotel = self.hotels.get(room.hotel_id)",
    "            if not hotel or hotel.city.lower() != request.location.lower():",
    "                continue",
    "            if room.capacity < request.guests:",
    "                continue",
    "            if request.price_max and room.price_cents > request.price_max * 100:",
    "                continue",
    "            is_available = all((room.id, n) not in self.availability for n in nights)",
    "            if is_available:",
    "                total_cents = room.price_cents * len(nights)",
    "                available_rooms.append({",
    "                    'id': room.id, 'hotel': hotel.name, 'type': room.room_type,",
    "                    'price_per_night': room.price_cents / 100,",
    "                    'total_price': total_cents / 100, 'capacity': room.capacity,",
    "                })",
    "        return SearchResponse(rooms=available_rooms, total_results=len(available_rooms))",
    "",
    "    def getRoomDetails(self, room_id: str, check_in: date, check_out: date) -> Optional[Dict]:",
    "        \"\"\"Get room details (unchanged from Part 1).\"\"\"",
    "        room = self.rooms.get(room_id)",
    "        if not room:",
    "            return None",
    "        hotel = self.hotels.get(room.hotel_id)",
    "        nights = self._get_date_range(check_in, check_out)",
    "        is_available = all((room_id, n) not in self.availability for n in nights)",
    "        return {",
    "            'id': room.id, 'hotel': hotel.name if hotel else 'Unknown',",
    "            'type': room.room_type, 'capacity': room.capacity,",
    "            'price_per_night': room.price_cents / 100,",
    "            'total_price': (room.price_cents * len(nights)) / 100,",
    "            'amenities': room.amenities, 'available': is_available,",
    "        }",
    "",
    "    def createBooking(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"Original booking method with NOWAIT pessimistic lock (unchanged).\"\"\"",
    "        if request.idempotency_key in self.processed_keys:",
    "            existing_id = self.processed_keys[request.idempotency_key]",
    "            existing = self.bookings.get(existing_id)",
    "            if existing:",
    "                return BookingResponse('CONFIRMED', existing_id, existing.total_price_cents / 100)",
    "        ",
    "        room = self.rooms.get(request.room_id)",
    "        if not room:",
    "            return BookingResponse(status='FAILED', error='ROOM_NOT_FOUND')",
    "        nights = self._get_date_range(request.check_in, request.check_out)",
    "        if not nights:",
    "            return BookingResponse(status='FAILED', error='INVALID_DATES')",
    "        ",
    "        room_lock = self._get_room_lock(request.room_id)",
    "        acquired = room_lock.acquire(blocking=False)  # NOWAIT",
    "        if not acquired:",
    "            return BookingResponse(status='FAILED', error='ROOM_BUSY',",
    "                message='Room is being booked by another user. Please retry.')",
    "        try:",
    "            for night in nights:",
    "                if (request.room_id, night) in self.availability:",
    "                    return BookingResponse(status='FAILED', error='ROOM_NOT_AVAILABLE',",
    "                        message=f'Room not available for: {night}')",
    "            booking_id = f'BK_{uuid.uuid4().hex[:8].upper()}'",
    "            total_cents = room.price_cents * len(nights)",
    "            for night in nights:",
    "                self.availability[(request.room_id, night)] = booking_id",
    "            booking = Booking(booking_id, request.user_id, request.room_id,",
    "                request.check_in, request.check_out, BookingStatus.CONFIRMED, total_cents)",
    "            self.bookings[booking_id] = booking",
    "            self.processed_keys[request.idempotency_key] = booking_id",
    "            self._increment_room_version(request.room_id)  # Track for optimistic",
    "            return BookingResponse('CONFIRMED', booking_id, total_cents / 100)",
    "        finally:",
    "            room_lock.release()",
    "",
    "    def create_booking_with_lock(self, request: BookingRequest, strategy: LockStrategy) -> BookingResponse:",
    "        \"\"\"",
    "        Create booking using specified locking strategy.",
    "        - PESSIMISTIC: Wait for lock with timeout",
    "        - OPTIMISTIC: Version check, fail on conflict",
    "        - CONSTRAINT: Rely on uniqueness, fail on duplicate",
    "        \"\"\"",
    "        # Common idempotency check",
    "        if request.idempotency_key in self.processed_keys:",
    "            existing_id = self.processed_keys[request.idempotency_key]",
    "            existing = self.bookings.get(existing_id)",
    "            if existing:",
    "                return BookingResponse('CONFIRMED', existing_id, existing.total_price_cents / 100)",
    "        ",
    "        room = self.rooms.get(request.room_id)",
    "        if not room:",
    "            return BookingResponse(status='FAILED', error='ROOM_NOT_FOUND')",
    "        nights = self._get_date_range(request.check_in, request.check_out)",
    "        if not nights:",
    "            return BookingResponse(status='FAILED', error='INVALID_DATES')",
    "        ",
    "        if strategy == LockStrategy.PESSIMISTIC:",
    "            return self._book_pessimistic(request, room, nights)",
    "        elif strategy == LockStrategy.OPTIMISTIC:",
    "            return self._book_optimistic(request, room, nights)",
    "        else:",
    "            return self._book_constraint(request, room, nights)",
    "",
    "    def _book_pessimistic(self, request: BookingRequest, room: Room, nights: List[date]) -> BookingResponse:",
    "        \"\"\"SELECT FOR UPDATE with timeout - wait for lock, fail if timeout.\"\"\"",
    "        room_lock = self._get_room_lock(request.room_id)",
    "        acquired = room_lock.acquire(timeout=self.lock_timeout)",
    "        ",
    "        if not acquired:",
    "            return BookingResponse(status='FAILED', error='LOCK_TIMEOUT',",
    "                message='Could not acquire lock within timeout')",
    "        try:",
    "            for night in nights:",
    "                if (request.room_id, night) in self.availability:",
    "                    return BookingResponse(status='FAILED', error='ROOM_NOT_AVAILABLE',",
    "                        message=f'Room not available for: {night}')",
    "            return self._commit_booking(request, room, nights)",
    "        finally:",
    "            room_lock.release()",
    "",
    "    def _book_optimistic(self, request: BookingRequest, room: Room, nights: List[date]) -> BookingResponse:",
    "        \"\"\"Version-based optimistic locking - read, check, verify version at commit.\"\"\"",
    "        # Read version BEFORE checking (without lock)",
    "        version_before = self._get_room_version(request.room_id)",
    "        ",
    "        # Check availability without holding lock (optimistic read)",
    "        for night in nights:",
    "            if (request.room_id, night) in self.availability:",
    "                return BookingResponse(status='FAILED', error='ROOM_NOT_AVAILABLE',",
    "                    message=f'Room not available for: {night}')",
    "        ",
    "        # Acquire lock only for commit phase",
    "        room_lock = self._get_room_lock(request.room_id)",
    "        with room_lock:",
    "            # Verify version unchanged",
    "            if self._get_room_version(request.room_id) != version_before:",
    "                return BookingResponse(status='FAILED', error='VERSION_CONFLICT',",
    "                    message='Resource was modified, please retry')",
    "            # Double-check availability within lock",
    "            for night in nights:",
    "                if (request.room_id, night) in self.availability:",
    "                    return BookingResponse(status='FAILED', error='ROOM_NOT_AVAILABLE',",
    "                        message=f'Room not available for: {night}')",
    "            return self._commit_booking(request, room, nights)",
    "",
    "    def _book_constraint(self, request: BookingRequest, room: Room, nights: List[date]) -> BookingResponse:",
    "        \"\"\"Constraint-based - simulate DB UNIQUE constraint enforcement.\"\"\"",
    "        room_lock = self._get_room_lock(request.room_id)  # Minimal lock for in-memory safety",
    "        with room_lock:",
    "            # Simulate INSERT ... ON CONFLICT behavior",
    "            for night in nights:",
    "                if (request.room_id, night) in self.availability:",
    "                    return BookingResponse(status='FAILED', error='CONSTRAINT_VIOLATION',",
    "                        message=f'Unique constraint violated for date: {night}')",
    "            return self._commit_booking(request, room, nights)",
    "",
    "    def _commit_booking(self, request: BookingRequest, room: Room, nights: List[date]) -> BookingResponse:",
    "        \"\"\"Common commit logic - insert availability and create booking record.\"\"\"",
    "        booking_id = f'BK_{uuid.uuid4().hex[:8].upper()}'",
    "        total_cents = room.price_cents * len(nights)",
    "        ",
    "        for night in nights:",
    "            self.availability[(request.room_id, night)] = booking_id",
    "        ",
    "        booking = Booking(booking_id, request.user_id, request.room_id,",
    "            request.check_in, request.check_out, BookingStatus.CONFIRMED, total_cents)",
    "        self.bookings[booking_id] = booking",
    "        self.processed_keys[request.idempotency_key] = booking_id",
    "        self._increment_room_version(request.room_id)",
    "        ",
    "        return BookingResponse('CONFIRMED', booking_id, total_cents / 100)",
    "",
    "    def getBooking(self, booking_id: str) -> Optional[Booking]:",
    "        return self.bookings.get(booking_id)",
    "",
    "    def cancelBooking(self, booking_id: str, user_id: str) -> BookingResponse:",
    "        \"\"\"Cancel booking and free availability (unchanged from Part 1).\"\"\"",
    "        booking = self.bookings.get(booking_id)",
    "        if not booking:",
    "            return BookingResponse(status='FAILED', error='BOOKING_NOT_FOUND')",
    "        if booking.user_id != user_id:",
    "            return BookingResponse(status='FAILED', error='UNAUTHORIZED')",
    "        if booking.status == BookingStatus.CANCELLED:",
    "            return BookingResponse(status='ALREADY_CANCELLED', booking_id=booking_id)",
    "        ",
    "        room_lock = self._get_room_lock(booking.room_id)",
    "        with room_lock:",
    "            nights = self._get_date_range(booking.check_in, booking.check_out)",
    "            for night in nights:",
    "                key = (booking.room_id, night)",
    "                if key in self.availability and self.availability[key] == booking_id:",
    "                    del self.availability[key]",
    "            booking.status = BookingStatus.CANCELLED",
    "            self._increment_room_version(booking.room_id)",
    "        return BookingResponse('CANCELLED', booking_id,",
    "            message='Booking cancelled. Refund will be processed within 5-7 days.')",
    "",
    "",
    "def demo_strategy_comparison():",
    "    \"\"\"Compare different locking strategies with concurrent bookings.\"\"\"",
    "    import concurrent.futures",
    "    ",
    "    print('\\n' + '=' * 70)",
    "    print('DEMO: Locking Strategy Comparison')",
    "    print('=' * 70)",
    "    ",
    "    for strategy in LockStrategy:",
    "        print(f'\\n--- Strategy: {strategy.value} ---')",
    "        system = HotelBookingSystem()",
    "        system.lock_timeout = 0.5  # Short timeout for demo",
    "        system.add_hotel(Hotel('H1', 'Test Hotel', 'NYC', 4.5))",
    "        system.add_room(Room('R1', 'H1', 'Suite', 2, 20000))",
    "        ",
    "        check_in, check_out = date(2024, 7, 1), date(2024, 7, 3)",
    "        ",
    "        def attempt(user_id):",
    "            req = BookingRequest(user_id, 'R1', check_in, check_out, f'key_{user_id}')",
    "            time.sleep(0.01)  # Small delay to increase contention",
    "            return (user_id, system.create_booking_with_lock(req, strategy))",
    "        ",
    "        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as ex:",
    "            results = list(ex.map(attempt, ['UserA', 'UserB', 'UserC']))",
    "        ",
    "        for user_id, resp in results:",
    "            if resp.status == 'CONFIRMED':",
    "                print(f'  {user_id}: \u2713 {resp.booking_id}')",
    "            else:",
    "                print(f'  {user_id}: \u2717 {resp.error}')",
    "",
    "",
    "def demo_optimistic_version_conflict():",
    "    \"\"\"Demonstrate version conflict detection in optimistic locking.\"\"\"",
    "    print('\\n' + '=' * 70)",
    "    print('DEMO: Optimistic Locking Version Conflict')",
    "    print('=' * 70)",
    "    ",
    "    system = HotelBookingSystem()",
    "    system.add_hotel(Hotel('H1', 'Version Hotel', 'LA', 4.0))",
    "    system.add_room(Room('R1', 'H1', 'King', 2, 15000))",
    "    ",
    "    # Book first - establishes version",
    "    req1 = BookingRequest('User1', 'R1', date(2024, 8, 1), date(2024, 8, 3), 'key1')",
    "    resp1 = system.create_booking_with_lock(req1, LockStrategy.OPTIMISTIC)",
    "    print(f'Booking 1 (Aug 1-3): {resp1.status}')",
    "    print(f'  Room version after: {system._get_room_version(\"R1\")}')",
    "    ",
    "    # Second booking - different dates, should work",
    "    req2 = BookingRequest('User2', 'R1', date(2024, 8, 5), date(2024, 8, 7), 'key2')",
    "    resp2 = system.create_booking_with_lock(req2, LockStrategy.OPTIMISTIC)",
    "    print(f'Booking 2 (Aug 5-7): {resp2.status}')",
    "    print(f'  Room version after: {system._get_room_version(\"R1\")}')",
    "",
    "",
    "def demo_constraint_violation():",
    "    \"\"\"Demonstrate constraint-based conflict detection.\"\"\"",
    "    print('\\n' + '=' * 70)",
    "    print('DEMO: Constraint-Based Booking')",
    "    print('=' * 70)",
    "    ",
    "    system = HotelBookingSystem()",
    "    system.add_hotel(Hotel('H1', 'Constraint Hotel', 'SF', 4.3))",
    "    system.add_room(Room('R1', 'H1', 'Standard', 2, 10000))",
    "    ",
    "    # First booking succeeds",
    "    req1 = BookingRequest('UserX', 'R1', date(2024, 9, 10), date(2024, 9, 12), 'keyX')",
    "    resp1 = system.create_booking_with_lock(req1, LockStrategy.CONSTRAINT)",
    "    print(f'Booking 1 (Sep 10-12): {resp1.status} - {resp1.booking_id}')",
    "    ",
    "    # Second booking same dates - constraint violation",
    "    req2 = BookingRequest('UserY', 'R1', date(2024, 9, 10), date(2024, 9, 12), 'keyY')",
    "    resp2 = system.create_booking_with_lock(req2, LockStrategy.CONSTRAINT)",
    "    print(f'Booking 2 (Sep 10-12): {resp2.status} - {resp2.error}')",
    "    ",
    "    # Partial overlap - also fails",
    "    req3 = BookingRequest('UserZ', 'R1', date(2024, 9, 11), date(2024, 9, 14), 'keyZ')",
    "    resp3 = system.create_booking_with_lock(req3, LockStrategy.CONSTRAINT)",
    "    print(f'Booking 3 (Sep 11-14): {resp3.status} - {resp3.error}')",
    "",
    "",
    "if __name__ == '__main__':",
    "    demo_strategy_comparison()",
    "    demo_optimistic_version_conflict()",
    "    demo_constraint_violation()"
  ],
  "solution_java_lines": [
    "import java.time.LocalDate;",
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.locks.*;",
    "",
    "public class HotelBookingSystem {",
    "",
    "    enum BookingStatus { PENDING, CONFIRMED, CANCELLED, COMPLETED }",
    "    enum LockStrategy { PESSIMISTIC, OPTIMISTIC, CONSTRAINT }",
    "",
    "    record Hotel(String id, String name, String city, double rating) {}",
    "    record Room(String id, String hotelId, String type, int capacity, int priceCents) {}",
    "    record Booking(String id, String userId, String roomId, LocalDate checkIn,",
    "                   LocalDate checkOut, BookingStatus status, int totalPriceCents) {}",
    "    record BookingRequest(String userId, String roomId, LocalDate checkIn,",
    "                          LocalDate checkOut, String idempotencyKey) {}",
    "    record BookingResponse(String status, String bookingId, BigDecimal totalPrice,",
    "                           String error, String message) {",
    "        static BookingResponse success(String id, BigDecimal price) {",
    "            return new BookingResponse(\"CONFIRMED\", id, price, null, null);",
    "        }",
    "        static BookingResponse failure(String error, String message) {",
    "            return new BookingResponse(\"FAILED\", null, null, error, message);",
    "        }",
    "    }",
    "",
    "    // Storage",
    "    private final Map<String, Hotel> hotels = new ConcurrentHashMap<>();",
    "    private final Map<String, Room> rooms = new ConcurrentHashMap<>();",
    "    private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    private final Map<String, String> availability = new ConcurrentHashMap<>();",
    "    private final Map<String, String> processedKeys = new ConcurrentHashMap<>();",
    "    private final ConcurrentHashMap<String, ReentrantLock> roomLocks = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2 additions",
    "    private final Map<String, Integer> roomVersions = new ConcurrentHashMap<>();",
    "    private long lockTimeoutMs = 2000;",
    "",
    "    private ReentrantLock getRoomLock(String roomId) {",
    "        return roomLocks.computeIfAbsent(roomId, k -> new ReentrantLock());",
    "    }",
    "",
    "    private List<LocalDate> getDateRange(LocalDate checkIn, LocalDate checkOut) {",
    "        return checkIn.datesUntil(checkOut).toList();",
    "    }",
    "",
    "    private String availKey(String roomId, LocalDate date) {",
    "        return roomId + \":\" + date;",
    "    }",
    "",
    "    private int getRoomVersion(String roomId) {",
    "        return roomVersions.getOrDefault(roomId, 0);",
    "    }",
    "",
    "    private void incrementRoomVersion(String roomId) {",
    "        roomVersions.merge(roomId, 1, Integer::sum);",
    "    }",
    "",
    "    public void addHotel(Hotel hotel) { hotels.put(hotel.id(), hotel); }",
    "    public void addRoom(Room room) { rooms.put(room.id(), room); }",
    "",
    "    /**",
    "     * Create booking with specified locking strategy.",
    "     * PESSIMISTIC: Wait with timeout, OPTIMISTIC: Version check, CONSTRAINT: DB unique.",
    "     */",
    "    public BookingResponse createBookingWithLock(BookingRequest req, LockStrategy strategy) {",
    "        // Idempotency check",
    "        if (processedKeys.containsKey(req.idempotencyKey())) {",
    "            String existingId = processedKeys.get(req.idempotencyKey());",
    "            Booking existing = bookings.get(existingId);",
    "            if (existing != null) {",
    "                return BookingResponse.success(existingId,",
    "                    BigDecimal.valueOf(existing.totalPriceCents() / 100.0));",
    "            }",
    "        }",
    "        ",
    "        Room room = rooms.get(req.roomId());",
    "        if (room == null) return BookingResponse.failure(\"ROOM_NOT_FOUND\", \"Room not found\");",
    "        ",
    "        List<LocalDate> nights = getDateRange(req.checkIn(), req.checkOut());",
    "        if (nights.isEmpty()) return BookingResponse.failure(\"INVALID_DATES\", \"Invalid dates\");",
    "        ",
    "        return switch (strategy) {",
    "            case PESSIMISTIC -> bookPessimistic(req, room, nights);",
    "            case OPTIMISTIC -> bookOptimistic(req, room, nights);",
    "            case CONSTRAINT -> bookConstraint(req, room, nights);",
    "        };",
    "    }",
    "",
    "    private BookingResponse bookPessimistic(BookingRequest req, Room room, List<LocalDate> nights) {",
    "        ReentrantLock lock = getRoomLock(req.roomId());",
    "        try {",
    "            if (!lock.tryLock(lockTimeoutMs, TimeUnit.MILLISECONDS)) {",
    "                return BookingResponse.failure(\"LOCK_TIMEOUT\",",
    "                    \"Could not acquire lock within timeout\");",
    "            }",
    "            try {",
    "                var conflict = findConflict(req.roomId(), nights);",
    "                if (conflict.isPresent()) {",
    "                    return BookingResponse.failure(\"ROOM_NOT_AVAILABLE\",",
    "                        \"Not available for: \" + conflict.get());",
    "                }",
    "                return commitBooking(req, room, nights);",
    "            } finally {",
    "                lock.unlock();",
    "            }",
    "        } catch (InterruptedException e) {",
    "            Thread.currentThread().interrupt();",
    "            return BookingResponse.failure(\"INTERRUPTED\", \"Operation interrupted\");",
    "        }",
    "    }",
    "",
    "    private BookingResponse bookOptimistic(BookingRequest req, Room room, List<LocalDate> nights) {",
    "        int versionBefore = getRoomVersion(req.roomId());",
    "        ",
    "        // Optimistic read without lock",
    "        var conflict = findConflict(req.roomId(), nights);",
    "        if (conflict.isPresent()) {",
    "            return BookingResponse.failure(\"ROOM_NOT_AVAILABLE\",",
    "                \"Not available for: \" + conflict.get());",
    "        }",
    "        ",
    "        // Lock only for commit",
    "        ReentrantLock lock = getRoomLock(req.roomId());",
    "        lock.lock();",
    "        try {",
    "            if (getRoomVersion(req.roomId()) != versionBefore) {",
    "                return BookingResponse.failure(\"VERSION_CONFLICT\",",
    "                    \"Resource was modified, please retry\");",
    "            }",
    "            // Double-check within lock",
    "            conflict = findConflict(req.roomId(), nights);",
    "            if (conflict.isPresent()) {",
    "                return BookingResponse.failure(\"ROOM_NOT_AVAILABLE\",",
    "                    \"Not available for: \" + conflict.get());",
    "            }",
    "            return commitBooking(req, room, nights);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    private BookingResponse bookConstraint(BookingRequest req, Room room, List<LocalDate> nights) {",
    "        ReentrantLock lock = getRoomLock(req.roomId());",
    "        lock.lock();",
    "        try {",
    "            var conflict = findConflict(req.roomId(), nights);",
    "            if (conflict.isPresent()) {",
    "                return BookingResponse.failure(\"CONSTRAINT_VIOLATION\",",
    "                    \"Unique constraint violated for: \" + conflict.get());",
    "            }",
    "            return commitBooking(req, room, nights);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    private Optional<LocalDate> findConflict(String roomId, List<LocalDate> nights) {",
    "        return nights.stream()",
    "            .filter(d -> availability.containsKey(availKey(roomId, d)))",
    "            .findFirst();",
    "    }",
    "",
    "    private BookingResponse commitBooking(BookingRequest req, Room room, List<LocalDate> nights) {",
    "        String bookingId = \"BK_\" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();",
    "        int totalCents = room.priceCents() * nights.size();",
    "        ",
    "        for (LocalDate night : nights) {",
    "            availability.put(availKey(req.roomId(), night), bookingId);",
    "        }",
    "        ",
    "        Booking booking = new Booking(bookingId, req.userId(), req.roomId(),",
    "            req.checkIn(), req.checkOut(), BookingStatus.CONFIRMED, totalCents);",
    "        bookings.put(bookingId, booking);",
    "        processedKeys.put(req.idempotencyKey(), bookingId);",
    "        incrementRoomVersion(req.roomId());",
    "        ",
    "        return BookingResponse.success(bookingId, BigDecimal.valueOf(totalCents / 100.0));",
    "    }",
    "",
    "    public static void main(String[] args) throws Exception {",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"DEMO: Locking Strategy Comparison\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        for (LockStrategy strategy : LockStrategy.values()) {",
    "            System.out.println(\"\\n--- Strategy: \" + strategy + \" ---\");",
    "            HotelBookingSystem system = new HotelBookingSystem();",
    "            system.lockTimeoutMs = 500;",
    "            system.addHotel(new Hotel(\"H1\", \"Test Hotel\", \"NYC\", 4.5));",
    "            system.addRoom(new Room(\"R1\", \"H1\", \"Suite\", 2, 20000));",
    "            ",
    "            LocalDate checkIn = LocalDate.of(2024, 7, 1);",
    "            LocalDate checkOut = LocalDate.of(2024, 7, 3);",
    "            ",
    "            ExecutorService executor = Executors.newFixedThreadPool(3);",
    "            List<Future<String>> futures = new ArrayList<>();",
    "            ",
    "            for (int i = 0; i < 3; i++) {",
    "                final String userId = \"User\" + i;",
    "                final LockStrategy s = strategy;",
    "                futures.add(executor.submit(() -> {",
    "                    BookingRequest req = new BookingRequest(",
    "                        userId, \"R1\", checkIn, checkOut, \"key_\" + userId);",
    "                    BookingResponse resp = system.createBookingWithLock(req, s);",
    "                    return userId + \": \" + (resp.status().equals(\"CONFIRMED\") ?",
    "                        \"\u2713 \" + resp.bookingId() : \"\u2717 \" + resp.error());",
    "                }));",
    "            }",
    "            ",
    "            for (Future<String> f : futures) {",
    "                System.out.println(\"  \" + f.get());",
    "            }",
    "            executor.shutdown();",
    "        }",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-25",
      "explanation": "Imports and new LockStrategy enum. Added to existing enums."
    },
    {
      "lines": "90-95",
      "explanation": "New instance variables: room_versions for optimistic locking, lock_timeout for pessimistic."
    },
    {
      "lines": "100-105",
      "explanation": "Helper methods for version management - simple int tracking per room."
    },
    {
      "lines": "170-185",
      "explanation": "create_booking_with_lock - main entry point. Common validation then dispatch to strategy."
    },
    {
      "lines": "187-200",
      "explanation": "_book_pessimistic - acquires lock WITH timeout (unlike Part 1's NOWAIT). Returns LOCK_TIMEOUT on failure."
    },
    {
      "lines": "202-220",
      "explanation": "_book_optimistic - reads version, checks availability without lock, then verifies version unchanged during commit."
    },
    {
      "lines": "222-232",
      "explanation": "_book_constraint - minimal locking, simulates UNIQUE constraint check. Error is CONSTRAINT_VIOLATION."
    },
    {
      "lines": "234-248",
      "explanation": "_commit_booking - shared logic extracted for DRY. Inserts availability, creates booking, updates version."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "create_booking_with_lock": {
          "complexity": "O(D)",
          "explanation": "D = nights. Lock O(1), availability check O(D), insert O(D). Same as createBooking."
        },
        "_get_room_version": {
          "complexity": "O(1)",
          "explanation": "Dictionary lookup"
        },
        "_increment_room_version": {
          "complexity": "O(1)",
          "explanation": "Dictionary update"
        }
      },
      "overall_change": "No change to asymptotic complexity. All booking operations remain O(D)."
    },
    "space": {
      "additional_space": "O(R)",
      "explanation": "room_versions stores one int per room (R rooms). Negligible compared to availability table O(B\u00d7D)."
    }
  },
  "dry_run": {
    "example_input": "Two concurrent OPTIMISTIC bookings for same room/dates",
    "steps": [
      {
        "step": 1,
        "action": "User A: read version",
        "state": "room_versions['R1'] = 0",
        "explanation": "Version before = 0"
      },
      {
        "step": 2,
        "action": "User B: read version",
        "state": "room_versions['R1'] = 0",
        "explanation": "Version before = 0 (same!)"
      },
      {
        "step": 3,
        "action": "User A: check availability",
        "state": "availability empty",
        "explanation": "All nights available"
      },
      {
        "step": 4,
        "action": "User B: check availability",
        "state": "availability empty",
        "explanation": "All nights still available (no lock held)"
      },
      {
        "step": 5,
        "action": "User A: acquire lock, verify version=0",
        "state": "Lock held by A",
        "explanation": "Version unchanged, proceeds"
      },
      {
        "step": 6,
        "action": "User A: commit, version++",
        "state": "availability filled, version=1",
        "explanation": "Booking confirmed"
      },
      {
        "step": 7,
        "action": "User A: release lock",
        "state": "Lock free",
        "explanation": "A completes successfully"
      },
      {
        "step": 8,
        "action": "User B: acquire lock, verify version=0",
        "state": "version=1 != 0",
        "explanation": "VERSION_CONFLICT detected!"
      },
      {
        "step": 9,
        "action": "User B: return error",
        "state": "No state change",
        "explanation": "B fails cleanly"
      }
    ],
    "final_output": "User A: CONFIRMED, User B: FAILED (VERSION_CONFLICT)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single booking with each strategy should work",
      "Same dates after cancel should work"
    ],
    "likely_bugs": [
      "Forgetting to increment version after booking/cancel",
      "Not double-checking availability in optimistic commit",
      "Lock not released in exception path"
    ],
    "recommended_logs_or_asserts": [
      "assert version_after >= version_before",
      "log(f'Strategy {strategy}: lock acquired in {elapsed}ms')"
    ],
    "how_to_localize": "1. Check which strategy fails. 2. Add logging at version read and commit. 3. Verify lock acquisition timing. 4. Check if availability dict is being modified outside locks."
  },
  "edge_cases": [
    {
      "case": "Lock timeout = 0",
      "handling": "Equivalent to NOWAIT from Part 1, immediate failure if locked",
      "gotcha": "Some languages may not support timeout=0 with tryLock"
    },
    {
      "case": "Same user, same idempotency key, different strategy",
      "handling": "Idempotency check happens before strategy dispatch, returns cached result",
      "gotcha": "Strategy is ignored on replay - intended behavior"
    },
    {
      "case": "Optimistic with rapid sequential bookings",
      "handling": "Version increments catch all modifications",
      "gotcha": "Even cancellations increment version"
    },
    {
      "case": "Empty date range",
      "handling": "Returns INVALID_DATES before strategy dispatch",
      "gotcha": "Validated in common code path"
    }
  ],
  "test_cases": [
    {
      "name": "Pessimistic timeout",
      "input": "Two concurrent PESSIMISTIC bookings, first holds lock longer than timeout",
      "expected": "First succeeds, second returns LOCK_TIMEOUT",
      "explanation": "Second request waits but exceeds timeout threshold"
    },
    {
      "name": "Optimistic version conflict",
      "input": "Two concurrent OPTIMISTIC bookings for same dates",
      "expected": "One succeeds, one returns VERSION_CONFLICT",
      "explanation": "Loser's version check fails at commit time"
    },
    {
      "name": "Constraint violation",
      "input": "CONSTRAINT booking for dates already booked",
      "expected": "Returns CONSTRAINT_VIOLATION",
      "explanation": "Simulates database UNIQUE constraint failure"
    },
    {
      "name": "Mixed strategies same room",
      "input": "PESSIMISTIC booking followed by OPTIMISTIC for different dates",
      "expected": "Both succeed (different dates)",
      "explanation": "Version incremented but dates don't overlap"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not incrementing version on cancellation",
      "why_wrong": "Optimistic readers won't detect that room became available",
      "correct_approach": "Any state change to availability must increment version",
      "code_example_wrong": "def cancelBooking(...):\n    del availability[...]\n    # Forgot version increment!",
      "code_example_correct": "def cancelBooking(...):\n    del availability[...]\n    self._increment_room_version(room_id)"
    },
    {
      "mistake": "Single availability check in optimistic",
      "why_wrong": "Another thread could commit between your read and your lock acquisition",
      "correct_approach": "Double-check availability inside the commit lock",
      "code_example_wrong": "# Read version, check avail, lock, commit\nif available: lock.acquire(); commit()",
      "code_example_correct": "# Read version, check avail, lock, RE-CHECK avail, commit\nif available: lock.acquire(); if still_available and version_ok: commit()"
    },
    {
      "mistake": "Using same error code for all strategies",
      "why_wrong": "Caller can't distinguish why booking failed for retry logic",
      "correct_approach": "Use LOCK_TIMEOUT, VERSION_CONFLICT, CONSTRAINT_VIOLATION distinctly",
      "code_example_wrong": "return BookingResponse(error='BOOKING_FAILED')",
      "code_example_correct": "return BookingResponse(error='VERSION_CONFLICT', message='retry with fresh data')"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by summarizing the three strategies and when each is appropriate. Then explain how you'll extend Part 1 minimally. Walk through the optimistic flow since it's most nuanced.",
    "what_to_mention": [
      "Trade-off: Pessimistic is simpler but blocks, Optimistic scales better but wastes work on conflict",
      "In production: constraints are safety net, locks are optimization",
      "Distributed consideration: Redis SETNX + DB constraint = belt AND suspenders"
    ],
    "time_allocation": "2 min understanding, 3 min explaining approach, 7-8 min implementing, 2 min testing/edge cases",
    "if_stuck": [
      "Start with pessimistic - it's similar to Part 1 with timeout",
      "For optimistic, think: read-modify-write with version guard",
      "Draw the timeline of two concurrent requests"
    ]
  },
  "connection_to_next_part": "Part 3 might add: distributed locking (Redis implementation), automatic retry with exponential backoff, or booking rate limiting. The version tracking and modular strategy pattern make these extensions clean.",
  "communication_script": {
    "transition_from_previous": "Part 1 gave us basic concurrency protection with NOWAIT locks. For Part 2, I need to support multiple locking strategies so the system can adapt to different contention levels.",
    "explaining_changes": "The key change is adding a strategy parameter and implementing three approaches: pessimistic with configurable timeout, optimistic with version checking, and constraint-based that relies on DB uniqueness. I'll add a room_versions dict for optimistic locking.",
    "while_extending_code": [
      "Adding LockStrategy enum...",
      "Adding room_versions for optimistic tracking...",
      "create_booking_with_lock dispatches to private strategy methods...",
      "The commit logic is shared since all strategies end the same way..."
    ],
    "after_completing": "Now we support all three strategies. PESSIMISTIC is O(D) with possible wait up to timeout. OPTIMISTIC is O(D) with potential VERSION_CONFLICT on contention. CONSTRAINT is O(D) with guaranteed no double-booking via uniqueness check. Happy to discuss when to use each."
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Understand the three strategies, identify additions needed (enum, version dict, timeout)",
    "by_5_min": "Explain approach, start adding LockStrategy enum and room_versions",
    "by_10_min": "Implement create_booking_with_lock and the three private methods",
    "by_15_min": "Add demo, test each strategy, handle edge cases",
    "warning_signs": "If still explaining at 5 min, jump to code. If one strategy is hard, implement the others first."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 1 should still work. If createBooking is broken, fix it - Part 2 can share its commit logic.",
    "if_new_requirement_unclear": "Ask: 'For optimistic, should version be per-room or per-date? Per-room is simpler.'",
    "if_running_behind": "Implement PESSIMISTIC first (easiest - just add timeout). Mention others conceptually."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Explaining why optimistic needs double-check inside lock",
      "Mentioning that cancellation must also increment version",
      "Discussing distributed locking as a layer above DB constraints",
      "Noting that timeout=0 is equivalent to Part 1's NOWAIT"
    ]
  },
  "pattern_recognition": {
    "pattern": "Concurrency Control Strategies / Locking Patterns",
    "indicators": [
      "Multiple users modifying same resource",
      "Need to prevent lost updates",
      "Discussion of 'race condition'"
    ],
    "similar_problems": [
      "Stock trading execution",
      "Ticket booking (concerts/flights)",
      "Inventory reservation"
    ],
    "template": "```python\n# Pessimistic: lock.acquire(timeout=X) -> check -> modify -> release\n# Optimistic: read_version -> check -> lock -> verify_version -> modify -> release\n# Constraint: try_insert -> catch_unique_violation\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'different locking strategies', I think strategy pattern with enum dispatch",
      "why": "Clean separation, easy to add new strategies later"
    },
    {
      "step": 2,
      "thought": "Optimistic needs version tracking",
      "why": "Must detect if someone else modified between my read and commit"
    },
    {
      "step": 3,
      "thought": "All strategies share commit logic",
      "why": "DRY principle - extract _commit_booking helper"
    },
    {
      "step": 4,
      "thought": "Existing createBooking stays unchanged",
      "why": "Backward compatibility, Part 1 tests should still pass"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you implement multiple concurrency strategies?",
      "Do you understand the trade-offs?",
      "Is your code modular and extensible?"
    ],
    "bonus_points": [
      "Explaining when each strategy is appropriate",
      "Mentioning distributed lock + constraint as layers",
      "Clean extraction of shared commit logic"
    ],
    "red_flags": [
      "Only implementing one strategy",
      "Not understanding why optimistic needs version check",
      "Breaking Part 1's createBooking"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for boilerplate enum/record definitions",
      "Let it help with threading timeout syntax"
    ],
    "what_not_to_do": [
      "Don't let AI merge all strategies into one method",
      "Verify the version check logic is correct"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking which strategy to prioritize if time-constrained",
      "Staying silent while implementing"
    ],
    "technical": [
      "Using global lock instead of per-room locks",
      "Not handling lock release in finally block"
    ],
    "communication": [
      "Not explaining why double-check is needed in optimistic",
      "Forgetting to mention trade-offs"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "All three strategies implemented and return correct error codes?",
      "Version incremented on booking AND cancellation?",
      "Lock always released (in finally)?",
      "Part 1's createBooking still works?"
    ],
    "quick_code_review": [
      "LockStrategy enum defined",
      "room_versions dict initialized",
      "lock_timeout is configurable",
      "Each strategy has distinct error code"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Metrics: track success rate per strategy",
      "Dynamic strategy selection based on contention",
      "Circuit breaker for lock timeouts"
    ],
    "why_not_in_interview": "Focus on demonstrating understanding of strategies; mention metrics verbally",
    "how_to_mention": "Say: 'In production, I'd add metrics to track which strategy has better success rates and potentially auto-switch.'"
  },
  "generated_at": "2026-01-19T04:21:42.440910",
  "_meta": {
    "problem_id": "booking_reservation_system",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}