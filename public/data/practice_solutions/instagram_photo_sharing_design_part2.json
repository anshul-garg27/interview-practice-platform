{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 2: Stories Feature (24-hour ephemeral content)",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 1 handled permanent posts with push/pull feed generation. Part 2 adds ephemeral Stories that auto-expire after 24 hours, require view tracking per user, and need a 'story ring' UI showing which followed users have unviewed stories. This fundamentally changes the data model from permanent content to time-bounded content with TTL semantics.",
    "new_requirements": [
      "Post ephemeral stories with 24-hour TTL",
      "Story ring showing followed users with active stories and viewed/unviewed status",
      "View tracking - record who viewed each story",
      "Story feed aggregated by user",
      "View analytics - count and viewer list"
    ],
    "new_constraints": [
      "Stories must auto-expire after 24 hours",
      "View events are extremely high volume (5x more than feed reads)",
      "Story ring must distinguish viewed vs unviewed per viewer",
      "500M story posts/day, billions of view events/day at scale"
    ],
    "key_insight": "Separate 'has viewed any' (fast, can use Bloom filter) from 'viewer list' (append-only log for analytics). Use lazy expiration on read rather than active deletion for simplicity in interview context."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Post Story with 24h TTL",
        "how_met": "post_story() creates Story with expires_at = created_at + 24h. _is_story_active() checks expiration.",
        "gotchas": [
          "Must check expiration on every read, not just write"
        ]
      },
      {
        "requirement": "Story Ring with viewed status",
        "how_met": "get_story_ring() aggregates followed users' active stories, checks viewer's view history to set has_unviewed flag",
        "gotchas": [
          "Need to check ALL stories from a user, not just latest, for viewed status"
        ]
      },
      {
        "requirement": "View tracking",
        "how_met": "mark_story_viewed() adds viewer to story_views set and increments counter. Idempotent.",
        "gotchas": [
          "Counter must not double-count on re-view"
        ]
      },
      {
        "requirement": "Story analytics",
        "how_met": "get_story_viewers() returns viewer list; view_count on Story object",
        "gotchas": [
          "View list can be huge - in production use sampling"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "post_story",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct insert into story store and user_stories list"
      },
      {
        "operation": "get_story_ring",
        "target": "O(F) where F=followed users",
        "achieved": "O(F \u00d7 S) where S=avg stories per user",
        "why": "Must check all followed users and their active stories"
      },
      {
        "operation": "mark_story_viewed",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Set add and counter increment"
      }
    ],
    "non_goals": [
      "Active story deletion (use lazy expiration)",
      "Story highlights/archives",
      "Story replies/reactions",
      "Close friends list"
    ]
  },
  "assumptions": [
    "24-hour TTL is a hard requirement (not configurable per story)",
    "View tracking is not privacy-restricted - story owner can see all viewers",
    "Eventual consistency acceptable for view counts",
    "Stories from non-followed users not visible (no explore stories)",
    "One media item per story (no multi-slide stories in this part)"
  ],
  "tradeoffs": [
    {
      "decision": "Lazy expiration vs Active TTL deletion",
      "chosen": "Lazy expiration",
      "why": "Simpler implementation, no background workers needed. Check expiration on read.",
      "alternative": "Background job with Cassandra TTL",
      "when_to_switch": "Production system with millions of expired stories consuming memory"
    },
    {
      "decision": "Set vs Bloom filter for view tracking",
      "chosen": "Set",
      "why": "Interview simplicity, exact viewer list needed for analytics",
      "alternative": "Bloom filter for 'has viewed' + separate append log for viewer list",
      "when_to_switch": "Billions of view events where memory/speed matters"
    },
    {
      "decision": "Inline view count vs Separate counter service",
      "chosen": "Inline increment",
      "why": "Simpler code, works for interview scale",
      "alternative": "Redis HyperLogLog or counter service",
      "when_to_switch": "High concurrency with counter races"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1 method signatures",
      "Follower/following graph structure",
      "Post/FeedItem data classes"
    ],
    "what_to_change": [
      "Added stories dict, user_stories dict, story_views dict",
      "New Story, StoryRing, StoryFeed dataclasses",
      "StoryType enum"
    ],
    "interfaces_and_boundaries": "Stories are completely separate from Posts - different storage, different lifecycle. Story ring reuses following relationship from Part 1. Part 3 could add Direct Messages which would also reuse the social graph.",
    "invariants": [
      "Expired stories never appear in story ring or feed",
      "View count is always >= viewer list size (never negative)",
      "User's own stories appear in their profile but not their story ring",
      "Story ring shows followed users only"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1 only):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Instagram                              \u2502\n\u2502  \u251c\u2500\u2500 posts (permanent)                  \u2502\n\u2502  \u251c\u2500\u2500 feeds (pre-computed)               \u2502\n\u2502  \u2514\u2500\u2500 followers/following (social graph) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 2 added):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Instagram                              \u2502\n\u2502  \u251c\u2500\u2500 posts (permanent)                  \u2502\n\u2502  \u251c\u2500\u2500 feeds (pre-computed)               \u2502\n\u2502  \u251c\u2500\u2500 followers/following (social graph) \u2502\n\u2502  \u2502                                      \u2502\n\u2502  \u251c\u2500\u2500 stories (ephemeral, TTL: 24h)     \u2502  \u2190 NEW\n\u2502  \u251c\u2500\u2500 user_stories (user \u2192 story_ids)   \u2502  \u2190 NEW\n\u2502  \u2514\u2500\u2500 story_views (story \u2192 viewers)     \u2502  \u2190 NEW\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nPOST STORY FLOW:\n  User \u2500\u2500post_story()\u2500\u2500\u25ba Create Story \u2500\u2500\u25ba Store in stories{}\n                               \u2502\n                               \u2514\u2500\u2500\u25ba Add to user_stories[user_id]\n\nSTORY RING FLOW:\n  User \u2500\u2500get_story_ring()\u2500\u2500\u25ba For each followed user:\n         \u2502                         \u2502\n         \u2502                   Get active stories\n         \u2502                   (filter expired)\n         \u2502                         \u2502\n         \u2502                   Check if any unviewed\n         \u2502                   by this viewer\n         \u2502                         \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Sort: unviewed first,\n                             then by recency\n                                   \u2502\n                                   \u25bc\n                             Return StoryRing\n\nVIEW TRACKING:\n  Viewer \u2500\u2500mark_story_viewed()\u2500\u2500\u25ba Add to story_views[story_id]\n                                        \u2502\n                                        \u2514\u2500\u2500\u25ba Increment view_count\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Store stories in same posts table with is_story flag, filter on every query for TTL",
      "time_complexity": "O(P) where P = all posts, need to scan for TTL check",
      "space_complexity": "O(P + V) where V = all view events ever",
      "why_not_optimal": "Mixing ephemeral and permanent content pollutes queries. No automatic cleanup means unbounded storage growth. View tracking per story becomes a hotspot."
    },
    {
      "name": "Optimal Approach",
      "description": "Separate stories storage with lazy TTL expiration. Story ring as aggregated view with per-viewer unviewed status. View tracking with idempotent counter.",
      "time_complexity": "O(1) for post_story, O(F\u00d7S) for get_story_ring, O(1) for mark_viewed",
      "space_complexity": "O(S_active) for stories + O(V) for views where S_active = non-expired stories",
      "key_insight": "Separate ephemeral from permanent. Lazy expiration avoids background jobs. Pre-aggregating 'has unviewed' per user enables fast story ring UI."
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Core Design Decisions:**\n\n1. **Separate Stories Storage**: Unlike posts which are permanent, stories have a fixed 24h lifecycle. Keeping them separate allows different retention policies.\n\n2. **Lazy TTL Expiration**: Rather than running background deletion jobs, we check `expires_at` on every read. Expired stories are filtered out and lazily cleaned from `user_stories` lists.\n\n3. **View Tracking with Idempotency**: `story_views[story_id]` is a **Set** of viewer IDs. Re-viewing doesn't double-count. The `view_count` on Story is incremented only on first view.\n\n4. **Story Ring Aggregation**: For each followed user, we:\n   - Get their active (non-expired) stories\n   - Check if viewer has seen ALL of them\n   - Record `has_unviewed = True` if any story is unseen\n   - Sort by unviewed first, then recency\n\n**Production Enhancements** (mentioned but not implemented):\n- Cassandra with TTL for automatic expiration\n- Bloom filter for O(1) 'has viewed' checks\n- Redis sorted set for story ring ordering\n- HyperLogLog for approximate unique view counts",
    "data_structures": [
      {
        "structure": "Dict[str, Story] stories",
        "purpose": "Story storage by story_id with TTL metadata"
      },
      {
        "structure": "Dict[str, List[str]] user_stories",
        "purpose": "Index of story_ids per user, newest first"
      },
      {
        "structure": "Dict[str, Set[str]] story_views",
        "purpose": "Viewers per story for deduplication and analytics"
      },
      {
        "structure": "StoryRing (dataclass)",
        "purpose": "Aggregated view of followed users with active stories"
      }
    ],
    "algorithm_steps": [
      "Step 1: post_story() - Create Story with expires_at = now + 24h, store in stories{}, prepend to user_stories[user_id]",
      "Step 2: _is_story_active() - Check current_time < expires_at",
      "Step 3: _get_active_stories() - Filter user's stories by expiration, lazy cleanup expired ones",
      "Step 4: get_story_ring() - For each followed user, get active stories, check viewed status, aggregate into StoryRingUser",
      "Step 5: mark_story_viewed() - Add viewer to story_views set (idempotent), increment counter only on first view"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Instagram System Design - Part 2: Stories Feature",
    "Extends Part 1 with ephemeral 24-hour stories and view tracking",
    "\"\"\"",
    "from typing import List, Dict, Optional, Set",
    "from dataclasses import dataclass, field",
    "from collections import defaultdict",
    "from datetime import datetime",
    "from enum import Enum",
    "import uuid",
    "",
    "",
    "@dataclass",
    "class Location:",
    "    lat: float",
    "    lng: float",
    "",
    "",
    "@dataclass",
    "class Post:",
    "    post_id: str",
    "    user_id: str",
    "    caption: str",
    "    image_urls: Dict[str, str]",
    "    tags: List[str]",
    "    location: Optional[Location]",
    "    created_at: int",
    "    like_count: int = 0",
    "    comment_count: int = 0",
    "",
    "",
    "@dataclass",
    "class FeedItem:",
    "    post_id: str",
    "    user_id: str",
    "    timestamp: int",
    "    is_celebrity: bool = False",
    "",
    "",
    "@dataclass",
    "class FeedResponse:",
    "    posts: List[Post]",
    "    next_cursor: Optional[str]",
    "",
    "",
    "# Part 2: New dataclasses for Stories",
    "class StoryType(Enum):",
    "    PHOTO = \"photo\"",
    "    VIDEO = \"video\"",
    "",
    "",
    "@dataclass",
    "class Story:",
    "    story_id: str",
    "    user_id: str",
    "    media_url: str",
    "    story_type: StoryType",
    "    created_at: int",
    "    expires_at: int",
    "    view_count: int = 0",
    "",
    "",
    "@dataclass",
    "class StoryRingUser:",
    "    user_id: str",
    "    has_unviewed: bool",
    "    latest_story_time: int",
    "",
    "",
    "@dataclass",
    "class StoryRing:",
    "    users: List[StoryRingUser]",
    "",
    "",
    "@dataclass",
    "class StoryFeed:",
    "    stories_by_user: Dict[str, List[Story]]",
    "",
    "",
    "class Instagram:",
    "    \"\"\"",
    "    Hybrid Push/Pull feed with ephemeral Stories.",
    "    Stories auto-expire after 24h via lazy TTL check.",
    "    \"\"\"",
    "    CELEBRITY_THRESHOLD = 10000",
    "    FEED_SIZE = 1000",
    "    STORY_TTL_SECONDS = 24 * 60 * 60  # 24 hours",
    "    ",
    "    def __init__(self):",
    "        # Part 1: Core data stores",
    "        self.users: Dict[str, dict] = {}",
    "        self.posts: Dict[str, Post] = {}",
    "        self.followers: Dict[str, Set[str]] = defaultdict(set)",
    "        self.following: Dict[str, Set[str]] = defaultdict(set)",
    "        self.feeds: Dict[str, List[FeedItem]] = defaultdict(list)",
    "        self.celebrity_posts: Dict[str, List[Post]] = defaultdict(list)",
    "        ",
    "        # Part 2: Stories data stores",
    "        self.stories: Dict[str, Story] = {}",
    "        self.user_stories: Dict[str, List[str]] = defaultdict(list)",
    "        self.story_views: Dict[str, Set[str]] = defaultdict(set)",
    "    ",
    "    # === Part 1 methods (unchanged) ===",
    "    def upload_photo(self, user_id: str, photo: bytes, caption: str,",
    "                     tags: List[str], location: Optional[Location]) -> str:",
    "        post_id = f\"post_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        image_urls = {",
    "            'thumbnail': f'cdn.instagram.com/{post_id}_150.jpg',",
    "            'small': f'cdn.instagram.com/{post_id}_320.jpg',",
    "            'medium': f'cdn.instagram.com/{post_id}_640.jpg',",
    "            'large': f'cdn.instagram.com/{post_id}_1080.jpg'",
    "        }",
    "        post = Post(post_id=post_id, user_id=user_id, caption=caption,",
    "                    image_urls=image_urls, tags=tags, location=location,",
    "                    created_at=timestamp)",
    "        self.posts[post_id] = post",
    "        self._fan_out(user_id, post)",
    "        return post_id",
    "    ",
    "    def _fan_out(self, user_id: str, post: Post) -> None:",
    "        follower_count = len(self.followers.get(user_id, set()))",
    "        if follower_count < self.CELEBRITY_THRESHOLD:",
    "            feed_item = FeedItem(post_id=post.post_id, user_id=user_id,",
    "                                 timestamp=post.created_at)",
    "            for follower_id in self.followers.get(user_id, set()):",
    "                self.feeds[follower_id].insert(0, feed_item)",
    "                if len(self.feeds[follower_id]) > self.FEED_SIZE:",
    "                    self.feeds[follower_id].pop()",
    "        else:",
    "            self.celebrity_posts[user_id].insert(0, post)",
    "    ",
    "    def get_news_feed(self, user_id: str, page_size: int,",
    "                       cursor: Optional[str]) -> FeedResponse:",
    "        start_idx = int(cursor) if cursor else 0",
    "        feed_items = self.feeds.get(user_id, [])[start_idx:start_idx + page_size * 2]",
    "        celebrity_followees = [",
    "            uid for uid in self.following.get(user_id, set())",
    "            if len(self.followers.get(uid, set())) >= self.CELEBRITY_THRESHOLD",
    "        ]",
    "        celeb_posts = []",
    "        for celeb_id in celebrity_followees:",
    "            celeb_posts.extend(self.celebrity_posts.get(celeb_id, [])[:10])",
    "        all_items = []",
    "        for item in feed_items:",
    "            post = self.posts.get(item.post_id)",
    "            if post:",
    "                all_items.append((item.timestamp, post, False))",
    "        for post in celeb_posts:",
    "            all_items.append((post.created_at, post, True))",
    "        all_items.sort(key=lambda x: x[0], reverse=True)",
    "        result_posts = [item[1] for item in all_items[:page_size]]",
    "        next_cursor = str(start_idx + page_size) if len(all_items) > page_size else None",
    "        return FeedResponse(posts=result_posts, next_cursor=next_cursor)",
    "    ",
    "    def get_user_timeline(self, user_id: str, page_size: int,",
    "                          cursor: Optional[str]) -> FeedResponse:",
    "        user_posts = [p for p in self.posts.values() if p.user_id == user_id]",
    "        user_posts.sort(key=lambda p: p.created_at, reverse=True)",
    "        start_idx = int(cursor) if cursor else 0",
    "        result = user_posts[start_idx:start_idx + page_size]",
    "        next_cursor = str(start_idx + page_size) if start_idx + page_size < len(user_posts) else None",
    "        return FeedResponse(posts=result, next_cursor=next_cursor)",
    "    ",
    "    def follow_user(self, follower_id: str, followee_id: str) -> bool:",
    "        if follower_id == followee_id:",
    "            return False",
    "        if followee_id in self.following[follower_id]:",
    "            return False",
    "        self.followers[followee_id].add(follower_id)",
    "        self.following[follower_id].add(followee_id)",
    "        recent_posts = [p for p in self.posts.values() if p.user_id == followee_id][:20]",
    "        for post in recent_posts:",
    "            self.feeds[follower_id].insert(0, FeedItem(",
    "                post_id=post.post_id, user_id=followee_id, timestamp=post.created_at))",
    "        return True",
    "    ",
    "    def like_post(self, user_id: str, post_id: str) -> bool:",
    "        if post_id not in self.posts:",
    "            return False",
    "        self.posts[post_id].like_count += 1",
    "        return True",
    "    ",
    "    # === Part 2: Stories methods ===",
    "    ",
    "    def post_story(self, user_id: str, media: bytes, story_type: StoryType) -> str:",
    "        \"\"\"Post ephemeral story with 24h TTL. Returns story_id immediately.\"\"\"",
    "        story_id = f\"story_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        ",
    "        story = Story(",
    "            story_id=story_id,",
    "            user_id=user_id,",
    "            media_url=f'cdn.instagram.com/stories/{story_id}.jpg',",
    "            story_type=story_type,",
    "            created_at=timestamp,",
    "            expires_at=timestamp + self.STORY_TTL_SECONDS",
    "        )",
    "        ",
    "        self.stories[story_id] = story",
    "        self.user_stories[user_id].insert(0, story_id)  # newest first",
    "        return story_id",
    "    ",
    "    def _is_story_active(self, story: Story) -> bool:",
    "        \"\"\"Check if story hasn't expired (lazy TTL check).\"\"\"",
    "        return int(datetime.now().timestamp()) < story.expires_at",
    "    ",
    "    def _get_active_stories(self, user_id: str) -> List[Story]:",
    "        \"\"\"Get non-expired stories for user with lazy cleanup.\"\"\"",
    "        active = []",
    "        new_story_ids = []",
    "        ",
    "        for sid in self.user_stories.get(user_id, []):",
    "            story = self.stories.get(sid)",
    "            if story and self._is_story_active(story):",
    "                active.append(story)",
    "                new_story_ids.append(sid)",
    "        ",
    "        self.user_stories[user_id] = new_story_ids  # cleanup expired",
    "        return active",
    "    ",
    "    def get_story_ring(self, user_id: str) -> StoryRing:",
    "        \"\"\"",
    "        Get followed users with active stories.",
    "        Sorted: unviewed first, then by recency.",
    "        \"\"\"",
    "        ring_users = []",
    "        ",
    "        # Collect stories this viewer has seen",
    "        viewed_stories = set()",
    "        for story_id, viewers in self.story_views.items():",
    "            if user_id in viewers:",
    "                viewed_stories.add(story_id)",
    "        ",
    "        # Check each followed user",
    "        for followee_id in self.following.get(user_id, set()):",
    "            active = self._get_active_stories(followee_id)",
    "            if not active:",
    "                continue",
    "            ",
    "            has_unviewed = any(s.story_id not in viewed_stories for s in active)",
    "            latest_time = max(s.created_at for s in active)",
    "            ",
    "            ring_users.append(StoryRingUser(",
    "                user_id=followee_id,",
    "                has_unviewed=has_unviewed,",
    "                latest_story_time=latest_time",
    "            ))",
    "        ",
    "        # Sort: unviewed first, then by recency",
    "        ring_users.sort(key=lambda u: (-u.has_unviewed, -u.latest_story_time))",
    "        return StoryRing(users=ring_users)",
    "    ",
    "    def get_stories(self, user_id: str) -> StoryFeed:",
    "        \"\"\"Get all active stories from followed users.\"\"\"",
    "        stories_by_user = {}",
    "        for followee_id in self.following.get(user_id, set()):",
    "            active = self._get_active_stories(followee_id)",
    "            if active:",
    "                stories_by_user[followee_id] = active",
    "        return StoryFeed(stories_by_user=stories_by_user)",
    "    ",
    "    def mark_story_viewed(self, user_id: str, story_id: str) -> bool:",
    "        \"\"\"Mark story as viewed. Idempotent - won't double count.\"\"\"",
    "        story = self.stories.get(story_id)",
    "        if not story or not self._is_story_active(story):",
    "            return False",
    "        ",
    "        # Only increment on first view",
    "        if user_id not in self.story_views[story_id]:",
    "            self.story_views[story_id].add(user_id)",
    "            story.view_count += 1",
    "        return True",
    "    ",
    "    def get_story_viewers(self, story_id: str) -> List[str]:",
    "        \"\"\"Get list of users who viewed this story.\"\"\"",
    "        return list(self.story_views.get(story_id, set()))",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('Instagram Part 2: Stories Demo')",
    "    print('=' * 60)",
    "    ",
    "    ig = Instagram()",
    "    alice, bob, charlie = 'alice', 'bob', 'charlie'",
    "    ",
    "    # Setup follow relationships",
    "    ig.follow_user(alice, bob)",
    "    ig.follow_user(alice, charlie)",
    "    print(f\"\\nAlice follows: {list(ig.following[alice])}\")",
    "    ",
    "    # Bob posts two stories",
    "    story1 = ig.post_story(bob, b'photo1', StoryType.PHOTO)",
    "    story2 = ig.post_story(bob, b'photo2', StoryType.PHOTO)",
    "    print(f\"\\nBob posted stories: {story1}, {story2}\")",
    "    ",
    "    # Charlie posts a story",
    "    story3 = ig.post_story(charlie, b'video', StoryType.VIDEO)",
    "    print(f\"Charlie posted story: {story3}\")",
    "    ",
    "    # Alice checks story ring - should see both with unviewed=True",
    "    ring = ig.get_story_ring(alice)",
    "    print(f\"\\nAlice's story ring (before viewing):\")",
    "    for u in ring.users:",
    "        print(f\"  - {u.user_id}: unviewed={u.has_unviewed}\")",
    "    ",
    "    # Alice views Bob's first story",
    "    ig.mark_story_viewed(alice, story1)",
    "    print(f\"\\nAlice viewed {story1}\")",
    "    ",
    "    # Bob still has unviewed (story2)",
    "    ring = ig.get_story_ring(alice)",
    "    print(f\"\\nAlice's story ring (after viewing one):\")",
    "    for u in ring.users:",
    "        print(f\"  - {u.user_id}: unviewed={u.has_unviewed}\")",
    "    ",
    "    # Alice views all of Bob's stories",
    "    ig.mark_story_viewed(alice, story2)",
    "    ring = ig.get_story_ring(alice)",
    "    print(f\"\\nAlice's story ring (after viewing all of Bob's):\")",
    "    for u in ring.users:",
    "        print(f\"  - {u.user_id}: unviewed={u.has_unviewed}\")",
    "    ",
    "    # Check view analytics",
    "    print(f\"\\nStory analytics for {story1}:\")",
    "    print(f\"  View count: {ig.stories[story1].view_count}\")",
    "    print(f\"  Viewers: {ig.get_story_viewers(story1)}\")",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('Key: Story ring shows unviewed users FIRST, sorted by recency!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.time.Instant;",
    "",
    "public class Instagram {",
    "    private static final int CELEBRITY_THRESHOLD = 10000;",
    "    private static final int FEED_SIZE = 1000;",
    "    private static final long STORY_TTL_SECONDS = 24 * 60 * 60;",
    "    ",
    "    // Part 1: Core data stores",
    "    private final Map<String, User> users = new ConcurrentHashMap<>();",
    "    private final Map<String, Post> posts = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> followers = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> following = new ConcurrentHashMap<>();",
    "    private final Map<String, Deque<FeedItem>> feeds = new ConcurrentHashMap<>();",
    "    private final Map<String, Deque<Post>> celebrityPosts = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2: Stories data stores",
    "    private final Map<String, Story> stories = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> userStories = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> storyViews = new ConcurrentHashMap<>();",
    "    ",
    "    // Inner classes from Part 1",
    "    static class Location { double lat, lng; Location(double lat, double lng) { this.lat = lat; this.lng = lng; } }",
    "    static class User { String userId, username; User(String id, String name) { userId = id; username = name; } }",
    "    static class Post {",
    "        String postId, userId, caption;",
    "        Map<String, String> imageUrls;",
    "        List<String> tags;",
    "        Location location;",
    "        long createdAt;",
    "        int likeCount = 0;",
    "    }",
    "    static class FeedItem { String postId, userId; long timestamp; boolean isCelebrity; }",
    "    static class FeedResponse { List<Post> posts; String nextCursor; FeedResponse(List<Post> p, String c) { posts = p; nextCursor = c; } }",
    "    ",
    "    // Part 2: New inner classes",
    "    enum StoryType { PHOTO, VIDEO }",
    "    ",
    "    static class Story {",
    "        String storyId, userId, mediaUrl;",
    "        StoryType storyType;",
    "        long createdAt, expiresAt;",
    "        int viewCount = 0;",
    "    }",
    "    ",
    "    static class StoryRingUser {",
    "        String userId;",
    "        boolean hasUnviewed;",
    "        long latestStoryTime;",
    "        StoryRingUser(String u, boolean h, long t) { userId = u; hasUnviewed = h; latestStoryTime = t; }",
    "    }",
    "    ",
    "    static class StoryRing { List<StoryRingUser> users; StoryRing(List<StoryRingUser> u) { users = u; } }",
    "    static class StoryFeed { Map<String, List<Story>> storiesByUser; StoryFeed(Map<String, List<Story>> s) { storiesByUser = s; } }",
    "    ",
    "    // === Part 1 methods (unchanged) ===",
    "    public String uploadPhoto(String userId, byte[] photo, String caption, List<String> tags, Location location) {",
    "        String postId = \"post_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Post post = new Post();",
    "        post.postId = postId; post.userId = userId; post.caption = caption;",
    "        post.tags = tags; post.location = location; post.createdAt = timestamp;",
    "        post.imageUrls = Map.of(\"thumbnail\", \"cdn/\" + postId + \"_150.jpg\", \"large\", \"cdn/\" + postId + \"_1080.jpg\");",
    "        posts.put(postId, post);",
    "        fanOut(userId, post);",
    "        return postId;",
    "    }",
    "    ",
    "    private void fanOut(String userId, Post post) {",
    "        Set<String> userFollowers = followers.getOrDefault(userId, Set.of());",
    "        if (userFollowers.size() < CELEBRITY_THRESHOLD) {",
    "            FeedItem item = new FeedItem(); item.postId = post.postId; item.userId = userId; item.timestamp = post.createdAt;",
    "            for (String followerId : userFollowers) {",
    "                feeds.computeIfAbsent(followerId, k -> new LinkedList<>()).addFirst(item);",
    "                while (feeds.get(followerId).size() > FEED_SIZE) feeds.get(followerId).removeLast();",
    "            }",
    "        } else { celebrityPosts.computeIfAbsent(userId, k -> new LinkedList<>()).addFirst(post); }",
    "    }",
    "    ",
    "    public FeedResponse getNewsFeed(String userId, int pageSize, String cursor) {",
    "        int startIdx = cursor != null ? Integer.parseInt(cursor) : 0;",
    "        List<FeedItem> feedList = new ArrayList<>(feeds.getOrDefault(userId, new LinkedList<>()));",
    "        List<Post> celebPosts = new ArrayList<>();",
    "        for (String followeeId : following.getOrDefault(userId, Set.of())) {",
    "            if (followers.getOrDefault(followeeId, Set.of()).size() >= CELEBRITY_THRESHOLD) {",
    "                Deque<Post> cp = celebrityPosts.get(followeeId);",
    "                if (cp != null) { int c = 0; for (Post p : cp) if (c++ < 10) celebPosts.add(p); }",
    "            }",
    "        }",
    "        List<Post> allPosts = new ArrayList<>();",
    "        for (FeedItem item : feedList) { Post p = posts.get(item.postId); if (p != null) allPosts.add(p); }",
    "        allPosts.addAll(celebPosts);",
    "        allPosts.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        int end = Math.min(startIdx + pageSize, allPosts.size());",
    "        return new FeedResponse(allPosts.subList(startIdx, end), end < allPosts.size() ? String.valueOf(end) : null);",
    "    }",
    "    ",
    "    public boolean followUser(String followerId, String followeeId) {",
    "        if (followerId.equals(followeeId)) return false;",
    "        followers.computeIfAbsent(followeeId, k -> ConcurrentHashMap.newKeySet()).add(followerId);",
    "        following.computeIfAbsent(followerId, k -> ConcurrentHashMap.newKeySet()).add(followeeId);",
    "        return true;",
    "    }",
    "    ",
    "    public boolean likePost(String userId, String postId) {",
    "        Post post = posts.get(postId);",
    "        if (post == null) return false;",
    "        post.likeCount++;",
    "        return true;",
    "    }",
    "    ",
    "    // === Part 2: Stories methods ===",
    "    ",
    "    public String postStory(String userId, byte[] media, StoryType type) {",
    "        String storyId = \"story_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        ",
    "        Story story = new Story();",
    "        story.storyId = storyId;",
    "        story.userId = userId;",
    "        story.mediaUrl = \"cdn.instagram.com/stories/\" + storyId + \".jpg\";",
    "        story.storyType = type;",
    "        story.createdAt = timestamp;",
    "        story.expiresAt = timestamp + STORY_TTL_SECONDS;",
    "        ",
    "        stories.put(storyId, story);",
    "        userStories.computeIfAbsent(userId, k -> new ArrayList<>()).add(0, storyId);",
    "        return storyId;",
    "    }",
    "    ",
    "    private boolean isStoryActive(Story story) {",
    "        return Instant.now().getEpochSecond() < story.expiresAt;",
    "    }",
    "    ",
    "    private List<Story> getActiveStories(String userId) {",
    "        List<Story> active = new ArrayList<>();",
    "        List<String> storyIds = userStories.getOrDefault(userId, new ArrayList<>());",
    "        List<String> newStoryIds = new ArrayList<>();",
    "        ",
    "        for (String sid : storyIds) {",
    "            Story story = stories.get(sid);",
    "            if (story != null && isStoryActive(story)) {",
    "                active.add(story);",
    "                newStoryIds.add(sid);",
    "            }",
    "        }",
    "        userStories.put(userId, newStoryIds);",
    "        return active;",
    "    }",
    "    ",
    "    public StoryRing getStoryRing(String userId) {",
    "        List<StoryRingUser> ringUsers = new ArrayList<>();",
    "        ",
    "        // Collect viewed stories",
    "        Set<String> viewedStories = new HashSet<>();",
    "        for (Map.Entry<String, Set<String>> e : storyViews.entrySet()) {",
    "            if (e.getValue().contains(userId)) viewedStories.add(e.getKey());",
    "        }",
    "        ",
    "        // Check each followed user",
    "        for (String followeeId : following.getOrDefault(userId, Set.of())) {",
    "            List<Story> active = getActiveStories(followeeId);",
    "            if (active.isEmpty()) continue;",
    "            ",
    "            boolean hasUnviewed = active.stream().anyMatch(s -> !viewedStories.contains(s.storyId));",
    "            long latestTime = active.stream().mapToLong(s -> s.createdAt).max().orElse(0);",
    "            ringUsers.add(new StoryRingUser(followeeId, hasUnviewed, latestTime));",
    "        }",
    "        ",
    "        // Sort: unviewed first, then by recency",
    "        ringUsers.sort((a, b) -> {",
    "            if (a.hasUnviewed != b.hasUnviewed) return b.hasUnviewed ? 1 : -1;",
    "            return Long.compare(b.latestStoryTime, a.latestStoryTime);",
    "        });",
    "        return new StoryRing(ringUsers);",
    "    }",
    "    ",
    "    public StoryFeed getStories(String userId) {",
    "        Map<String, List<Story>> storiesByUser = new HashMap<>();",
    "        for (String followeeId : following.getOrDefault(userId, Set.of())) {",
    "            List<Story> active = getActiveStories(followeeId);",
    "            if (!active.isEmpty()) storiesByUser.put(followeeId, active);",
    "        }",
    "        return new StoryFeed(storiesByUser);",
    "    }",
    "    ",
    "    public boolean markStoryViewed(String userId, String storyId) {",
    "        Story story = stories.get(storyId);",
    "        if (story == null || !isStoryActive(story)) return false;",
    "        ",
    "        Set<String> viewers = storyViews.computeIfAbsent(storyId, k -> ConcurrentHashMap.newKeySet());",
    "        if (!viewers.contains(userId)) {",
    "            viewers.add(userId);",
    "            story.viewCount++;",
    "        }",
    "        return true;",
    "    }",
    "    ",
    "    public List<String> getStoryViewers(String storyId) {",
    "        return new ArrayList<>(storyViews.getOrDefault(storyId, Set.of()));",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Instagram Part 2: Stories Demo (Java)\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        Instagram ig = new Instagram();",
    "        ",
    "        ig.followUser(\"alice\", \"bob\");",
    "        ig.followUser(\"alice\", \"charlie\");",
    "        ",
    "        String story1 = ig.postStory(\"bob\", new byte[0], StoryType.PHOTO);",
    "        String story2 = ig.postStory(\"bob\", new byte[0], StoryType.PHOTO);",
    "        String story3 = ig.postStory(\"charlie\", new byte[0], StoryType.VIDEO);",
    "        System.out.println(\"\\nBob posted: \" + story1 + \", \" + story2);",
    "        System.out.println(\"Charlie posted: \" + story3);",
    "        ",
    "        StoryRing ring = ig.getStoryRing(\"alice\");",
    "        System.out.println(\"\\nAlice's story ring (before viewing):\");",
    "        for (StoryRingUser u : ring.users) {",
    "            System.out.println(\"  - \" + u.userId + \": unviewed=\" + u.hasUnviewed);",
    "        }",
    "        ",
    "        ig.markStoryViewed(\"alice\", story1);",
    "        ig.markStoryViewed(\"alice\", story2);",
    "        ",
    "        ring = ig.getStoryRing(\"alice\");",
    "        System.out.println(\"\\nAlice's story ring (after viewing Bob's):\");",
    "        for (StoryRingUser u : ring.users) {",
    "            System.out.println(\"  - \" + u.userId + \": unviewed=\" + u.hasUnviewed);",
    "        }",
    "        ",
    "        System.out.println(\"\\nStory \" + story1 + \" views: \" + ig.stories.get(story1).viewCount);",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-11",
      "explanation": "Imports and module docstring indicating this extends Part 1 with Stories"
    },
    {
      "lines": "44-58",
      "explanation": "New dataclasses: StoryType enum, Story with TTL fields, StoryRingUser for ring UI"
    },
    {
      "lines": "74-77",
      "explanation": "New Part 2 data stores: stories by ID, user_stories index, view tracking"
    },
    {
      "lines": "145-159",
      "explanation": "post_story(): Creates Story with expires_at, stores in both stories{} and user_stories[]"
    },
    {
      "lines": "161-163",
      "explanation": "_is_story_active(): Simple TTL check - current time vs expires_at"
    },
    {
      "lines": "165-176",
      "explanation": "_get_active_stories(): Filters expired stories, lazy cleanup of user_stories list"
    },
    {
      "lines": "178-201",
      "explanation": "get_story_ring(): Core algorithm - aggregates followed users' stories, checks viewed status, sorts unviewed first"
    },
    {
      "lines": "211-221",
      "explanation": "mark_story_viewed(): Idempotent view tracking - only increments counter on first view"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "post_story": {
          "complexity": "O(1)",
          "explanation": "Direct insert into hash map and list prepend"
        },
        "get_story_ring": {
          "complexity": "O(F \u00d7 S + F log F)",
          "explanation": "F = followed users, S = avg stories per user. Iteration is O(F\u00d7S), sort is O(F log F)"
        },
        "get_stories": {
          "complexity": "O(F \u00d7 S)",
          "explanation": "Iterate all followed users and their stories"
        },
        "mark_story_viewed": {
          "complexity": "O(1)",
          "explanation": "Hash set add and counter increment"
        },
        "get_story_viewers": {
          "complexity": "O(V)",
          "explanation": "V = viewers of that story, copying set to list"
        }
      },
      "overall_change": "Part 1 operations unchanged. New story operations are bounded by social graph size."
    },
    "space": {
      "additional_space": "O(S + U\u00d7S_avg + V) where S=total stories, U=users with stories, V=total view events",
      "explanation": "stories{} stores all active stories. user_stories{} indexes story IDs per user. story_views{} stores all view events."
    }
  },
  "dry_run": {
    "example_input": "Alice follows Bob and Charlie. Bob posts 2 stories. Alice views story1. Get story ring.",
    "steps": [
      {
        "step": 1,
        "action": "follow_user(alice, bob)",
        "state": "following[alice] = {bob}",
        "explanation": "Alice now follows Bob"
      },
      {
        "step": 2,
        "action": "post_story(bob, PHOTO)",
        "state": "stories[story1] = Story(...), user_stories[bob] = [story1]",
        "explanation": "Bob posts first story"
      },
      {
        "step": 3,
        "action": "post_story(bob, PHOTO)",
        "state": "user_stories[bob] = [story2, story1]",
        "explanation": "Bob posts second story, prepended"
      },
      {
        "step": 4,
        "action": "mark_story_viewed(alice, story1)",
        "state": "story_views[story1] = {alice}, story1.view_count = 1",
        "explanation": "Alice views story1"
      },
      {
        "step": 5,
        "action": "get_story_ring(alice)",
        "state": "Check bob's stories: [story2, story1]",
        "explanation": "Alice has viewed story1 but not story2"
      },
      {
        "step": 6,
        "action": "Build StoryRingUser",
        "state": "has_unviewed = True (story2 not viewed)",
        "explanation": "Bob appears with unviewed=True because story2 is unseen"
      }
    ],
    "final_output": "StoryRing with Bob showing has_unviewed=True"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Post story, get story ring - should appear",
      "View all stories, has_unviewed should be False"
    ],
    "likely_bugs": [
      "Forgetting to check ALL stories for viewed status",
      "Not sorting story ring correctly",
      "Double-counting views"
    ],
    "recommended_logs_or_asserts": [
      "assert story.expires_at > story.created_at",
      "log story_views changes for debugging"
    ],
    "how_to_localize": "1. Check if story is being stored correctly (stories{}). 2. Check if user_stories index is updated. 3. Check viewed_stories set construction. 4. Verify sort order."
  },
  "edge_cases": [
    {
      "case": "User has no followers with stories",
      "handling": "get_story_ring returns empty StoryRing",
      "gotcha": "Don't fail on empty following set"
    },
    {
      "case": "All stories expired",
      "handling": "_get_active_stories returns empty list, lazy cleanup occurs",
      "gotcha": "User should disappear from story ring"
    },
    {
      "case": "View own story",
      "handling": "Allowed - owner can view their own analytics",
      "gotcha": "Owner should still see view count increment"
    },
    {
      "case": "Re-view same story",
      "handling": "Idempotent - no double count",
      "gotcha": "Check set membership before incrementing"
    },
    {
      "case": "View expired story",
      "handling": "Return False, don't track view",
      "gotcha": "Must check TTL before allowing view"
    }
  ],
  "test_cases": [
    {
      "name": "Basic story flow",
      "input": "post_story(bob, photo, PHOTO) -> get_story_ring(alice who follows bob)",
      "expected": "StoryRing with bob, has_unviewed=True",
      "explanation": "New story appears in follower's story ring as unviewed"
    },
    {
      "name": "View marks story as viewed",
      "input": "post_story(bob, ...) -> mark_story_viewed(alice, story_id) -> get_story_ring(alice)",
      "expected": "StoryRing with bob, has_unviewed=False (if only one story)",
      "explanation": "After viewing all stories, has_unviewed becomes False"
    },
    {
      "name": "Partial view",
      "input": "post_story(bob) x2 -> mark_story_viewed(alice, story1) -> get_story_ring(alice)",
      "expected": "StoryRing with bob, has_unviewed=True",
      "explanation": "Still has unviewed because story2 wasn't viewed"
    },
    {
      "name": "Story ring ordering",
      "input": "bob posts story -> charlie posts story -> alice views charlie's -> get_story_ring(alice)",
      "expected": "StoryRing: [bob (unviewed), charlie (viewed)]",
      "explanation": "Unviewed users appear first regardless of recency"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking only latest story for viewed status",
      "why_wrong": "User may have viewed latest but not earlier stories - still should show as unviewed",
      "correct_approach": "Check if ANY story from user is unviewed",
      "code_example_wrong": "has_unviewed = active[0].story_id not in viewed_stories",
      "code_example_correct": "has_unviewed = any(s.story_id not in viewed_stories for s in active)"
    },
    {
      "mistake": "Not handling TTL expiration",
      "why_wrong": "Expired stories should not appear in ring or count toward viewed status",
      "correct_approach": "Always filter by _is_story_active() before processing",
      "code_example_wrong": "for sid in user_stories[user_id]: active.append(stories[sid])",
      "code_example_correct": "for sid in user_stories[user_id]: if self._is_story_active(stories[sid]): active.append(stories[sid])"
    },
    {
      "mistake": "Double-counting view events",
      "why_wrong": "Re-viewing shouldn't increase count",
      "correct_approach": "Check set membership before incrementing counter",
      "code_example_wrong": "story_views[story_id].add(user_id); story.view_count += 1",
      "code_example_correct": "if user_id not in story_views[story_id]: story_views[story_id].add(user_id); story.view_count += 1"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by highlighting the key difference from posts: TTL management and per-viewer state. Explain the data model additions, then walk through the story ring algorithm.",
    "what_to_mention": [
      "Lazy TTL expiration vs background deletion tradeoff",
      "In production: Bloom filter for has_viewed, HyperLogLog for unique counts",
      "Story ring sorting: unviewed first provides better UX",
      "View tracking is idempotent - critical for high write volume"
    ],
    "time_allocation": "2 min understanding, 3 min design, 7 min implementation, 2 min testing",
    "if_stuck": [
      "Focus on post_story and get_story_ring first - they're the core",
      "Remember: stories are just posts with TTL",
      "View tracking is a simple set add"
    ]
  },
  "connection_to_next_part": "Part 3 could add Direct Messages, which would reuse the social graph and potentially include story replies. The story infrastructure (ephemeral content, view tracking) could extend to disappearing DMs.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 handles permanent posts with hybrid push/pull feed. For Part 2, I need to add ephemeral Stories that auto-expire after 24 hours. The key differences are TTL management and per-viewer viewed/unviewed tracking.",
    "explaining_changes": "I'll add three new data structures: stories{} for story storage with expiration, user_stories{} to index stories by user, and story_views{} for view tracking. The story ring aggregates followed users' active stories with viewed status.",
    "while_extending_code": [
      "Adding Story dataclass with expires_at field",
      "post_story is similar to upload_photo but with TTL",
      "get_story_ring needs to check ALL stories from each user for viewed status"
    ],
    "after_completing": "This handles Part 2. post_story is O(1), get_story_ring is O(F\u00d7S) where F is followed users and S is average stories per user. The view tracking is idempotent to handle high write volume. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Understand stories vs posts difference (TTL, view tracking). Identify new data structures needed.",
    "by_5_min": "Explain story ring algorithm - aggregation and sorting logic. Start coding dataclasses.",
    "by_10_min": "Implement post_story, get_story_ring, mark_story_viewed. These are the critical methods.",
    "warning_signs": "If still designing at 6 min, start coding immediately. The algorithm is straightforward once data structures are clear."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Stories are independent of Part 1 feed generation. If Part 1 has bugs, mention them but proceed with Part 2 - they don't interact directly.",
    "if_new_requirement_unclear": "Ask: 'For the story ring, should a user appear if they have only expired stories? I assume no - only active stories count.'",
    "if_running_behind": "Focus on post_story and get_story_ring. mark_story_viewed can be simplified to just add to set without the idempotency check if needed."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Explaining lazy vs active TTL expiration tradeoff",
      "Mentioning Bloom filter optimization for production scale",
      "Noting that view events are 5x feed reads - justifying idempotency",
      "Discussing story ring sort order UX implications"
    ]
  },
  "pattern_recognition": {
    "pattern": "TTL-based Ephemeral Storage + View Tracking",
    "indicators": [
      "24-hour expiration mentioned",
      "Need to track who viewed what",
      "High write volume for view events"
    ],
    "similar_problems": [
      "Snapchat stories",
      "WhatsApp status",
      "LinkedIn 'who viewed your profile'",
      "Any time-bounded content system"
    ],
    "template": "1. Store content with expires_at timestamp. 2. Filter by expiration on every read (lazy cleanup). 3. Track views in a set for deduplication. 4. Aggregate per-user status for UI."
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see '24-hour expiration', I immediately think TTL management",
      "why": "Ephemeral content requires either active deletion (background job) or lazy expiration (check on read). Lazy is simpler for interview."
    },
    {
      "step": 2,
      "thought": "Story ring shows 'viewed vs unviewed' - this is per-viewer state",
      "why": "Unlike like counts (global), viewed status is relative to the viewer. Need to track which stories each user has seen."
    },
    {
      "step": 3,
      "thought": "High write volume for view events suggests idempotency is critical",
      "why": "Users may view same story multiple times. Must not double-count."
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend existing code cleanly without breaking Part 1?",
      "Do you understand TTL/ephemeral content patterns?",
      "Can you design the story ring aggregation correctly?",
      "Do you handle idempotency for high-volume writes?"
    ],
    "bonus_points": [
      "Mentioning production optimizations (Bloom filter, HyperLogLog)",
      "Discussing lazy vs active expiration tradeoff",
      "Noting the UX reasoning for story ring sort order"
    ],
    "red_flags": [
      "Rewriting Part 1 code unnecessarily",
      "Not handling expired stories",
      "Double-counting views",
      "Checking only latest story for viewed status"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for boilerplate dataclasses",
      "Let it help with timestamp handling"
    ],
    "what_not_to_do": [
      "Don't let AI design the story ring algorithm - understand it yourself",
      "Verify the TTL check logic - AI may miss edge cases"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about TTL semantics (hard vs soft expiration)",
      "Jumping to code without explaining story ring algorithm"
    ],
    "technical": [
      "Mixing stories into posts table",
      "Forgetting TTL checks on read operations",
      "Not handling partial view state (some stories viewed, some not)"
    ],
    "communication": [
      "Not explaining why stories need separate storage",
      "Forgetting to mention idempotency for view tracking"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does post_story set expires_at correctly?",
      "Does get_story_ring filter expired stories?",
      "Does has_unviewed check ALL stories, not just latest?",
      "Is mark_story_viewed idempotent?",
      "Does story ring sort unviewed first?"
    ],
    "quick_code_review": [
      "New dataclasses have all required fields",
      "TTL constant is 24 hours in seconds",
      "No unused imports added",
      "Part 1 methods unchanged"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Cassandra with TTL for automatic expiration",
      "Bloom filter for O(1) 'has viewed' checks",
      "Redis sorted set for story ring with TTL",
      "Sampling for viewer list when > 1000 viewers"
    ],
    "why_not_in_interview": "Focus on core algorithm. In-memory implementation demonstrates understanding without distributed systems complexity.",
    "how_to_mention": "Say: 'In production, I'd use Cassandra with TTL for automatic expiration, and a Bloom filter for efficient view checks at scale.'"
  },
  "generated_at": "2026-01-19T04:45:33.295067",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}