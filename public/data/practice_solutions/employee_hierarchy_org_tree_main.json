{
  "problem_title": "Employee Hierarchy / Org Tree",
  "difficulty": "medium",
  "category": "DSA/Trees + OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic OOP + Tree design problem**. The organizational hierarchy naturally forms an N-ary tree where each node (employee) can have multiple children (direct reports) but only one parent (manager). The key challenge is maintaining efficient lookups while supporting bidirectional traversal.",
    "pattern_recognition": "**HashMap + N-ary Tree + Bidirectional References**. The HashMap provides O(1) lookup by employee ID. The tree structure captures the reporting hierarchy. Bidirectional references (manager \u2194 subordinates) enable traversal in both directions.",
    "key_constraints": [
      "**Unique IDs (1 \u2264 id \u2264 10\u2076)** - HashMap is perfect for this range",
      "**Max 10\u2075 employees** - O(n) operations are acceptable, but O(1) lookups are preferred",
      "**Single CEO (null manager)** - Must validate only one root exists",
      "**Manager must exist before subordinate** - Topological constraint on insertion order"
    ],
    "clarifying_questions": [
      "**Can there be multiple CEOs?** - No, only one employee can have null manager. Important for validation.",
      "**What if manager ID doesn't exist?** - Return false. Must handle gracefully.",
      "**Can employee IDs be reused after removal?** - Not specified in Part 1, assume no removals yet.",
      "**Is the tree always connected?** - Yes, every employee except CEO has a manager path to root.",
      "**Are there any constraints on tree depth?** - Not specified, but deep recursion could be an issue for follow-ups.",
      "**Should getEmployee return a copy or reference?** - Reference is fine for this problem."
    ],
    "edge_cases_to_consider": [
      "Single employee org (CEO only) - has 0 direct reports",
      "Linear chain (each person has exactly one report)",
      "Wide tree (CEO has all employees as direct reports)",
      "Adding employee with non-existent manager ID",
      "Adding duplicate employee ID",
      "Querying non-existent employee ID",
      "Attempting to add second CEO"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Employee class with id, name, rating, manager, subordinates",
        "how_met": "Employee class stores all fields, manager is Optional/nullable, subordinates is a List",
        "gotchas": [
          "Subordinates list must be initialized to empty, not null"
        ]
      },
      {
        "requirement": "addEmployee returns true if successful, false if ID exists or manager not found",
        "how_met": "Check HashMap.containsKey first, then validate managerId exists",
        "gotchas": [
          "Also need to check for second CEO attempt"
        ]
      },
      {
        "requirement": "getDirectReportCount returns direct reports only, -1 if not found",
        "how_met": "Return len(subordinates) after existence check",
        "gotchas": [
          "Direct \u2260 total subordinates - common mistake"
        ]
      },
      {
        "requirement": "getEmployee returns employee or null if not found",
        "how_met": "HashMap.get() returns null naturally for missing keys",
        "gotchas": [
          "In Python, use .get() not [] to avoid KeyError"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "addEmployee",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion + list append are both O(1)"
      },
      {
        "operation": "getDirectReportCount",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup + list.length are O(1)"
      },
      {
        "operation": "getEmployee",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct HashMap lookup"
      }
    ],
    "non_goals": [
      "Removal of employees (not in Part 1)",
      "Updating employee information",
      "Computing total subordinates (that's for follow-ups)",
      "Thread-safety (unless interviewer asks)"
    ]
  },
  "assumptions": [
    "**Insertion order respects hierarchy** - Manager always added before their subordinates",
    "**No concurrent modifications** - Single-threaded operations assumed",
    "**No employee removal** - Employees only added, not removed in Part 1",
    "**Ratings are within valid range** - Not explicitly validated (could ask interviewer)"
  ],
  "tradeoffs": [
    {
      "decision": "Store subordinates as List vs Set",
      "chosen": "List",
      "why": "Preserves insertion order, iteration is common",
      "alternative": "Set for O(1) contains check",
      "when_to_switch": "If checking 'is X a direct report of Y' is frequent"
    },
    {
      "decision": "Bidirectional references (manager + subordinates)",
      "chosen": "Bidirectional",
      "why": "Enables efficient traversal both up and down the tree",
      "alternative": "Only parent pointer + traverse from root",
      "when_to_switch": "If memory is extremely constrained"
    },
    {
      "decision": "HashMap for employee lookup",
      "chosen": "HashMap",
      "why": "O(1) lookup by ID is essential for all operations",
      "alternative": "TreeMap for sorted iteration",
      "when_to_switch": "If you need employees sorted by ID"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Single responsibility**: Employee class manages data, OrgChart manages relationships",
      "**Encapsulation**: Internal structure (HashMap) is private",
      "**Open for extension**: Easy to add new methods without modifying existing ones"
    ],
    "why_this_design_scales": "The bidirectional tree + HashMap design naturally supports Part 2 (tree traversal for team metrics) and Part 3 (DFS aggregation). Adding methods like `getTeamSize()` or `getTeamAverageRating()` just requires DFS from any node - no structural changes needed.",
    "expected_followup_hooks": [
      "**getTeamSize(id)** - Will use DFS from node, subordinates list is ready",
      "**getAverageRating(id)** - DFS accumulation, rating field exists",
      "**findCommonManager(id1, id2)** - LCA problem, parent pointers exist",
      "**Filtering by rating threshold** - Add predicate to traversal"
    ],
    "invariants": [
      "Every employee except CEO has exactly one manager",
      "No cycles in the reporting structure",
      "Employee IDs are unique across the organization",
      "Subordinates list is always consistent with manager pointers"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 ORGANIZATIONAL HIERARCHY                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                      \u2502   CEO (1)   \u2502 \u25c4\u2500\u2500 manager = null     \u2502\n\u2502                      \u2502   Alice     \u2502                        \u2502\n\u2502                      \u2502  rating: 8  \u2502                        \u2502\n\u2502                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502               \u2502                           \u2502                 \u2502\n\u2502               \u25bc                           \u25bc                 \u2502\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502        \u2502  VP Eng (2) \u2502             \u2502 VP Sales(3) \u2502          \u2502\n\u2502        \u2502    Bob      \u2502             \u2502   Carol     \u2502          \u2502\n\u2502        \u2502  rating: 7  \u2502             \u2502  rating: 6  \u2502          \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502               \u2502                                             \u2502\n\u2502               \u25bc                                             \u2502\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                      \u2502\n\u2502        \u2502 Manager (4) \u2502                                      \u2502\n\u2502        \u2502   David     \u2502                                      \u2502\n\u2502        \u2502  rating: 5  \u2502                                      \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                      \u2502\n\u2502                                                             \u2502\n\u2502  Direct Reports: Alice\u21922, Bob\u21921, Carol\u21920, David\u21920          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURES                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  employees HashMap:                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502 Key \u2502 Value (Employee object)                     \u2502      \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\n\u2502  \u2502  1  \u2502 {id:1, name:Alice, rating:8,                \u2502      \u2502\n\u2502  \u2502     \u2502  manager:null, subordinates:[Emp2, Emp3]}   \u2502      \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\n\u2502  \u2502  2  \u2502 {id:2, name:Bob, rating:7,                  \u2502      \u2502\n\u2502  \u2502     \u2502  manager:Emp1, subordinates:[Emp4]}         \u2502      \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\n\u2502  \u2502  3  \u2502 {id:3, name:Carol, rating:6,                \u2502      \u2502\n\u2502  \u2502     \u2502  manager:Emp1, subordinates:[]}             \u2502      \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\n\u2502  \u2502  4  \u2502 {id:4, name:David, rating:5,                \u2502      \u2502\n\u2502  \u2502     \u2502  manager:Emp2, subordinates:[]}             \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                             \u2502\n\u2502  ceo: \u2192 Emp1 (Alice)                                        \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "addEmployee(1, 'Alice', 8, null) - Adding CEO",
        "visualization": "```\nCheck: id=1 not in employees? \u2713\nCheck: managerId=null \u2192 This is CEO\nCheck: ceo is null? \u2713\nCreate: Employee(1, 'Alice', 8)\nSet: ceo = new employee\nStore: employees[1] = new employee\nReturn: true\n```",
        "key_point": "CEO is special case - no manager, stored in ceo field"
      },
      {
        "step": 2,
        "description": "addEmployee(2, 'Bob', 7, 1) - Adding under CEO",
        "visualization": "```\nCheck: id=2 not in employees? \u2713\nCheck: managerId=1 exists? \u2713 (Alice)\nCreate: Employee(2, 'Bob', 7)\nSet: bob.manager = Alice\nUpdate: Alice.subordinates.append(Bob)\nStore: employees[2] = Bob\nReturn: true\n```",
        "key_point": "Bidirectional link: Bob knows Alice, Alice's list includes Bob"
      },
      {
        "step": 3,
        "description": "getDirectReportCount(1) - Query Alice",
        "visualization": "```\nLookup: employees[1] \u2192 Alice\nReturn: len(Alice.subordinates) = 2\n```",
        "key_point": "O(1) - just list length, not tree traversal"
      }
    ],
    "dry_run_table": "| Step | Operation | employees Map | ceo | Result |\n|------|-----------|---------------|-----|--------|\n| 1 | OrgChart() | {} | null | - |\n| 2 | addEmployee(1, 'Alice', 8, null) | {1: Alice} | Alice | true |\n| 3 | addEmployee(2, 'Bob', 7, 1) | {1: Alice, 2: Bob} | Alice | true |\n| 4 | addEmployee(3, 'Carol', 6, 1) | {1: Alice, 2: Bob, 3: Carol} | Alice | true |\n| 5 | addEmployee(4, 'David', 5, 2) | {1-4: all employees} | Alice | true |\n| 6 | getDirectReportCount(1) | - | - | **2** (Bob, Carol) |\n| 7 | getDirectReportCount(2) | - | - | **1** (David) |\n| 8 | getDirectReportCount(4) | - | - | **0** (leaf node) |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'organizational hierarchy'**, I immediately think **tree data structure** - each employee has one manager (parent) and possibly many subordinates (children). This is a classic N-ary tree.",
      "**When I see 'O(1) lookup by ID'**, I know I need a **HashMap<ID, Employee>** for constant-time access. Without this, every operation becomes O(n) tree search.",
      "**The key insight is bidirectional references** - each Employee stores both their manager (for upward traversal) AND their subordinates list (for downward traversal). This enables efficient queries in either direction.",
      "**For addEmployee**, I need to: (1) validate ID doesn't exist, (2) validate manager exists or this is CEO, (3) create employee, (4) establish bidirectional links, (5) store in HashMap.",
      "**For getDirectReportCount**, it's simply `len(subordinates)` - direct reports are the immediate children, NOT all descendants. This is a common point of confusion."
    ],
    "key_insight": "**Direct reports \u2260 Total subordinates**. Alice's direct reports are only Bob and Carol (2 people), even though David also reports up to Alice through Bob. This distinction is crucial and a common interview mistake.",
    "why_this_works": "The HashMap + Tree design gives us the best of both worlds: O(1) random access by ID (HashMap) AND efficient hierarchical queries (Tree structure). The bidirectional links mean we never need to traverse the whole tree to find a relationship."
  },
  "approaches": [
    {
      "name": "Brute Force: List + Linear Search",
      "description": "Store all employees in a simple list, search linearly for lookups",
      "pseudocode": "addEmployee:\n  for each employee in list:\n    if employee.id == id: return false\n  add to list, find manager by linear search\n\ngetEmployee:\n  for each employee in list:\n    if employee.id == id: return employee\n  return null",
      "time_complexity": "O(n) for all operations",
      "space_complexity": "O(n)",
      "pros": [
        "Simple to implement",
        "No extra data structures"
      ],
      "cons": [
        "O(n) lookup is too slow",
        "Doesn't scale to 10\u2075 employees"
      ],
      "when_to_use": "Never for this problem - doesn't meet performance requirements"
    },
    {
      "name": "Optimal: HashMap + Bidirectional Tree",
      "description": "HashMap for O(1) ID lookup, bidirectional parent-child references for hierarchy",
      "pseudocode": "addEmployee:\n  if id in employees: return false\n  if managerId != null and managerId not in employees: return false\n  create Employee\n  set employee.manager = employees[managerId]\n  employees[managerId].subordinates.add(employee)\n  employees[id] = employee\n  return true\n\ngetDirectReportCount:\n  if id not in employees: return -1\n  return employees[id].subordinates.size()",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(n) for n employees",
      "pros": [
        "Meets all complexity requirements",
        "Clean API",
        "Extensible for follow-ups"
      ],
      "cons": [
        "Slightly more complex than brute force"
      ],
      "key_insight": "HashMap gives O(1) lookup, bidirectional links enable efficient traversal"
    }
  ],
  "optimal_solution": {
    "name": "HashMap + Bidirectional N-ary Tree",
    "explanation_md": "## Approach\n\nWe model the organization as an **N-ary tree** where each `Employee` node contains:\n- Basic info: `id`, `name`, `rating`\n- **Parent pointer**: `manager` (null for CEO)\n- **Children list**: `subordinates` (direct reports)\n\nWe maintain a **HashMap<Integer, Employee>** for O(1) lookup by ID.\n\n### Why Bidirectional?\n\nStoring both `manager` and `subordinates` seems redundant, but it enables:\n1. **O(1) direct report count**: Just return `subordinates.length`\n2. **Efficient upward traversal**: Follow `manager` pointers to CEO\n3. **Efficient downward traversal**: DFS through `subordinates` (for follow-ups)\n\n### Key Validation in addEmployee\n\n1. **ID uniqueness**: Check `id not in employees`\n2. **Manager existence**: If `managerId != null`, verify `managerId in employees`\n3. **Single CEO**: If `managerId == null`, verify `ceo == null`",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Employee>",
        "purpose": "O(1) lookup by employee ID - the backbone of all operations"
      },
      {
        "structure": "Employee.manager (reference)",
        "purpose": "Link to parent node, null for CEO, enables upward traversal"
      },
      {
        "structure": "Employee.subordinates (List)",
        "purpose": "Links to children, enables direct report count and downward DFS"
      }
    ],
    "algorithm_steps": [
      "1. **Initialize**: Empty HashMap, ceo = null",
      "2. **addEmployee**: Validate \u2192 Create Employee \u2192 Establish bidirectional links \u2192 Store in HashMap",
      "3. **getDirectReportCount**: Lookup in HashMap \u2192 Return subordinates list length",
      "4. **getEmployee**: Direct HashMap lookup"
    ],
    "why_decimal": "Not applicable for this problem - ratings are integers"
  },
  "solution_python_lines": [
    "from typing import Optional, List, Dict",
    "",
    "class Employee:",
    "    \"\"\"Employee node in the organizational tree.\"\"\"",
    "    ",
    "    def __init__(self, id: int, name: str, rating: int):",
    "        self.id = id",
    "        self.name = name",
    "        self.rating = rating",
    "        self.manager: Optional['Employee'] = None",
    "        self.subordinates: List['Employee'] = []",
    "    ",
    "    def __repr__(self):",
    "        return f\"Employee({self.id}, '{self.name}', rating={self.rating})\"",
    "",
    "",
    "class OrgChart:",
    "    \"\"\"",
    "    Organizational chart with O(1) operations.",
    "    Uses HashMap for lookups + bidirectional tree for hierarchy.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.employees: Dict[int, Employee] = {}",
    "        self.ceo: Optional[Employee] = None",
    "    ",
    "    def add_employee(self, id: int, name: str, rating: int, ",
    "                     manager_id: Optional[int]) -> bool:",
    "        \"\"\"Add employee. Returns False if ID exists or manager not found.\"\"\"",
    "        # Validation 1: ID must be unique",
    "        if id in self.employees:",
    "            return False",
    "        ",
    "        # Validation 2: Manager must exist (unless this is CEO)",
    "        if manager_id is not None:",
    "            if manager_id not in self.employees:",
    "                return False",
    "            manager = self.employees[manager_id]",
    "        else:",
    "            # This is CEO - ensure only one CEO",
    "            if self.ceo is not None:",
    "                return False",
    "            manager = None",
    "        ",
    "        # Create employee and establish bidirectional links",
    "        employee = Employee(id, name, rating)",
    "        employee.manager = manager",
    "        ",
    "        if manager is not None:",
    "            manager.subordinates.append(employee)",
    "        else:",
    "            self.ceo = employee",
    "        ",
    "        self.employees[id] = employee",
    "        return True",
    "    ",
    "    def get_direct_report_count(self, employee_id: int) -> int:",
    "        \"\"\"Returns count of direct reports, -1 if employee not found.\"\"\"",
    "        if employee_id not in self.employees:",
    "            return -1",
    "        return len(self.employees[employee_id].subordinates)",
    "    ",
    "    def get_employee(self, employee_id: int) -> Optional[Employee]:",
    "        \"\"\"Returns employee or None if not found.\"\"\"",
    "        return self.employees.get(employee_id)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"DEMO: Employee Hierarchy / Org Tree\")",
    "    print(\"=\" * 60)",
    "    ",
    "    org = OrgChart()",
    "    ",
    "    # Build org structure from Example 1",
    "    print(\"\\n1. Building organization...\")",
    "    print(f\"   Add CEO Alice: {org.add_employee(1, 'Alice', 8, None)}\")",
    "    print(f\"   Add Bob (under Alice): {org.add_employee(2, 'Bob', 7, 1)}\")",
    "    print(f\"   Add Carol (under Alice): {org.add_employee(3, 'Carol', 6, 1)}\")",
    "    print(f\"   Add David (under Bob): {org.add_employee(4, 'David', 5, 2)}\")",
    "    ",
    "    # Query direct reports",
    "    print(\"\\n2. Direct report counts:\")",
    "    print(f\"   Alice (CEO): {org.get_direct_report_count(1)} (Bob, Carol)\")",
    "    print(f\"   Bob: {org.get_direct_report_count(2)} (David)\")",
    "    print(f\"   David (leaf): {org.get_direct_report_count(4)}\")",
    "    ",
    "    # Error handling",
    "    print(\"\\n3. Error cases:\")",
    "    print(f\"   Add with non-existent manager (99): {org.add_employee(5, 'Eve', 5, 99)}\")",
    "    print(f\"   Add duplicate ID (1): {org.add_employee(1, 'Fake', 5, None)}\")",
    "    print(f\"   Query non-existent (100): {org.get_direct_report_count(100)}\")",
    "    ",
    "    # Get employee details",
    "    print(\"\\n4. Employee lookup:\")",
    "    alice = org.get_employee(1)",
    "    print(f\"   get_employee(1): {alice}\")",
    "    print(f\"   Alice's subordinates: {alice.subordinates}\")",
    "    print(f\"   get_employee(999): {org.get_employee(999)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed!\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class OrgChart {",
    "    private Map<Integer, Employee> employees = new HashMap<>();",
    "    private Employee ceo = null;",
    "    ",
    "    /** Employee node in the organizational tree. */",
    "    public static class Employee {",
    "        int id;",
    "        String name;",
    "        int rating;",
    "        Employee manager;",
    "        List<Employee> subordinates = new ArrayList<>();",
    "        ",
    "        Employee(int id, String name, int rating) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.rating = rating;",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return \"Employee(\" + id + \", '\" + name + \"', rating=\" + rating + \")\";",
    "        }",
    "    }",
    "    ",
    "    /** Add employee. Returns false if ID exists or manager not found. */",
    "    public boolean addEmployee(int id, String name, int rating, Integer managerId) {",
    "        // Validation 1: ID must be unique",
    "        if (employees.containsKey(id)) {",
    "            return false;",
    "        }",
    "        ",
    "        // Validation 2: Manager must exist (unless this is CEO)",
    "        Employee manager;",
    "        if (managerId != null) {",
    "            if (!employees.containsKey(managerId)) {",
    "                return false;",
    "            }",
    "            manager = employees.get(managerId);",
    "        } else {",
    "            // This is CEO - ensure only one CEO",
    "            if (ceo != null) {",
    "                return false;",
    "            }",
    "            manager = null;",
    "        }",
    "        ",
    "        // Create employee and establish bidirectional links",
    "        Employee employee = new Employee(id, name, rating);",
    "        employee.manager = manager;",
    "        ",
    "        if (manager != null) {",
    "            manager.subordinates.add(employee);",
    "        } else {",
    "            ceo = employee;",
    "        }",
    "        ",
    "        employees.put(id, employee);",
    "        return true;",
    "    }",
    "    ",
    "    /** Returns count of direct reports, -1 if employee not found. */",
    "    public int getDirectReportCount(int employeeId) {",
    "        if (!employees.containsKey(employeeId)) {",
    "            return -1;",
    "        }",
    "        return employees.get(employeeId).subordinates.size();",
    "    }",
    "    ",
    "    /** Returns employee or null if not found. */",
    "    public Employee getEmployee(int employeeId) {",
    "        return employees.get(employeeId);",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"DEMO: Employee Hierarchy / Org Tree\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        OrgChart org = new OrgChart();",
    "        ",
    "        // Build org structure",
    "        System.out.println(\"\\n1. Building organization...\");",
    "        System.out.println(\"   Add CEO Alice: \" + org.addEmployee(1, \"Alice\", 8, null));",
    "        System.out.println(\"   Add Bob (under Alice): \" + org.addEmployee(2, \"Bob\", 7, 1));",
    "        System.out.println(\"   Add Carol (under Alice): \" + org.addEmployee(3, \"Carol\", 6, 1));",
    "        System.out.println(\"   Add David (under Bob): \" + org.addEmployee(4, \"David\", 5, 2));",
    "        ",
    "        // Query direct reports",
    "        System.out.println(\"\\n2. Direct report counts:\");",
    "        System.out.println(\"   Alice (CEO): \" + org.getDirectReportCount(1) + \" (Bob, Carol)\");",
    "        System.out.println(\"   Bob: \" + org.getDirectReportCount(2) + \" (David)\");",
    "        System.out.println(\"   David (leaf): \" + org.getDirectReportCount(4));",
    "        ",
    "        // Error handling",
    "        System.out.println(\"\\n3. Error cases:\");",
    "        System.out.println(\"   Add with non-existent manager (99): \" + org.addEmployee(5, \"Eve\", 5, 99));",
    "        System.out.println(\"   Add duplicate ID (1): \" + org.addEmployee(1, \"Fake\", 5, null));",
    "        System.out.println(\"   Query non-existent (100): \" + org.getDirectReportCount(100));",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-2",
      "section": "Imports",
      "explanation": "We import `Optional`, `List`, and `Dict` from typing for proper type hints. These make the code self-documenting and help catch bugs."
    },
    {
      "lines": "4-14",
      "section": "Employee Class",
      "explanation": "The Employee class is a **node in our N-ary tree**. Key design: `manager` is Optional (null for CEO), `subordinates` is initialized to empty list (not None). The `__repr__` helps with debugging."
    },
    {
      "lines": "17-24",
      "section": "OrgChart Class & __init__",
      "explanation": "**HashMap `employees`** is the core - enables O(1) lookup by ID. **`ceo`** is stored separately for quick access to tree root. Both start empty/None."
    },
    {
      "lines": "26-52",
      "section": "add_employee Method",
      "explanation": "**Three validations**: (1) ID must be unique, (2) Manager must exist (if not CEO), (3) Only one CEO allowed. Then: create employee, set bidirectional links (employee.manager AND manager.subordinates), store in HashMap."
    },
    {
      "lines": "54-58",
      "section": "get_direct_report_count Method",
      "explanation": "**O(1) operation**: Check existence, return `len(subordinates)`. This is DIRECT reports only - not a tree traversal. Common mistake is to count all descendants."
    },
    {
      "lines": "60-62",
      "section": "get_employee Method",
      "explanation": "Simple HashMap lookup using `.get()` which returns None for missing keys (safer than `[]` which raises KeyError)."
    },
    {
      "lines": "65-95",
      "section": "Demo / Main",
      "explanation": "Comprehensive demo showing: (1) Building org structure, (2) Querying direct reports, (3) Error handling for invalid operations, (4) Employee lookup. This proves the implementation works."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test addEmployee for CEO first (null manager)\n2. Test adding one subordinate\n3. Test getDirectReportCount immediately after each add\n4. Test error cases: duplicate ID, non-existent manager\n5. Test getEmployee for existing and non-existing IDs",
    "what_to_print_or_assert": [
      "print(f'employees map: {list(self.employees.keys())}') - see what's stored",
      "print(f'subordinates of {id}: {[e.id for e in emp.subordinates]}') - verify links",
      "assert org.get_direct_report_count(1) == 2, 'CEO should have 2 reports'"
    ],
    "common_failure_modes": [
      "**Forgetting bidirectional link**: Added to HashMap but not to manager's subordinates",
      "**Not initializing subordinates list**: NullPointerException when appending",
      "**Using [] instead of .get()**: KeyError in Python for missing keys",
      "**Counting all descendants**: Using recursion when only direct count needed"
    ],
    "how_to_fix_fast": "1. Add print statements to addEmployee showing both the new employee AND the manager's subordinates list after update\n2. Trace through one add operation manually with pen and paper\n3. Check if bidirectional invariant holds: for each subordinate S of manager M, S.manager == M"
  },
  "complexity_analysis": {
    "time": {
      "add_employee": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup (O(1)) + HashMap insertion (O(1)) + List append (amortized O(1))"
      },
      "get_direct_report_count": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup (O(1)) + List.length (O(1))"
      },
      "get_employee": {
        "complexity": "O(1)",
        "explanation": "Direct HashMap lookup"
      },
      "overall": "All Part 1 operations are O(1) - optimal for this problem"
    },
    "space": {
      "complexity": "O(n) where n = number of employees",
      "breakdown": "- HashMap storing n employees: O(n)\n- Each employee has O(1) fields plus subordinates list\n- Total subordinate references across all lists: O(n) (each employee appears in exactly one subordinates list)\n- CEO reference: O(1)",
      "note": "Space is optimal - we must store all employees, and the bidirectional links are necessary for efficient queries"
    },
    "can_we_do_better": "No - O(1) time for all operations is optimal. O(n) space is required to store n employees. The design is already optimal for Part 1."
  },
  "dry_run": {
    "example": "OrgChart(), addEmployee(1, 'Alice', 8, null), addEmployee(2, 'Bob', 7, 1), addEmployee(3, 'Carol', 6, 1), addEmployee(4, 'David', 5, 2), getDirectReportCount(1), getDirectReportCount(2), getDirectReportCount(4)",
    "trace_table": "| Step | Operation | Validation | Action | employees keys | Result |\n|------|-----------|------------|--------|----------------|--------|\n| 1 | OrgChart() | - | Initialize empty | {} | - |\n| 2 | addEmployee(1, 'Alice', 8, null) | id=1 not in {} \u2713, managerId=null \u2192 CEO, ceo=null \u2713 | Create Alice, set ceo=Alice | {1} | **true** |\n| 3 | addEmployee(2, 'Bob', 7, 1) | id=2 not in {1} \u2713, managerId=1 in {1} \u2713 | Create Bob, Bob.manager=Alice, Alice.subordinates=[Bob] | {1,2} | **true** |\n| 4 | addEmployee(3, 'Carol', 6, 1) | id=3 not in {1,2} \u2713, managerId=1 in {1,2} \u2713 | Create Carol, Carol.manager=Alice, Alice.subordinates=[Bob,Carol] | {1,2,3} | **true** |\n| 5 | addEmployee(4, 'David', 5, 2) | id=4 not in {1,2,3} \u2713, managerId=2 in {1,2,3} \u2713 | Create David, David.manager=Bob, Bob.subordinates=[David] | {1,2,3,4} | **true** |\n| 6 | getDirectReportCount(1) | id=1 in employees \u2713 | len(Alice.subordinates) = len([Bob,Carol]) | - | **2** |\n| 7 | getDirectReportCount(2) | id=2 in employees \u2713 | len(Bob.subordinates) = len([David]) | - | **1** |\n| 8 | getDirectReportCount(4) | id=4 in employees \u2713 | len(David.subordinates) = len([]) | - | **0** |",
    "final_answer": "Results: [null, true, true, true, true, 2, 1, 0] - matches expected output"
  },
  "test_cases": [
    {
      "name": "Single employee (CEO only)",
      "category": "Edge Case",
      "input": "addEmployee(1, 'CEO', 10, null), getDirectReportCount(1)",
      "expected": "true, 0",
      "explanation": "CEO with no subordinates has 0 direct reports"
    },
    {
      "name": "Linear chain",
      "category": "Structure",
      "input": "addEmployee(1, 'A', 8, null), addEmployee(2, 'B', 7, 1), addEmployee(3, 'C', 6, 2), getDirectReportCount(1), getDirectReportCount(2)",
      "expected": "true, true, true, 1, 1",
      "explanation": "A\u2192B\u2192C chain: A has 1 direct (B), B has 1 direct (C)"
    },
    {
      "name": "Wide tree",
      "category": "Structure",
      "input": "addEmployee(1, 'CEO', 10, null), addEmployee(2, 'A', 5, 1), addEmployee(3, 'B', 5, 1), addEmployee(4, 'C', 5, 1), getDirectReportCount(1)",
      "expected": "true, true, true, true, 3",
      "explanation": "CEO with 3 direct reports: A, B, C"
    },
    {
      "name": "Non-existent manager",
      "category": "Error Handling",
      "input": "addEmployee(1, 'CEO', 8, null), addEmployee(2, 'Orphan', 5, 99)",
      "expected": "true, false",
      "explanation": "Manager ID 99 doesn't exist, addEmployee returns false"
    },
    {
      "name": "Duplicate ID",
      "category": "Error Handling",
      "input": "addEmployee(1, 'Alice', 8, null), addEmployee(1, 'Fake', 5, null)",
      "expected": "true, false",
      "explanation": "ID 1 already exists, cannot add duplicate"
    },
    {
      "name": "Query non-existent employee",
      "category": "Error Handling",
      "input": "addEmployee(1, 'CEO', 8, null), getDirectReportCount(999)",
      "expected": "true, -1",
      "explanation": "Employee 999 doesn't exist, return -1"
    },
    {
      "name": "Second CEO attempt",
      "category": "Error Handling",
      "input": "addEmployee(1, 'CEO1', 8, null), addEmployee(2, 'CEO2', 9, null)",
      "expected": "true, false",
      "explanation": "Only one CEO allowed, second attempt fails"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Counting ALL subordinates instead of DIRECT reports",
      "why_wrong": "getDirectReportCount should return immediate children only, not all descendants",
      "correct_approach": "Return len(subordinates) - the list only contains direct children by design",
      "code_wrong": "def get_direct_report_count(self, id):\n    count = 0\n    def dfs(emp):  # WRONG: traverses entire subtree\n        nonlocal count\n        for sub in emp.subordinates:\n            count += 1\n            dfs(sub)\n    dfs(self.employees[id])\n    return count",
      "code_correct": "def get_direct_report_count(self, id):\n    return len(self.employees[id].subordinates)  # Just list length!"
    },
    {
      "mistake": "Forgetting to update bidirectional links",
      "why_wrong": "If you add employee to HashMap but don't add to manager's subordinates list, getDirectReportCount will be wrong",
      "correct_approach": "Always update BOTH employee.manager AND manager.subordinates.append(employee)",
      "code_wrong": "employee = Employee(id, name, rating)\nemployee.manager = manager\nself.employees[id] = employee\n# MISSING: manager.subordinates.append(employee)",
      "code_correct": "employee = Employee(id, name, rating)\nemployee.manager = manager\nif manager is not None:\n    manager.subordinates.append(employee)  # Don't forget this!\nself.employees[id] = employee"
    },
    {
      "mistake": "Not handling null/None manager for CEO",
      "why_wrong": "Calling manager.subordinates.append() when manager is null causes NullPointerException",
      "correct_approach": "Check if manager is null before accessing its subordinates",
      "code_wrong": "manager = self.employees.get(manager_id)\nmanager.subordinates.append(employee)  # Crashes if manager_id was null!",
      "code_correct": "if manager_id is not None:\n    manager = self.employees[manager_id]\n    manager.subordinates.append(employee)\nelse:\n    self.ceo = employee"
    },
    {
      "mistake": "Using [] instead of .get() for HashMap lookup",
      "why_wrong": "In Python, dict[key] raises KeyError if key missing; in Java, map.get() returns null",
      "correct_approach": "Use .get() method or check containsKey() first",
      "code_wrong": "return self.employees[employee_id]  # KeyError if not found!",
      "code_correct": "return self.employees.get(employee_id)  # Returns None if not found"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for the problem. Before I start coding, I'd like to clarify a few things and walk through my understanding...",
    "clarifying_questions_to_ask": [
      "Is there always exactly one CEO, or could there be multiple roots?",
      "Should employees be added in hierarchical order (manager before subordinate)?",
      "What should happen if we try to add an employee with a non-existent manager ID?",
      "For getDirectReportCount, do you want just immediate subordinates, or all descendants?",
      "Are there any operations to remove employees, or is this add-only?"
    ],
    "what_to_mention_proactively": [
      "I'll use a HashMap for O(1) employee lookup by ID",
      "I'll maintain bidirectional links - each employee knows their manager AND each manager knows their subordinates",
      "Direct reports means immediate children only, not total descendants",
      "Let me trace through an example after coding to verify"
    ],
    "communication_during_coding": [
      "I'm creating the Employee class first - it's essentially a node in an N-ary tree",
      "The HashMap is the key to O(1) lookups - without it, every operation would be O(n)",
      "Notice I'm updating BOTH directions - the new employee's manager field AND the manager's subordinates list",
      "For getDirectReportCount, I just return the list length - no recursion needed"
    ],
    "if_stuck": [
      "Step back: What data structure represents hierarchy? \u2192 Tree",
      "What enables O(1) lookup by ID? \u2192 HashMap",
      "Direct vs total subordinates - what's the difference? \u2192 Direct = immediate children",
      "Draw out a small example and trace through operations"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Explain approach | 10-25min: Code | 25-35min: Test & verify | 35-45min: Complexity analysis & follow-up discussion"
  },
  "pattern_recognition": {
    "pattern_name": "HashMap + Tree Hybrid for Hierarchical Data",
    "indicators": [
      "Hierarchical/parent-child relationships",
      "Need O(1) lookup by ID",
      "Queries at different levels (node, subtree)"
    ],
    "similar_problems": [
      "LC 690 - Employee Importance: Same tree structure, sum values in subtree (DFS)",
      "LC 559 - Maximum Depth of N-ary Tree: Tree traversal to find depth",
      "LC 339 - Nested List Weight Sum: Weighted DFS through hierarchy",
      "LC 1490 - Clone N-ary Tree: Deep copy of tree structure"
    ],
    "template": "1. Create Node class with parent + children references\n2. Maintain HashMap<ID, Node> for O(1) lookup\n3. Use DFS/BFS for tree traversal queries\n4. Update bidirectionally on mutations"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 likely asks for 'best performing team' - you'll need DFS to traverse subtrees and aggregate ratings. The subordinates list is already set up for this!",
    "part_3_hint": "Part 3 might add filtering (e.g., 'team members with rating > X') or generic aggregation. Consider adding a method that takes a predicate/lambda for flexible filtering.",
    "data_structure_evolution": "Part 1: HashMap + Tree \u2192 Part 2: Add DFS for aggregation \u2192 Part 3: Add predicate-based filtering or caching for frequently queried subtrees"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. I see we're building an organizational chart system. Before I start coding, let me clarify my understanding and share my approach.",
    "after_clarification": "Great, so to summarize: We need an OrgChart with O(1) lookups, employees form a tree structure, and getDirectReportCount returns only immediate subordinates. I'll use a HashMap for lookups and bidirectional tree links. Sound good?",
    "while_coding": [
      "I'm creating the Employee class as a tree node with parent and children references...",
      "The HashMap enables O(1) lookup - this is crucial for meeting performance requirements...",
      "Notice I update both the new employee's manager AND the manager's subordinates list - bidirectional consistency..."
    ],
    "after_coding": "Let me trace through the first example to verify: We add Alice as CEO, then Bob and Carol under Alice, then David under Bob. getDirectReportCount(1) should return 2 for Alice's direct reports...",
    "when_stuck_verbatim": "Let me think about this for a moment... The key question is what data structure best represents a hierarchy with fast lookups...",
    "after_mistake": "Good catch - I see the issue. I forgot to update the manager's subordinates list. Let me fix that here...",
    "before_moving_on": "Part 1 is complete. Time complexity is O(1) for all operations, space is O(n) for n employees. The bidirectional tree structure is ready for Part 2's subtree queries. Shall I continue?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Understanding of tree data structures",
      "Ability to design clean OOP classes",
      "HashMap usage for efficient lookups",
      "Attention to edge cases",
      "Clear communication"
    ],
    "bonus_points": [
      "Immediately identifying this as an N-ary tree problem",
      "Mentioning bidirectional links proactively",
      "Distinguishing direct vs total subordinates without prompting",
      "Clean code with meaningful variable names",
      "Thorough testing after implementation"
    ],
    "red_flags": [
      "Confusing direct reports with all subordinates",
      "Forgetting to handle null manager for CEO",
      "Not using HashMap (O(n) lookups)",
      "Silent coding without explanation",
      "Not testing after implementation"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize the tree structure, proactively mention the HashMap for O(1) lookups, understand the bidirectional link requirement, and clearly distinguish between direct and total subordinates. They write clean, well-organized code and test thoroughly."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions, confirm direct vs total subordinates distinction",
    "by_10_min": "Explain approach (HashMap + bidirectional tree), draw quick diagram, get interviewer buy-in",
    "by_20_min": "Employee class done, OrgChart with addEmployee implemented",
    "by_25_min": "All methods implemented, start testing with examples",
    "by_30_min": "Part 1 complete with complexity analysis, ready for Part 2",
    "warning_signs": "If still clarifying at 10min or still coding at 30min, you're behind. Simplify and focus on core logic."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'Actually, I see an issue - I forgot to update the bidirectional link. Let me fix that.' Fix it cleanly and move on.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for Optional in Python, but I know I need to indicate this can be None. Let me use a comment for now and we can look it up.'",
    "when_approach_is_wrong": "Say: 'I realize my approach of counting all descendants doesn't match the requirement for direct reports only. Let me simplify - I just need to return the subordinates list length.'",
    "when_completely_stuck": "Say: 'I'm stuck on how to efficiently look up employees. Could you give me a hint about what data structure would help?'",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me implement the core addEmployee and getDirectReportCount, and explain what I'd add for getEmployee.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Use AI tools for boilerplate and syntax, but demonstrate understanding of the core algorithm.",
    "what_to_do": [
      "Let AI generate the Employee class structure",
      "Use for type hints and docstrings",
      "Accept suggestions for HashMap operations",
      "Generate test cases"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and accept the solution",
      "Don't accept tree traversal code without understanding it",
      "Don't let AI drive your approach"
    ],
    "how_to_demonstrate_understanding": "If AI suggests bidirectional links, explain WHY: 'This enables O(1) direct report count and efficient upward traversal for future features.'",
    "expectation_adjustment": "With AI assistance, you should complete Part 1 in 15-20 minutes and be well into Part 2. If you're slower with AI than without, focus on understanding first."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately recognizing this as an N-ary tree with HashMap augmentation",
      "Drawing a quick ASCII diagram before coding",
      "Proactively mentioning the bidirectional link requirement",
      "Clearly distinguishing direct vs total subordinates without prompting",
      "Writing clean code with good variable names on first pass"
    ],
    "subtle_signals_of_experience": [
      "Using .get() instead of [] for safe HashMap access",
      "Initializing subordinates as empty list, not null",
      "Checking for second CEO attempt",
      "Testing incrementally after each method implementation"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Coding silently for more than 30 seconds",
      "Getting defensive when interviewer points out issue",
      "Not asking any clarifying questions",
      "Rushing to code without explaining approach"
    ],
    "technical": [
      "Using O(n) linear search instead of HashMap",
      "Confusing direct reports with all descendants",
      "Forgetting null checks for CEO",
      "Not handling error cases (non-existent manager, duplicate ID)"
    ],
    "communication": [
      "Using jargon without explanation",
      "Not summarizing approach before coding",
      "Not testing after implementation",
      "Not discussing complexity"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I implement all three methods: addEmployee, getDirectReportCount, getEmployee?",
      "Did I handle error cases: duplicate ID, non-existent manager?",
      "Did I trace through at least one example to verify correctness?",
      "Did I discuss time and space complexity?",
      "Is my code readable with meaningful variable names?",
      "Did I distinguish direct reports from total subordinates?"
    ],
    "quick_code_review": [
      "No null pointer risks",
      "HashMap used for O(1) lookups",
      "Bidirectional links maintained",
      "Error cases return correct values (-1, false, null)",
      "Proper indentation"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation with descriptive error messages (name not empty, rating in range)",
      "Logging for debugging and audit trail",
      "Thread-safety if concurrent modifications possible",
      "Employee removal with proper cleanup of bidirectional links",
      "Serialization support for persistence"
    ],
    "why_not_in_interview": "Keep interview code focused on the algorithm. Mention these verbally to show senior thinking.",
    "how_to_mention": "Say: 'In production, I'd add input validation, logging, and potentially thread-safety, but for this interview I'll focus on the core logic.'"
  },
  "generated_at": "2026-01-19T03:58:45.619819",
  "_meta": {
    "problem_id": "employee_hierarchy_org_tree",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}