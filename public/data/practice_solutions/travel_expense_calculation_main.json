{
  "problem_title": "Travel Expense Calculation System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic OOP Design problem requiring Strategy Pattern for varying expense calculations and Factory Pattern for object creation. The core challenge is designing a clean, extensible system while handling financial precision correctly. Similar to Uber's ride fare calculation or PayPal's transaction fee systems.",
    "pattern_recognition": "**Strategy Pattern** (different expense policies) + **Factory Pattern** (expense creation) + **HashMap** (O(1) lookups) + **Decimal Precision** (financial calculations)",
    "key_constraints": [
      "Financial precision to 2 decimal places - MUST use Decimal/BigDecimal, not float",
      "Up to 1000 employees \u00d7 500 expenses = 500K total expenses - need efficient storage",
      "Four expense types with different calculation rules - Strategy pattern is ideal",
      "Must be extensible for new expense types - Open/Closed principle"
    ],
    "clarifying_questions": [
      "Is the amount field the TOTAL expense or the daily/nightly rate? - Critical for calculations",
      "Should invalid expense types throw an exception or return an error code? - Error handling strategy",
      "Can employees have concurrent expenses on the same day? - Affects storage design",
      "How should rounding work - HALF_UP, HALF_EVEN, or truncate? - Financial precision",
      "Should we validate date formats, or assume valid input? - Input validation scope",
      "Is there a maximum total reimbursement limit per employee? - Policy constraints",
      "Are expense IDs globally unique or per-employee? - ID generation strategy"
    ],
    "edge_cases_to_consider": [
      "Employee with no expenses - return 0.0",
      "Minimum expense amount ($0.01) - precision edge case",
      "Hotel with 1 night at exactly $200 - boundary condition",
      "Meal where 50% calculation results in exactly $50 cap",
      "Flight at exactly $1000 limit",
      "Very large expenses exceeding policy limits",
      "Multiple expenses of same type for one employee"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "ExpenseManager() - Initialize system with default policies",
        "how_met": "Constructor creates strategy map and empty employee expenses dict",
        "gotchas": [
          "Must initialize ALL four strategies",
          "Use factory pattern for expense creation"
        ]
      },
      {
        "requirement": "addExpense() - Add expense and return ID",
        "how_met": "Factory creates expense with auto-incrementing ID, stored in employee's list",
        "gotchas": [
          "ID must be unique globally",
          "Validate expense type before creating"
        ]
      },
      {
        "requirement": "calculateReimbursement() - Apply policies, return 2 decimal places",
        "how_met": "Iterate expenses, apply strategy for each type, sum with Decimal precision",
        "gotchas": [
          "Round to 2 decimals at END only",
          "Handle empty employee case"
        ]
      },
      {
        "requirement": "getExpensesByType() - Filter expenses by type",
        "how_met": "Filter employee's expense list by ExpenseType enum",
        "gotchas": [
          "Return empty list, not None, for no matches"
        ]
      },
      {
        "requirement": "getTotalExpenses() - Raw total before policy",
        "how_met": "Sum amounts accounting for nights/days multipliers",
        "gotchas": [
          "Hotel/Meal amounts are rates that must be multiplied"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "addExpense",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct append to employee's list"
      },
      {
        "operation": "calculateReimbursement",
        "target": "O(E)",
        "achieved": "O(E)",
        "why": "Must iterate all expenses for employee"
      },
      {
        "operation": "getExpensesByType",
        "target": "O(E)",
        "achieved": "O(E)",
        "why": "Filter through employee's expenses"
      },
      {
        "operation": "getTotalExpenses",
        "target": "O(E)",
        "achieved": "O(E)",
        "why": "Sum all employee expenses"
      }
    ],
    "non_goals": [
      "Persistence/database storage - in-memory only",
      "Multi-currency support (that's Part 2)",
      "Per-diem location-based calculations (that's Part 3)",
      "Expense deletion or modification",
      "Thread safety (unless specifically asked)"
    ]
  },
  "assumptions": [
    "Amount for HOTEL is the per-night rate (not total for all nights)",
    "Amount for MEAL is the per-day rate (not total for all days)",
    "Amount for FLIGHT/TRANSPORT is the total expense amount",
    "Expense IDs follow format 'exp_N' with global counter",
    "Invalid expense types should raise ValueError",
    "Empty employee returns 0.0 for calculations, empty list for queries"
  ],
  "tradeoffs": [
    {
      "decision": "Strategy Pattern vs if-else chain",
      "chosen": "Strategy Pattern",
      "why": "Follows Open/Closed principle - adding new expense types doesn't modify existing code",
      "alternative": "if-else chain in calculateReimbursement",
      "when_to_switch": "Never - Strategy is clearly better for this use case"
    },
    {
      "decision": "Store expenses by employee vs flat list",
      "chosen": "Dict<employeeId, List<Expense>>",
      "why": "O(1) employee lookup, expenses naturally grouped",
      "alternative": "Flat list with employeeId in each expense",
      "when_to_switch": "If querying all expenses across employees is common"
    },
    {
      "decision": "Compute reimbursement on demand vs cache",
      "chosen": "Compute on demand",
      "why": "Simple, no cache invalidation issues, queries are O(E) which is acceptable",
      "alternative": "Cache running total per employee",
      "when_to_switch": "If calculateReimbursement called very frequently"
    },
    {
      "decision": "Enum vs String for expense type",
      "chosen": "Enum internally, String at API boundary",
      "why": "Type safety internally, flexible API externally",
      "alternative": "Strings throughout",
      "when_to_switch": "If types are dynamically defined at runtime"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "Strategy Pattern enables adding new expense types without modifying ExpenseManager",
      "Factory Pattern centralizes expense creation for easy modification",
      "Decimal precision maintained throughout for accurate financial calculations",
      "Clean separation: Manager orchestrates, Strategies calculate, Factory creates"
    ],
    "why_this_design_scales": "Adding a new expense type (e.g., PARKING) requires: (1) Add enum value, (2) Create new Strategy class, (3) Register in Manager constructor. Zero changes to existing code!",
    "expected_followup_hooks": [
      "Part 2 (Multi-Currency): Add CurrencyConverter that Strategies use before calculation",
      "Part 3 (Per-Diem by Location): Add LocationPolicyProvider that Strategies query for caps",
      "Strategies are the natural extension point for policy changes"
    ],
    "invariants": [
      "Reimbursement \u2264 Policy limit for each expense type",
      "Total reimbursement = sum of individual reimbursements",
      "Expense IDs are unique and never recycled",
      "Financial calculations use Decimal throughout"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 EXPENSE REIMBURSEMENT FLOW                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  Employee submits:     Policy Applied:        Result:            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Flight $1500 \u2502 \u2500\u2500\u25b6 \u2502 Cap at $1000 \u2502 \u2500\u2500\u25b6  \u2502 Reimb $1000 \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Hotel $250   \u2502 \u2500\u2500\u25b6 \u2502 Cap $200/nt  \u2502 \u2500\u2500\u25b6  \u2502 Reimb $400  \u2502     \u2502\n\u2502  \u2502 \u00d7 2 nights   \u2502     \u2502 $200 \u00d7 2     \u2502      \u2502 (not $500)  \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Meal $80/day \u2502 \u2500\u2500\u25b6 \u2502 50% = $40    \u2502 \u2500\u2500\u25b6  \u2502 Reimb $80   \u2502     \u2502\n\u2502  \u2502 \u00d7 2 days     \u2502     \u2502 $40 \u00d7 2 days \u2502      \u2502 (under cap) \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Transport    \u2502 \u2500\u2500\u25b6 \u2502 100% no cap  \u2502 \u2500\u2500\u25b6  \u2502 Reimb $45   \u2502     \u2502\n\u2502  \u2502 $45          \u2502     \u2502              \u2502      \u2502             \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                                  \u2502\n\u2502                              Total: $1000 + $400 + $80 + $45     \u2502\n\u2502                                   = $1525.00                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURE STATE                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  _employee_expenses: Dict[str, List[Expense]]                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 \"emp001\" \u2500\u2500\u25b6 [                                             \u2502 \u2502\n\u2502  \u2502               Expense(id=\"exp_1\", type=FLIGHT, amt=450),   \u2502 \u2502\n\u2502  \u2502               Expense(id=\"exp_2\", type=HOTEL, amt=180,     \u2502 \u2502\n\u2502  \u2502                       details={\"nights\": 2}),              \u2502 \u2502\n\u2502  \u2502               Expense(id=\"exp_3\", type=MEAL, amt=75,       \u2502 \u2502\n\u2502  \u2502                       details={\"days\": 2})                 \u2502 \u2502\n\u2502  \u2502             ]                                              \u2502 \u2502\n\u2502  \u2502                                                            \u2502 \u2502\n\u2502  \u2502 \"emp002\" \u2500\u2500\u25b6 [                                             \u2502 \u2502\n\u2502  \u2502               Expense(id=\"exp_4\", type=TRANSPORT, amt=89.5)\u2502 \u2502\n\u2502  \u2502             ]                                              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                  \u2502\n\u2502  _strategies: Dict[ExpenseType, ReimbursementStrategy]           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 FLIGHT    \u2500\u2500\u25b6 FlightReimbursementStrategy(limit=$1000)     \u2502 \u2502\n\u2502  \u2502 HOTEL     \u2500\u2500\u25b6 HotelReimbursementStrategy(cap=$200/night)   \u2502 \u2502\n\u2502  \u2502 MEAL      \u2500\u2500\u25b6 MealReimbursementStrategy(rate=50%, cap=$50) \u2502 \u2502\n\u2502  \u2502 TRANSPORT \u2500\u2500\u25b6 TransportReimbursementStrategy(no limit)     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Initialize ExpenseManager",
        "visualization": "```\nstrategies = {FLIGHT: FlightStrategy, HOTEL: HotelStrategy, ...}\nemployee_expenses = {}\n```",
        "key_point": "Strategies registered upfront - no conditional logic later"
      },
      {
        "step": 2,
        "description": "Add expense via Factory",
        "visualization": "```\nExpenseFactory.create(\"HOTEL\", 250, date, {nights: 2})\n  \u2514\u2500\u2500\u25b6 Expense(id=\"exp_1\", type=HOTEL, amount=Decimal('250'), ...)\n```",
        "key_point": "Factory handles ID generation and type conversion"
      },
      {
        "step": 3,
        "description": "Store in employee's list",
        "visualization": "```\nemployee_expenses[\"emp001\"].append(expense)\n```",
        "key_point": "O(1) append operation"
      },
      {
        "step": 4,
        "description": "Calculate reimbursement",
        "visualization": "```\nfor expense in employee_expenses[\"emp001\"]:\n    strategy = strategies[expense.type]  # O(1) lookup\n    total += strategy.calculate(expense) # Polymorphism!\n```",
        "key_point": "Strategy pattern eliminates if-else chains"
      }
    ],
    "dry_run_table": "| Step | Operation | employee_expenses | strategies used | Result |\n|------|-----------|-------------------|-----------------|--------|\n| 1 | ExpenseManager() | {} | All 4 initialized | - |\n| 2 | addExpense(\"e1\", \"FLIGHT\", 450, ...) | {e1: [Flight]} | - | \"exp_1\" |\n| 3 | addExpense(\"e1\", \"HOTEL\", 180, {n:2}) | {e1: [Flight, Hotel]} | - | \"exp_2\" |\n| 4 | addExpense(\"e1\", \"MEAL\", 75, {d:2}) | {e1: [Flight, Hotel, Meal]} | - | \"exp_3\" |\n| 5 | calculateReimbursement(\"e1\") | - | Flight\u2192$450, Hotel\u2192$360, Meal\u2192$75 | $885.00 |\n| 6 | getTotalExpenses(\"e1\") | - | - | $705.00 |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'different expense types with different calculation rules', I immediately think **Strategy Pattern** - each type encapsulates its own algorithm",
      "When I see 'create expense objects', I think **Factory Pattern** - centralize creation logic and ID generation",
      "The key insight is that policies VARY by expense type, but the INTERFACE is uniform - calculate(expense) \u2192 reimbursement",
      "I should use Decimal/BigDecimal because financial calculations with float lead to 0.1 + 0.1 + 0.1 \u2260 0.3",
      "For storage, HashMap<employeeId, List<Expense>> gives O(1) employee lookup and natural grouping",
      "The system should be Open for extension (new expense types), Closed for modification (don't touch existing strategies)"
    ],
    "key_insight": "**The Strategy Pattern transforms a problem with multiple conditional branches into a polymorphic solution where each expense type owns its calculation logic.** This makes the code extensible, testable, and maintainable.",
    "why_this_works": "By delegating calculation to Strategy objects, the ExpenseManager doesn't need to know HOW each expense type is calculated - only that it CAN be calculated. Adding a new expense type requires zero changes to ExpenseManager."
  },
  "approaches": [
    {
      "name": "Brute Force: if-else Chain",
      "description": "Handle all expense types with conditional statements in calculateReimbursement",
      "pseudocode": "def calculate_reimbursement(employee_id):\n    for expense in expenses:\n        if expense.type == 'FLIGHT':\n            total += min(amount, 1000)\n        elif expense.type == 'HOTEL':\n            total += min(amount, 200) * nights\n        elif expense.type == 'MEAL':\n            total += min(amount * 0.5, 50) * days\n        elif expense.type == 'TRANSPORT':\n            total += amount",
      "time_complexity": "O(E) per calculation - acceptable",
      "space_complexity": "O(E) for expense storage",
      "pros": [
        "Simple to implement quickly",
        "Easy to understand initially"
      ],
      "cons": [
        "Violates Open/Closed principle",
        "Adding new type requires modifying existing code",
        "Hard to test individual policies",
        "Code becomes spaghetti as types grow"
      ],
      "when_to_use": "Only for quick prototypes with 2-3 types that won't change"
    },
    {
      "name": "Optimal: Strategy Pattern with Factory",
      "description": "Each expense type has its own Strategy class implementing a common interface. Factory creates expenses with proper type conversion.",
      "pseudocode": "class ReimbursementStrategy:\n    @abstractmethod\n    def calculate(expense): pass\n\nclass FlightStrategy(ReimbursementStrategy):\n    def calculate(expense): return min(expense.amount, LIMIT)\n\nclass ExpenseManager:\n    strategies = {FLIGHT: FlightStrategy(), ...}\n    def calculate_reimbursement(employee_id):\n        for expense in expenses:\n            total += strategies[expense.type].calculate(expense)",
      "time_complexity": "O(E) per calculation - same as brute force",
      "space_complexity": "O(E) + O(T) where T = number of expense types (constant)",
      "pros": [
        "Open/Closed principle - extensible",
        "Each strategy is independently testable",
        "Clean separation of concerns",
        "Self-documenting code"
      ],
      "cons": [
        "More initial code",
        "Might seem over-engineered for simple cases"
      ],
      "key_insight": "The upfront investment in design pays off immediately when requirements change or new types are added"
    }
  ],
  "optimal_solution": {
    "name": "Strategy Pattern with Factory and Decimal Precision",
    "explanation_md": "## Approach\n\nThe solution uses **three key design patterns** working together:\n\n### 1. Strategy Pattern for Calculations\nEach expense type has its own Strategy class implementing `calculate(expense) -> Decimal`:\n- `FlightReimbursementStrategy`: 100% up to $1000\n- `HotelReimbursementStrategy`: 100% up to $200/night \u00d7 nights\n- `MealReimbursementStrategy`: 50% up to $50/day \u00d7 days\n- `TransportReimbursementStrategy`: 100% no limit\n\n### 2. Factory Pattern for Creation\n`ExpenseFactory` handles:\n- Auto-incrementing unique IDs (`exp_1`, `exp_2`, ...)\n- String-to-Enum type conversion\n- Decimal amount conversion for precision\n\n### 3. Repository Pattern for Storage\n`ExpenseManager` uses `Dict[employeeId, List[Expense]]` for:\n- O(1) employee lookup\n- Natural expense grouping\n- Easy filtering by type\n\n### Why This Works\n```\nEmployee's Expense \u2192 Factory Creates Object \u2192 Manager Stores\n                                                    \u2193\nQuery Reimbursement \u2192 Manager Iterates \u2192 Strategy Calculates\n                                                    \u2193\n                                              Sum with Decimal\n```",
    "data_structures": [
      {
        "structure": "Dict[str, List[Expense]]",
        "purpose": "O(1) employee lookup, groups expenses naturally"
      },
      {
        "structure": "Dict[ExpenseType, ReimbursementStrategy]",
        "purpose": "O(1) strategy lookup by expense type"
      },
      {
        "structure": "Decimal",
        "purpose": "Precise financial calculations avoiding float errors"
      },
      {
        "structure": "Enum ExpenseType",
        "purpose": "Type safety and validation for expense categories"
      }
    ],
    "algorithm_steps": [
      "1. **Initialize**: Create strategy instances for each expense type, store in HashMap",
      "2. **Add Expense**: Use Factory to create Expense with unique ID, append to employee's list",
      "3. **Calculate Reimbursement**: For each expense, lookup strategy by type, call calculate(), sum results",
      "4. **Get Total Expenses**: Sum raw amounts, multiplying by nights/days where applicable",
      "5. **Round Final Result**: Use HALF_UP rounding to 2 decimal places only at the end"
    ],
    "why_decimal": "Using float causes precision errors:\n```\n>>> 0.1 + 0.1 + 0.1 == 0.3\nFalse  # Actually 0.30000000000000004!\n```\nWith Decimal:\n```\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') == Decimal('0.3')\nTrue\n```"
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from decimal import Decimal, ROUND_HALF_UP",
    "from typing import Dict, List, Any",
    "from enum import Enum",
    "from dataclasses import dataclass",
    "",
    "",
    "class ExpenseType(Enum):",
    "    \"\"\"Supported expense categories with type-safe values.\"\"\"",
    "    FLIGHT = \"FLIGHT\"",
    "    HOTEL = \"HOTEL\"",
    "    MEAL = \"MEAL\"",
    "    TRANSPORT = \"TRANSPORT\"",
    "",
    "",
    "@dataclass",
    "class Expense:",
    "    \"\"\"Immutable expense record with all submission details.\"\"\"",
    "    id: str",
    "    expense_type: ExpenseType",
    "    amount: Decimal",
    "    date: str",
    "    details: Dict[str, Any]",
    "",
    "",
    "class ReimbursementStrategy(ABC):",
    "    \"\"\"Strategy interface - each expense type implements its policy.\"\"\"",
    "    @abstractmethod",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        pass",
    "",
    "",
    "class FlightReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"Flight: 100% reimbursed up to $1000 limit.\"\"\"",
    "    LIMIT = Decimal('1000')",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return min(expense.amount, self.LIMIT)",
    "",
    "",
    "class HotelReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"Hotel: 100% up to $200/night cap.\"\"\"",
    "    NIGHTLY_CAP = Decimal('200')",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        nights = Decimal(str(expense.details.get('nights', 1)))",
    "        capped_rate = min(expense.amount, self.NIGHTLY_CAP)",
    "        return capped_rate * nights",
    "",
    "",
    "class MealReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"Meal: 50% reimbursed up to $50/day cap.\"\"\"",
    "    DAILY_CAP = Decimal('50')",
    "    REIMBURSEMENT_RATE = Decimal('0.5')",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        days = Decimal(str(expense.details.get('days', 1)))",
    "        per_day_reimbursement = min(expense.amount * self.REIMBURSEMENT_RATE, self.DAILY_CAP)",
    "        return per_day_reimbursement * days",
    "",
    "",
    "class TransportReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"Transport: 100% reimbursed with no limit.\"\"\"",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return expense.amount",
    "",
    "",
    "class ExpenseFactory:",
    "    \"\"\"Factory for creating Expense objects with auto-incrementing IDs.\"\"\"",
    "    _counter = 0",
    "    ",
    "    @classmethod",
    "    def create(cls, expense_type: str, amount: float, date: str,",
    "               details: Dict[str, Any]) -> Expense:",
    "        cls._counter += 1",
    "        return Expense(",
    "            id=f\"exp_{cls._counter}\",",
    "            expense_type=ExpenseType(expense_type),",
    "            amount=Decimal(str(amount)),",
    "            date=date,",
    "            details=details or {}",
    "        )",
    "",
    "",
    "class ExpenseManager:",
    "    \"\"\"",
    "    Main service for managing employee expenses and calculating reimbursements.",
    "    Uses Strategy pattern for extensible policy calculations.",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        self._employee_expenses: Dict[str, List[Expense]] = {}",
    "        self._strategies: Dict[ExpenseType, ReimbursementStrategy] = {",
    "            ExpenseType.FLIGHT: FlightReimbursementStrategy(),",
    "            ExpenseType.HOTEL: HotelReimbursementStrategy(),",
    "            ExpenseType.MEAL: MealReimbursementStrategy(),",
    "            ExpenseType.TRANSPORT: TransportReimbursementStrategy(),",
    "        }",
    "    ",
    "    def add_expense(self, employee_id: str, expense_type: str, amount: float,",
    "                    date: str, details: dict) -> str:",
    "        \"\"\"Add expense for employee, returns unique expense ID.\"\"\"",
    "        expense = ExpenseFactory.create(expense_type, amount, date, details)",
    "        if employee_id not in self._employee_expenses:",
    "            self._employee_expenses[employee_id] = []",
    "        self._employee_expenses[employee_id].append(expense)",
    "        return expense.id",
    "    ",
    "    def calculate_reimbursement(self, employee_id: str) -> float:",
    "        \"\"\"Calculate total reimbursable amount with all policies applied.\"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        total = Decimal('0')",
    "        for expense in expenses:",
    "            strategy = self._strategies[expense.expense_type]",
    "            total += strategy.calculate(expense)",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "    ",
    "    def get_expenses_by_type(self, employee_id: str, expense_type: str) -> List[Expense]:",
    "        \"\"\"Filter employee expenses by type.\"\"\"",
    "        target_type = ExpenseType(expense_type)",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        return [e for e in expenses if e.expense_type == target_type]",
    "    ",
    "    def get_total_expenses(self, employee_id: str) -> float:",
    "        \"\"\"Get raw expense total before policy application.\"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        total = Decimal('0')",
    "        for expense in expenses:",
    "            if expense.expense_type == ExpenseType.HOTEL:",
    "                nights = Decimal(str(expense.details.get('nights', 1)))",
    "                total += expense.amount * nights",
    "            elif expense.expense_type == ExpenseType.MEAL:",
    "                days = Decimal(str(expense.details.get('days', 1)))",
    "                total += expense.amount * days",
    "            else:",
    "                total += expense.amount",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"TRAVEL EXPENSE CALCULATION SYSTEM - Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Reset factory counter for clean demo",
    "    ExpenseFactory._counter = 0",
    "    manager = ExpenseManager()",
    "    ",
    "    # Demo 1: Multi-type expenses",
    "    print(\"\\n--- Employee emp001: Mixed Expenses ---\")",
    "    id1 = manager.add_expense(\"emp001\", \"FLIGHT\", 450.00, \"2024-03-15\", {})",
    "    id2 = manager.add_expense(\"emp001\", \"HOTEL\", 180.00, \"2024-03-15\", {\"nights\": 2})",
    "    id3 = manager.add_expense(\"emp001\", \"MEAL\", 75.00, \"2024-03-15\", {\"days\": 2})",
    "    ",
    "    print(f\"Added expenses: {id1}, {id2}, {id3}\")",
    "    print(f\"Total raw expenses: ${manager.get_total_expenses('emp001'):.2f}\")",
    "    print(f\"Total reimbursement: ${manager.calculate_reimbursement('emp001'):.2f}\")",
    "    ",
    "    # Demo 2: Policy caps in action",
    "    print(\"\\n--- Employee emp002: Policy Caps Applied ---\")",
    "    manager.add_expense(\"emp002\", \"HOTEL\", 350.00, \"2024-03-20\", {\"nights\": 3})",
    "    manager.add_expense(\"emp002\", \"FLIGHT\", 1500.00, \"2024-03-20\", {})",
    "    ",
    "    print(f\"Hotel: $350/night x 3 nights, capped at $200/night\")",
    "    print(f\"Flight: $1500, capped at $1000\")",
    "    print(f\"Total reimbursement: ${manager.calculate_reimbursement('emp002'):.2f}\")",
    "    ",
    "    # Demo 3: Filter by type",
    "    print(\"\\n--- Employee emp003: Multiple Transport ---\")",
    "    manager.add_expense(\"emp003\", \"TRANSPORT\", 89.50, \"2024-03-25\", {})",
    "    manager.add_expense(\"emp003\", \"TRANSPORT\", 45.75, \"2024-03-26\", {})",
    "    ",
    "    transports = manager.get_expenses_by_type(\"emp003\", \"TRANSPORT\")",
    "    print(f\"Transport expenses: {[(e.id, float(e.amount)) for e in transports]}\")",
    "    print(f\"Total reimbursement: ${manager.calculate_reimbursement('emp003'):.2f}\")",
    "    ",
    "    # Demo 4: Empty employee",
    "    print(\"\\n--- Employee emp004: No Expenses ---\")",
    "    print(f\"Reimbursement for new employee: ${manager.calculate_reimbursement('emp004'):.2f}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Demo complete!\")"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "enum ExpenseType {",
    "    FLIGHT, HOTEL, MEAL, TRANSPORT",
    "}",
    "",
    "class Expense {",
    "    private final String id;",
    "    private final ExpenseType type;",
    "    private final BigDecimal amount;",
    "    private final String date;",
    "    private final Map<String, Object> details;",
    "    ",
    "    public Expense(String id, ExpenseType type, BigDecimal amount,",
    "                   String date, Map<String, Object> details) {",
    "        this.id = id;",
    "        this.type = type;",
    "        this.amount = amount;",
    "        this.date = date;",
    "        this.details = details != null ? details : new HashMap<>();",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public ExpenseType getType() { return type; }",
    "    public BigDecimal getAmount() { return amount; }",
    "    public Map<String, Object> getDetails() { return details; }",
    "}",
    "",
    "interface ReimbursementStrategy {",
    "    BigDecimal calculate(Expense expense);",
    "}",
    "",
    "class FlightReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal LIMIT = new BigDecimal(\"1000\");",
    "    ",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount().min(LIMIT);",
    "    }",
    "}",
    "",
    "class HotelReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal NIGHTLY_CAP = new BigDecimal(\"200\");",
    "    ",
    "    public BigDecimal calculate(Expense expense) {",
    "        int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "        BigDecimal capped = expense.getAmount().min(NIGHTLY_CAP);",
    "        return capped.multiply(BigDecimal.valueOf(nights));",
    "    }",
    "}",
    "",
    "class MealReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal DAILY_CAP = new BigDecimal(\"50\");",
    "    private static final BigDecimal RATE = new BigDecimal(\"0.5\");",
    "    ",
    "    public BigDecimal calculate(Expense expense) {",
    "        int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "        BigDecimal perDay = expense.getAmount().multiply(RATE).min(DAILY_CAP);",
    "        return perDay.multiply(BigDecimal.valueOf(days));",
    "    }",
    "}",
    "",
    "class TransportReimbursementStrategy implements ReimbursementStrategy {",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount();",
    "    }",
    "}",
    "",
    "class ExpenseFactory {",
    "    private static int counter = 0;",
    "    ",
    "    public static Expense create(String type, double amount,",
    "                                  String date, Map<String, Object> details) {",
    "        counter++;",
    "        return new Expense(",
    "            \"exp_\" + counter,",
    "            ExpenseType.valueOf(type),",
    "            BigDecimal.valueOf(amount),",
    "            date,",
    "            details",
    "        );",
    "    }",
    "}",
    "",
    "public class ExpenseManager {",
    "    private Map<String, List<Expense>> employeeExpenses = new HashMap<>();",
    "    private Map<ExpenseType, ReimbursementStrategy> strategies = new HashMap<>();",
    "    ",
    "    public ExpenseManager() {",
    "        strategies.put(ExpenseType.FLIGHT, new FlightReimbursementStrategy());",
    "        strategies.put(ExpenseType.HOTEL, new HotelReimbursementStrategy());",
    "        strategies.put(ExpenseType.MEAL, new MealReimbursementStrategy());",
    "        strategies.put(ExpenseType.TRANSPORT, new TransportReimbursementStrategy());",
    "    }",
    "    ",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String date, Map<String, Object> details) {",
    "        Expense expense = ExpenseFactory.create(type, amount, date, details);",
    "        employeeExpenses.computeIfAbsent(employeeId, k -> new ArrayList<>()).add(expense);",
    "        return expense.getId();",
    "    }",
    "    ",
    "    public double calculateReimbursement(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            total = total.add(strategies.get(expense.getType()).calculate(expense));",
    "        }",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    public List<Expense> getExpensesByType(String employeeId, String type) {",
    "        ExpenseType expType = ExpenseType.valueOf(type);",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        List<Expense> result = new ArrayList<>();",
    "        for (Expense e : expenses) {",
    "            if (e.getType() == expType) result.add(e);",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    public double getTotalExpenses(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            if (expense.getType() == ExpenseType.HOTEL) {",
    "                int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "                total = total.add(expense.getAmount().multiply(BigDecimal.valueOf(nights)));",
    "            } else if (expense.getType() == ExpenseType.MEAL) {",
    "                int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "                total = total.add(expense.getAmount().multiply(BigDecimal.valueOf(days)));",
    "            } else {",
    "                total = total.add(expense.getAmount());",
    "            }",
    "        }",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"TRAVEL EXPENSE SYSTEM - Java Demo\");",
    "        System.out.println(\"=\" .repeat(60));",
    "        ",
    "        ExpenseManager manager = new ExpenseManager();",
    "        ",
    "        manager.addExpense(\"emp001\", \"FLIGHT\", 450.00, \"2024-03-15\", new HashMap<>());",
    "        manager.addExpense(\"emp001\", \"HOTEL\", 180.00, \"2024-03-15\", Map.of(\"nights\", 2));",
    "        manager.addExpense(\"emp001\", \"TRANSPORT\", 50.00, \"2024-03-15\", new HashMap<>());",
    "        ",
    "        System.out.printf(\"Total Raw: $%.2f%n\", manager.getTotalExpenses(\"emp001\"));",
    "        System.out.printf(\"Reimbursement: $%.2f%n\", manager.calculateReimbursement(\"emp001\"));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-6",
      "section": "Imports and Dependencies",
      "explanation": "We import `Decimal` with `ROUND_HALF_UP` for financial precision, `ABC/abstractmethod` for the Strategy interface, and `Enum` for type-safe expense categories."
    },
    {
      "lines": "8-13",
      "section": "ExpenseType Enum",
      "explanation": "Enum provides type safety - invalid types fail fast at `ExpenseType(value)`. The string values match the API input exactly."
    },
    {
      "lines": "16-23",
      "section": "Expense Dataclass",
      "explanation": "`@dataclass` auto-generates `__init__`, `__repr__`, etc. This is our immutable value object containing all expense data."
    },
    {
      "lines": "26-30",
      "section": "Strategy Interface (ABC)",
      "explanation": "Abstract base class defines the contract: every strategy must implement `calculate(expense) -> Decimal`. This enables polymorphism."
    },
    {
      "lines": "33-38",
      "section": "FlightReimbursementStrategy",
      "explanation": "Simple implementation: `min(amount, $1000)`. The LIMIT constant makes policy clear and easy to change."
    },
    {
      "lines": "41-47",
      "section": "HotelReimbursementStrategy",
      "explanation": "Gets nights from details dict, caps per-night rate at $200, multiplies by nights. Note Decimal conversion for precision."
    },
    {
      "lines": "50-57",
      "section": "MealReimbursementStrategy",
      "explanation": "Most complex policy: 50% rate, then cap at $50/day, then multiply by days. Order matters!"
    },
    {
      "lines": "60-63",
      "section": "TransportReimbursementStrategy",
      "explanation": "Simplest policy: 100% reimbursement, no limit. Still needs its own class for extensibility."
    },
    {
      "lines": "66-77",
      "section": "ExpenseFactory",
      "explanation": "Factory centralizes object creation, handles ID generation with class-level counter, converts string type to Enum and float to Decimal."
    },
    {
      "lines": "80-93",
      "section": "ExpenseManager.__init__",
      "explanation": "Constructor initializes empty expenses dict and registers all four strategies. Adding new expense type = add one line here."
    },
    {
      "lines": "95-101",
      "section": "add_expense()",
      "explanation": "Delegates to Factory, stores in employee's list. `setdefault` pattern creates list on first expense. Returns ID for caller."
    },
    {
      "lines": "103-110",
      "section": "calculate_reimbursement()",
      "explanation": "Core algorithm: iterate expenses, lookup strategy by type (O(1)), call calculate(), sum. Round only at END to preserve precision."
    },
    {
      "lines": "112-116",
      "section": "get_expenses_by_type()",
      "explanation": "Simple filter using list comprehension. Returns empty list (not None) for no matches - important API contract."
    },
    {
      "lines": "118-129",
      "section": "get_total_expenses()",
      "explanation": "Calculates raw totals. Note: Hotel/Meal amounts are rates that must be multiplied by nights/days respectively."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test ExpenseFactory creates with incrementing IDs. 2. Test each Strategy in isolation with known inputs. 3. Test add_expense stores correctly. 4. Test calculate_reimbursement with one expense type. 5. Test with multiple types.",
    "what_to_print_or_assert": [
      "print(f'Created expense: {expense.id}, type={expense.expense_type}, amount={expense.amount}')",
      "assert strategy.calculate(test_expense) == expected_value",
      "print(f'Running total: {total}') inside the loop",
      "assert calculate_reimbursement('new_employee') == 0.0"
    ],
    "common_failure_modes": [
      "Forgetting to multiply by nights/days in Hotel/Meal strategies",
      "Rounding at intermediate steps instead of only at the end",
      "Not handling empty details dict (KeyError)",
      "Using float instead of Decimal for calculations"
    ],
    "how_to_fix_fast": "Add print statements at each step: (1) After Factory creates expense, print all fields. (2) Before and after each strategy calculates, print input and output. (3) Print running total after each expense. Compare against hand-calculated values."
  },
  "complexity_analysis": {
    "time": {
      "add_expense": {
        "complexity": "O(1)",
        "explanation": "Factory creation O(1), dict lookup O(1), list append O(1)"
      },
      "calculate_reimbursement": {
        "complexity": "O(E)",
        "explanation": "Iterate all E expenses for employee, each strategy calculation is O(1)"
      },
      "get_expenses_by_type": {
        "complexity": "O(E)",
        "explanation": "Filter through all E expenses for employee"
      },
      "get_total_expenses": {
        "complexity": "O(E)",
        "explanation": "Sum all E expenses for employee"
      },
      "overall": "All operations are O(1) or O(E) where E = expenses for one employee"
    },
    "space": {
      "complexity": "O(N \u00d7 E) where N = employees, E = avg expenses per employee",
      "breakdown": "- Employee map: O(N) entries\n- Each employee's list: O(E) expenses\n- Strategies: O(4) = O(1) constant\n- Expense objects: O(1) each, O(N\u00d7E) total",
      "note": "No redundant storage - each expense stored exactly once"
    },
    "can_we_do_better": "Time is optimal - we must examine each expense at least once. Space could use streaming if expenses were from external source, but for in-memory this is optimal."
  },
  "dry_run": {
    "example": "ExpenseManager(), addExpense('e1', 'FLIGHT', 450), addExpense('e1', 'HOTEL', 180, nights=2), calculateReimbursement('e1')",
    "trace_table": "| Step | Operation | _employee_expenses | Strategy Called | Result |\n|------|-----------|-------------------|-----------------|--------|\n| 1 | __init__() | {} | - | Manager ready |\n| 2 | addExpense('e1', 'FLIGHT', 450) | {'e1': [Exp(FLIGHT,$450)]} | - | 'exp_1' |\n| 3 | addExpense('e1', 'HOTEL', 180, n=2) | {'e1': [..,$180]} | - | 'exp_2' |\n| 4 | calculateReimbursement('e1') | (read only) | Flight\u2192min(450,1000)=450 | - |\n| 4 | (continued) | | Hotel\u2192min(180,200)\u00d72=360 | - |\n| 4 | (sum) | | | 450+360=**$810.00** |",
    "final_answer": "$810.00 reimbursement"
  },
  "test_cases": [
    {
      "name": "Single flight under limit",
      "category": "Happy Path",
      "input": "addExpense('e1', 'FLIGHT', 500, ..., {}), calculateReimbursement('e1')",
      "expected": "500.00",
      "explanation": "Flight $500 < $1000 limit, fully reimbursed"
    },
    {
      "name": "Flight over limit",
      "category": "Policy Cap",
      "input": "addExpense('e1', 'FLIGHT', 1500, ..., {}), calculateReimbursement('e1')",
      "expected": "1000.00",
      "explanation": "Flight $1500 > $1000 limit, capped at $1000"
    },
    {
      "name": "Hotel under nightly cap",
      "category": "Happy Path",
      "input": "addExpense('e1', 'HOTEL', 150, ..., {nights: 3}), calculateReimbursement('e1')",
      "expected": "450.00",
      "explanation": "$150/night \u00d7 3 = $450, under $200/night cap"
    },
    {
      "name": "Hotel over nightly cap",
      "category": "Policy Cap",
      "input": "addExpense('e1', 'HOTEL', 275, ..., {nights: 2}), calculateReimbursement('e1')",
      "expected": "400.00",
      "explanation": "$275/night capped to $200/night \u00d7 2 = $400"
    },
    {
      "name": "Meal 50% under cap",
      "category": "Happy Path",
      "input": "addExpense('e1', 'MEAL', 80, ..., {days: 2}), calculateReimbursement('e1')",
      "expected": "80.00",
      "explanation": "$80/day \u00d7 50% = $40/day (under $50 cap) \u00d7 2 = $80"
    },
    {
      "name": "Meal 50% over cap",
      "category": "Policy Cap",
      "input": "addExpense('e1', 'MEAL', 120, ..., {days: 2}), calculateReimbursement('e1')",
      "expected": "100.00",
      "explanation": "$120/day \u00d7 50% = $60/day, capped to $50/day \u00d7 2 = $100"
    },
    {
      "name": "Transport no limit",
      "category": "Happy Path",
      "input": "addExpense('e1', 'TRANSPORT', 89.50, ..., {}), calculateReimbursement('e1')",
      "expected": "89.50",
      "explanation": "100% reimbursed, no limit"
    },
    {
      "name": "Empty employee",
      "category": "Edge Case",
      "input": "calculateReimbursement('new_emp')",
      "expected": "0.00",
      "explanation": "No expenses returns 0, not error"
    },
    {
      "name": "Decimal precision",
      "category": "Precision",
      "input": "addExpense('e1', 'TRANSPORT', 33.33, ..., {}), addExpense('e1', 'TRANSPORT', 33.33), addExpense('e1', 'TRANSPORT', 33.34)",
      "expected": "100.00",
      "explanation": "33.33 + 33.33 + 33.34 = 100.00 exactly with Decimal"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float for monetary calculations",
      "why_wrong": "0.1 + 0.1 + 0.1 in float = 0.30000000000000004, not 0.3",
      "correct_approach": "Use Decimal('0.1') for all financial math",
      "code_wrong": "amount = 33.33 + 33.33 + 33.34  # Not exactly 100.0!",
      "code_correct": "amount = Decimal('33.33') + Decimal('33.33') + Decimal('33.34')  # Exactly 100.00"
    },
    {
      "mistake": "Hardcoding expense types in if-else chains",
      "why_wrong": "Violates Open/Closed principle - adding new type requires modifying existing code",
      "correct_approach": "Use Strategy pattern - each type is its own class",
      "code_wrong": "if expense.type == 'FLIGHT': ... elif expense.type == 'HOTEL': ...",
      "code_correct": "strategies[expense.type].calculate(expense)"
    },
    {
      "mistake": "Forgetting to multiply by nights/days",
      "why_wrong": "Hotel/Meal amounts are per-night/per-day rates, not totals",
      "correct_approach": "Always multiply capped rate by count from details",
      "code_wrong": "return min(expense.amount, NIGHTLY_CAP)  # Missing \u00d7 nights",
      "code_correct": "return min(expense.amount, NIGHTLY_CAP) * nights"
    },
    {
      "mistake": "Rounding at intermediate steps",
      "why_wrong": "Accumulates rounding errors across multiple expenses",
      "correct_approach": "Keep full Decimal precision, round only the final result",
      "code_wrong": "total += round(strategy.calculate(expense), 2)  # Rounds each expense",
      "code_correct": "total += strategy.calculate(expense)  # Round only at end"
    },
    {
      "mistake": "Not validating expense type",
      "why_wrong": "Invalid type silently creates broken data or crashes later",
      "correct_approach": "Convert to Enum early - fails fast with clear error",
      "code_wrong": "expense.type = type_string  # No validation",
      "code_correct": "expense.type = ExpenseType(type_string)  # ValueError if invalid"
    }
  ],
  "interview_tips": {
    "opening": "This is an OOP Design problem requiring Strategy Pattern for different expense policies. Let me clarify a few things before designing...",
    "clarifying_questions_to_ask": [
      "Is the amount the total expense or the per-night/per-day rate for hotels and meals?",
      "What precision is required - should I use BigDecimal/Decimal for financial calculations?",
      "Should invalid expense types throw an exception or return an error?",
      "Can an employee submit multiple expenses of the same type?",
      "Are expense IDs globally unique or per-employee?"
    ],
    "what_to_mention_proactively": [
      "I'll use Strategy Pattern so each expense type encapsulates its calculation logic",
      "I'll use Factory Pattern for expense object creation",
      "I'll use Decimal/BigDecimal to avoid floating-point precision issues",
      "This design follows Open/Closed principle - adding new types won't modify existing code"
    ],
    "communication_during_coding": [
      "I'm creating an abstract ReimbursementStrategy - each expense type will implement this",
      "The ExpenseFactory handles ID generation and type conversion in one place",
      "Notice the strategies dictionary gives O(1) lookup by expense type",
      "I'm keeping full Decimal precision throughout, rounding only at the final return"
    ],
    "if_stuck": [
      "Step back: What varies between expense types? The calculation formula \u2192 Strategy pattern",
      "What's shared? The interface (calculate) \u2192 Abstract base class",
      "Draw the class diagram first, then implement",
      "Start with one expense type working end-to-end, then add others"
    ],
    "time_management": "0-5min: Clarify & design | 5-15min: Core classes (Expense, Strategy interface) | 15-30min: Strategies & Manager | 30-40min: Test & debug | 40-45min: Discuss extensions"
  },
  "pattern_recognition": {
    "pattern_name": "Strategy Pattern + Factory Pattern",
    "indicators": [
      "Multiple algorithms for the same purpose (different expense policies)",
      "Need to switch between algorithms at runtime (different expense types)",
      "Want to add new variants without modifying existing code",
      "Object creation logic is complex or needs centralization"
    ],
    "similar_problems": [
      "Payment processing with different payment methods",
      "Shipping cost calculation with different carriers",
      "Tax calculation with different regions",
      "Discount application with different promotion types"
    ],
    "template": "1. Define Strategy interface with common method\n2. Implement concrete Strategy for each variant\n3. Context class holds map of strategies\n4. Client passes data, Context delegates to appropriate Strategy"
  },
  "follow_up_preparation": {
    "part_2_hint": "Multi-Currency Support: Add CurrencyConverter that Strategies call. The conversion could be: (1) Convert at submission, (2) Convert at calculation. Part 2 likely adds a base currency and exchange rates.",
    "part_3_hint": "Per-Diem by Location: Caps become location-dependent. Add LocationPolicyProvider that returns caps by city/country. Strategies query this instead of using constants.",
    "data_structure_evolution": "Part 1: Strategy constants for caps \u2192 Part 2: CurrencyConverter service injection \u2192 Part 3: LocationPolicyProvider with city/cap mappings"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. This is an OOP Design challenge involving expense calculations with different policies. Before I start coding, I'd like to clarify a few things and outline my approach.",
    "after_clarification": "Great, so to summarize: (1) Different expense types have different reimbursement rules, (2) I need to use precise decimal math, (3) The system should be extensible. I'll use Strategy Pattern for the different policies and Factory Pattern for expense creation. Does this sound reasonable?",
    "while_coding": [
      "I'm starting with the Expense dataclass - this holds all the data for one expense submission...",
      "Now the Strategy interface - each expense type will implement calculate()...",
      "The ExpenseManager ties it together - it delegates calculations to the appropriate strategy...",
      "Notice I'm using Decimal throughout and only rounding at the final return..."
    ],
    "after_coding": "Let me trace through an example to verify: Employee submits a $250 hotel for 2 nights. Strategy looks up HotelStrategy, which calculates min($250, $200) \u00d7 2 = $400. That matches expected behavior.",
    "when_stuck_verbatim": "I'm thinking about how to handle the different calculation rules... The key insight is that while the formulas differ, they all take an expense and return a reimbursement amount. That's the Strategy pattern.",
    "after_mistake": "Actually, I see I forgot to multiply by nights in the hotel calculation. Let me fix that - the amount is per-night, so I need to multiply after applying the cap.",
    "before_moving_on": "This completes Part 1. Time complexity is O(E) for calculations, space is O(N\u00d7E). The Strategy pattern makes this extensible for new expense types. Ready for Part 2?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "OOP Design skills - proper use of Strategy/Factory patterns",
      "Financial precision awareness - using Decimal without being prompted",
      "Clean code - meaningful names, single responsibility",
      "Communication - explaining design decisions",
      "Extensibility mindset - thinking about how to add new expense types"
    ],
    "bonus_points": [
      "Drawing a class diagram before coding",
      "Mentioning SOLID principles by name",
      "Bringing up Decimal/BigDecimal without being asked",
      "Discussing how follow-up parts would fit into the design",
      "Writing clean, well-named code on first pass"
    ],
    "red_flags": [
      "Using if-else chain instead of Strategy pattern (this is an OOP problem!)",
      "Using float for money calculations",
      "Not asking about precision/rounding requirements",
      "Tight coupling between expense types and manager",
      "No consideration for extensibility"
    ],
    "what_differentiates_strong_candidates": "Strong candidates recognize this as an OOP Design problem immediately, propose Strategy pattern within the first 2 minutes, ask about financial precision, and write clean extensible code. They treat the expense types as plug-ins, not special cases."
  },
  "time_milestones": {
    "by_5_min": "Problem understood, clarifications done, Strategy pattern proposed",
    "by_10_min": "Class diagram sketched, starting code with Expense class",
    "by_20_min": "Strategy interface and at least 2 concrete strategies done",
    "by_30_min": "ExpenseManager complete, basic testing started",
    "by_40_min": "All tests passing, edge cases handled, complexity discussed",
    "by_45_min": "Ready for Part 2, discussing extensibility",
    "warning_signs": "If still designing at 15 min, simplify. If tests failing at 35 min, debug systematically."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see the hotel isn't multiplying by nights. Let me fix that - the amount is a per-night rate.' Fix cleanly and move on.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact Decimal rounding syntax - let me write the concept and look it up.' Most interviewers accept this.",
    "when_approach_is_wrong": "If you started with if-else and realize Strategy is better, say: 'Actually, this would be cleaner with Strategy pattern. Let me refactor - it's more extensible.'",
    "when_completely_stuck": "Say: 'I'm stuck on how to handle different policies. Could you hint whether inheritance or composition would work better here?'",
    "when_running_out_of_time": "Say: 'I have 5 minutes left. Let me focus on getting the core calculation working and explain what I'd add for production.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them wisely - they help with boilerplate but the DESIGN is what matters.",
    "what_to_do": [
      "Use AI for dataclass boilerplate",
      "Use for generating test cases",
      "Use for Decimal syntax if unsure",
      "Let it autocomplete obvious implementations"
    ],
    "what_not_to_do": [
      "Don't let AI generate the class structure - YOU decide on Strategy vs other patterns",
      "Don't accept if-else chains that AI might suggest",
      "Don't skip explaining your design because AI wrote the code"
    ],
    "how_to_demonstrate_understanding": "After AI helps, explain: 'The Strategy pattern here means each expense type owns its calculation. Adding a new type is just adding a new Strategy class - no changes to ExpenseManager.'",
    "expectation_adjustment": "With AI, you should complete Part 1 faster and have more time for clean code and Part 2."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately recognizing Strategy pattern applicability",
      "Drawing UML diagram before coding",
      "Mentioning Decimal for financial precision without prompting",
      "Writing self-documenting code with clear naming",
      "Discussing how Part 2 (currency) would plug in"
    ],
    "subtle_signals_of_experience": [
      "Using dataclass for immutable value objects",
      "Keeping strategy constants as class attributes, not magic numbers",
      "Returning empty list (not None) from filter methods",
      "Rounding only at API boundary, not intermediate steps"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping straight to code without discussing design",
      "Not asking any clarifying questions",
      "Dismissing OOP patterns as 'overkill'",
      "Getting defensive when interviewer points out if-else could be Strategy"
    ],
    "technical": [
      "Using float for monetary calculations",
      "if type == 'FLIGHT' elif type == 'HOTEL' chain",
      "Mixing storage and calculation in one class",
      "Not handling empty employee case"
    ],
    "communication": [
      "Coding in silence for extended periods",
      "Not explaining why Strategy pattern fits",
      "Ignoring the explicit 'use Strategy pattern' hint in problem"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "All 5 API methods implemented?",
      "Strategy pattern used for expense calculations?",
      "Factory pattern used for expense creation?",
      "Decimal used for financial precision?",
      "Empty employee returns 0.0 (not error)?",
      "At least one dry run with actual values?"
    ],
    "quick_code_review": [
      "No magic numbers (use named constants)",
      "Consistent naming (camelCase or snake_case)",
      "Type hints on all methods (Python)",
      "Brief docstrings on classes and key methods",
      "Round only at final return, not intermediate steps"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation with descriptive error messages",
      "Logging for audit trail and debugging",
      "Thread safety if concurrent submissions",
      "Persistence layer (database) instead of in-memory",
      "Configuration for policy limits (not hardcoded)",
      "Date validation and timezone handling"
    ],
    "why_not_in_interview": "Interview code should focus on core algorithm and design. Mention these verbally to show senior thinking.",
    "how_to_mention": "Say: 'In production, I'd add input validation, logging, and externalize the policy limits to configuration. For this interview, I'll focus on the core design.'"
  },
  "generated_at": "2026-01-19T04:11:28.705035",
  "_meta": {
    "problem_id": "travel_expense_calculation",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}