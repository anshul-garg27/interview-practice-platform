{
  "problem_title": "2D Canvas / Drawing Application - Part 4: Undo/Redo Support",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "We add undo/redo functionality using the Command Pattern. Every mutating operation (create, move, delete, z-order changes) must now be wrapped in a Command object that knows how to execute and reverse itself. Two stacks track undo/redo history.",
    "new_requirements": [
      "undo() - reverse the most recent operation",
      "redo() - re-apply the most recently undone operation",
      "All 6 existing mutating operations must be undoable",
      "New operations clear the redo stack"
    ],
    "new_constraints": [
      "Each command must store enough state to fully reverse itself",
      "Must maintain data structure invariants through undo/redo cycles"
    ],
    "key_insight": "Each operation creates a Command object that captures the 'delta' - the exact information needed to undo. For moves, this is old position. For deletes, this is the shape object AND its z-index. For z-order ops, this is the old index."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "undo() reverses last operation",
        "how_met": "Pop from undo_stack, call cmd.undo(), push to redo_stack",
        "gotchas": [
          "Must handle empty stack gracefully"
        ]
      },
      {
        "requirement": "redo() re-applies undone operation",
        "how_met": "Pop from redo_stack, call cmd.execute(), push to undo_stack",
        "gotchas": [
          "Don't increment counters again on redo"
        ]
      },
      {
        "requirement": "New operations clear redo stack",
        "how_met": "_execute_command() calls redo_stack.clear()",
        "gotchas": [
          "All 6 operations must use this helper"
        ]
      },
      {
        "requirement": "Create operations undoable",
        "how_met": "CreateShapeCmd stores shape reference; undo removes, redo re-adds same object",
        "gotchas": [
          "Shape ID must stay same on redo"
        ]
      },
      {
        "requirement": "Move operations undoable",
        "how_met": "MoveShapeCmd stores old_x, old_y; undo restores old position",
        "gotchas": [
          "Need get_position() method on Shape"
        ]
      },
      {
        "requirement": "Delete operations undoable",
        "how_met": "DeleteShapeCmd stores shape AND z_index; undo re-inserts at exact position",
        "gotchas": [
          "Must restore z-order, not just existence"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "undo",
        "target": "O(1) to O(n)",
        "achieved": "O(1) to O(n)",
        "why": "Stack pop is O(1), but underlying operation may be O(n) for z-order changes"
      },
      {
        "operation": "redo",
        "target": "O(1) to O(n)",
        "achieved": "O(1) to O(n)",
        "why": "Same reasoning as undo"
      }
    ],
    "non_goals": [
      "Multiple undo levels limit",
      "Undo grouping/batching",
      "Persistent undo history"
    ]
  },
  "assumptions": [
    "Undo/redo on empty stack is a silent no-op (no exception)",
    "Shape IDs are preserved across undo/redo cycles",
    "rect_count/circle_count are NOT decremented on undo (IDs are unique forever)",
    "No limit on undo/redo stack size"
  ],
  "tradeoffs": [
    {
      "decision": "Command per operation vs. Memento pattern",
      "chosen": "Command pattern",
      "why": "More memory efficient - only store deltas, not full canvas state",
      "alternative": "Memento (snapshot)",
      "when_to_switch": "If operations are complex or interdependent"
    },
    {
      "decision": "Separate command classes vs. single parameterized class",
      "chosen": "Separate classes",
      "why": "Clearer logic, easier to maintain, type-safe",
      "alternative": "Single class with operation enum",
      "when_to_switch": "If you have 20+ operation types"
    },
    {
      "decision": "Store shape reference vs. shape ID in commands",
      "chosen": "Store shape reference",
      "why": "Avoids lookup on execute/undo, simpler for delete undo",
      "alternative": "Store ID only",
      "when_to_switch": "If shapes could be modified externally"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Command interface (execute/undo)",
      "Stack-based undo/redo mechanism",
      "All Part 3 public methods"
    ],
    "what_to_change": [
      "Added undo_stack and redo_stack",
      "Modified all mutating methods to create commands",
      "Added get_position() to Shape classes"
    ],
    "interfaces_and_boundaries": "Command is an abstract interface. Each operation has its own command class. Canvas orchestrates command execution.",
    "invariants": [
      "undo_stack + redo_stack contains all reversible history",
      "shapes_by_id.keys() == {s.id for s in shapes} maintained through undo/redo",
      "Redoing a create uses the same shape object (same ID)"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 3):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 Canvas          \u2502\\n\u2502 - shapes []     \u2502\\n\u2502 - shapes_by_id  \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\nAFTER (Part 4):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 Canvas                          \u2502\\n\u2502 - shapes []                     \u2502\\n\u2502 - shapes_by_id {}               \u2502\\n\u2502 - undo_stack [cmd1, cmd2, ...]  \u2502 \u2190 NEW\\n\u2502 - redo_stack [cmd3, ...]        \u2502 \u2190 NEW\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "algorithm_flow": "OPERATION FLOW:\\n\\n1. User calls createRectangle(...)\\n   \u2502\\n   \u25bc\\n2. Create shape object\\n   \u2502\\n   \u25bc\\n3. Create CreateShapeCmd(canvas, shape)\\n   \u2502\\n   \u25bc\\n4. _execute_command(cmd):\\n   \u251c\u2500\u25ba cmd.execute() \u2192 adds shape to structures\\n   \u251c\u2500\u25ba undo_stack.append(cmd)\\n   \u2514\u2500\u25ba redo_stack.clear()\\n\\nUNDO FLOW:\\n\\n1. User calls undo()\\n   \u2502\\n   \u25bc\\n2. cmd = undo_stack.pop()\\n   \u2502\\n   \u25bc\\n3. cmd.undo() \u2192 reverses the operation\\n   \u2502\\n   \u25bc\\n4. redo_stack.append(cmd)"
  },
  "approaches": [
    {
      "name": "Naive: Store full canvas snapshots",
      "description": "On each operation, deep-copy entire canvas state. Undo restores previous snapshot.",
      "time_complexity": "O(n) per operation for copying",
      "space_complexity": "O(n * k) where k is number of operations",
      "why_not_optimal": "Extremely wasteful on memory. Moving one shape shouldn't require copying all shapes."
    },
    {
      "name": "Optimal: Command Pattern with deltas",
      "description": "Each operation creates a lightweight Command storing only what's needed to reverse it. Two stacks manage history.",
      "time_complexity": "O(1) extra per operation + operation cost",
      "space_complexity": "O(k) where k is operation count, each command is O(1)",
      "key_insight": "A move command only needs 4 integers (old_x, old_y, new_x, new_y). A delete needs the shape reference and its index. Minimal storage, maximum flexibility."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The **Command Pattern** is the textbook solution for undo/redo. Each operation becomes a **first-class object** with:\n\n1. **execute()** - performs the operation\n2. **undo()** - reverses the operation\n\n**Key Implementation Details:**\n\n- **CreateShapeCmd**: Stores the shape object. Execute adds to canvas, undo removes. Since we store the *object reference*, redo re-adds the **same shape** with the **same ID**.\n\n- **MoveShapeCmd**: Stores shape_id, old position, new position. We add `get_position()` to Shape to capture current position before moving.\n\n- **DeleteShapeCmd**: Stores shape reference AND z-index. Critical insight: undo must restore the shape to its **exact z-order position**, not just re-add it.\n\n- **BringToFront/SendToBackCmd**: Store old z-index. Undo removes from current position and re-inserts at old index.\n\n**Stack Management:**\n```\nNew operation \u2192 execute \u2192 push to undo_stack \u2192 CLEAR redo_stack\nUndo \u2192 pop from undo_stack \u2192 undo() \u2192 push to redo_stack\nRedo \u2192 pop from redo_stack \u2192 execute() \u2192 push to undo_stack\n```",
    "data_structures": [
      {
        "structure": "List<Command> undo_stack",
        "purpose": "LIFO stack of executed commands, most recent at end"
      },
      {
        "structure": "List<Command> redo_stack",
        "purpose": "LIFO stack of undone commands, cleared on new operations"
      },
      {
        "structure": "Command interface/ABC",
        "purpose": "Defines execute() and undo() contract"
      }
    ],
    "algorithm_steps": [
      "Step 1: Define Command ABC with execute() and undo() abstract methods",
      "Step 2: Create concrete command classes for each of 6 operations, each storing necessary state",
      "Step 3: Add undo_stack and redo_stack to Canvas.__init__()",
      "Step 4: Create _execute_command() helper that: executes, pushes to undo_stack, clears redo_stack",
      "Step 5: Modify all 6 mutating methods to create appropriate command and call _execute_command()",
      "Step 6: Implement undo(): pop from undo_stack, call undo(), push to redo_stack",
      "Step 7: Implement redo(): pop from redo_stack, call execute(), push to undo_stack"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List, Dict, Tuple",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all shapes on the canvas.\"\"\"",
    "    def __init__(self, shape_id: str):",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains(self, x: int, y: int) -> bool: pass",
    "    ",
    "    @abstractmethod",
    "    def move_to(self, new_x: int, new_y: int) -> None: pass",
    "    ",
    "    @abstractmethod",
    "    def get_position(self) -> Tuple[int, int]: pass  # NEW for Part 4",
    "",
    "",
    "class Rectangle(Shape):",
    "    def __init__(self, shape_id: str, x: int, y: int, width: int, height: int):",
    "        super().__init__(shape_id)",
    "        self.x, self.y = x, y",
    "        self.width, self.height = width, height",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        return self.x <= px <= self.x + self.width and self.y <= py <= self.y + self.height",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        self.x, self.y = new_x, new_y",
    "    ",
    "    def get_position(self) -> Tuple[int, int]:",
    "        return (self.x, self.y)",
    "",
    "",
    "class Circle(Shape):",
    "    def __init__(self, shape_id: str, center_x: int, center_y: int, radius: int):",
    "        super().__init__(shape_id)",
    "        self.cx, self.cy = center_x, center_y",
    "        self.radius = radius",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        dx, dy = px - self.cx, py - self.cy",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        self.cx, self.cy = new_x, new_y",
    "    ",
    "    def get_position(self) -> Tuple[int, int]:",
    "        return (self.cx, self.cy)",
    "",
    "",
    "# ==================== PART 4: Command Pattern ====================",
    "",
    "class Command(ABC):",
    "    \"\"\"Base class for undoable commands.\"\"\"",
    "    @abstractmethod",
    "    def execute(self) -> None: pass",
    "    ",
    "    @abstractmethod",
    "    def undo(self) -> None: pass",
    "",
    "",
    "class CreateShapeCmd(Command):",
    "    \"\"\"Undoable shape creation - stores shape reference for redo.\"\"\"",
    "    def __init__(self, canvas: 'Canvas', shape: Shape):",
    "        self.canvas, self.shape = canvas, shape",
    "    ",
    "    def execute(self):",
    "        self.canvas.shapes.append(self.shape)",
    "        self.canvas.shapes_by_id[self.shape.id] = self.shape",
    "    ",
    "    def undo(self):",
    "        self.canvas.shapes.remove(self.shape)",
    "        del self.canvas.shapes_by_id[self.shape.id]",
    "",
    "",
    "class MoveShapeCmd(Command):",
    "    \"\"\"Undoable move - stores old position.\"\"\"",
    "    def __init__(self, canvas: 'Canvas', shape_id: str, old_pos: Tuple[int, int], new_pos: Tuple[int, int]):",
    "        self.canvas, self.shape_id = canvas, shape_id",
    "        self.old_pos, self.new_pos = old_pos, new_pos",
    "    ",
    "    def execute(self):",
    "        self.canvas.shapes_by_id[self.shape_id].move_to(*self.new_pos)",
    "    ",
    "    def undo(self):",
    "        self.canvas.shapes_by_id[self.shape_id].move_to(*self.old_pos)",
    "",
    "",
    "class DeleteShapeCmd(Command):",
    "    \"\"\"Undoable delete - stores shape and z-index for restoration.\"\"\"",
    "    def __init__(self, canvas: 'Canvas', shape: Shape, z_index: int):",
    "        self.canvas, self.shape, self.z_index = canvas, shape, z_index",
    "    ",
    "    def execute(self):",
    "        del self.canvas.shapes_by_id[self.shape.id]",
    "        self.canvas.shapes.remove(self.shape)",
    "    ",
    "    def undo(self):",
    "        self.canvas.shapes_by_id[self.shape.id] = self.shape",
    "        self.canvas.shapes.insert(self.z_index, self.shape)",
    "",
    "",
    "class ZOrderCmd(Command):",
    "    \"\"\"Undoable z-order change - stores old index and target index.\"\"\"",
    "    def __init__(self, canvas: 'Canvas', shape: Shape, old_index: int, to_front: bool):",
    "        self.canvas, self.shape = canvas, shape",
    "        self.old_index, self.to_front = old_index, to_front",
    "    ",
    "    def execute(self):",
    "        self.canvas.shapes.remove(self.shape)",
    "        if self.to_front:",
    "            self.canvas.shapes.append(self.shape)",
    "        else:",
    "            self.canvas.shapes.insert(0, self.shape)",
    "    ",
    "    def undo(self):",
    "        self.canvas.shapes.remove(self.shape)",
    "        self.canvas.shapes.insert(self.old_index, self.shape)",
    "",
    "",
    "class Canvas:",
    "    \"\"\"2D canvas with undo/redo support via Command Pattern.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.shapes: List[Shape] = []",
    "        self.shapes_by_id: Dict[str, Shape] = {}",
    "        self.rect_count = 0",
    "        self.circle_count = 0",
    "        # Part 4: Undo/Redo stacks",
    "        self.undo_stack: List[Command] = []",
    "        self.redo_stack: List[Command] = []",
    "    ",
    "    def _execute_command(self, cmd: Command) -> None:",
    "        \"\"\"Execute command, push to undo stack, clear redo stack.\"\"\"",
    "        cmd.execute()",
    "        self.undo_stack.append(cmd)",
    "        self.redo_stack.clear()",
    "    ",
    "    def create_rectangle(self, x: int, y: int, width: int, height: int) -> str:",
    "        self.rect_count += 1",
    "        shape_id = f\"rect_{self.rect_count}\"",
    "        shape = Rectangle(shape_id, x, y, width, height)",
    "        self._execute_command(CreateShapeCmd(self, shape))",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: int, center_y: int, radius: int) -> str:",
    "        self.circle_count += 1",
    "        shape_id = f\"circle_{self.circle_count}\"",
    "        shape = Circle(shape_id, center_x, center_y, radius)",
    "        self._execute_command(CreateShapeCmd(self, shape))",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: int, y: int) -> Optional[str]:",
    "        for shape in reversed(self.shapes):",
    "            if shape.contains(x, y):",
    "                return shape.id",
    "        return None",
    "    ",
    "    def move_shape(self, shape_id: str, new_x: int, new_y: int) -> None:",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id[shape_id]",
    "            old_pos = shape.get_position()",
    "            self._execute_command(MoveShapeCmd(self, shape_id, old_pos, (new_x, new_y)))",
    "    ",
    "    def delete_shape(self, shape_id: str) -> None:",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id[shape_id]",
    "            z_index = self.shapes.index(shape)",
    "            self._execute_command(DeleteShapeCmd(self, shape, z_index))",
    "    ",
    "    def bring_to_front(self, shape_id: str) -> None:",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id[shape_id]",
    "            old_index = self.shapes.index(shape)",
    "            self._execute_command(ZOrderCmd(self, shape, old_index, to_front=True))",
    "    ",
    "    def send_to_back(self, shape_id: str) -> None:",
    "        if shape_id in self.shapes_by_id:",
    "            shape = self.shapes_by_id[shape_id]",
    "            old_index = self.shapes.index(shape)",
    "            self._execute_command(ZOrderCmd(self, shape, old_index, to_front=False))",
    "    ",
    "    # ==================== PART 4: Undo/Redo ====================",
    "    ",
    "    def undo(self) -> None:",
    "        \"\"\"Undo most recent operation. No-op if nothing to undo.\"\"\"",
    "        if self.undo_stack:",
    "            cmd = self.undo_stack.pop()",
    "            cmd.undo()",
    "            self.redo_stack.append(cmd)",
    "    ",
    "    def redo(self) -> None:",
    "        \"\"\"Redo most recently undone operation. No-op if nothing to redo.\"\"\"",
    "        if self.redo_stack:",
    "            cmd = self.redo_stack.pop()",
    "            cmd.execute()",
    "            self.undo_stack.append(cmd)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"TEST 1: Undo/Redo Create\")",
    "    print(\"=\" * 60)",
    "    c = Canvas()",
    "    c.create_rectangle(0, 0, 50, 50)",
    "    print(f\"After create: getShapeAt(25,25) = {c.get_shape_at(25, 25)}\")",
    "    c.undo()",
    "    print(f\"After undo:   getShapeAt(25,25) = {c.get_shape_at(25, 25)}\")",
    "    c.redo()",
    "    print(f\"After redo:   getShapeAt(25,25) = {c.get_shape_at(25, 25)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 2: Undo Move\")",
    "    print(\"=\" * 60)",
    "    c2 = Canvas()",
    "    c2.create_rectangle(0, 0, 50, 50)",
    "    c2.move_shape(\"rect_1\", 100, 100)",
    "    print(f\"After move:   at(25,25)={c2.get_shape_at(25, 25)}, at(125,125)={c2.get_shape_at(125, 125)}\")",
    "    c2.undo()",
    "    print(f\"After undo:   at(25,25)={c2.get_shape_at(25, 25)}, at(125,125)={c2.get_shape_at(125, 125)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 3: Undo Delete (restores z-order)\")",
    "    print(\"=\" * 60)",
    "    c3 = Canvas()",
    "    c3.create_rectangle(0, 0, 100, 100)   # rect_1 (bottom)",
    "    c3.create_circle(50, 50, 30)          # circle_1 (top)",
    "    print(f\"Before delete: at(50,50) = {c3.get_shape_at(50, 50)} (circle on top)\")",
    "    c3.delete_shape(\"circle_1\")",
    "    print(f\"After delete:  at(50,50) = {c3.get_shape_at(50, 50)} (rect visible)\")",
    "    c3.undo()",
    "    print(f\"After undo:    at(50,50) = {c3.get_shape_at(50, 50)} (circle restored on top)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 4: New operation clears redo stack\")",
    "    print(\"=\" * 60)",
    "    c4 = Canvas()",
    "    c4.create_rectangle(0, 0, 50, 50)",
    "    c4.undo()",
    "    print(f\"After undo: redo_stack size = {len(c4.redo_stack)}\")",
    "    c4.create_circle(100, 100, 20)  # New operation clears redo",
    "    print(f\"After new create: redo_stack size = {len(c4.redo_stack)}\")",
    "    c4.redo()  # Should be no-op",
    "    print(f\"Redo is no-op, shapes = {[s.id for s in c4.shapes]}\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "abstract class Shape {",
    "    protected String id;",
    "    public Shape(String id) { this.id = id; }",
    "    public String getId() { return id; }",
    "    public abstract boolean contains(int x, int y);",
    "    public abstract void moveTo(int newX, int newY);",
    "    public abstract int[] getPosition();  // NEW for Part 4",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private int x, y, width, height;",
    "    public Rectangle(String id, int x, int y, int w, int h) {",
    "        super(id); this.x = x; this.y = y; this.width = w; this.height = h;",
    "    }",
    "    public boolean contains(int px, int py) {",
    "        return x <= px && px <= x + width && y <= py && py <= y + height;",
    "    }",
    "    public void moveTo(int newX, int newY) { this.x = newX; this.y = newY; }",
    "    public int[] getPosition() { return new int[]{x, y}; }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private int cx, cy, radius;",
    "    public Circle(String id, int cx, int cy, int r) {",
    "        super(id); this.cx = cx; this.cy = cy; this.radius = r;",
    "    }",
    "    public boolean contains(int px, int py) {",
    "        long dx = px - cx, dy = py - cy;",
    "        return dx * dx + dy * dy <= (long) radius * radius;",
    "    }",
    "    public void moveTo(int newX, int newY) { this.cx = newX; this.cy = newY; }",
    "    public int[] getPosition() { return new int[]{cx, cy}; }",
    "}",
    "",
    "// ==================== PART 4: Command Pattern ====================",
    "",
    "interface Command {",
    "    void execute();",
    "    void undo();",
    "}",
    "",
    "class CreateShapeCmd implements Command {",
    "    private Canvas canvas;",
    "    private Shape shape;",
    "    CreateShapeCmd(Canvas c, Shape s) { this.canvas = c; this.shape = s; }",
    "    public void execute() {",
    "        canvas.shapes.add(shape);",
    "        canvas.shapesById.put(shape.getId(), shape);",
    "    }",
    "    public void undo() {",
    "        canvas.shapes.remove(shape);",
    "        canvas.shapesById.remove(shape.getId());",
    "    }",
    "}",
    "",
    "class MoveShapeCmd implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private int[] oldPos, newPos;",
    "    MoveShapeCmd(Canvas c, String id, int[] oldP, int[] newP) {",
    "        this.canvas = c; this.shapeId = id; this.oldPos = oldP; this.newPos = newP;",
    "    }",
    "    public void execute() { canvas.shapesById.get(shapeId).moveTo(newPos[0], newPos[1]); }",
    "    public void undo() { canvas.shapesById.get(shapeId).moveTo(oldPos[0], oldPos[1]); }",
    "}",
    "",
    "class DeleteShapeCmd implements Command {",
    "    private Canvas canvas;",
    "    private Shape shape;",
    "    private int zIndex;",
    "    DeleteShapeCmd(Canvas c, Shape s, int z) { this.canvas = c; this.shape = s; this.zIndex = z; }",
    "    public void execute() {",
    "        canvas.shapesById.remove(shape.getId());",
    "        canvas.shapes.remove(shape);",
    "    }",
    "    public void undo() {",
    "        canvas.shapesById.put(shape.getId(), shape);",
    "        canvas.shapes.add(zIndex, shape);",
    "    }",
    "}",
    "",
    "class ZOrderCmd implements Command {",
    "    private Canvas canvas;",
    "    private Shape shape;",
    "    private int oldIndex;",
    "    private boolean toFront;",
    "    ZOrderCmd(Canvas c, Shape s, int idx, boolean front) {",
    "        this.canvas = c; this.shape = s; this.oldIndex = idx; this.toFront = front;",
    "    }",
    "    public void execute() {",
    "        canvas.shapes.remove(shape);",
    "        if (toFront) canvas.shapes.add(shape);",
    "        else canvas.shapes.add(0, shape);",
    "    }",
    "    public void undo() {",
    "        canvas.shapes.remove(shape);",
    "        canvas.shapes.add(oldIndex, shape);",
    "    }",
    "}",
    "",
    "public class Canvas {",
    "    List<Shape> shapes = new ArrayList<>();",
    "    Map<String, Shape> shapesById = new HashMap<>();",
    "    private int rectCount = 0, circleCount = 0;",
    "    // Part 4: Undo/Redo stacks",
    "    private List<Command> undoStack = new ArrayList<>();",
    "    private List<Command> redoStack = new ArrayList<>();",
    "    ",
    "    private void executeCommand(Command cmd) {",
    "        cmd.execute();",
    "        undoStack.add(cmd);",
    "        redoStack.clear();",
    "    }",
    "    ",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        String id = \"rect_\" + (++rectCount);",
    "        Shape shape = new Rectangle(id, x, y, width, height);",
    "        executeCommand(new CreateShapeCmd(this, shape));",
    "        return id;",
    "    }",
    "    ",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        String id = \"circle_\" + (++circleCount);",
    "        Shape shape = new Circle(id, centerX, centerY, radius);",
    "        executeCommand(new CreateShapeCmd(this, shape));",
    "        return id;",
    "    }",
    "    ",
    "    public String getShapeAt(int x, int y) {",
    "        for (int i = shapes.size() - 1; i >= 0; i--)",
    "            if (shapes.get(i).contains(x, y)) return shapes.get(i).getId();",
    "        return null;",
    "    }",
    "    ",
    "    public void moveShape(String shapeId, int newX, int newY) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            int[] oldPos = shape.getPosition();",
    "            executeCommand(new MoveShapeCmd(this, shapeId, oldPos, new int[]{newX, newY}));",
    "        }",
    "    }",
    "    ",
    "    public void deleteShape(String shapeId) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            int zIndex = shapes.indexOf(shape);",
    "            executeCommand(new DeleteShapeCmd(this, shape, zIndex));",
    "        }",
    "    }",
    "    ",
    "    public void bringToFront(String shapeId) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            int oldIndex = shapes.indexOf(shape);",
    "            executeCommand(new ZOrderCmd(this, shape, oldIndex, true));",
    "        }",
    "    }",
    "    ",
    "    public void sendToBack(String shapeId) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            int oldIndex = shapes.indexOf(shape);",
    "            executeCommand(new ZOrderCmd(this, shape, oldIndex, false));",
    "        }",
    "    }",
    "    ",
    "    // ==================== PART 4: Undo/Redo ====================",
    "    ",
    "    public void undo() {",
    "        if (!undoStack.isEmpty()) {",
    "            Command cmd = undoStack.remove(undoStack.size() - 1);",
    "            cmd.undo();",
    "            redoStack.add(cmd);",
    "        }",
    "    }",
    "    ",
    "    public void redo() {",
    "        if (!redoStack.isEmpty()) {",
    "            Command cmd = redoStack.remove(redoStack.size() - 1);",
    "            cmd.execute();",
    "            undoStack.add(cmd);",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"TEST 1: Undo/Redo Create\");",
    "        Canvas c = new Canvas();",
    "        c.createRectangle(0, 0, 50, 50);",
    "        System.out.println(\"After create: \" + c.getShapeAt(25, 25));",
    "        c.undo();",
    "        System.out.println(\"After undo: \" + c.getShapeAt(25, 25));",
    "        c.redo();",
    "        System.out.println(\"After redo: \" + c.getShapeAt(25, 25));",
    "        ",
    "        System.out.println(\"\\nTEST 2: Undo Move\");",
    "        Canvas c2 = new Canvas();",
    "        c2.createRectangle(0, 0, 50, 50);",
    "        c2.moveShape(\"rect_1\", 100, 100);",
    "        System.out.println(\"After move: at(25,25)=\" + c2.getShapeAt(25,25) + \", at(125,125)=\" + c2.getShapeAt(125,125));",
    "        c2.undo();",
    "        System.out.println(\"After undo: at(25,25)=\" + c2.getShapeAt(25,25) + \", at(125,125)=\" + c2.getShapeAt(125,125));",
    "        ",
    "        System.out.println(\"\\nTEST 3: Undo Delete restores z-order\");",
    "        Canvas c3 = new Canvas();",
    "        c3.createRectangle(0, 0, 100, 100);",
    "        c3.createCircle(50, 50, 30);",
    "        System.out.println(\"Before delete: \" + c3.getShapeAt(50, 50));",
    "        c3.deleteShape(\"circle_1\");",
    "        System.out.println(\"After delete: \" + c3.getShapeAt(50, 50));",
    "        c3.undo();",
    "        System.out.println(\"After undo: \" + c3.getShapeAt(50, 50));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-46",
      "explanation": "Shape hierarchy unchanged except for new get_position() abstract method and implementations"
    },
    {
      "lines": "48-56",
      "explanation": "Command ABC defines the interface: execute() performs operation, undo() reverses it"
    },
    {
      "lines": "58-69",
      "explanation": "CreateShapeCmd: stores canvas + shape reference. Execute adds to both structures; undo removes from both"
    },
    {
      "lines": "71-81",
      "explanation": "MoveShapeCmd: stores old_pos and new_pos tuples. Execute moves to new; undo moves to old"
    },
    {
      "lines": "83-95",
      "explanation": "DeleteShapeCmd: CRITICAL - stores shape AND z_index. Undo must restore at exact z-position"
    },
    {
      "lines": "97-111",
      "explanation": "ZOrderCmd: handles both bringToFront and sendToBack via boolean flag. Stores old_index for undo"
    },
    {
      "lines": "113-126",
      "explanation": "Canvas __init__ adds undo_stack and redo_stack. _execute_command helper handles stack management"
    },
    {
      "lines": "128-157",
      "explanation": "Modified create/move/delete/z-order methods now create commands and call _execute_command"
    },
    {
      "lines": "159-172",
      "explanation": "undo() and redo() implementations: pop from one stack, call method, push to other stack"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "undo": {
          "complexity": "O(1) + operation",
          "explanation": "Stack pop O(1), plus cost of underlying operation (O(1) for move, O(n) for z-order)"
        },
        "redo": {
          "complexity": "O(1) + operation",
          "explanation": "Same as undo"
        }
      },
      "modified_methods": {
        "create_rectangle": {
          "complexity": "O(1)",
          "explanation": "Still O(1), just wrapped in command"
        },
        "move_shape": {
          "complexity": "O(1)",
          "explanation": "Still O(1), added get_position() call"
        },
        "delete_shape": {
          "complexity": "O(n)",
          "explanation": "Added shapes.index() call for z_index"
        },
        "bring_to_front": {
          "complexity": "O(n)",
          "explanation": "Added shapes.index() call for old_index"
        },
        "send_to_back": {
          "complexity": "O(n)",
          "explanation": "Added shapes.index() call for old_index"
        }
      },
      "overall_change": "No asymptotic change. Operations that were O(n) remain O(n). Command wrapper adds O(1) overhead."
    },
    "space": {
      "additional_space": "O(k) where k = number of operations",
      "explanation": "Each operation creates one Command object (constant size). undo_stack + redo_stack together hold all commands."
    }
  },
  "dry_run": {
    "example_input": "create rect, move it, undo move, check positions",
    "steps": [
      {
        "step": 1,
        "action": "createRectangle(0,0,50,50)",
        "state": "shapes=[rect_1], undo=[CreateCmd], redo=[]",
        "explanation": "Shape created, command pushed"
      },
      {
        "step": 2,
        "action": "moveShape('rect_1',100,100)",
        "state": "rect_1 at (100,100), undo=[CreateCmd,MoveCmd], redo=[]",
        "explanation": "MoveCmd stores old_pos=(0,0), new_pos=(100,100)"
      },
      {
        "step": 3,
        "action": "undo()",
        "state": "rect_1 at (0,0), undo=[CreateCmd], redo=[MoveCmd]",
        "explanation": "MoveCmd.undo() restores old position, cmd moves to redo"
      },
      {
        "step": 4,
        "action": "getShapeAt(25,25)",
        "state": "unchanged",
        "explanation": "Returns 'rect_1' - shape is back at origin"
      },
      {
        "step": 5,
        "action": "getShapeAt(125,125)",
        "state": "unchanged",
        "explanation": "Returns None - shape no longer at (100,100)"
      }
    ],
    "final_output": "rect_1 visible at original position, not at moved position"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create, undo, redo - shape should be back",
      "Move, undo - position restored"
    ],
    "likely_bugs": [
      "Forgetting to clear redo_stack on new operation",
      "Not storing z_index for delete undo",
      "Calling execute() in redo instead of letting command handle it"
    ],
    "recommended_logs_or_asserts": [
      "assert len(shapes) == len(shapes_by_id)",
      "Log undo/redo stack sizes after each operation"
    ],
    "how_to_localize": "Add print in execute() and undo() of each command. Trace which command is being called and with what state."
  },
  "edge_cases": [
    {
      "case": "Undo with empty stack",
      "handling": "No-op, check if stack empty before pop",
      "gotcha": "Don't throw exception"
    },
    {
      "case": "Redo with empty stack",
      "handling": "No-op, same as undo",
      "gotcha": "Don't throw exception"
    },
    {
      "case": "New operation after undo",
      "handling": "Clear redo_stack in _execute_command",
      "gotcha": "Redo becomes impossible after this"
    },
    {
      "case": "Undo delete then redo",
      "handling": "Shape restored at same z-index, then re-deleted",
      "gotcha": "Z-index must be stored, not just shape"
    },
    {
      "case": "Multiple undos then partial redo",
      "handling": "Works naturally with stack semantics",
      "gotcha": "Don't modify redo_stack during iteration"
    }
  ],
  "test_cases": [
    {
      "name": "Basic undo/redo create",
      "input": "create, getShapeAt, undo, getShapeAt, redo, getShapeAt",
      "expected": "[rect_1, rect_1, null, null, null, rect_1]",
      "explanation": "Shape appears, disappears on undo, reappears on redo"
    },
    {
      "name": "Undo move restores position",
      "input": "create(0,0,50,50), move(rect_1,100,100), undo, getShapeAt(25,25)",
      "expected": "rect_1",
      "explanation": "Move undone, shape back at origin"
    },
    {
      "name": "New op clears redo",
      "input": "create, undo, create_circle, redo",
      "expected": "redo is no-op, only circle exists",
      "explanation": "Second create cleared redo_stack"
    },
    {
      "name": "Undo delete preserves z-order",
      "input": "create rect, create circle (on top), delete circle, undo, getShapeAt(overlap)",
      "expected": "circle",
      "explanation": "Circle restored on top, not at bottom"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not storing z-index for delete",
      "why_wrong": "Undo would add shape at end (top) instead of original position",
      "correct_approach": "Store z_index = shapes.index(shape) before delete",
      "code_example_wrong": "# undo just appends\\nself.canvas.shapes.append(self.shape)",
      "code_example_correct": "# undo inserts at stored index\\nself.canvas.shapes.insert(self.z_index, self.shape)"
    },
    {
      "mistake": "Forgetting to clear redo stack",
      "why_wrong": "After undo then new operation, redo would restore inconsistent state",
      "correct_approach": "Always clear redo_stack when executing new command",
      "code_example_wrong": "def _execute_command(self, cmd):\\n    cmd.execute()\\n    self.undo_stack.append(cmd)\\n    # Forgot redo_stack.clear()",
      "code_example_correct": "def _execute_command(self, cmd):\\n    cmd.execute()\\n    self.undo_stack.append(cmd)\\n    self.redo_stack.clear()  # Critical!"
    },
    {
      "mistake": "Storing shape ID instead of reference for create undo",
      "why_wrong": "After undo, shape object is gone. Redo would need to recreate it, possibly with wrong ID",
      "correct_approach": "Store shape object reference. It survives undo (held by command)",
      "code_example_wrong": "self.shape_id = shape.id  # Lost the object!",
      "code_example_correct": "self.shape = shape  # Keep reference for redo"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by saying 'This is a textbook Command Pattern use case.' Draw the two stacks. Explain that each operation becomes an object that knows how to execute and undo itself.",
    "what_to_mention": [
      "Command Pattern is THE design pattern for undo/redo",
      "Key insight: store deltas, not snapshots",
      "Critical for delete: must store z-index, not just shape",
      "Trade-off: memory for command objects vs. full snapshots"
    ],
    "time_allocation": "2 min explain pattern, 3 min design commands, 8 min implement, 2 min test",
    "if_stuck": [
      "Remember: Command needs execute() and undo()",
      "Think about what state each command needs to reverse itself"
    ]
  },
  "connection_to_next_part": "Part 5 might add: grouping/ungrouping shapes, composite pattern for groups, or undo/redo limits. The Command pattern extends naturally - just create new command classes.",
  "communication_script": {
    "transition_from_previous": "Part 3 gave us delete and z-order control. For Part 4, I need undo/redo - this is the classic Command Pattern. Let me design the command classes first.",
    "explaining_changes": "The key change is that every mutating operation now creates a Command object that knows how to reverse itself. I'll add two stacks and modify all six methods to use commands.",
    "while_extending_code": [
      "I'm adding get_position() to Shape so MoveCommand can capture the old position",
      "This DeleteShapeCmd stores the z-index - crucial for correct undo",
      "The _execute_command helper ensures redo_stack is always cleared"
    ],
    "after_completing": "Undo/redo now works for all operations. Both are O(1) plus the operation cost. The space overhead is O(k) for k operations. Ready for Part 5?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_3_min": "Explain Command Pattern, identify the 6 operations needing commands",
    "by_8_min": "Design command classes, identify what state each needs",
    "by_15_min": "Implementation complete, basic tests passing",
    "warning_signs": "If still designing commands at 10 min, simplify - maybe combine similar commands"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 3 z-order is buggy, fix it first. Commands depend on correct base operations.",
    "if_new_requirement_unclear": "Ask: 'Should undo of bringToFront restore exact position, or just move down one level?'",
    "if_running_behind": "Focus on CreateShapeCmd and MoveShapeCmd first - they're the most common. Mention you'd add the others similarly."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing Command Pattern",
      "Noting that delete needs z-index, not just shape reference",
      "Mentioning that redo_stack.clear() is critical for consistency",
      "Discussing memory trade-offs vs. snapshot approach"
    ]
  },
  "pattern_recognition": {
    "pattern": "Command Pattern",
    "indicators": [
      "Undo/redo requirement",
      "Operations that need to be reversible",
      "Action history tracking"
    ],
    "similar_problems": [
      "Text editor with undo",
      "Transaction systems",
      "Game state rollback"
    ],
    "template": "interface Command { void execute(); void undo(); }\\nclass ConcreteCmd implements Command { /* store delta */ }"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Undo/redo immediately suggests Command Pattern",
      "why": "It's THE textbook solution for reversible operations"
    },
    {
      "step": 2,
      "thought": "Each command needs to store just enough to reverse",
      "why": "Snapshots are too expensive; deltas are minimal"
    },
    {
      "step": 3,
      "thought": "Delete is tricky - need z-index",
      "why": "Just storing the shape isn't enough to restore z-order"
    },
    {
      "step": 4,
      "thought": "Two stacks with push/pop/clear semantics",
      "why": "Classic undo/redo state machine"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you know Command Pattern?",
      "Can you identify what state each command needs?",
      "Do you handle the redo_stack clearing correctly?"
    ],
    "bonus_points": [
      "Mentioning Memento vs Command trade-off",
      "Noting z-index for delete",
      "Clean code organization"
    ],
    "red_flags": [
      "Not knowing Command Pattern",
      "Storing full snapshots",
      "Missing redo_stack clearing"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI generate boilerplate command classes",
      "Use AI for stack manipulation code"
    ],
    "what_not_to_do": [
      "Don't let AI decide what state each command needs",
      "Verify the undo logic yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not mentioning Command Pattern by name",
      "Overcomplicating the design"
    ],
    "technical": [
      "Snapshot approach instead of commands",
      "Missing get_position() for move undo"
    ],
    "communication": [
      "Not explaining why z-index matters for delete",
      "Skipping redo_stack clearing explanation"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "All 6 operations create commands",
      "redo_stack cleared on new operation",
      "DeleteShapeCmd stores z_index",
      "Empty stack checks in undo/redo"
    ],
    "quick_code_review": [
      "Command ABC/interface defined",
      "get_position() added to Shape",
      "Consistent naming with Part 3"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Undo/redo stack size limits",
      "Command batching for grouped operations",
      "Persistence of undo history"
    ],
    "why_not_in_interview": "Focus on core Command Pattern; mention these verbally",
    "how_to_mention": "Say: 'In production, I'd add a max undo stack size to prevent memory issues.'"
  },
  "generated_at": "2026-01-19T04:40:41.789954",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}