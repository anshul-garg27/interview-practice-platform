{
  "problem_title": "Process Scheduling on Processors",
  "difficulty": "hard",
  "category": "DSA/Binary Search",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **Binary Search on Answer** problem combined with **Greedy Feasibility Checking**. The key signal is the optimization question ('find minimum time') with a feasibility constraint. When I see 'find minimum X such that constraint Y is satisfied', I immediately think binary search.",
    "pattern_recognition": "Binary Search on Answer + Greedy Assignment + Sorting. Similar to LC 2141 (Maximum Running Time), LC 1482 (Minimum Days for Bouquets), and Meeting Rooms II style problems.",
    "key_constraints": [
      "1 \u2264 n, m \u2264 10\u2075 - Arrays can be large, need O(n log n) or better",
      "Values up to 10\u2079 - Can't use values as array indices, must use comparison-based algorithms",
      "Pause time formula: k processes = 2k-1 seconds - Critical for time calculation",
      "Capacity constraint: process must fit in processor - Creates assignment restrictions"
    ],
    "clarifying_questions": [
      "Can multiple processes run simultaneously on different processors? (Yes, parallelism allowed)",
      "Does the pause time apply between different processors? (No, only sequential on same processor)",
      "If a processor handles 0 processes, does it contribute to the answer? (No, only active processors count)",
      "Can we assume input arrays are non-empty? (Yes, constraints say n,m \u2265 1)",
      "Is there a preference between processors if multiple can handle the same process? (No, just need feasibility)"
    ],
    "edge_cases_to_consider": [
      "Largest process exceeds largest capacity \u2192 return -1",
      "More processes than processors \u00d7 slots \u2192 need more time",
      "All processes same size \u2192 distribution problem",
      "Single process, single processor \u2192 answer is 1",
      "Many small processes, few large-capacity processors \u2192 bottle on processor count"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Return minimum time to complete all processes",
        "how_met": "Binary search finds minimum T where feasibility check passes",
        "gotchas": [
          "Using greedy alone gives suboptimal results"
        ]
      },
      {
        "requirement": "Return -1 if any process cannot be assigned",
        "how_met": "Early check: if max(processSize) > max(capacity), return -1",
        "gotchas": [
          "Must check before binary search"
        ]
      },
      {
        "requirement": "Handle pause time between processes",
        "how_met": "Formula: k processes = 2k-1 seconds, so slots = (T+1)//2",
        "gotchas": [
          "Off-by-one in formula derivation"
        ]
      },
      {
        "requirement": "Capacity constraint enforcement",
        "how_met": "Greedy assignment only assigns process if cap >= size",
        "gotchas": [
          "Must sort both arrays descending"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "minTime overall",
        "target": "O((n+m) log n)",
        "achieved": "O((n+m) log n)",
        "why": "Binary search O(log n) \u00d7 feasibility O(n+m)"
      },
      {
        "operation": "Feasibility check",
        "target": "O(n+m)",
        "achieved": "O(n+m)",
        "why": "Single pass through both sorted arrays"
      },
      {
        "operation": "Sorting",
        "target": "O(n log n + m log m)",
        "achieved": "O(n log n + m log m)",
        "why": "Standard sorting for both arrays"
      }
    ],
    "non_goals": [
      "Tracking which process goes to which processor (only need feasibility)",
      "Optimizing for specific processor utilization"
    ]
  },
  "assumptions": [
    "Processes are indistinguishable beyond their size (no process IDs matter for assignment)",
    "Processors can start immediately at time 0",
    "Time is measured in discrete seconds",
    "A process of size S can run on ANY processor with capacity \u2265 S (not exactly S)"
  ],
  "tradeoffs": [
    {
      "decision": "Greedy assignment vs. optimal matching",
      "chosen": "Greedy with sorted arrays",
      "why": "Provably optimal for this problem due to sorting invariant",
      "alternative": "Hungarian algorithm / bipartite matching",
      "when_to_switch": "If processors had different costs or priorities"
    },
    {
      "decision": "Binary search range",
      "chosen": "[1, 2n-1]",
      "why": "Min is 1 (all parallel), max is 2n-1 (all sequential on one processor)",
      "alternative": "Tighter bounds based on processor count",
      "when_to_switch": "If answer typically near bounds, could compute tighter range"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "Separate feasibility check from search logic",
      "Sort once, use many times",
      "Binary search for monotonic properties"
    ],
    "why_this_design_scales": "The can_complete() function is modular and can be modified for variable execution times (Part 2) without changing binary search structure",
    "expected_followup_hooks": [
      "can_complete() would change for variable execution times",
      "Different cost functions",
      "Processor preferences or priorities"
    ],
    "invariants": [
      "Sorted descending order maintained",
      "Largest processes assigned to largest capable processors",
      "Feasibility is monotonic in time"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    PROCESS SCHEDULING SYSTEM                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  INPUT:                                                          \u2502\n\u2502  Processes: [4, 3, 2, 1]  (sizes, sorted desc)                  \u2502\n\u2502  Capacities: [4, 4, 1]    (sorted desc)                         \u2502\n\u2502                                                                  \u2502\n\u2502  TIME T=3: Each processor can handle (3+1)/2 = 2 processes      \u2502\n\u2502                                                                  \u2502\n\u2502  ASSIGNMENT (Greedy):                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502 Cap=4 Proc 1 \u2502  \u2502 Cap=4 Proc 2 \u2502  \u2502 Cap=1 Proc 3 \u2502           \u2502\n\u2502  \u2502   [4] [3]    \u2502  \u2502   [2] [1]    \u2502  \u2502   (empty)    \u2502           \u2502\n\u2502  \u2502 2 processes  \u2502  \u2502 2 processes  \u2502  \u2502 can't fit \u22652 \u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502        \u2193                  \u2193                                      \u2502\n\u2502     3 seconds          3 seconds                                 \u2502\n\u2502                                                                  \u2502\n\u2502  ANSWER: max(3, 3) = 3 seconds                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  STATE DURING ALGORITHM                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  After Sorting:                                              \u2502\n\u2502  processes = [4, 3, 2, 1]  (descending)                     \u2502\n\u2502  caps      = [4, 4, 1]     (descending)                     \u2502\n\u2502                                                              \u2502\n\u2502  Binary Search State:                                        \u2502\n\u2502  lo=1  \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  hi=7         \u2502\n\u2502                    mid=4                                     \u2502\n\u2502                      \u2502                                       \u2502\n\u2502              can_complete(4)? \u2713                             \u2502\n\u2502                      \u2193                                       \u2502\n\u2502  lo=1  \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  hi=4                                  \u2502\n\u2502           mid=2                                              \u2502\n\u2502             \u2502                                                \u2502\n\u2502     can_complete(2)? \u2717                                      \u2502\n\u2502             \u2193                                                \u2502\n\u2502        lo=3  \u2501\u2501\u2501  hi=4                                      \u2502\n\u2502           mid=3                                              \u2502\n\u2502             \u2502                                                \u2502\n\u2502     can_complete(3)? \u2713                                      \u2502\n\u2502             \u2193                                                \u2502\n\u2502        lo=3  \u2501  hi=3  \u2192  ANSWER: 3                          \u2502\n\u2502                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Sort both arrays descending",
        "visualization": "processes: [1,2,3,4] \u2192 [4,3,2,1]\ncaps: [4,4,1] \u2192 [4,4,1]",
        "key_point": "Sorting enables greedy assignment"
      },
      {
        "step": 2,
        "description": "Check impossibility",
        "visualization": "max(process)=4 \u2264 max(cap)=4 \u2713",
        "key_point": "Early exit if largest process can't fit"
      },
      {
        "step": 3,
        "description": "Binary search on time T",
        "visualization": "Search range: [1, 7]",
        "key_point": "Minimum 1s (all parallel), max 2n-1 (all sequential)"
      },
      {
        "step": 4,
        "description": "Feasibility check for mid=3",
        "visualization": "slots=(3+1)/2=2\nProc1: [4,3] \u2192 2 assigned\nProc2: [2,1] \u2192 2 assigned\nAll 4 done! \u2713",
        "key_point": "Greedy assigns largest processes to largest capable processors"
      },
      {
        "step": 5,
        "description": "Narrow search to find minimum",
        "visualization": "mid=2 fails, mid=3 succeeds \u2192 answer=3",
        "key_point": "Binary search converges to minimum feasible time"
      }
    ],
    "dry_run_table": "| Step | lo | hi | mid | slots | Can Complete? | Action |\n|------|----|----|-----|-------|---------------|--------|\n| 1 | 1 | 7 | 4 | 2 | Yes | hi = 4 |\n| 2 | 1 | 4 | 2 | 1 | No (only 3 slots for 4 processes) | lo = 3 |\n| 3 | 3 | 4 | 3 | 2 | Yes | hi = 3 |\n| 4 | 3 | 3 | - | - | Done | Return 3 |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'find minimum time' with constraints, I immediately think **binary search on answer** - this is a classic pattern",
      "The key insight is: if we can complete in time T, we can complete in time T+1, T+2, etc. This **monotonicity** enables binary search",
      "For the feasibility check, I need to determine: given time T, can I assign all processes? This is a **greedy assignment** problem",
      "The formula k processes = 2k-1 seconds tells me: in T seconds, max processes = (T+1)/2 per processor",
      "Sorting both arrays descending enables greedy: assign largest processes first to largest-capacity processors",
      "Why greedy works: if a process is too big for current processor, it's too big for ALL remaining processors (sorted order)",
      "Edge case: if max(processSize) > max(capacity), immediately return -1"
    ],
    "key_insight": "**Binary search converts an optimization problem into a decision problem.** Instead of asking 'what is the minimum time?', we ask 'can we finish in time T?' and binary search on T. The greedy feasibility check works because sorting ensures largest-first assignment without backtracking.",
    "why_this_works": "The greedy assignment is optimal because: (1) Sorting descending means we try to fit hard-to-place processes first, (2) If a process can't fit anywhere, more time won't help with capacity - it only helps with slots, (3) The feasibility function is monotonic in T, making binary search correct."
  },
  "approaches": [
    {
      "name": "Brute Force: Try All Times",
      "description": "Check every time from 1 to 2n-1 sequentially",
      "pseudocode": "for time = 1 to 2n-1:\n    if can_complete(time):\n        return time\nreturn -1",
      "time_complexity": "O(n \u00d7 (n + m)) - Linear search \u00d7 feasibility check",
      "space_complexity": "O(n + m) for sorted arrays",
      "pros": [
        "Simple to implement",
        "Easy to verify correctness"
      ],
      "cons": [
        "Too slow for n = 10^5",
        "Doesn't exploit monotonicity"
      ],
      "when_to_use": "Only for very small inputs or debugging"
    },
    {
      "name": "Optimal: Binary Search + Greedy Feasibility",
      "description": "Binary search on time T, use greedy assignment to check feasibility",
      "pseudocode": "sort processes descending\nsort capacities descending\n\nif max(processes) > max(capacities):\n    return -1\n\nlo, hi = 1, 2n-1\nwhile lo < hi:\n    mid = (lo + hi) / 2\n    if can_complete(mid):\n        hi = mid\n    else:\n        lo = mid + 1\nreturn lo\n\ncan_complete(time):\n    slots = (time + 1) / 2\n    proc_idx = 0\n    for cap in capacities:\n        assigned = 0\n        while assigned < slots and proc_idx < n:\n            if processes[proc_idx] <= cap:\n                proc_idx++, assigned++\n            else:\n                break  # Too big for this and all remaining processors\n    return proc_idx == n",
      "time_complexity": "O((n + m) log n) - Binary search \u00d7 feasibility check",
      "space_complexity": "O(n + m) for sorted arrays (or O(1) if sorting in-place)",
      "pros": [
        "Optimal time complexity",
        "Clean separation of concerns"
      ],
      "cons": [
        "Must prove greedy correctness",
        "Slightly more complex"
      ],
      "key_insight": "Monotonicity of feasibility enables binary search; sorting enables greedy without backtracking"
    }
  ],
  "optimal_solution": {
    "name": "Binary Search on Answer with Greedy Feasibility Check",
    "explanation_md": "## Approach\n\nThe key insight is that this is a **binary search on answer** problem. Instead of directly computing the minimum time, we ask: **'Can we complete all processes in time T?'**\n\n### Why Binary Search Works\n\nIf we can complete in time T, we can certainly complete in time T+1 (more time = more slots per processor). This **monotonicity** means we can binary search.\n\n### Why Greedy Works\n\nBy sorting both arrays in **descending order**:\n1. We try to place the **largest processes first**\n2. These have the **fewest options** (fewer processors can handle them)\n3. If a process can't fit in the current processor, it can't fit in any **remaining** processors (smaller capacity)\n\n### Time Formula\n\n```\nk processes on one processor = k executions + (k-1) pauses = 2k - 1 seconds\n\nSolving for k given T seconds:\nT = 2k - 1\nk = (T + 1) / 2  (integer division)\n```",
    "data_structures": [
      {
        "structure": "Sorted int[] processes",
        "purpose": "Descending order enables greedy assignment (largest first)"
      },
      {
        "structure": "Sorted int[] capacities",
        "purpose": "Descending order ensures largest-capacity processors tried first"
      },
      {
        "structure": "Two pointers: proc_idx, assigned",
        "purpose": "Track assignment progress without extra space"
      }
    ],
    "algorithm_steps": [
      "1. **Sort** both arrays in descending order",
      "2. **Early exit**: If max(process) > max(capacity), return -1",
      "3. **Binary search** on time T in range [1, 2n-1]",
      "4. For each mid, run **can_complete(mid)** feasibility check",
      "5. In can_complete: calculate slots = (T+1)/2 per processor",
      "6. **Greedy assignment**: iterate processors, assign processes while cap >= size",
      "7. Return True if all processes assigned, else False",
      "8. **Narrow search** based on feasibility result"
    ],
    "why_decimal": "N/A - This problem uses integer arithmetic only"
  },
  "solution_python_lines": [
    "from typing import List",
    "",
    "class Solution:",
    "    def min_time(self, process_size: List[int], capacity: List[int]) -> int:",
    "        \"\"\"",
    "        Find minimum time to execute all processes.",
    "        ",
    "        Approach: Binary search on time T, greedy feasibility check.",
    "        Key: k processes = 2k-1 seconds, so slots = (T+1)//2",
    "        \"\"\"",
    "        # Sort descending for greedy assignment",
    "        processes = sorted(process_size, reverse=True)",
    "        caps = sorted(capacity, reverse=True)",
    "        ",
    "        n, m = len(processes), len(caps)",
    "        ",
    "        # Early exit: largest process must fit somewhere",
    "        if processes[0] > caps[0]:",
    "            return -1",
    "        ",
    "        def can_complete(time: int) -> bool:",
    "            \"\"\"Check if all processes can complete in given time.\"\"\"",
    "            slots = (time + 1) // 2  # Max processes per processor",
    "            proc_idx = 0  # Current process to assign",
    "            ",
    "            for cap in caps:",
    "                assigned = 0",
    "                while assigned < slots and proc_idx < n:",
    "                    if processes[proc_idx] <= cap:",
    "                        proc_idx += 1",
    "                        assigned += 1",
    "                    else:",
    "                        # Process too big for this and all remaining processors",
    "                        break",
    "                ",
    "                if proc_idx == n:",
    "                    return True",
    "            ",
    "            return proc_idx == n",
    "        ",
    "        # Binary search on time: [1, 2n-1]",
    "        lo, hi = 1, 2 * n - 1",
    "        ",
    "        while lo < hi:",
    "            mid = (lo + hi) // 2",
    "            if can_complete(mid):",
    "                hi = mid  # Try smaller time",
    "            else:",
    "                lo = mid + 1  # Need more time",
    "        ",
    "        return lo",
    "",
    "",
    "if __name__ == '__main__':",
    "    sol = Solution()",
    "    ",
    "    # Example 1: Parallel execution",
    "    print(\"Example 1:\", sol.min_time([2, 5, 3], [6, 2, 4]))",
    "    # Expected: 1 (all processes run in parallel)",
    "    ",
    "    # Example 2: Impossible",
    "    print(\"Example 2:\", sol.min_time([2, 5, 8], [6, 7, 4]))",
    "    # Expected: -1 (process 8 > max capacity 7)",
    "    ",
    "    # Example 3: Sequential needed",
    "    print(\"Example 3:\", sol.min_time([1, 2, 3, 4], [4, 4, 1]))",
    "    # Expected: 3 (each cap-4 processor handles 2 processes)",
    "    ",
    "    # Example 4: Many processes, few processors",
    "    print(\"Example 4:\", sol.min_time([1,1,1,1,1,1,1], [5, 5]))",
    "    # Expected: 7 (4+3 distribution = max(7,5) = 7)",
    "    ",
    "    # Edge case: Single process",
    "    print(\"Single:\", sol.min_time([5], [5]))",
    "    # Expected: 1",
    "    ",
    "    print(\"\\n\" + \"=\"*50)",
    "    print(\"All tests completed!\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class Solution {",
    "    /**",
    "     * Find minimum time to execute all processes.",
    "     * Approach: Binary search on time T, greedy feasibility check.",
    "     */",
    "    public int minTime(int[] processSize, int[] capacity) {",
    "        int n = processSize.length;",
    "        int m = capacity.length;",
    "        ",
    "        // Sort descending for greedy assignment",
    "        Integer[] processes = Arrays.stream(processSize).boxed().toArray(Integer[]::new);",
    "        Integer[] caps = Arrays.stream(capacity).boxed().toArray(Integer[]::new);",
    "        Arrays.sort(processes, Collections.reverseOrder());",
    "        Arrays.sort(caps, Collections.reverseOrder());",
    "        ",
    "        // Early exit: largest process must fit somewhere",
    "        if (processes[0] > caps[0]) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Binary search on time: [1, 2n-1]",
    "        int lo = 1, hi = 2 * n - 1;",
    "        ",
    "        while (lo < hi) {",
    "            int mid = (lo + hi) / 2;",
    "            if (canComplete(processes, caps, mid)) {",
    "                hi = mid;",
    "            } else {",
    "                lo = mid + 1;",
    "            }",
    "        }",
    "        ",
    "        return lo;",
    "    }",
    "    ",
    "    /**",
    "     * Check if all processes can complete in given time.",
    "     * Greedy: assign largest processes to largest capable processors.",
    "     */",
    "    private boolean canComplete(Integer[] processes, Integer[] caps, int time) {",
    "        int slots = (time + 1) / 2;  // Max processes per processor",
    "        int procIdx = 0;",
    "        int n = processes.length;",
    "        ",
    "        for (int cap : caps) {",
    "            int assigned = 0;",
    "            while (assigned < slots && procIdx < n) {",
    "                if (processes[procIdx] <= cap) {",
    "                    procIdx++;",
    "                    assigned++;",
    "                } else {",
    "                    break;  // Too big for this and remaining processors",
    "                }",
    "            }",
    "            if (procIdx == n) return true;",
    "        }",
    "        ",
    "        return procIdx == n;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        Solution sol = new Solution();",
    "        ",
    "        System.out.println(\"Example 1: \" + sol.minTime(",
    "            new int[]{2, 5, 3}, new int[]{6, 2, 4}));  // Expected: 1",
    "        ",
    "        System.out.println(\"Example 2: \" + sol.minTime(",
    "            new int[]{2, 5, 8}, new int[]{6, 7, 4}));  // Expected: -1",
    "        ",
    "        System.out.println(\"Example 3: \" + sol.minTime(",
    "            new int[]{1, 2, 3, 4}, new int[]{4, 4, 1}));  // Expected: 3",
    "        ",
    "        System.out.println(\"Example 4: \" + sol.minTime(",
    "            new int[]{1,1,1,1,1,1,1}, new int[]{5, 5}));  // Expected: 7",
    "        ",
    "        System.out.println(\"\\nAll tests completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-9",
      "section": "Imports and Method Signature",
      "explanation": "Standard imports. The method takes process sizes and capacities, returns minimum time or -1."
    },
    {
      "lines": "11-13",
      "section": "Sorting Setup",
      "explanation": "**Critical step**: Sort both arrays in descending order. This enables the greedy assignment to work correctly - we must try to place largest processes first."
    },
    {
      "lines": "17-18",
      "section": "Early Impossibility Check",
      "explanation": "If the largest process exceeds the largest capacity, it's impossible. Check this BEFORE binary search to avoid unnecessary work."
    },
    {
      "lines": "20-35",
      "section": "can_complete() Feasibility Check",
      "explanation": "The heart of the algorithm. Given time T, calculate slots = (T+1)//2. For each processor (largest first), greedily assign as many processes as fit. If a process is too big, break (all remaining processors are smaller). Return True if all processes assigned."
    },
    {
      "lines": "38-45",
      "section": "Binary Search on Answer",
      "explanation": "Search time T in [1, 2n-1]. If can_complete(mid) succeeds, try smaller (hi=mid). If fails, need more time (lo=mid+1). Loop terminates when lo==hi, which is the minimum feasible time."
    },
    {
      "lines": "48-67",
      "section": "Test Cases",
      "explanation": "Demonstrates all example cases: parallel execution (T=1), impossible assignment (-1), sequential needed (T=3), and many processes on few processors (T=7)."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test can_complete() alone with known T values. 2. Print slots calculation. 3. Trace assignment process with small examples. 4. Verify binary search converges correctly.",
    "what_to_print_or_assert": [
      "print(f'T={time}, slots={slots}')",
      "print(f'Assigning process {proc_idx} (size {processes[proc_idx]}) to cap {cap}')",
      "assert can_complete(answer) == True",
      "assert can_complete(answer - 1) == False  # For answer > 1"
    ],
    "common_failure_modes": [
      "Off-by-one in slots formula (should be (T+1)//2, not T//2)",
      "Forgetting to break when process too big",
      "Binary search bounds wrong (should be 2n-1, not 2n)",
      "Not sorting both arrays descending"
    ],
    "how_to_fix_fast": "1. Check slots formula with manual calculation. 2. Trace Example 3 by hand. 3. Verify sorting order. 4. Print state at each binary search iteration."
  },
  "complexity_analysis": {
    "time": {
      "sorting": {
        "complexity": "O(n log n + m log m)",
        "explanation": "Standard sorting for both arrays"
      },
      "binary_search": {
        "complexity": "O(log n)",
        "explanation": "Search range is [1, 2n-1] \u2192 O(log n) iterations"
      },
      "feasibility_check": {
        "complexity": "O(n + m)",
        "explanation": "Single pass through both sorted arrays with two pointers"
      },
      "overall": "O((n + m) log n) - Binary search \u00d7 feasibility check + sorting"
    },
    "space": {
      "complexity": "O(n + m)",
      "breakdown": "- Sorted copies of input arrays: O(n + m)\n- Recursion: O(1) (iterative approach)\n- No additional data structures needed",
      "note": "Can be O(1) extra space if sorting in-place and inputs are modifiable"
    },
    "can_we_do_better": "No - we need O(n log n) for sorting, and the binary search approach is optimal for this problem type."
  },
  "dry_run": {
    "example": "processSize=[1,2,3,4], capacity=[4,4,1]",
    "trace_table": "| Step | lo | hi | mid | slots | Assignment Progress | Result |\n|------|----|----|-----|-------|---------------------|--------|\n| Init | 1 | 7 | - | - | processes=[4,3,2,1], caps=[4,4,1] | - |\n| 1 | 1 | 7 | 4 | 2 | cap4: [4,3], cap4: [2,1], cap1: - | \u2713 all assigned |\n| 2 | 1 | 4 | 2 | 1 | cap4: [4], cap4: [3], cap1: can't fit 2 | \u2717 |\n| 3 | 3 | 4 | 3 | 2 | cap4: [4,3], cap4: [2,1] | \u2713 all assigned |\n| 4 | 3 | 3 | - | - | lo == hi | Return 3 |",
    "final_answer": "3 seconds"
  },
  "test_cases": [
    {
      "name": "Parallel Execution (Optimal)",
      "category": "Basic",
      "input": "processSize=[2,5,3], capacity=[6,2,4]",
      "expected": "1",
      "explanation": "Each process maps to one processor: 5\u21926, 3\u21924, 2\u21922. All run in parallel in 1 second."
    },
    {
      "name": "Impossible - Process Too Large",
      "category": "Edge Case",
      "input": "processSize=[2,5,8], capacity=[6,7,4]",
      "expected": "-1",
      "explanation": "Process 8 > max capacity 7. No valid assignment exists."
    },
    {
      "name": "Sequential Processing Required",
      "category": "Medium",
      "input": "processSize=[1,2,3,4], capacity=[4,4,1]",
      "expected": "3",
      "explanation": "4 processes, but only 2 useful processors (cap=1 can't handle sizes 2-4). Each handles 2: time = 2\u00d72-1 = 3."
    },
    {
      "name": "Many Processes, Few Processors",
      "category": "Hard",
      "input": "processSize=[1,1,1,1,1,1,1], capacity=[5,5]",
      "expected": "7",
      "explanation": "7 processes on 2 processors. Best split: 4+3. Time = max(2\u00d74-1, 2\u00d73-1) = max(7,5) = 7."
    },
    {
      "name": "Single Process",
      "category": "Edge Case",
      "input": "processSize=[5], capacity=[10]",
      "expected": "1",
      "explanation": "One process on one capable processor takes exactly 1 second."
    },
    {
      "name": "All Same Size",
      "category": "Edge Case",
      "input": "processSize=[5,5,5,5,5], capacity=[5,5]",
      "expected": "5",
      "explanation": "5 processes on 2 processors. Best split: 3+2. Time = max(5,3) = 5 seconds."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Wrong slots formula",
      "why_wrong": "Using T//2 instead of (T+1)//2. Example: T=3 should give slots=2, not 1.",
      "correct_approach": "slots = (time + 1) // 2",
      "code_wrong": "slots = time // 2  # Wrong! T=3 \u2192 1 slot",
      "code_correct": "slots = (time + 1) // 2  # Correct! T=3 \u2192 2 slots"
    },
    {
      "mistake": "Sorting in ascending order",
      "why_wrong": "Greedy assignment fails. Large processes might not get placed.",
      "correct_approach": "Sort BOTH arrays in DESCENDING order",
      "code_wrong": "processes = sorted(process_size)  # Ascending",
      "code_correct": "processes = sorted(process_size, reverse=True)  # Descending"
    },
    {
      "mistake": "Not breaking when process too big",
      "why_wrong": "Trying smaller processes when current one doesn't fit is incorrect - we sorted descending, so subsequent processes ARE smaller but the current large one is still unassigned.",
      "correct_approach": "Break immediately - if current process doesn't fit, it means we can't place it",
      "code_wrong": "if processes[proc_idx] <= cap:\n    # assign\nelse:\n    proc_idx += 1  # Skip to next - WRONG!",
      "code_correct": "if processes[proc_idx] <= cap:\n    # assign\nelse:\n    break  # This processor can't help anymore"
    },
    {
      "mistake": "Using greedy alone without binary search",
      "why_wrong": "Greedy tells us IF assignment works for given T, not WHAT T to use",
      "correct_approach": "Binary search to find minimum T, greedy to verify feasibility",
      "code_wrong": "# Directly try to assign without searching for optimal T",
      "code_correct": "# Binary search on T, use greedy as feasibility oracle"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for the problem. This looks like a process scheduling optimization problem. Before I code, let me clarify a few things and share my approach...",
    "clarifying_questions_to_ask": [
      "Does pause time apply only within a single processor, not across processors? (Yes)",
      "Can I modify the input arrays, or should I create copies? (Usually can modify)",
      "Should I optimize for time or space? (Time is typically priority)",
      "What's the expected input size? (Up to 10^5 - need efficient algorithm)"
    ],
    "what_to_mention_proactively": [
      "This is a binary search on answer problem - the feasibility function is monotonic",
      "I'll sort both arrays descending to enable greedy assignment",
      "Let me derive the time formula: k processes = 2k-1 seconds",
      "I'll check impossibility upfront before binary search"
    ],
    "communication_during_coding": [
      "Here's the sorting for greedy assignment...",
      "This can_complete function is the feasibility oracle...",
      "Notice I break early when a process is too big...",
      "Binary search narrows down to the minimum feasible time..."
    ],
    "if_stuck": [
      "Step back: What makes this problem hard? The optimization + constraint combination",
      "Key realization: Binary search converts optimization to decision",
      "Try a small example by hand to see the greedy pattern"
    ],
    "time_management": "0-5min: Clarify & understand | 5-10min: Explain approach | 10-25min: Code | 25-35min: Test & debug | 35-45min: Complexity analysis & follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Binary Search on Answer + Greedy Feasibility",
    "indicators": [
      "Find minimum/maximum X such that constraint Y",
      "Can we do it in time T?",
      "Optimization with monotonic feasibility"
    ],
    "similar_problems": [
      "LC 2141 - Maximum Running Time of N Computers (same pattern, different domain)",
      "LC 1482 - Minimum Days to Make m Bouquets (binary search + feasibility)",
      "LC 2071 - Maximum Number of Tasks (assignment with binary search)",
      "LC 875 - Koko Eating Bananas (classic binary search on answer)"
    ],
    "template": "1. Identify the answer space (min to max possible). 2. Write feasibility function can_do(X). 3. Binary search to find boundary. 4. Return first feasible or last infeasible + 1."
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 may add variable execution times per process. The greedy assignment would need modification - might need more sophisticated matching.",
    "part_3_hint": "Part 3 might involve rate limiting or resource constraints. Consider how the feasibility check would change.",
    "data_structure_evolution": "Part 1: Sorted arrays + greedy \u2192 Part 2: Might need priority queue or more complex matching \u2192 Part 3: Add rate limiting state"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. At first glance, this looks like a binary search on answer problem combined with greedy assignment. Let me think through the key insights...",
    "after_clarification": "Great, so to summarize: I need to find minimum time where all processes complete, each processor handles at most k processes in time 2k-1, and I need to respect capacity constraints. My approach will be binary search on time with a greedy feasibility check. Sound good?",
    "while_coding": [
      "I'm sorting descending so largest processes get assigned first...",
      "This feasibility check returns true if we can complete in time T...",
      "Notice the slots formula: (T+1)//2 comes from inverting 2k-1=T..."
    ],
    "after_coding": "Let me trace through Example 3 to verify: processSize=[1,2,3,4], capacity=[4,4,1]...",
    "when_stuck_verbatim": "Let me step back. The key constraint is that feasibility is monotonic in time - if we can finish in T, we can finish in T+1. This means binary search applies...",
    "after_mistake": "Good catch - I see the issue. The slots formula should be (T+1)//2, not T//2. Let me fix that...",
    "before_moving_on": "This handles Part 1 with O((n+m) log n) time complexity. The space is O(n+m) for sorted copies. Ready for Part 2?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Pattern recognition (binary search on answer)",
      "Clean algorithm design",
      "Ability to prove greedy correctness",
      "Code quality and testing instinct",
      "Communication clarity"
    ],
    "bonus_points": [
      "Immediately recognizing binary search on answer pattern",
      "Deriving the time formula correctly",
      "Explaining why greedy works without being asked",
      "Catching the descending sort requirement",
      "Testing with edge cases proactively"
    ],
    "red_flags": [
      "Trying pure greedy without binary search",
      "Wrong slots formula",
      "Ascending sort instead of descending",
      "Not checking impossibility upfront",
      "Silent coding without explanation"
    ],
    "what_differentiates_strong_candidates": "Strong candidates recognize the pattern immediately, explain WHY the greedy is correct (sorted order + monotonicity), and test their solution methodically. They treat the problem as a conversation, not a test."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, recognize binary search on answer pattern, clarify pause time formula",
    "by_10_min": "Explain full approach: sort \u2192 impossibility check \u2192 binary search \u2192 greedy feasibility",
    "by_20_min": "Core implementation complete, basic structure working",
    "by_30_min": "Full solution coded, tested with examples, complexity analyzed",
    "by_40_min": "Edge cases handled, ready for follow-up parts",
    "warning_signs": "If still confused about approach at 10 min, or debugging basic errors at 25 min, you're behind"
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Stay calm. Say: 'Let me trace through this... ah, I see the issue - the slots formula is off by one. Let me fix it.' Interviewers expect bugs; they evaluate your debugging process.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for reverse sort in Java, but I need to sort descending. Let me write it as a comparator...' This is fine.",
    "when_approach_is_wrong": "If greedy alone doesn't work: 'Actually, greedy gives a valid assignment but not the minimum time. I need to binary search on time and use greedy as a feasibility check.'",
    "when_completely_stuck": "Ask: 'Could you give me a hint about what approach works here?' Then build from there.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me finish the core algorithm and explain what edge cases I'd handle given more time.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "AI tools are allowed at Rippling. Use them for boilerplate and syntax, not for the core algorithm insight.",
    "what_to_do": [
      "Let AI autocomplete sort syntax",
      "Use for generating test cases",
      "Autocomplete obvious loop structures"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem for a solution",
      "Don't accept binary search bounds without verifying",
      "Don't let AI write the feasibility check logic"
    ],
    "how_to_demonstrate_understanding": "If AI suggests something, explain it: 'This sorts descending because we need to assign largest processes first to ensure they get capable processors.'",
    "expectation_adjustment": "With AI, you should complete faster. If you're slower with AI than without, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately saying 'This is binary search on answer' in first minute",
      "Deriving slots = (T+1)//2 unprompted",
      "Explaining greedy correctness: 'Sorted descending means if current doesn't fit, all remaining processors are smaller'",
      "Drawing ASCII timeline diagram before coding"
    ],
    "subtle_signals_of_experience": [
      "Checking impossibility before binary search",
      "Using lo < hi (not <=) correctly",
      "Recognizing why the greedy break is correct",
      "Testing with Example 3 (the non-trivial one)"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining approach",
      "Getting defensive about bugs",
      "Not asking any clarifying questions",
      "Silent for >30 seconds"
    ],
    "technical": [
      "Using wrong slots formula (T//2 vs (T+1)//2)",
      "Sorting ascending instead of descending",
      "Using <= in binary search when should be <",
      "Not handling -1 case"
    ],
    "communication": [
      "Not explaining WHY greedy works",
      "Over-complicating the solution",
      "Not summarizing complexity at end"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I handle the -1 case (impossible)?",
      "Did I sort BOTH arrays descending?",
      "Is my slots formula correct: (T+1)//2?",
      "Did I trace through at least one non-trivial example?",
      "Did I state time complexity: O((n+m) log n)?",
      "Did I verify binary search converges correctly?"
    ],
    "quick_code_review": [
      "No magic numbers (use n, m variables)",
      "Clear variable names (proc_idx, not i)",
      "Proper break in feasibility loop",
      "Correct binary search bounds [1, 2n-1]"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation (non-empty arrays, positive values)",
      "Logging for debugging process assignments",
      "Metrics for optimization tracking",
      "Configuration for different scheduling strategies"
    ],
    "why_not_in_interview": "Keep interview code focused on the algorithm. Mention these verbally to show senior thinking.",
    "how_to_mention": "Say: 'In production, I'd add input validation and logging, but for the interview I'll focus on the core algorithm.'"
  },
  "generated_at": "2026-01-19T04:07:11.152451",
  "_meta": {
    "problem_id": "process_scheduling",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}