{
  "problem_title": "Corporate Expense Rules Engine - Part 2: Trip-Level Aggregation Rules",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 evaluated individual expenses in isolation. Part 2 requires aggregating expenses by trip_id and checking totals against limits. This fundamentally changes the evaluation model from 1:1 (one rule, one expense) to 1:N (one rule, many expenses grouped by trip).",
    "new_requirements": [
      "Group expenses by trip_id before evaluation",
      "TripTotalLimitRule: Sum ALL expenses per trip, check against limit",
      "ExpenseTypeAggregationRule: Sum expenses of specific type per trip, check against limit",
      "Return contributing_expenses list for transparency",
      "New violation type with trip_id instead of expense_id"
    ],
    "new_constraints": [
      "Aggregation rules see all expenses for a trip at once",
      "Violations must include all contributing expense_ids",
      "Must maintain separation between individual rules and aggregation rules"
    ],
    "key_insight": "Aggregation rules are fundamentally different from individual rules - they need the entire trip context. Design a separate AggregationRule interface and pre-group expenses by trip_id in O(n) before applying rules."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Group expenses by trip_id",
        "how_met": "HashMap in evaluate_aggregation_rules pre-groups in O(n)",
        "gotchas": [
          "Expenses without trip_id should be handled"
        ]
      },
      {
        "requirement": "TripTotalLimitRule sums all trip expenses",
        "how_met": "Iterates trip_expenses, sums amounts using Decimal",
        "gotchas": [
          "Use Decimal for monetary math"
        ]
      },
      {
        "requirement": "ExpenseTypeAggregationRule filters by type",
        "how_met": "Filters trip_expenses by expense_type before summing",
        "gotchas": [
          "Return None if no matching expenses"
        ]
      },
      {
        "requirement": "Return contributing_expenses",
        "how_met": "AggregationViolation dataclass includes List[str] of expense_ids",
        "gotchas": [
          "Include only relevant expenses for type rules"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "groupByTrip",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Single pass through expenses with HashMap"
      },
      {
        "operation": "evaluateAggregationRules",
        "target": "O(n + t*r)",
        "achieved": "O(n*r)",
        "why": "Each expense visited once per rule in worst case"
      }
    ],
    "non_goals": [
      "Combining individual and aggregation rules in single call",
      "Caching trip totals across rule evaluations"
    ]
  },
  "assumptions": [
    "Expenses may or may not have trip_id field - expenses without trip_id are skipped",
    "Empty trip_id string is treated as 'no trip'",
    "Contributing expenses should be in order they appear in input",
    "Aggregation violations are separate from individual violations (different types)"
  ],
  "tradeoffs": [
    {
      "decision": "Separate AggregationRule interface vs reusing Rule",
      "chosen": "Separate interface",
      "why": "Different signature (operates on list of expenses), different return type (includes trip_id, contributing_expenses)",
      "alternative": "Overloaded evaluate method",
      "when_to_switch": "If we need polymorphic handling of both rule types"
    },
    {
      "decision": "Pre-group all expenses vs lazy grouping",
      "chosen": "Pre-group in HashMap",
      "why": "Simple, O(n) time, enables efficient rule evaluation",
      "alternative": "Stream-based grouping per rule",
      "when_to_switch": "If memory is extremely constrained"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Violation class from Part 1",
      "Rule interface from Part 1",
      "evaluate_rules method signature"
    ],
    "what_to_change": [
      "Add AggregationViolation class",
      "Add AggregationRule abstract class",
      "Add evaluate_aggregation_rules method"
    ],
    "interfaces_and_boundaries": "Clean separation: individual rules use Rule interface, aggregation rules use AggregationRule. Engine has two evaluate methods, one for each type.",
    "invariants": [
      "Trip grouping happens once before rule evaluation",
      "Each rule is stateless - same trip expenses always produce same result",
      "Contributing expenses list matches exactly which expenses contributed to violation"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 1):                    AFTER (Part 2):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Expense   \u2502\u2500\u2500\u2500\u25ba Rule \u2500\u2500\u2500\u25ba ?    \u2502   Expenses  \u2502\u2500\u2500\u2500\u25ba Group by trip_id\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     (1:1)          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n                                                            \u25bc\n                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                   \u2502 Trip T001: [E001, E002]     \u2502\n                                   \u2502 Trip T002: [E003]           \u2502\n                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                \u2502\n                                                \u25bc\n                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                   \u2502 AggregationRule.evaluate()  \u2502\n                                   \u2502 (trip_id, [expenses])       \u2502\n                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                \u2502\n                                                \u25bc\n                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                   \u2502 AggregationViolation        \u2502\n                                   \u2502 trip_id + contributing_ids  \u2502\n                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "algorithm_flow": "Step 1: expenses = [E001, E002, E003, ...]\n        \u2502\n        \u25bc\nStep 2: trips = {\n          'T001': [E001, E002],\n          'T002': [E003]\n        }\n        \u2502\n        \u25bc\nStep 3: For each trip:\n        \u2502\n        \u251c\u2500\u2500\u25ba TripTotalLimitRule:\n        \u2502    sum([50, 100]) = 150\n        \u2502    150 > 100? \u2192 Violation!\n        \u2502\n        \u2514\u2500\u2500\u25ba ExpenseTypeAggregationRule(meals):\n             filter by 'meals' \u2192 [E001]\n             sum([50]) = 50\n             50 > 200? \u2192 Pass"
  },
  "approaches": [
    {
      "name": "Naive Extension - Recompute grouping per rule",
      "description": "For each aggregation rule, iterate all expenses, group by trip_id, then evaluate",
      "time_complexity": "O(E * R) with high constant - regroups every time",
      "space_complexity": "O(E) for grouping per rule",
      "why_not_optimal": "Redundant grouping - we group expenses R times instead of once"
    },
    {
      "name": "Optimal Approach - Pre-group once",
      "description": "Group all expenses by trip_id in O(n), then pass each trip's expenses to each rule",
      "time_complexity": "O(E + T*R) where T is number of trips",
      "space_complexity": "O(E) for trip grouping HashMap",
      "key_insight": "Grouping is trip-independent, so do it once. Rules are stateless, so they only need their trip slice."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Separate Interface + Pre-Grouping\n\n**Key insight**: Aggregation rules fundamentally differ from individual rules:\n1. They operate on **lists of expenses** (per trip), not single expenses\n2. They return **trip-level violations** with multiple contributing expenses\n\n### Design\n\n1. **AggregationViolation** - New dataclass with `trip_id` and `contributing_expenses`\n2. **AggregationRule** - Abstract class with `evaluate(trip_id, trip_expenses)`\n3. **Pre-grouping** - HashMap groups expenses by trip_id in O(n)\n4. **Evaluation** - Each rule sees pre-grouped expenses, evaluates in O(expenses_per_trip)\n\n### Why This Works\n\n```\nTotal time = O(E) [grouping] + O(T*R*avg_trip_size) [evaluation]\n           = O(E) + O(E*R) = O(E*R)\n```\n\nBut with grouping done once, constant factors are much better than naive approach.",
    "data_structures": [
      {
        "structure": "Dict[str, List[Dict]]",
        "purpose": "Group expenses by trip_id for efficient per-trip access"
      },
      {
        "structure": "Decimal",
        "purpose": "Precise monetary arithmetic for aggregation sums"
      }
    ],
    "algorithm_steps": [
      "Step 1: Create empty HashMap for trips \u2192 expenses mapping",
      "Step 2: Iterate expenses, append each to its trip's list",
      "Step 3: For each (trip_id, trip_expenses) pair:",
      "Step 4:   For each aggregation rule:",
      "Step 5:     Call rule.evaluate(trip_id, trip_expenses)",
      "Step 6:     If violation returned, add to results",
      "Step 7: Return all violations"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass",
    "from decimal import Decimal",
    "from typing import List, Dict, Optional",
    "from collections import defaultdict",
    "",
    "",
    "@dataclass",
    "class Violation:",
    "    \"\"\"Immutable result when expense fails a rule.\"\"\"",
    "    expense_id: str",
    "    rule_name: str",
    "    reason: str",
    "",
    "",
    "@dataclass",
    "class AggregationViolation:",
    "    \"\"\"Trip-level violation with contributing expenses.\"\"\"",
    "    trip_id: str",
    "    rule_name: str",
    "    reason: str",
    "    contributing_expenses: List[str]",
    "",
    "",
    "class Rule(ABC):",
    "    \"\"\"Strategy interface - all rule types implement this.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        pass",
    "",
    "",
    "class AggregationRule(ABC):",
    "    \"\"\"Interface for rules that aggregate expenses by trip.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, trip_id: str, ",
    "                 trip_expenses: List[Dict[str, str]]) -> Optional[AggregationViolation]:",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        pass",
    "",
    "",
    "class BanRule(Rule):",
    "    \"\"\"Blocks expenses where field matches banned value.\"\"\"",
    "    ",
    "    def __init__(self, field: str, value: str):",
    "        self.field = field",
    "        self.banned_value = value",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        if expense.get(self.field) == self.banned_value:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.field} '{self.banned_value}' is not allowed\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'BanRule'",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"Caps individual expense at max_amount.\"\"\"",
    "    ",
    "    def __init__(self, max_amount: float):",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        amount = Decimal(expense['amount_usd'])",
    "        if amount > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"amount ${amount:.2f} exceeds maximum ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'MaxAmountRule'",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"Caps amount for specific vendor_type.\"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: float):",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        if expense.get('vendor_type') != self.vendor_type:",
    "            return None",
    "        amount = Decimal(expense['amount_usd'])",
    "        if amount > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.vendor_type} expense ${amount:.2f} exceeds limit ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'VendorTypeLimitRule'",
    "",
    "",
    "class TripTotalLimitRule(AggregationRule):",
    "    \"\"\"Caps total spending per trip across all expense types.\"\"\"",
    "    ",
    "    def __init__(self, max_trip_total: float):",
    "        self.max_trip_total = Decimal(str(max_trip_total))",
    "    ",
    "    def evaluate(self, trip_id: str,",
    "                 trip_expenses: List[Dict[str, str]]) -> Optional[AggregationViolation]:",
    "        total = sum(Decimal(e['amount_usd']) for e in trip_expenses)",
    "        if total > self.max_trip_total:",
    "            return AggregationViolation(",
    "                trip_id=trip_id,",
    "                rule_name=self.get_name(),",
    "                reason=f\"trip total ${total:.2f} exceeds limit ${self.max_trip_total:.2f}\",",
    "                contributing_expenses=[e['expense_id'] for e in trip_expenses]",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'TripTotalLimitRule'",
    "",
    "",
    "class ExpenseTypeAggregationRule(AggregationRule):",
    "    \"\"\"Caps total spending per trip for a specific expense type.\"\"\"",
    "    ",
    "    def __init__(self, expense_type: str, max_amount: float):",
    "        self.expense_type = expense_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, trip_id: str,",
    "                 trip_expenses: List[Dict[str, str]]) -> Optional[AggregationViolation]:",
    "        # Filter to only matching expense types",
    "        matching = [e for e in trip_expenses ",
    "                    if e.get('expense_type') == self.expense_type]",
    "        if not matching:",
    "            return None",
    "        ",
    "        total = sum(Decimal(e['amount_usd']) for e in matching)",
    "        if total > self.max_amount:",
    "            return AggregationViolation(",
    "                trip_id=trip_id,",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.expense_type} total ${total:.2f} exceeds limit ${self.max_amount:.2f}\",",
    "                contributing_expenses=[e['expense_id'] for e in matching]",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'ExpenseTypeAggregationRule'",
    "",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"Evaluates expenses against individual and aggregation rules.\"\"\"",
    "    ",
    "    def evaluate_rules(self, rules: List[Rule], ",
    "                       expenses: List[Dict[str, str]]) -> List[Violation]:",
    "        \"\"\"Evaluate individual expenses against rules.\"\"\"",
    "        violations = []",
    "        for expense in expenses:",
    "            for rule in rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "    ",
    "    def evaluate_aggregation_rules(",
    "            self, rules: List[AggregationRule],",
    "            expenses: List[Dict[str, str]]) -> List[AggregationViolation]:",
    "        \"\"\"",
    "        Evaluate trip-level aggregation rules.",
    "        Groups expenses by trip_id, then applies each rule to each trip.",
    "        \"\"\"",
    "        # Step 1: Group expenses by trip_id - O(n)",
    "        trips: Dict[str, List[Dict[str, str]]] = defaultdict(list)",
    "        for expense in expenses:",
    "            trip_id = expense.get('trip_id', '')",
    "            if trip_id:  # Skip expenses without trip_id",
    "                trips[trip_id].append(expense)",
    "        ",
    "        # Step 2: Evaluate each rule against each trip - O(t * r)",
    "        violations = []",
    "        for trip_id, trip_expenses in trips.items():",
    "            for rule in rules:",
    "                violation = rule.evaluate(trip_id, trip_expenses)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "",
    "",
    "if __name__ == '__main__':",
    "    engine = ExpenseRulesEngine()",
    "    ",
    "    # Test Case 1: Trip total exceeds limit",
    "    print('=' * 60)",
    "    print('TEST 1: Trip Total Limit')",
    "    print('=' * 60)",
    "    ",
    "    expenses1 = [",
    "        {'expense_id': 'E001', 'trip_id': 'T001', 'amount_usd': '150.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E002', 'trip_id': 'T001', 'amount_usd': '200.00',",
    "         'expense_type': 'lodging', 'vendor_type': 'hotel'},",
    "        {'expense_id': 'E003', 'trip_id': 'T002', 'amount_usd': '100.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'}",
    "    ]",
    "    ",
    "    agg_rules1 = [TripTotalLimitRule(300)]",
    "    violations1 = engine.evaluate_aggregation_rules(agg_rules1, expenses1)",
    "    ",
    "    for v in violations1:",
    "        print(f'[{v.trip_id}] {v.rule_name}: {v.reason}')",
    "        print(f'  Contributing: {v.contributing_expenses}')",
    "    # Expected: T001 violates (350 > 300), T002 passes (100 <= 300)",
    "    ",
    "    # Test Case 2: Expense type aggregation",
    "    print('\\n' + '=' * 60)",
    "    print('TEST 2: Expense Type Aggregation')",
    "    print('=' * 60)",
    "    ",
    "    expenses2 = [",
    "        {'expense_id': 'E001', 'trip_id': 'T001', 'amount_usd': '80.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E002', 'trip_id': 'T001', 'amount_usd': '150.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E003', 'trip_id': 'T001', 'amount_usd': '500.00',",
    "         'expense_type': 'lodging', 'vendor_type': 'hotel'}",
    "    ]",
    "    ",
    "    agg_rules2 = [ExpenseTypeAggregationRule('meals', 200)]",
    "    violations2 = engine.evaluate_aggregation_rules(agg_rules2, expenses2)",
    "    ",
    "    for v in violations2:",
    "        print(f'[{v.trip_id}] {v.rule_name}: {v.reason}')",
    "        print(f'  Contributing: {v.contributing_expenses}')",
    "    # Expected: meals total $230 exceeds $200, lodging not counted",
    "    ",
    "    # Test Case 3: Multiple rules, multiple trips",
    "    print('\\n' + '=' * 60)",
    "    print('TEST 3: Multiple Rules + Multiple Trips')",
    "    print('=' * 60)",
    "    ",
    "    expenses3 = [",
    "        {'expense_id': 'E001', 'trip_id': 'T001', 'amount_usd': '100.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E002', 'trip_id': 'T001', 'amount_usd': '100.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E003', 'trip_id': 'T002', 'amount_usd': '500.00',",
    "         'expense_type': 'lodging', 'vendor_type': 'hotel'}",
    "    ]",
    "    ",
    "    agg_rules3 = [",
    "        TripTotalLimitRule(400),",
    "        ExpenseTypeAggregationRule('meals', 150)",
    "    ]",
    "    violations3 = engine.evaluate_aggregation_rules(agg_rules3, expenses3)",
    "    ",
    "    for v in violations3:",
    "        print(f'[{v.trip_id}] {v.rule_name}: {v.reason}')",
    "        print(f'  Contributing: {v.contributing_expenses}')",
    "    # T001: meals=$200 > $150 (violates), total=$200 <= $400 (pass)",
    "    # T002: no meals (pass), total=$500 > $400 (violates)",
    "    ",
    "    # Test Case 4: Combined with Part 1 individual rules",
    "    print('\\n' + '=' * 60)",
    "    print('TEST 4: Individual + Aggregation Rules Together')",
    "    print('=' * 60)",
    "    ",
    "    individual_rules = [MaxAmountRule(400), BanRule('expense_type', 'entertainment')]",
    "    ind_violations = engine.evaluate_rules(individual_rules, expenses3)",
    "    agg_violations = engine.evaluate_aggregation_rules(agg_rules3, expenses3)",
    "    ",
    "    print('Individual violations:')",
    "    for v in ind_violations:",
    "        print(f'  [{v.expense_id}] {v.rule_name}: {v.reason}')",
    "    print('Aggregation violations:')",
    "    for v in agg_violations:",
    "        print(f'  [{v.trip_id}] {v.rule_name}: {v.reason}')"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "",
    "// Immutable violation result for individual expenses",
    "class Violation {",
    "    public final String expenseId;",
    "    public final String ruleName;",
    "    public final String reason;",
    "    ",
    "    public Violation(String expenseId, String ruleName, String reason) {",
    "        this.expenseId = expenseId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "    }",
    "}",
    "",
    "// Trip-level violation with contributing expenses",
    "class AggregationViolation {",
    "    public final String tripId;",
    "    public final String ruleName;",
    "    public final String reason;",
    "    public final List<String> contributingExpenses;",
    "    ",
    "    public AggregationViolation(String tripId, String ruleName, ",
    "                                 String reason, List<String> contributingExpenses) {",
    "        this.tripId = tripId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "        this.contributingExpenses = contributingExpenses;",
    "    }",
    "}",
    "",
    "// Strategy interface for individual expense rules",
    "interface Rule {",
    "    Optional<Violation> evaluate(Map<String, String> expense);",
    "    String getName();",
    "}",
    "",
    "// Strategy interface for trip-level aggregation rules",
    "interface AggregationRule {",
    "    Optional<AggregationViolation> evaluate(String tripId, ",
    "                                            List<Map<String, String>> tripExpenses);",
    "    String getName();",
    "}",
    "",
    "class BanRule implements Rule {",
    "    private final String field;",
    "    private final String bannedValue;",
    "    ",
    "    public BanRule(String field, String value) {",
    "        this.field = field;",
    "        this.bannedValue = value;",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (bannedValue.equals(expense.get(field))) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                String.format(\"%s '%s' is not allowed\", field, bannedValue)));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"BanRule\"; }",
    "}",
    "",
    "class MaxAmountRule implements Rule {",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public MaxAmountRule(double maxAmount) {",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "        if (amount.compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                String.format(\"amount $%.2f exceeds maximum $%.2f\", amount, maxAmount)));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"MaxAmountRule\"; }",
    "}",
    "",
    "class VendorTypeLimitRule implements Rule {",
    "    private final String vendorType;",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public VendorTypeLimitRule(String vendorType, double maxAmount) {",
    "        this.vendorType = vendorType;",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (!vendorType.equals(expense.get(\"vendor_type\"))) {",
    "            return Optional.empty();",
    "        }",
    "        BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "        if (amount.compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                String.format(\"%s expense $%.2f exceeds limit $%.2f\", ",
    "                              vendorType, amount, maxAmount)));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"VendorTypeLimitRule\"; }",
    "}",
    "",
    "class TripTotalLimitRule implements AggregationRule {",
    "    private final BigDecimal maxTripTotal;",
    "    ",
    "    public TripTotalLimitRule(double maxTripTotal) {",
    "        this.maxTripTotal = BigDecimal.valueOf(maxTripTotal);",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<AggregationViolation> evaluate(String tripId,",
    "                                    List<Map<String, String>> tripExpenses) {",
    "        BigDecimal total = tripExpenses.stream()",
    "            .map(e -> new BigDecimal(e.get(\"amount_usd\")))",
    "            .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "        ",
    "        if (total.compareTo(maxTripTotal) > 0) {",
    "            List<String> contributingIds = new ArrayList<>();",
    "            for (Map<String, String> e : tripExpenses) {",
    "                contributingIds.add(e.get(\"expense_id\"));",
    "            }",
    "            return Optional.of(new AggregationViolation(",
    "                tripId, getName(),",
    "                String.format(\"trip total $%.2f exceeds limit $%.2f\", total, maxTripTotal),",
    "                contributingIds));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"TripTotalLimitRule\"; }",
    "}",
    "",
    "class ExpenseTypeAggregationRule implements AggregationRule {",
    "    private final String expenseType;",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public ExpenseTypeAggregationRule(String expenseType, double maxAmount) {",
    "        this.expenseType = expenseType;",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<AggregationViolation> evaluate(String tripId,",
    "                                    List<Map<String, String>> tripExpenses) {",
    "        // Filter to matching expense type",
    "        List<Map<String, String>> matching = new ArrayList<>();",
    "        for (Map<String, String> e : tripExpenses) {",
    "            if (expenseType.equals(e.get(\"expense_type\"))) {",
    "                matching.add(e);",
    "            }",
    "        }",
    "        if (matching.isEmpty()) return Optional.empty();",
    "        ",
    "        BigDecimal total = matching.stream()",
    "            .map(e -> new BigDecimal(e.get(\"amount_usd\")))",
    "            .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "        ",
    "        if (total.compareTo(maxAmount) > 0) {",
    "            List<String> contributingIds = new ArrayList<>();",
    "            for (Map<String, String> e : matching) {",
    "                contributingIds.add(e.get(\"expense_id\"));",
    "            }",
    "            return Optional.of(new AggregationViolation(",
    "                tripId, getName(),",
    "                String.format(\"%s total $%.2f exceeds limit $%.2f\", ",
    "                              expenseType, total, maxAmount),",
    "                contributingIds));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"ExpenseTypeAggregationRule\"; }",
    "}",
    "",
    "public class ExpenseRulesEngine {",
    "    ",
    "    public List<Violation> evaluateRules(List<Rule> rules, ",
    "                                         List<Map<String, String>> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        for (Map<String, String> expense : expenses) {",
    "            for (Rule rule : rules) {",
    "                rule.evaluate(expense).ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "    ",
    "    public List<AggregationViolation> evaluateAggregationRules(",
    "            List<AggregationRule> rules,",
    "            List<Map<String, String>> expenses) {",
    "        // Step 1: Group expenses by trip_id - O(n)",
    "        Map<String, List<Map<String, String>>> trips = new HashMap<>();",
    "        for (Map<String, String> expense : expenses) {",
    "            String tripId = expense.get(\"trip_id\");",
    "            if (tripId != null && !tripId.isEmpty()) {",
    "                trips.computeIfAbsent(tripId, k -> new ArrayList<>()).add(expense);",
    "            }",
    "        }",
    "        ",
    "        // Step 2: Evaluate each rule against each trip - O(t * r)",
    "        List<AggregationViolation> violations = new ArrayList<>();",
    "        for (Map.Entry<String, List<Map<String, String>>> entry : trips.entrySet()) {",
    "            for (AggregationRule rule : rules) {",
    "                rule.evaluate(entry.getKey(), entry.getValue())",
    "                    .ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        ExpenseRulesEngine engine = new ExpenseRulesEngine();",
    "        ",
    "        // Test expenses",
    "        List<Map<String, String>> expenses = new ArrayList<>();",
    "        Map<String, String> e1 = new HashMap<>();",
    "        e1.put(\"expense_id\", \"E001\"); e1.put(\"trip_id\", \"T001\");",
    "        e1.put(\"amount_usd\", \"150.00\"); e1.put(\"expense_type\", \"meals\");",
    "        expenses.add(e1);",
    "        ",
    "        Map<String, String> e2 = new HashMap<>();",
    "        e2.put(\"expense_id\", \"E002\"); e2.put(\"trip_id\", \"T001\");",
    "        e2.put(\"amount_usd\", \"200.00\"); e2.put(\"expense_type\", \"lodging\");",
    "        expenses.add(e2);",
    "        ",
    "        Map<String, String> e3 = new HashMap<>();",
    "        e3.put(\"expense_id\", \"E003\"); e3.put(\"trip_id\", \"T002\");",
    "        e3.put(\"amount_usd\", \"100.00\"); e3.put(\"expense_type\", \"meals\");",
    "        expenses.add(e3);",
    "        ",
    "        // Test TripTotalLimitRule",
    "        List<AggregationRule> aggRules = Arrays.asList(",
    "            new TripTotalLimitRule(300)",
    "        );",
    "        ",
    "        System.out.println(\"AGGREGATION VIOLATION REPORT\");",
    "        List<AggregationViolation> violations = ",
    "            engine.evaluateAggregationRules(aggRules, expenses);",
    "        ",
    "        for (AggregationViolation v : violations) {",
    "            System.out.printf(\"[%s] %s: %s%n\", v.tripId, v.ruleName, v.reason);",
    "            System.out.printf(\"  Contributing: %s%n\", v.contributingExpenses);",
    "        }",
    "        // Expected: T001 total $350 exceeds limit $300",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-6",
      "explanation": "Imports - added defaultdict for cleaner grouping"
    },
    {
      "lines": "18-23",
      "explanation": "NEW: AggregationViolation dataclass with trip_id and contributing_expenses list"
    },
    {
      "lines": "35-45",
      "explanation": "NEW: AggregationRule abstract class - different interface than Rule, takes trip context"
    },
    {
      "lines": "100-116",
      "explanation": "NEW: TripTotalLimitRule - sums all expenses for a trip, returns all expense_ids as contributors"
    },
    {
      "lines": "119-141",
      "explanation": "NEW: ExpenseTypeAggregationRule - filters by type first, sums only matching, returns only matching as contributors"
    },
    {
      "lines": "155-170",
      "explanation": "NEW: evaluate_aggregation_rules - groups by trip_id in O(n), then applies each rule to each trip"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "evaluate_aggregation_rules": {
          "complexity": "O(E + T*R)",
          "explanation": "O(E) to group, O(T*R) to evaluate where T=trips, R=rules. Since expenses are distributed across trips, effectively O(E*R)"
        },
        "TripTotalLimitRule.evaluate": {
          "complexity": "O(n)",
          "explanation": "O(n) to sum amounts where n=expenses in trip"
        },
        "ExpenseTypeAggregationRule.evaluate": {
          "complexity": "O(n)",
          "explanation": "O(n) to filter and sum where n=expenses in trip"
        }
      },
      "overall_change": "Part 1 was O(E*R). Part 2 adds O(E*Ragg) for aggregation. Total: O(E*(R+Ragg))"
    },
    "space": {
      "additional_space": "O(E)",
      "explanation": "HashMap stores references to all expenses grouped by trip. No duplication of expense data."
    }
  },
  "dry_run": {
    "example_input": "expenses=[E001:T001:$150, E002:T001:$200, E003:T002:$100], rule=TripTotalLimitRule($300)",
    "steps": [
      {
        "step": 1,
        "action": "Group by trip_id",
        "state": "trips = {T001: [E001, E002], T002: [E003]}",
        "explanation": "Single pass creates HashMap"
      },
      {
        "step": 2,
        "action": "Evaluate T001",
        "state": "sum(150 + 200) = 350",
        "explanation": "350 > 300, violation!"
      },
      {
        "step": 3,
        "action": "Create violation for T001",
        "state": "AggregationViolation(T001, [E001, E002])",
        "explanation": "All expenses in trip are contributors"
      },
      {
        "step": 4,
        "action": "Evaluate T002",
        "state": "sum(100) = 100",
        "explanation": "100 <= 300, no violation"
      },
      {
        "step": 5,
        "action": "Return violations",
        "state": "[AggregationViolation(T001)]",
        "explanation": "Only T001 violated the rule"
      }
    ],
    "final_output": "[{trip_id: T001, rule: TripTotalLimitRule, reason: 'trip total $350.00 exceeds limit $300.00', contributing_expenses: [E001, E002]}]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single expense under limit \u2192 no violations",
      "Two expenses in same trip over limit \u2192 one violation with both"
    ],
    "likely_bugs": [
      "Forgetting to filter by expense_type in ExpenseTypeAggregationRule",
      "Including all expenses instead of matching ones as contributors",
      "Using float instead of Decimal for sums"
    ],
    "recommended_logs_or_asserts": [
      "assert total == sum of individual amounts",
      "log trips dict after grouping",
      "log contributing_expenses before creating violation"
    ],
    "how_to_localize": "1. Print trips dict to verify grouping. 2. Print total before comparison. 3. Verify contributing_expenses list contents."
  },
  "edge_cases": [
    {
      "case": "Empty expenses list",
      "handling": "Returns empty violations list - no trips to evaluate",
      "gotcha": "Don't crash on empty input"
    },
    {
      "case": "Expense without trip_id",
      "handling": "Skipped during grouping - only trip-based expenses matter for aggregation",
      "gotcha": "Check for empty/null trip_id"
    },
    {
      "case": "Trip exactly at limit ($300 total, $300 limit)",
      "handling": "Passes - we use > not >= for comparison",
      "gotcha": "Consistency with Part 1 semantics"
    },
    {
      "case": "No matching expense types",
      "handling": "ExpenseTypeAggregationRule returns None - no violation",
      "gotcha": "Must check if matching list is empty before summing"
    },
    {
      "case": "Single expense violates trip limit",
      "handling": "Works fine - list of 1 is valid",
      "gotcha": "Don't special-case single expenses"
    }
  ],
  "test_cases": [
    {
      "name": "Trip total exceeds limit",
      "input": "expenses=[E001:T001:$150, E002:T001:$200], rule=TripTotalLimitRule($300)",
      "expected": "[AggregationViolation(T001, $350 > $300, [E001, E002])]",
      "explanation": "Combined $350 exceeds $300 limit"
    },
    {
      "name": "Type aggregation - only meals counted",
      "input": "expenses=[E001:T001:$80:meals, E002:T001:$150:meals, E003:T001:$500:lodging], rule=ExpenseTypeAggregationRule(meals, $200)",
      "expected": "[AggregationViolation(T001, meals $230 > $200, [E001, E002])]",
      "explanation": "Lodging not included in sum or contributors"
    },
    {
      "name": "Multiple trips - only one violates",
      "input": "expenses=[E001:T001:$350, E002:T002:$100], rule=TripTotalLimitRule($300)",
      "expected": "[AggregationViolation(T001, $350 > $300, [E001])]",
      "explanation": "T002 under limit, no violation"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Including ALL trip expenses as contributors for type-based rules",
      "why_wrong": "Only expenses of the matching type should be listed as contributors",
      "correct_approach": "Filter expenses by type BEFORE creating contributor list",
      "code_example_wrong": "contributing_expenses=[e['expense_id'] for e in trip_expenses]",
      "code_example_correct": "contributing_expenses=[e['expense_id'] for e in matching]"
    },
    {
      "mistake": "Using the same Violation class for aggregation rules",
      "why_wrong": "Aggregation violations have trip_id and multiple contributors, not single expense_id",
      "correct_approach": "Create separate AggregationViolation class",
      "code_example_wrong": "return Violation(expense_id=trip_expenses[0]['expense_id'], ...)",
      "code_example_correct": "return AggregationViolation(trip_id=trip_id, contributing_expenses=[...])"
    },
    {
      "mistake": "Re-grouping expenses for each rule",
      "why_wrong": "Wasteful - O(E) work repeated R times",
      "correct_approach": "Group once before rule loop",
      "code_example_wrong": "for rule in rules: trips = group_by_trip(expenses); ...",
      "code_example_correct": "trips = group_by_trip(expenses); for trip in trips: for rule in rules: ..."
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining WHY aggregation needs a different interface - individual rules can't 'see' other expenses. Draw the grouping diagram. Then explain the pre-grouping optimization.",
    "what_to_mention": [
      "Separate interface for fundamentally different evaluation model",
      "Pre-group in O(n) for efficiency",
      "Contributing expenses for auditability",
      "Decimal for monetary precision"
    ],
    "time_allocation": "2 min understand, 3 min design discussion, 5 min implement, 2 min test",
    "if_stuck": [
      "Think about what information an aggregation rule needs that an individual rule doesn't",
      "How would you efficiently access all expenses for a trip?",
      "What should the violation contain for debugging?"
    ]
  },
  "connection_to_next_part": "Part 3 could add: time-window rules (spending per day), rolling aggregations, or composite rules that combine individual and aggregation checks. The clean separation of interfaces makes this extensible.",
  "communication_script": {
    "transition_from_previous": "Part 1 handles individual expense validation. For Part 2, I need to add trip-level aggregation which is fundamentally different - rules need to see ALL expenses for a trip, not just one.",
    "explaining_changes": "The key insight is that aggregation rules have a different interface - they take (trip_id, list_of_expenses) instead of a single expense. I'll create a separate AggregationRule abstract class and a new evaluate_aggregation_rules method.",
    "while_extending_code": [
      "First, let me add the AggregationViolation dataclass with trip_id and contributing_expenses...",
      "Now the AggregationRule interface that takes trip context...",
      "The engine method pre-groups by trip_id for O(n) efficiency..."
    ],
    "after_completing": "This now handles trip-level aggregation with O(E) grouping plus O(T*R) evaluation. Part 1 rules still work unchanged. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "10-12 minutes for this part",
    "by_2_min": "Understand that aggregation needs different interface - operates on expense groups",
    "by_5_min": "Have AggregationRule interface and AggregationViolation designed, starting implementation",
    "by_10_min": "Both rule types implemented, testing with examples",
    "warning_signs": "If spending >3 min debating whether to reuse Rule interface, just decide and move on"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 1 rules are independent - Part 2 additions should not affect them. If Part 1 has bugs, mention it but focus on Part 2 implementation.",
    "if_new_requirement_unclear": "Ask: 'For contributing_expenses, should ExpenseTypeAggregationRule include all trip expenses or only the ones of the matching type?'",
    "if_running_behind": "Implement TripTotalLimitRule first (simpler), then ExpenseTypeAggregationRule. The engine method is critical - don't skip it."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing that aggregation needs a different interface",
      "Pre-grouping optimization without being prompted",
      "Including contributing_expenses for auditability",
      "Mentioning that this pattern (group-then-evaluate) is common in analytics"
    ]
  },
  "pattern_recognition": {
    "pattern": "Group-Aggregate-Filter (similar to SQL GROUP BY)",
    "indicators": [
      "'sum of all expenses for a trip'",
      "'total spending per trip'",
      "'aggregate across'"
    ],
    "similar_problems": [
      "LC 1076 - Project Employees",
      "Any GROUP BY with HAVING clause",
      "MapReduce patterns"
    ],
    "template": "1. Group items by key (HashMap)\n2. Aggregate each group (sum/count/max)\n3. Filter groups by condition\n4. Return results"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'sum of all expenses for a trip', I immediately think grouping by trip_id",
      "why": "This is a classic GROUP BY pattern"
    },
    {
      "step": 2,
      "thought": "Individual rules can't do this - they only see one expense",
      "why": "Fundamental interface mismatch"
    },
    {
      "step": 3,
      "thought": "Need a new interface that takes the whole group at once",
      "why": "Aggregation requires full context"
    },
    {
      "step": 4,
      "thought": "Pre-group all expenses in O(n) for efficiency",
      "why": "Don't want to re-scan for each rule"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you identify when existing abstractions don't fit?",
      "Do you design clean interfaces?",
      "Can you handle the group-by pattern efficiently?"
    ],
    "bonus_points": [
      "Clean separation between Rule and AggregationRule",
      "Efficient pre-grouping",
      "Including contributing_expenses without prompting"
    ],
    "red_flags": [
      "Trying to force-fit aggregation into existing Rule interface",
      "Re-grouping for each rule",
      "Forgetting contributing_expenses"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for boilerplate dataclass generation",
      "Let it help with defaultdict syntax"
    ],
    "what_not_to_do": [
      "Don't let AI generate a single Rule interface that tries to handle both cases",
      "Verify the grouping logic yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code before explaining the interface difference",
      "Not asking about edge cases like missing trip_id"
    ],
    "technical": [
      "Using float for monetary sums",
      "Modifying the Rule interface to accommodate aggregation"
    ],
    "communication": [
      "Not explaining WHY a separate interface is needed",
      "Forgetting to test both rule types"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I group expenses by trip_id efficiently (O(n))?",
      "Does AggregationViolation include trip_id and contributing_expenses?",
      "Does ExpenseTypeAggregationRule filter expenses before summing?",
      "Did I test with the provided examples?"
    ],
    "quick_code_review": [
      "Using Decimal for all monetary operations",
      "AggregationRule is separate from Rule",
      "evaluate_aggregation_rules method exists on engine"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Caching trip totals if same trips evaluated with multiple rules",
      "Streaming support for very large expense lists",
      "Parallel evaluation of rules per trip"
    ],
    "why_not_in_interview": "Focus on correct interface design and algorithm. Mention optimizations verbally.",
    "how_to_mention": "Say: 'In production, I might cache trip totals to avoid recomputing for each rule, but for interview simplicity I'm keeping it straightforward.'"
  },
  "generated_at": "2026-01-19T04:21:50.534764",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}