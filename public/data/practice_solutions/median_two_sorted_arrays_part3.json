{
  "problem_title": "Median of Two Sorted Arrays - Part 3: Median of K Sorted Arrays",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "We extend from 2 sorted arrays to K sorted arrays. The partition-based binary search from Part 1 doesn't generalize well to K arrays, so we need a fundamentally different approach: K-way merge using a min heap.",
    "new_requirements": [
      "Handle arbitrary number K of sorted arrays",
      "Find median of all elements combined efficiently",
      "Handle empty arrays within the input"
    ],
    "new_constraints": [
      "K can be large (potentially hundreds of arrays)",
      "Total elements N across all arrays can be large",
      "Individual arrays can be empty"
    ],
    "key_insight": "Use a min heap to perform K-way merge, extracting elements in sorted order. We only need to extract N/2 + 1 elements to find the median - we don't need to merge everything."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Find median of K sorted arrays",
        "how_met": "K-way merge with min heap extracts elements in sorted order until median position",
        "gotchas": [
          "Must handle both odd and even total counts differently"
        ]
      },
      {
        "requirement": "Handle empty arrays",
        "how_met": "Filter out empty arrays before processing, check for all-empty edge case",
        "gotchas": [
          "Null arrays in Java need separate check from length-0 arrays"
        ]
      },
      {
        "requirement": "Efficient for large K",
        "how_met": "Min heap maintains O(log K) per extraction, not O(K)",
        "gotchas": [
          "Don't use linear scan to find minimum each time"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "findMedianOfKArrays",
        "target": "O(N log K)",
        "achieved": "O(N log K)",
        "why": "Extract N/2 elements, each extraction is O(log K) for heap operations"
      }
    ],
    "non_goals": [
      "Handling streaming/online additions",
      "Modifying the original arrays"
    ]
  },
  "assumptions": [
    "Each individual array is already sorted in non-decreasing order",
    "Arrays contain integers (matching Part 1 and Part 2)",
    "At least one array is non-empty (or return 0.0 for edge case)",
    "No duplicate handling needed beyond standard median calculation"
  ],
  "tradeoffs": [
    {
      "decision": "Heap approach vs Binary search on value",
      "chosen": "Heap approach",
      "why": "More intuitive, handles duplicates naturally, exact O(N log K) vs potentially O(K * N * log(range)) for binary search on value",
      "alternative": "Binary search on answer value",
      "when_to_switch": "If arrays are very long but total distinct values small, or if memory is extremely constrained"
    },
    {
      "decision": "Early termination vs Full merge",
      "chosen": "Early termination at N/2+1",
      "why": "Only need median position, not full sorted array",
      "alternative": "Merge all then index",
      "when_to_switch": "If you need multiple queries on the same data"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "findMedianSortedArrays signature and behavior",
      "findKthElement signature and behavior"
    ],
    "what_to_change": [
      "Add findMedianOfKArrays as new independent method"
    ],
    "interfaces_and_boundaries": "K-array method is self-contained; could internally use findKthElement if we generalized it to K arrays, but heap approach is cleaner",
    "invariants": [
      "Heap always contains at most K elements (one per non-exhausted array)",
      "Each extraction gives the next smallest element globally",
      "prev and curr track the two most recent extractions for even-count median"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2): Only handle 2 arrays\n  nums1: [1, 3, 5]    nums2: [2, 4, 6]\n  Use binary elimination: O(log k)\n\nAFTER (Part 3): Handle K arrays\n  arr0: [1, 5, 9]\n  arr1: [2, 6, 10]\n  arr2: [3, 7, 11]\n  Use min heap for K-way merge: O(N log K)\n```",
    "algorithm_flow": "```\nK-Way Merge with Min Heap:\n\nStep 0: Initialize heap with first element of each array\n        Heap: [(1,arr0), (2,arr1), (3,arr2)]\n\nStep 1: Extract min=1 from arr0, push arr0[1]=5\n        Heap: [(2,arr1), (3,arr2), (5,arr0)]\n        Extracted: [1]\n\nStep 2: Extract min=2 from arr1, push arr1[1]=6\n        Heap: [(3,arr2), (5,arr0), (6,arr1)]\n        Extracted: [1, 2]\n\nStep 3: Extract min=3 from arr2, push arr2[1]=7\n        Heap: [(5,arr0), (6,arr1), (7,arr2)]\n        Extracted: [1, 2, 3]\n\n... continue until position N/2 + 1 ...\n\nStep 5: curr=6, total=9 (odd) \u2192 return 6.0\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Merge All Then Find Median",
      "description": "Merge all K arrays into one sorted array, then find median by indexing",
      "time_complexity": "O(N log N) or O(N * K)",
      "space_complexity": "O(N)",
      "why_not_optimal": "Wastes time sorting/merging elements beyond median position. Also uses O(N) extra space to store merged array."
    },
    {
      "name": "Optimal Approach - K-Way Merge with Min Heap",
      "description": "Use min heap to track smallest current element across all arrays. Extract N/2 + 1 elements to find median without full merge.",
      "time_complexity": "O(N log K)",
      "space_complexity": "O(K)",
      "key_insight": "Heap maintains the 'frontier' of K arrays. Each extraction gives next smallest element globally. Stop at median position."
    },
    {
      "name": "Alternative - Binary Search on Value",
      "description": "Binary search on answer value, counting elements <= mid in each array",
      "time_complexity": "O(K * log(N) * log(max-min))",
      "space_complexity": "O(1)",
      "key_insight": "Elegant but tricky edge cases for finding exact median value when it must exist in the arrays"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## K-Way Merge with Min Heap\n\nThe key insight is that we don't need to fully merge all arrays - we only need to find the **median position**.\n\n### Algorithm:\n1. **Initialize heap** with `(value, array_index, element_index)` for first element of each non-empty array\n2. **Extract minimum** repeatedly - each extraction gives the next smallest element globally\n3. **Track two values** (`prev` and `curr`) for handling even-length median\n4. **Stop early** at position `N/2 + 1` - we have enough info for median\n5. **Return** `curr` for odd total, `(prev + curr) / 2` for even total\n\n### Why O(N log K):\n- We extract at most `N/2 + 1` elements\n- Each heap operation (pop + push) is `O(log K)` where K = number of arrays\n- Total: `O(N * log K)`",
    "data_structures": [
      {
        "structure": "Min Heap / Priority Queue",
        "purpose": "Efficiently track and extract the minimum across K frontiers in O(log K)"
      }
    ],
    "algorithm_steps": [
      "Step 1: Filter out empty arrays and calculate total element count N",
      "Step 2: Initialize min heap with (value, array_idx, element_idx) for first element of each array",
      "Step 3: Loop N/2 + 1 times, each iteration: extract min, update prev/curr, push next element from same array",
      "Step 4: After loop, return curr if odd total, else (prev + curr) / 2"
    ]
  },
  "solution_python_lines": [
    "import heapq",
    "from typing import List",
    "",
    "class Solution:",
    "    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:",
    "        \"\"\"Part 1: Median of two sorted arrays using binary search partitioning.\"\"\"",
    "        if len(nums1) > len(nums2):",
    "            nums1, nums2 = nums2, nums1",
    "        ",
    "        m, n = len(nums1), len(nums2)",
    "        left, right = 0, m",
    "        half = (m + n + 1) // 2",
    "        ",
    "        while left <= right:",
    "            i = (left + right) // 2",
    "            j = half - i",
    "            ",
    "            maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]",
    "            minRight1 = float('inf') if i == m else nums1[i]",
    "            maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]",
    "            minRight2 = float('inf') if j == n else nums2[j]",
    "            ",
    "            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:",
    "                if (m + n) % 2 == 1:",
    "                    return float(max(maxLeft1, maxLeft2))",
    "                else:",
    "                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2",
    "            elif maxLeft1 > minRight2:",
    "                right = i - 1",
    "            else:",
    "                left = i + 1",
    "        return 0.0",
    "    ",
    "    def findKthElement(self, nums1: List[int], nums2: List[int], k: int) -> int:",
    "        \"\"\"Part 2: Find k-th smallest element using binary elimination.\"\"\"",
    "        idx1, idx2 = 0, 0",
    "        m, n = len(nums1), len(nums2)",
    "        ",
    "        while True:",
    "            if idx1 == m:",
    "                return nums2[idx2 + k - 1]",
    "            if idx2 == n:",
    "                return nums1[idx1 + k - 1]",
    "            if k == 1:",
    "                return min(nums1[idx1], nums2[idx2])",
    "            ",
    "            half = k // 2",
    "            newIdx1 = min(idx1 + half, m) - 1",
    "            newIdx2 = min(idx2 + half, n) - 1",
    "            ",
    "            if nums1[newIdx1] <= nums2[newIdx2]:",
    "                k -= (newIdx1 - idx1 + 1)",
    "                idx1 = newIdx1 + 1",
    "            else:",
    "                k -= (newIdx2 - idx2 + 1)",
    "                idx2 = newIdx2 + 1",
    "    ",
    "    def findMedianOfKArrays(self, arrays: List[List[int]]) -> float:",
    "        \"\"\"",
    "        Part 3: Find median of K sorted arrays using K-way merge with min heap.",
    "        Time: O(N log K) where N = total elements, K = number of arrays",
    "        Space: O(K) for the heap",
    "        ",
    "        Key insight: Extract elements in sorted order using min heap.",
    "        Stop at median position - no need for full merge.",
    "        \"\"\"",
    "        # Filter empty arrays and count total elements",
    "        arrays = [arr for arr in arrays if arr]",
    "        if not arrays:",
    "            return 0.0",
    "        ",
    "        total = sum(len(arr) for arr in arrays)",
    "        if total == 0:",
    "            return 0.0",
    "        ",
    "        # Initialize heap: (value, array_index, element_index)",
    "        heap = []",
    "        for i, arr in enumerate(arrays):",
    "            heapq.heappush(heap, (arr[0], i, 0))",
    "        ",
    "        # Extract elements until median position",
    "        prev, curr = 0, 0",
    "        for _ in range(total // 2 + 1):",
    "            prev = curr",
    "            val, arr_idx, elem_idx = heapq.heappop(heap)",
    "            curr = val",
    "            ",
    "            # Push next element from same array if exists",
    "            if elem_idx + 1 < len(arrays[arr_idx]):",
    "                next_val = arrays[arr_idx][elem_idx + 1]",
    "                heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))",
    "        ",
    "        # Return median based on odd/even total",
    "        if total % 2 == 1:",
    "            return float(curr)",
    "        else:",
    "            return (prev + curr) / 2.0",
    "",
    "",
    "if __name__ == '__main__':",
    "    sol = Solution()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"PART 3: Median of K Sorted Arrays\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Test 1: Basic odd total",
    "    arrays1 = [[1, 5, 9], [2, 6, 10], [3, 7, 11]]",
    "    print(f\"\\nTest 1: {arrays1}\")",
    "    print(f\"Merged: [1,2,3,5,6,7,9,10,11], median position 5\")",
    "    print(f\"Result: {sol.findMedianOfKArrays(arrays1)}\")",
    "    print(\"Expected: 6.0\")",
    "    ",
    "    # Test 2: Even total",
    "    arrays2 = [[1, 2], [3, 4], [5, 6], [7, 8]]",
    "    print(f\"\\nTest 2: {arrays2}\")",
    "    print(f\"Merged: [1,2,3,4,5,6,7,8], median = (4+5)/2\")",
    "    print(f\"Result: {sol.findMedianOfKArrays(arrays2)}\")",
    "    print(\"Expected: 4.5\")",
    "    ",
    "    # Test 3: Single array",
    "    arrays3 = [[1, 2, 3, 4, 5]]",
    "    print(f\"\\nTest 3: {arrays3}\")",
    "    print(f\"Result: {sol.findMedianOfKArrays(arrays3)}\")",
    "    print(\"Expected: 3.0\")",
    "    ",
    "    # Test 4: Arrays with empty",
    "    arrays4 = [[1, 3], [], [2, 4]]",
    "    print(f\"\\nTest 4: {arrays4}\")",
    "    print(f\"Result: {sol.findMedianOfKArrays(arrays4)}\")",
    "    print(\"Expected: 2.5\")",
    "    ",
    "    # Test 5: Verify Part 1 still works",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Verification: Part 1 & 2 still work\")",
    "    print(\"=\" * 60)",
    "    print(f\"Part 1 - Median of [1,3] and [2]: {sol.findMedianSortedArrays([1,3], [2])}\")",
    "    print(f\"Part 2 - 4th element of [1,3,5] and [2,4,6]: {sol.findKthElement([1,3,5], [2,4,6], 4)}\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class Solution {",
    "    /**",
    "     * Part 1: Median of two sorted arrays using binary search partitioning.",
    "     */",
    "    public double findMedianSortedArrays(int[] nums1, int[] nums2) {",
    "        if (nums1.length > nums2.length) {",
    "            int[] temp = nums1; nums1 = nums2; nums2 = temp;",
    "        }",
    "        ",
    "        int m = nums1.length, n = nums2.length;",
    "        int left = 0, right = m;",
    "        int half = (m + n + 1) / 2;",
    "        ",
    "        while (left <= right) {",
    "            int i = (left + right) / 2;",
    "            int j = half - i;",
    "            ",
    "            int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];",
    "            int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];",
    "            int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];",
    "            int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];",
    "            ",
    "            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {",
    "                if ((m + n) % 2 == 1) {",
    "                    return Math.max(maxLeft1, maxLeft2);",
    "                } else {",
    "                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;",
    "                }",
    "            } else if (maxLeft1 > minRight2) {",
    "                right = i - 1;",
    "            } else {",
    "                left = i + 1;",
    "            }",
    "        }",
    "        return 0.0;",
    "    }",
    "    ",
    "    /**",
    "     * Part 2: Find k-th smallest element using binary elimination.",
    "     */",
    "    public int findKthElement(int[] nums1, int[] nums2, int k) {",
    "        int idx1 = 0, idx2 = 0;",
    "        int m = nums1.length, n = nums2.length;",
    "        ",
    "        while (true) {",
    "            if (idx1 == m) return nums2[idx2 + k - 1];",
    "            if (idx2 == n) return nums1[idx1 + k - 1];",
    "            if (k == 1) return Math.min(nums1[idx1], nums2[idx2]);",
    "            ",
    "            int half = k / 2;",
    "            int newIdx1 = Math.min(idx1 + half, m) - 1;",
    "            int newIdx2 = Math.min(idx2 + half, n) - 1;",
    "            ",
    "            if (nums1[newIdx1] <= nums2[newIdx2]) {",
    "                k -= (newIdx1 - idx1 + 1);",
    "                idx1 = newIdx1 + 1;",
    "            } else {",
    "                k -= (newIdx2 - idx2 + 1);",
    "                idx2 = newIdx2 + 1;",
    "            }",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Part 3: Find median of K sorted arrays using K-way merge with min heap.",
    "     * Time: O(N log K), Space: O(K)",
    "     * ",
    "     * Key insight: Use heap to extract elements in sorted order.",
    "     * Stop at median position - no need for full merge.",
    "     */",
    "    public double findMedianOfKArrays(int[][] arrays) {",
    "        // Min heap: {value, array_index, element_index}",
    "        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);",
    "        int total = 0;",
    "        ",
    "        // Initialize heap with first element of each non-empty array",
    "        for (int i = 0; i < arrays.length; i++) {",
    "            if (arrays[i] != null && arrays[i].length > 0) {",
    "                heap.offer(new int[]{arrays[i][0], i, 0});",
    "                total += arrays[i].length;",
    "            }",
    "        }",
    "        ",
    "        if (total == 0) return 0.0;",
    "        ",
    "        // Extract elements until median position",
    "        int prev = 0, curr = 0;",
    "        for (int i = 0; i <= total / 2; i++) {",
    "            prev = curr;",
    "            int[] entry = heap.poll();",
    "            curr = entry[0];",
    "            int arrIdx = entry[1];",
    "            int elemIdx = entry[2];",
    "            ",
    "            // Push next element from same array if exists",
    "            if (elemIdx + 1 < arrays[arrIdx].length) {",
    "                heap.offer(new int[]{arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1});",
    "            }",
    "        }",
    "        ",
    "        // Return median based on odd/even total",
    "        if (total % 2 == 1) {",
    "            return (double) curr;",
    "        } else {",
    "            return (prev + curr) / 2.0;",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        Solution sol = new Solution();",
    "        ",
    "        System.out.println(\"============ PART 3: Median of K Arrays ============\");",
    "        ",
    "        // Test 1: Basic odd total",
    "        int[][] arrays1 = {{1, 5, 9}, {2, 6, 10}, {3, 7, 11}};",
    "        System.out.println(\"\\nTest 1: [[1,5,9], [2,6,10], [3,7,11]]\");",
    "        System.out.println(\"Result: \" + sol.findMedianOfKArrays(arrays1));",
    "        System.out.println(\"Expected: 6.0\");",
    "        ",
    "        // Test 2: Even total",
    "        int[][] arrays2 = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};",
    "        System.out.println(\"\\nTest 2: [[1,2], [3,4], [5,6], [7,8]]\");",
    "        System.out.println(\"Result: \" + sol.findMedianOfKArrays(arrays2));",
    "        System.out.println(\"Expected: 4.5\");",
    "        ",
    "        // Test 3: Single array",
    "        int[][] arrays3 = {{1, 2, 3, 4, 5}};",
    "        System.out.println(\"\\nTest 3: Single array\");",
    "        System.out.println(\"Result: \" + sol.findMedianOfKArrays(arrays3));",
    "        System.out.println(\"Expected: 3.0\");",
    "        ",
    "        // Verify Part 1 & 2 still work",
    "        System.out.println(\"\\n============ Verification ============\");",
    "        System.out.println(\"Part 1: \" + sol.findMedianSortedArrays(new int[]{1,3}, new int[]{2}));",
    "        System.out.println(\"Part 2: \" + sol.findKthElement(new int[]{1,3,5}, new int[]{2,4,6}, 4));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-3",
      "explanation": "Import heapq for min heap operations and List for type hints"
    },
    {
      "lines": "55-62",
      "explanation": "Method signature and docstring explaining the K-way merge approach with complexity"
    },
    {
      "lines": "64-68",
      "explanation": "Filter out empty arrays and handle edge case of no elements"
    },
    {
      "lines": "70-73",
      "explanation": "Initialize min heap with (value, array_idx, elem_idx) tuples for first element of each array"
    },
    {
      "lines": "75-83",
      "explanation": "Main loop: extract minimum N/2+1 times, tracking prev and curr for even-count median. Push next element from same array after each extraction."
    },
    {
      "lines": "85-89",
      "explanation": "Return curr for odd total (middle element), average of prev and curr for even total"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "findMedianOfKArrays": {
          "complexity": "O(N log K)",
          "explanation": "Extract N/2 + 1 elements, each extraction involves heap pop O(log K) and potentially heap push O(log K). K = number of arrays, N = total elements."
        }
      },
      "overall_change": "Part 1: O(log(min(m,n))), Part 2: O(log k), Part 3: O(N log K). Each part addresses different use cases."
    },
    "space": {
      "additional_space": "O(K)",
      "explanation": "Heap contains at most K elements (one frontier element per non-exhausted array). No additional storage for merged array."
    }
  },
  "dry_run": {
    "example_input": "arrays = [[1,5,9], [2,6,10], [3,7,11]]",
    "steps": [
      {
        "step": 1,
        "action": "Initialize",
        "state": "total=9, heap=[(1,0,0), (2,1,0), (3,2,0)]",
        "explanation": "First element from each array added to heap"
      },
      {
        "step": 2,
        "action": "Extract i=0",
        "state": "curr=1, heap=[(2,1,0), (3,2,0), (5,0,1)]",
        "explanation": "Pop (1,0,0), push arr0[1]=5"
      },
      {
        "step": 3,
        "action": "Extract i=1",
        "state": "prev=1, curr=2, heap=[(3,2,0), (5,0,1), (6,1,1)]",
        "explanation": "Pop (2,1,0), push arr1[1]=6"
      },
      {
        "step": 4,
        "action": "Extract i=2",
        "state": "prev=2, curr=3, heap=[(5,0,1), (6,1,1), (7,2,1)]",
        "explanation": "Pop (3,2,0), push arr2[1]=7"
      },
      {
        "step": 5,
        "action": "Extract i=3",
        "state": "prev=3, curr=5, heap=[(6,1,1), (7,2,1), (9,0,2)]",
        "explanation": "Pop (5,0,1), push arr0[2]=9"
      },
      {
        "step": 6,
        "action": "Extract i=4",
        "state": "prev=5, curr=6",
        "explanation": "Pop (6,1,1), this is the 5th element (median position for 9 elements)"
      }
    ],
    "final_output": "total=9 (odd), return curr=6.0"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single array [[1,2,3]] should return 2.0",
      "Two equal arrays [[1],[1]] should return 1.0"
    ],
    "likely_bugs": [
      "Off-by-one in loop count (should be total//2 + 1 iterations)",
      "Forgetting to track prev for even total",
      "Not filtering empty arrays"
    ],
    "recommended_logs_or_asserts": [
      "assert total > 0 before loop",
      "print heap state after each extraction for debugging"
    ],
    "how_to_localize": "Trace through with 3-element example. If median position wrong, check loop count. If wrong value, check heap operations."
  },
  "edge_cases": [
    {
      "case": "All arrays empty",
      "handling": "Filter returns empty list, return 0.0",
      "gotcha": "Check before calculating total"
    },
    {
      "case": "Single array",
      "handling": "Heap has one element, extracts normally",
      "gotcha": "Works correctly - no special case needed"
    },
    {
      "case": "Arrays of very different sizes",
      "handling": "Heap naturally handles - longer arrays contribute more extractions",
      "gotcha": "Don't assume equal sizes"
    },
    {
      "case": "Single element total",
      "handling": "total=1, loop runs once, returns that element",
      "gotcha": "total//2 + 1 = 1 iteration, correct"
    },
    {
      "case": "Two elements total (even)",
      "handling": "Extract both, return average",
      "gotcha": "prev gets first, curr gets second"
    }
  ],
  "test_cases": [
    {
      "name": "Basic odd total",
      "input": "[[1,5,9], [2,6,10], [3,7,11]]",
      "expected": "6.0",
      "explanation": "9 elements, median is 5th = 6"
    },
    {
      "name": "Even total",
      "input": "[[1,2], [3,4], [5,6], [7,8]]",
      "expected": "4.5",
      "explanation": "8 elements, median is (4+5)/2 = 4.5"
    },
    {
      "name": "Single array",
      "input": "[[1,2,3,4,5]]",
      "expected": "3.0",
      "explanation": "5 elements, median is 3rd = 3"
    },
    {
      "name": "With empty arrays",
      "input": "[[1,3], [], [2,4]]",
      "expected": "2.5",
      "explanation": "Empty array filtered, 4 elements, median = (2+3)/2 = 2.5"
    },
    {
      "name": "Many small arrays",
      "input": "[[1], [2], [3], [4], [5]]",
      "expected": "3.0",
      "explanation": "5 single-element arrays, median = 3"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Wrong loop iteration count",
      "why_wrong": "Using total//2 instead of total//2 + 1 misses the median element",
      "correct_approach": "Loop total//2 + 1 times to reach the correct position for both odd and even",
      "code_example_wrong": "for _ in range(total // 2):  # Wrong!",
      "code_example_correct": "for _ in range(total // 2 + 1):  # Correct"
    },
    {
      "mistake": "Not tracking prev for even case",
      "why_wrong": "Even median requires average of two middle elements",
      "correct_approach": "Always update prev = curr before extracting new curr",
      "code_example_wrong": "curr = heapq.heappop(heap)[0]",
      "code_example_correct": "prev = curr; curr = heapq.heappop(heap)[0]"
    },
    {
      "mistake": "Integer overflow in heap comparison (Java)",
      "why_wrong": "a[0] - b[0] can overflow for extreme values",
      "correct_approach": "Use Integer.compare() for safe comparison",
      "code_example_wrong": "(a, b) -> a[0] - b[0]",
      "code_example_correct": "(a, b) -> Integer.compare(a[0], b[0])"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining why Part 1's partition approach doesn't extend well to K arrays, then introduce the K-way merge concept. Draw the heap state for a small example.",
    "what_to_mention": [
      "K-way merge is a classic pattern (also used in external sorting)",
      "Early termination optimization - we only need N/2 + 1 extractions",
      "Space is O(K) not O(N) since we only store frontier elements"
    ],
    "time_allocation": "2 min understand + 3 min explain approach + 8 min implement + 2 min test",
    "if_stuck": [
      "Think about merge sort - how do you merge K sorted lists?",
      "What data structure gives you the minimum of K elements efficiently?",
      "Do you need to fully merge or can you stop early?"
    ]
  },
  "connection_to_next_part": "Part 4 might add streaming/online updates (adding new arrays or elements), which would require maintaining the heap state and tracking position differently. Could also extend to weighted median or percentile queries.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 handles finding any k-th element in two arrays. For Part 3, we need K arrays instead of 2. The partition approach from Part 1 doesn't generalize well, so I'll use a different technique - K-way merge with a min heap.",
    "explaining_changes": "The key insight is we can use a min heap to efficiently track the smallest element across all K arrays. By extracting elements one by one, we get them in sorted order without actually merging all arrays.",
    "while_extending_code": [
      "I'm adding findMedianOfKArrays as a new method - Parts 1 and 2 remain unchanged",
      "The heap stores tuples of (value, array_index, element_index) so we know which array to pull the next element from",
      "I'll stop at N/2 + 1 extractions since that's all we need for the median"
    ],
    "after_completing": "This handles K arrays in O(N log K) time with O(K) space. The existing methods are preserved. Want me to trace through an example?"
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Recognize that K-way merge with heap is the right approach. Understand we need N/2 + 1 extractions.",
    "by_5_min": "Explain the heap structure (value, arr_idx, elem_idx) and the extraction loop logic. Start coding.",
    "by_10_min": "Core implementation done. Handle edge cases (empty arrays, odd/even).",
    "warning_signs": "If struggling with heap syntax at 7 min, ask about API. If stuck on odd/even logic, trace through 3-element example."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 3 is independent of Parts 1 and 2 - they're kept separate. If a bug exists in previous parts, it won't affect this implementation.",
    "if_new_requirement_unclear": "Ask: 'For K arrays, should I assume all arrays are non-null, or handle null arrays as well? Are the arrays themselves sorted or do I need to sort them?'",
    "if_running_behind": "Focus on getting heap-based extraction working first. Handle even/odd median logic second. Empty array filtering can be mentioned verbally if short on time."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning this is the same pattern used in external merge sort",
      "Discussing the alternative binary search on value approach and its tradeoffs",
      "Noting that we could generalize to find any k-th element across K arrays",
      "Proactively mentioning the early termination optimization"
    ]
  },
  "pattern_recognition": {
    "pattern": "K-way Merge with Min Heap",
    "indicators": [
      "Multiple sorted sequences",
      "Need elements in global sorted order",
      "K sources to merge"
    ],
    "similar_problems": [
      "LC 23 - Merge K Sorted Lists",
      "LC 373 - Find K Pairs with Smallest Sums",
      "LC 378 - Kth Smallest Element in Sorted Matrix"
    ],
    "template": "```python\n# K-way merge template\nheap = [(arr[0], i, 0) for i, arr in enumerate(arrays) if arr]\nheapify(heap)\nwhile heap:\n    val, arr_i, elem_i = heappop(heap)\n    process(val)\n    if elem_i + 1 < len(arrays[arr_i]):\n        heappush(heap, (arrays[arr_i][elem_i+1], arr_i, elem_i+1))\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see K sorted arrays and need combined result, I immediately think K-way merge",
      "why": "Classic pattern - same as merging K sorted lists or external sorting"
    },
    {
      "step": 2,
      "thought": "For median specifically, I realize I don't need full merge",
      "why": "Median only needs position N/2 (and N/2+1 for even), so early termination saves work"
    },
    {
      "step": 3,
      "thought": "Min heap is the right data structure",
      "why": "O(log K) to find and remove minimum across K frontiers, vs O(K) for linear scan"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you recognize K-way merge pattern?",
      "Can you implement heap operations correctly?",
      "Do you handle odd/even median cases?",
      "Is your code clean and readable?"
    ],
    "bonus_points": [
      "Mentioning early termination",
      "Discussing alternative approaches",
      "Clean handling of empty arrays",
      "Correct complexity analysis"
    ],
    "red_flags": [
      "Using O(K) linear scan instead of heap",
      "Merging all elements then finding median",
      "Forgetting prev tracking for even case",
      "Off-by-one errors in loop count"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for heap syntax if unfamiliar with language",
      "Let it help with the tuple/array structure for heap entries"
    ],
    "what_not_to_do": [
      "Don't let AI choose merge-all approach",
      "Understand why we need prev and curr tracking",
      "Verify the loop count formula yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Immediately coding without explaining the K-way merge concept",
      "Not drawing/tracing through an example"
    ],
    "technical": [
      "Using linear scan O(K) to find minimum instead of heap",
      "Merging all N elements when we only need N/2",
      "Wrong loop iteration count"
    ],
    "communication": [
      "Not explaining why Part 1's approach doesn't generalize",
      "Forgetting to mention time/space complexity of the new method"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does the new method handle both odd and even total counts?",
      "Are empty arrays filtered correctly?",
      "Is the heap structured correctly with (value, arr_idx, elem_idx)?",
      "Did I trace through the example to verify correctness?"
    ],
    "quick_code_review": [
      "Loop runs total//2 + 1 times",
      "prev updated before curr in each iteration",
      "Next element pushed only if index in bounds",
      "Return float for consistency with Part 1"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Input validation for null/empty arrays",
      "Logging for debugging large inputs",
      "Consider streaming API for very large datasets"
    ],
    "why_not_in_interview": "Focus on core algorithm; validation and logging are secondary concerns",
    "how_to_mention": "Say: 'In production, I'd add validation for null arrays and possibly logging for debugging. I'd also consider a streaming API if the data is too large to fit in memory.'"
  },
  "generated_at": "2026-01-19T04:56:21.237186",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}