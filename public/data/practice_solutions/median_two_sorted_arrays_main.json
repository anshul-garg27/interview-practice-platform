{
  "problem_title": "Median of Two Sorted Arrays",
  "difficulty": "hard",
  "category": "DSA/Binary Search",
  "estimated_time": "35-45 minutes",
  "problem_analysis": {
    "first_impressions": "Classic hard binary search problem. The naive O(m+n) merge is easy, but O(log(min(m,n))) requires a fundamentally different approach - **partition-based binary search**. This tests deep understanding of binary search beyond simple 'find element in sorted array'.",
    "pattern_recognition": "Binary Search + Divide and Conquer + Array Partitioning. The key pattern is **binary search on answer space** - we're not searching for a specific element, but searching for the correct partition point.",
    "key_constraints": [
      "O(log(min(m,n))) time complexity - this FORCES binary search, merge is disqualified",
      "Arrays are already sorted - we can leverage this for binary search",
      "At least one array is non-empty - no need to handle both empty",
      "Precision within 10^-5 - floating point division is acceptable"
    ],
    "clarifying_questions": [
      "Can both arrays be empty? - No, at least one element exists; affects edge case handling",
      "Are there duplicate elements? - Yes, this doesn't affect our approach but good to clarify",
      "Are arrays sorted ascending? - Yes, confirmed; critical for binary search correctness",
      "Is the median always a valid number or could overflow occur? - Elements in [-10^6, 10^6], sum fits in double",
      "Should I optimize for space as well? - O(1) space is expected since we're not merging"
    ],
    "edge_cases_to_consider": [
      "One array is empty - median is simply the middle of the other array",
      "Arrays don't overlap (e.g., [1,2] and [3,4]) - partition at boundary",
      "Single element in one/both arrays - need careful boundary handling",
      "All elements equal - any partition is valid",
      "Even vs odd total length - different median formulas"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Return median of combined sorted arrays",
        "how_met": "Partition approach finds the median without actually merging",
        "gotchas": [
          "Even vs odd total length requires different formulas"
        ]
      },
      {
        "requirement": "O(log(min(m,n))) time complexity",
        "how_met": "Binary search on smaller array only, each iteration halves search space",
        "gotchas": [
          "Must swap to ensure binary search on smaller array"
        ]
      },
      {
        "requirement": "O(1) space complexity",
        "how_met": "Only use constant extra variables, no merging or copying",
        "gotchas": [
          "Don't accidentally create merged array for verification"
        ]
      },
      {
        "requirement": "Handle empty arrays",
        "how_met": "Use -inf and +inf as boundary sentinels when partition is at edges",
        "gotchas": [
          "Off-by-one errors at partition boundaries"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "findMedianSortedArrays",
        "target": "O(log(min(m,n)))",
        "achieved": "O(log(min(m,n)))",
        "why": "Binary search on smaller array, each iteration halves search space"
      }
    ],
    "non_goals": [
      "Modifying input arrays",
      "Handling unsorted input",
      "Supporting streaming data"
    ]
  },
  "assumptions": [
    "Arrays are sorted in non-decreasing order (confirmed by problem)",
    "At least one array has at least one element",
    "Floating point precision is sufficient (double in Java, float in Python)",
    "We should return exact median, not approximation"
  ],
  "tradeoffs": [
    {
      "decision": "Binary search vs merge approach",
      "chosen": "Binary search partition",
      "why": "O(log(min(m,n))) vs O(m+n) - logarithmic is exponentially faster for large inputs",
      "alternative": "Merge and find middle",
      "when_to_switch": "Never for this problem - merge violates complexity requirement"
    },
    {
      "decision": "Binary search on smaller vs larger array",
      "chosen": "Always smaller array",
      "why": "O(log(min(m,n))) vs O(log(max(m,n))) - could be significant difference",
      "alternative": "Search on either",
      "when_to_switch": "Never - smaller is always better or equal"
    },
    {
      "decision": "Use sentinels (-inf, +inf) vs explicit boundary checks",
      "chosen": "Sentinels for cleaner code",
      "why": "Eliminates 4+ if-else branches, code is more readable",
      "alternative": "Explicit checks at every boundary",
      "when_to_switch": "In languages without infinity support"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "Single responsibility - one function does one thing",
      "Handle edge cases uniformly with sentinels",
      "Binary search template is reusable"
    ],
    "why_this_design_scales": "The partition concept generalizes to finding k-th element (Part 2) and extends to k sorted arrays (Part 3). The binary search framework remains the same.",
    "expected_followup_hooks": [
      "Partition calculation can be parameterized for k-th element",
      "Can wrap in class for streaming data (Part 4)",
      "Median of medians for k arrays"
    ],
    "invariants": [
      "Left half always has (m+n+1)/2 elements",
      "max(left) <= min(right) at valid partition",
      "Binary search bounds always converge"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n         THE CORE INSIGHT: PARTITIONING\n         \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    Instead of merging, we PARTITION both arrays:\n    \n    nums1: [1, 3 | 8, 9, 15]        \u2190 partition at index 2\n    nums2: [7, 11, 18 | 19, 21, 25] \u2190 partition at index 3\n           \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n           LEFT HALF   RIGHT HALF\n           (5 elems)   (6 elems)\n    \n    Key property we need:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  max(left_half) \u2264 min(right_half)           \u2502\n    \u2502                                             \u2502\n    \u2502  nums1[1]=3  \u2264  nums2[3]=19  \u2713             \u2502\n    \u2502  nums2[2]=18 \u2264  nums1[2]=8   \u2717 INVALID!   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    When invalid: adjust partition using binary search\n```",
    "data_structure_state": "```\n    BINARY SEARCH STATE PROGRESSION\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    nums1 = [1, 3, 8, 9, 15]  (m=5)\n    nums2 = [7, 11, 18, 19, 21, 25]  (n=6)\n    half = (5+6+1)/2 = 6  \u2190 left half needs 6 elements\n    \n    Iteration 1: left=0, right=5\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 i = (0+5)/2 = 2                         \u2502\n    \u2502 j = 6 - 2 = 4                           \u2502\n    \u2502                                         \u2502\n    \u2502 nums1: [1, 3 | 8, 9, 15]               \u2502\n    \u2502 nums2: [7, 11, 18, 19 | 21, 25]        \u2502\n    \u2502                                         \u2502\n    \u2502 maxL1=3, minR1=8, maxL2=19, minR2=21   \u2502\n    \u2502 3\u226421\u2713 but 19>8\u2717 \u2192 i too small         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    Iteration 2: left=3, right=5\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 i = (3+5)/2 = 4                         \u2502\n    \u2502 j = 6 - 4 = 2                           \u2502\n    \u2502                                         \u2502\n    \u2502 nums1: [1, 3, 8, 9 | 15]               \u2502\n    \u2502 nums2: [7, 11 | 18, 19, 21, 25]        \u2502\n    \u2502                                         \u2502\n    \u2502 maxL1=9, minR1=15, maxL2=11, minR2=18  \u2502\n    \u2502 9\u226418\u2713 AND 11\u226415\u2713 \u2192 VALID!             \u2502\n    \u2502                                         \u2502\n    \u2502 Total odd \u2192 median = max(9,11) = 11    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Ensure nums1 is smaller array",
        "visualization": "if len(nums1) > len(nums2): swap",
        "key_point": "Always binary search on smaller for O(log(min(m,n)))"
      },
      {
        "step": 2,
        "description": "Initialize binary search bounds",
        "visualization": "left=0, right=m, half=(m+n+1)/2",
        "key_point": "half is size of left partition we need"
      },
      {
        "step": 3,
        "description": "Calculate partition points",
        "visualization": "i = mid in nums1, j = half - i in nums2",
        "key_point": "If we take i from nums1, we need half-i from nums2"
      },
      {
        "step": 4,
        "description": "Get boundary values with sentinels",
        "visualization": "maxL1 = -inf if i=0 else nums1[i-1]",
        "key_point": "Sentinels handle edge cases elegantly"
      },
      {
        "step": 5,
        "description": "Check partition validity",
        "visualization": "maxL1\u2264minR2 AND maxL2\u2264minR1?",
        "key_point": "Cross-check ensures correct global ordering"
      },
      {
        "step": 6,
        "description": "Adjust binary search or return median",
        "visualization": "if valid: return median, else adjust left/right",
        "key_point": "maxL1>minR2 means i too big; maxL2>minR1 means i too small"
      }
    ],
    "dry_run_table": "| Step | left | right | i | j | maxL1 | minR1 | maxL2 | minR2 | Action |\n|------|------|-------|---|---|-------|-------|-------|-------|--------|\n| 1 | 0 | 5 | 2 | 4 | 3 | 8 | 19 | 21 | 19>8 \u2192 left=3 |\n| 2 | 3 | 5 | 4 | 2 | 9 | 15 | 11 | 18 | Valid! max(9,11)=**11** |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'median of two sorted arrays' with O(log) requirement, I immediately think binary search - but WHERE to apply it?",
      "The naive O(m+n) merge is easy but violates the complexity requirement. I need a fundamentally different approach.",
      "Key insight: Median divides a sorted list into two equal halves. I don't need to MERGE arrays, just PARTITION them correctly!",
      "If I partition both arrays such that left_half has (m+n)/2 elements and max(left) \u2264 min(right), I've found the median.",
      "Binary search finds the partition point: for partition i in nums1, partition in nums2 is forced to be (m+n+1)/2 - i.",
      "The condition maxLeft1 \u2264 minRight2 AND maxLeft2 \u2264 minRight1 tells me if the partition is correct.",
      "If maxLeft1 > minRight2, I've taken too many from nums1, so move left. Otherwise, move right.",
      "Always search on smaller array to ensure O(log(min(m,n)))."
    ],
    "key_insight": "**We're not searching for an element - we're searching for a PARTITION POINT.** Once we fix partition in one array, the other is determined. Valid partition = correct median.",
    "why_this_works": "The median is the boundary between the smaller and larger halves. By ensuring max(left) \u2264 min(right), we guarantee our partition correctly separates smaller from larger elements across both arrays."
  },
  "approaches": [
    {
      "name": "Brute Force - Merge and Find",
      "description": "Merge both sorted arrays into one, then find the middle element(s).",
      "pseudocode": "merged = merge(nums1, nums2)\nn = len(merged)\nif n is odd:\n    return merged[n/2]\nelse:\n    return (merged[n/2-1] + merged[n/2]) / 2",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(m + n)",
      "pros": [
        "Simple to implement",
        "Easy to understand",
        "Always correct"
      ],
      "cons": [
        "Violates O(log(min(m,n))) requirement",
        "Uses O(m+n) extra space",
        "Not acceptable answer for this problem"
      ],
      "when_to_use": "Only mention as baseline to show you understand the straightforward approach before optimizing"
    },
    {
      "name": "Two Pointers - Count to Median",
      "description": "Use two pointers to virtually merge arrays, stop when we reach the median position.",
      "pseudocode": "p1, p2 = 0, 0\nfor i in range((m+n)/2 + 1):\n    move smaller pointer forward\n    track last two values\nreturn median based on parity",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(1)",
      "pros": [
        "O(1) space",
        "Conceptually simpler than binary search"
      ],
      "cons": [
        "Still O(m+n) time",
        "Doesn't meet requirement"
      ],
      "when_to_use": "If interviewer only needs O(1) space and relaxes time constraint"
    },
    {
      "name": "Optimal: Binary Search Partitioning",
      "description": "Binary search on the smaller array to find correct partition point. Partner partition in larger array is determined automatically.",
      "pseudocode": "ensure nums1 is smaller\nleft, right = 0, m\nwhile left <= right:\n    i = mid point in nums1\n    j = half - i  // partner in nums2\n    if valid_partition(i, j):\n        return calculate_median()\n    elif maxLeft1 > minRight2:\n        right = i - 1  // too many from nums1\n    else:\n        left = i + 1   // too few from nums1",
      "time_complexity": "O(log(min(m, n)))",
      "space_complexity": "O(1)",
      "pros": [
        "Meets complexity requirement",
        "Constant space",
        "Elegant once understood"
      ],
      "cons": [
        "Complex to derive",
        "Boundary cases are tricky"
      ],
      "key_insight": "The partition in nums2 is FORCED once we choose partition in nums1. We only binary search one dimension!"
    }
  ],
  "optimal_solution": {
    "name": "Binary Search Partitioning",
    "explanation_md": "## Approach\n\n### Core Idea\nInstead of merging arrays, we **partition** both arrays into left and right halves such that:\n1. `len(left_half) = (m + n + 1) / 2`\n2. `max(left_half) \u2264 min(right_half)`\n\n### Why This Works\nThe median is by definition the element that separates the smaller half from the larger half. If we can partition both arrays correctly, the median is:\n- **Odd total**: `max(left_half)`\n- **Even total**: `(max(left_half) + min(right_half)) / 2`\n\n### Binary Search Logic\n- Binary search on **smaller array** for partition index `i`\n- Partner partition in larger array: `j = (m+n+1)/2 - i`\n- Valid partition: `nums1[i-1] \u2264 nums2[j]` AND `nums2[j-1] \u2264 nums1[i]`\n- Use `-inf` and `+inf` as sentinels for boundary cases",
    "data_structures": [
      {
        "structure": "Two integer variables (left, right)",
        "purpose": "Binary search bounds on smaller array"
      },
      {
        "structure": "Four boundary variables (maxLeft1, minRight1, maxLeft2, minRight2)",
        "purpose": "Partition boundary values for validation"
      }
    ],
    "algorithm_steps": [
      "1. **Swap if needed**: Ensure nums1 is the smaller array",
      "2. **Initialize**: left=0, right=m, half=(m+n+1)/2",
      "3. **Binary search**: Calculate i and j partition points",
      "4. **Get boundaries**: Use sentinels for edge partitions",
      "5. **Validate**: Check cross-conditions for valid partition",
      "6. **Adjust or return**: Move binary search bounds or compute median"
    ],
    "why_decimal": "Not applicable here - we use float division which has sufficient precision for the 10^-5 requirement"
  },
  "solution_python_lines": [
    "from typing import List",
    "",
    "class Solution:",
    "    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:",
    "        \"\"\"",
    "        Find median of two sorted arrays using binary search partitioning.",
    "        Time: O(log(min(m,n))), Space: O(1)",
    "        ",
    "        Key insight: Partition both arrays so max(left) <= min(right).",
    "        Binary search finds the correct partition in O(log(min(m,n))).",
    "        \"\"\"",
    "        # Ensure nums1 is the smaller array for O(log(min(m,n)))",
    "        if len(nums1) > len(nums2):",
    "            nums1, nums2 = nums2, nums1",
    "        ",
    "        m, n = len(nums1), len(nums2)",
    "        left, right = 0, m",
    "        half = (m + n + 1) // 2  # Size of left partition",
    "        ",
    "        while left <= right:",
    "            i = (left + right) // 2  # Partition index in nums1",
    "            j = half - i              # Corresponding partition in nums2",
    "            ",
    "            # Get boundary values using sentinels for edge cases",
    "            maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]",
    "            minRight1 = float('inf') if i == m else nums1[i]",
    "            maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]",
    "            minRight2 = float('inf') if j == n else nums2[j]",
    "            ",
    "            # Check if we found valid partition",
    "            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:",
    "                # Valid partition found - calculate median",
    "                if (m + n) % 2 == 1:",
    "                    return float(max(maxLeft1, maxLeft2))",
    "                else:",
    "                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2",
    "            elif maxLeft1 > minRight2:",
    "                # Too many elements from nums1, move partition left",
    "                right = i - 1",
    "            else:",
    "                # Too few elements from nums1, move partition right",
    "                left = i + 1",
    "        ",
    "        return 0.0  # Should never reach here with valid input",
    "",
    "",
    "if __name__ == '__main__':",
    "    sol = Solution()",
    "    ",
    "    # Test 1: Odd total length",
    "    print(\"Test 1: nums1=[1,3], nums2=[2]\")",
    "    print(f\"Median: {sol.findMedianSortedArrays([1, 3], [2])}\")",
    "    print(\"Expected: 2.0\\n\")",
    "    ",
    "    # Test 2: Even total length",
    "    print(\"Test 2: nums1=[1,2], nums2=[3,4]\")",
    "    print(f\"Median: {sol.findMedianSortedArrays([1, 2], [3, 4])}\")",
    "    print(\"Expected: 2.5\\n\")",
    "    ",
    "    # Test 3: Empty array",
    "    print(\"Test 3: nums1=[], nums2=[1]\")",
    "    print(f\"Median: {sol.findMedianSortedArrays([], [1])}\")",
    "    print(\"Expected: 1.0\\n\")",
    "    ",
    "    # Test 4: Larger interleaving arrays",
    "    print(\"Test 4: nums1=[1,3,8,9,15], nums2=[7,11,18,19,21,25]\")",
    "    print(f\"Median: {sol.findMedianSortedArrays([1,3,8,9,15], [7,11,18,19,21,25])}\")",
    "    print(\"Expected: 11.0\\n\")",
    "    ",
    "    # Test 5: Non-overlapping arrays",
    "    print(\"Test 5: nums1=[1,2], nums2=[3,4,5,6]\")",
    "    print(f\"Median: {sol.findMedianSortedArrays([1, 2], [3, 4, 5, 6])}\")",
    "    print(\"Expected: 3.5\")"
  ],
  "solution_java_lines": [
    "public class Solution {",
    "    /**",
    "     * Find median of two sorted arrays using binary search partitioning.",
    "     * Time: O(log(min(m,n))), Space: O(1)",
    "     * ",
    "     * Key insight: Partition both arrays so max(left) <= min(right).",
    "     */",
    "    public double findMedianSortedArrays(int[] nums1, int[] nums2) {",
    "        // Ensure nums1 is the smaller array",
    "        if (nums1.length > nums2.length) {",
    "            int[] temp = nums1;",
    "            nums1 = nums2;",
    "            nums2 = temp;",
    "        }",
    "        ",
    "        int m = nums1.length;",
    "        int n = nums2.length;",
    "        int left = 0, right = m;",
    "        int half = (m + n + 1) / 2;",
    "        ",
    "        while (left <= right) {",
    "            int i = (left + right) / 2;  // Partition in nums1",
    "            int j = half - i;             // Partition in nums2",
    "            ",
    "            // Get boundary values with edge case handling",
    "            int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];",
    "            int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];",
    "            int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];",
    "            int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];",
    "            ",
    "            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {",
    "                // Valid partition - calculate median",
    "                if ((m + n) % 2 == 1) {",
    "                    return Math.max(maxLeft1, maxLeft2);",
    "                } else {",
    "                    return (Math.max(maxLeft1, maxLeft2) + ",
    "                            Math.min(minRight1, minRight2)) / 2.0;",
    "                }",
    "            } else if (maxLeft1 > minRight2) {",
    "                right = i - 1;  // Move partition left",
    "            } else {",
    "                left = i + 1;   // Move partition right",
    "            }",
    "        }",
    "        ",
    "        return 0.0;  // Should never reach here",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        Solution sol = new Solution();",
    "        ",
    "        // Test 1: Odd total",
    "        System.out.println(\"Test 1: \" + ",
    "            sol.findMedianSortedArrays(new int[]{1, 3}, new int[]{2}));",
    "        System.out.println(\"Expected: 2.0\\n\");",
    "        ",
    "        // Test 2: Even total",
    "        System.out.println(\"Test 2: \" + ",
    "            sol.findMedianSortedArrays(new int[]{1, 2}, new int[]{3, 4}));",
    "        System.out.println(\"Expected: 2.5\\n\");",
    "        ",
    "        // Test 3: Empty array",
    "        System.out.println(\"Test 3: \" + ",
    "            sol.findMedianSortedArrays(new int[]{}, new int[]{1}));",
    "        System.out.println(\"Expected: 1.0\\n\");",
    "        ",
    "        // Test 4: Larger arrays",
    "        System.out.println(\"Test 4: \" + ",
    "            sol.findMedianSortedArrays(",
    "                new int[]{1,3,8,9,15}, new int[]{7,11,18,19,21,25}));",
    "        System.out.println(\"Expected: 11.0\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-11",
      "section": "Class and Method Setup",
      "explanation": "We define the Solution class with comprehensive docstring explaining the O(log(min(m,n))) time complexity and the key insight about partitioning."
    },
    {
      "lines": "12-15",
      "section": "Ensure nums1 is Smaller",
      "explanation": "**Critical for complexity**: By always binary searching on the smaller array, we guarantee O(log(min(m,n))) instead of O(log(max(m,n))). This swap is essential."
    },
    {
      "lines": "17-19",
      "section": "Initialize Variables",
      "explanation": "`half = (m+n+1)//2` calculates how many elements should be in the left partition. The +1 handles odd lengths correctly, placing the extra element on the left."
    },
    {
      "lines": "21-27",
      "section": "Calculate Partition Points and Boundaries",
      "explanation": "`i` is our partition guess in nums1. `j = half - i` is FORCED - if we take i elements from nums1, we need half-i from nums2. Sentinels (`-inf`, `+inf`) elegantly handle edge cases when partition is at array boundaries."
    },
    {
      "lines": "29-36",
      "section": "Check Valid Partition",
      "explanation": "**The heart of the algorithm**: Valid partition means elements 'cross correctly' - left1 \u2264 right2 AND left2 \u2264 right1. If valid, we can compute the median immediately."
    },
    {
      "lines": "37-41",
      "section": "Adjust Binary Search Bounds",
      "explanation": "If maxLeft1 > minRight2, we've taken too many from nums1 (need to move partition left). Otherwise, we've taken too few (move partition right). Classic binary search adjustment."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. First verify swap works with larger first array. 2. Test single element arrays. 3. Test empty array edge case. 4. Test interleaving values. 5. Test non-overlapping arrays.",
    "what_to_print_or_assert": [
      "print(f'i={i}, j={j}, maxL1={maxLeft1}, minR1={minRight1}, maxL2={maxLeft2}, minR2={minRight2}')",
      "assert left <= right, 'Binary search bounds crossed'"
    ],
    "common_failure_modes": [
      "Off-by-one in partition index",
      "Wrong direction in binary search adjustment",
      "Forgetting to swap arrays",
      "Integer overflow in (left + right) / 2 for very large arrays"
    ],
    "how_to_fix_fast": "If getting wrong median: print partition boundaries at each step and verify the cross-conditions manually. If infinite loop: check binary search direction logic."
  },
  "complexity_analysis": {
    "time": {
      "findMedianSortedArrays": {
        "complexity": "O(log(min(m, n)))",
        "explanation": "Binary search on smaller array. Each iteration halves the search space from 0 to m."
      },
      "overall": "O(log(min(m, n))) - logarithmic in the size of the smaller array"
    },
    "space": {
      "complexity": "O(1)",
      "breakdown": "- 6 integer/float variables for bounds and boundaries\n- No additional arrays or data structures\n- Input arrays are not modified",
      "note": "Constant space regardless of input size"
    },
    "can_we_do_better": "No - O(log(min(m,n))) is optimal. Any algorithm must examine at least O(log(min(m,n))) elements to determine the median. This is provable by adversarial argument."
  },
  "dry_run": {
    "example": "nums1 = [1, 3, 8, 9, 15], nums2 = [7, 11, 18, 19, 21, 25]",
    "trace_table": "| Step | left | right | i | j | maxL1 | minR1 | maxL2 | minR2 | Condition | Action |\n|------|------|-------|---|---|-------|-------|-------|-------|-----------|--------|\n| Init | 0 | 5 | - | - | - | - | - | - | m=5,n=6,half=6 | Start search |\n| 1 | 0 | 5 | 2 | 4 | 3 | 8 | 19 | 21 | 19>8 | left=3 |\n| 2 | 3 | 5 | 4 | 2 | 9 | 15 | 11 | 18 | 9\u226418 \u2713, 11\u226415 \u2713 | Valid! |\n| Result | - | - | - | - | - | - | - | - | Odd total: max(9,11) | **Return 11** |",
    "final_answer": "11.0"
  },
  "test_cases": [
    {
      "name": "Simple Odd Length",
      "category": "Basic",
      "input": "nums1=[1,3], nums2=[2]",
      "expected": "2.0",
      "explanation": "Combined: [1,2,3], middle element is 2"
    },
    {
      "name": "Simple Even Length",
      "category": "Basic",
      "input": "nums1=[1,2], nums2=[3,4]",
      "expected": "2.5",
      "explanation": "Combined: [1,2,3,4], average of 2 and 3"
    },
    {
      "name": "Empty First Array",
      "category": "Edge Case",
      "input": "nums1=[], nums2=[1]",
      "expected": "1.0",
      "explanation": "Single element is the median"
    },
    {
      "name": "Empty Second Array",
      "category": "Edge Case",
      "input": "nums1=[2], nums2=[]",
      "expected": "2.0",
      "explanation": "Swap ensures we search smaller array (empty one)"
    },
    {
      "name": "Non-Overlapping Arrays",
      "category": "Edge Case",
      "input": "nums1=[1,2], nums2=[3,4,5,6]",
      "expected": "3.5",
      "explanation": "Combined: [1,2,3,4,5,6], avg(3,4)=3.5. Partition at boundary."
    },
    {
      "name": "Interleaving Values",
      "category": "Standard",
      "input": "nums1=[1,3,8,9,15], nums2=[7,11,18,19,21,25]",
      "expected": "11.0",
      "explanation": "11 elements, median is 6th = 11"
    },
    {
      "name": "Negative Numbers",
      "category": "Edge Case",
      "input": "nums1=[-5,-3,-1], nums2=[-4,-2,0]",
      "expected": "-2.5",
      "explanation": "Combined: [-5,-4,-3,-2,-1,0], avg(-3,-2)=-2.5"
    },
    {
      "name": "All Same Values",
      "category": "Edge Case",
      "input": "nums1=[2,2,2], nums2=[2,2]",
      "expected": "2.0",
      "explanation": "Any partition is valid, median is 2"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Binary searching on larger array instead of smaller",
      "why_wrong": "Changes complexity from O(log(min)) to O(log(max)), violating requirement",
      "correct_approach": "Always swap to ensure nums1 is smaller before searching",
      "code_wrong": "# No swap, just proceed\nleft, right = 0, len(nums1)",
      "code_correct": "if len(nums1) > len(nums2):\n    nums1, nums2 = nums2, nums1"
    },
    {
      "mistake": "Off-by-one in partition indices",
      "why_wrong": "Partition at index i means i elements on left. nums1[i-1] is last left element.",
      "correct_approach": "Remember: partition i means elements 0 to i-1 are on left",
      "code_wrong": "maxLeft1 = nums1[i]  # Wrong! This is first of right half",
      "code_correct": "maxLeft1 = nums1[i-1] if i > 0 else float('-inf')"
    },
    {
      "mistake": "Incorrect median calculation for even vs odd",
      "why_wrong": "Using wrong formula gives off-by-0.5 errors",
      "correct_approach": "Odd: max(left), Even: (max(left) + min(right)) / 2",
      "code_wrong": "return (maxLeft1 + maxLeft2) / 2  # Wrong for odd length",
      "code_correct": "if (m + n) % 2 == 1:\n    return max(maxLeft1, maxLeft2)\nelse:\n    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2"
    },
    {
      "mistake": "Wrong binary search direction",
      "why_wrong": "Moving left when should move right causes infinite loop or wrong answer",
      "correct_approach": "maxLeft1 > minRight2 means nums1 contributes too much, move LEFT",
      "code_wrong": "if maxLeft1 > minRight2: left = i + 1  # WRONG direction!",
      "code_correct": "if maxLeft1 > minRight2: right = i - 1  # Move left"
    },
    {
      "mistake": "Not handling boundary sentinels",
      "why_wrong": "When i=0 or i=m, accessing nums1[i-1] or nums1[i] causes IndexError",
      "correct_approach": "Use -inf and +inf as sentinels for boundary cases",
      "code_wrong": "maxLeft1 = nums1[i-1]  # IndexError when i=0",
      "code_correct": "maxLeft1 = float('-inf') if i == 0 else nums1[i-1]"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. I recognize this as the classic median of two sorted arrays problem. Before coding, let me clarify a few things and outline my approach.",
    "clarifying_questions_to_ask": [
      "Should I optimize for time or space? (Expecting O(log(min(m,n))) time requirement)",
      "Can both arrays be empty? (No, at least one element total)",
      "Are the arrays strictly increasing or can there be duplicates?",
      "What precision is expected for the result?"
    ],
    "what_to_mention_proactively": [
      "The naive merge approach is O(m+n), but I'll use binary search partitioning for O(log(min(m,n)))",
      "I'll always search on the smaller array to achieve the optimal complexity",
      "The key insight is that we're searching for a PARTITION, not an element"
    ],
    "communication_during_coding": [
      "I'm swapping here to ensure nums1 is smaller - this is critical for O(log(min))",
      "Using sentinels (-inf, +inf) handles edge cases elegantly",
      "This cross-condition check verifies our partition is correct globally"
    ],
    "if_stuck": [
      "Think about WHAT we're searching for - not an element, but a partition point",
      "If we take i from nums1, we MUST take half-i from nums2",
      "Draw the partition and check: does max(left) \u2264 min(right)?"
    ],
    "time_management": "0-5min: Clarify & outline | 5-15min: Explain approach with diagram | 15-30min: Code | 30-40min: Test & debug | 40-45min: Complexity & follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Binary Search on Answer Space / Partitioning",
    "indicators": [
      "Logarithmic time requirement",
      "Two sorted arrays",
      "Finding a position/boundary rather than specific element"
    ],
    "similar_problems": [
      "LC 33 - Search in Rotated Sorted Array: Binary search with modified conditions",
      "LC 153 - Find Minimum in Rotated Sorted Array: Search for partition point",
      "LC 378 - Kth Smallest in Sorted Matrix: Binary search on value range",
      "LC 719 - Find K-th Smallest Pair Distance: Binary search on answer"
    ],
    "template": "Binary search on one dimension when other dimension is constrained/forced. Verify correctness with cross-boundary checks."
  },
  "follow_up_preparation": {
    "part_2_hint": "**Find K-th Element**: Instead of median (fixed at half), parameterize k. The partition approach generalizes directly - just change half to k.",
    "part_3_hint": "**Median of K Sorted Arrays**: Use heap-based merge or recursively find median of medians. Harder to achieve true O(log) complexity.",
    "data_structure_evolution": "Part 1: Direct binary search \u2192 Part 2: Parameterized k \u2192 Part 3: Heap/tournament tree \u2192 Part 4: Online algorithm with balanced BST"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. This is the classic median of two sorted arrays problem. I know the naive O(m+n) merge approach, but given the hard difficulty, I'll use binary search partitioning for O(log(min(m,n))). Let me first clarify a few things...",
    "after_clarification": "Great. So my approach is: partition both arrays such that the left half has exactly half the elements and max(left) \u2264 min(right). I'll binary search on the smaller array to find the correct partition. Let me draw this out...",
    "while_coding": [
      "I'm swapping to ensure nums1 is smaller - critical for the complexity...",
      "Using sentinels here handles the edge cases when partition is at boundaries...",
      "This cross-check validates our partition is correct globally..."
    ],
    "after_coding": "Let me trace through the example: nums1=[1,3], nums2=[2]. We need partition such that left has 2 elements...",
    "when_stuck_verbatim": "Let me think about what we're really searching for here... We need a partition point, not a specific element. If I take i elements from nums1, the rest is forced...",
    "after_mistake": "Ah, I see the issue - I had the binary search direction backwards. When maxLeft1 > minRight2, we've taken too many from nums1, so we should move LEFT, not right. Let me fix that.",
    "before_moving_on": "This solution is O(log(min(m,n))) time and O(1) space. The key insight is that we're searching for a partition point where the cross-boundary conditions are satisfied. Ready for the follow-up?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Understanding of binary search beyond basic 'find element'",
      "Ability to handle complex edge cases",
      "Clear communication of non-trivial algorithm",
      "Systematic debugging approach"
    ],
    "bonus_points": [
      "Drawing partition diagram before coding",
      "Explaining WHY we search on smaller array",
      "Mentioning the sentinel technique proactively",
      "Discussing why O(log(min)) is optimal"
    ],
    "red_flags": [
      "Jumping to brute force merge without mentioning complexity",
      "Confusion about what we're binary searching for",
      "Unable to explain why the cross-conditions work",
      "Getting stuck on boundary cases without systematic approach"
    ],
    "what_differentiates_strong_candidates": "Strong candidates recognize this as a partition problem, not a merge problem. They can explain the algorithm intuitively with diagrams, handle edge cases systematically, and articulate WHY the approach works."
  },
  "time_milestones": {
    "by_5_min": "Problem understood, clarifying questions asked, approach outlined (partition-based binary search)",
    "by_15_min": "Algorithm explained with visual diagram, key insight articulated, edge cases identified",
    "by_25_min": "Core implementation complete, basic test passing",
    "by_35_min": "Edge cases handled, dry run complete, complexity analyzed",
    "by_45_min": "Follow-up questions discussed (k-th element, k arrays)",
    "warning_signs": "If still explaining approach at 15 min or stuck on implementation at 30 min, simplify or ask for hints"
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'Let me trace through this carefully...' Walk through step by step to find the issue. Binary search direction and off-by-one are most common.",
    "when_you_dont_know_syntax": "Say: 'I don't remember exact Python/Java syntax for infinity, but conceptually I need a value larger than any element.' Use comments to show intent.",
    "when_approach_is_wrong": "If stuck on merge approach, say: 'The merge is O(m+n), but we need O(log). Let me think about what logarithmic implies - binary search. What can we binary search on?'",
    "when_completely_stuck": "Say: 'I'm stuck on how to handle the partitioning. Could you give me a hint about what invariant the partition should maintain?' Getting unstuck is better than silence.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me write pseudocode for the remaining edge cases and explain verbally how I'd complete this.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "This problem is well-known, so AI will likely suggest the correct approach. Use AI for syntax and boilerplate, but demonstrate YOU understand WHY it works.",
    "what_to_do": [
      "Let AI help with sentinel syntax",
      "Use AI for test case generation",
      "Accept boilerplate code suggestions"
    ],
    "what_not_to_do": [
      "Don't paste 'find median of two sorted arrays' and accept solution",
      "Don't accept partition logic without being able to explain it",
      "Don't skip tracing through example because AI says it's correct"
    ],
    "how_to_demonstrate_understanding": "After AI suggests code, explain: 'This works because we're binary searching for a partition where max(left) \u2264 min(right). Let me trace through to verify...'",
    "expectation_adjustment": "With AI tools, you should complete this problem faster and have time for follow-ups. If AI slows you down, write it yourself."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing the partition diagram unprompted before coding",
      "Explaining why O(log(min)) is optimal (adversarial argument)",
      "Discussing how this generalizes to k-th element immediately",
      "Clean code with perfect variable names on first pass"
    ],
    "subtle_signals_of_experience": [
      "Using sentinels instead of multiple conditionals",
      "Testing boundary cases methodically",
      "Mentioning the swap as 'critical for complexity'",
      "Immediately recognizing this as a partition problem"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Long silence while trying to remember the algorithm",
      "Defensive when interviewer points out the merge approach is too slow",
      "Not drawing diagrams for a visual problem"
    ],
    "technical": [
      "Confusing partition index with array index",
      "Wrong binary search direction causing infinite loop",
      "Forgetting to handle empty array case",
      "Using left <= right vs left < right incorrectly"
    ],
    "communication": [
      "Saying 'I've seen this before' without explaining the insight",
      "Using 'partition' without defining what it means",
      "Not explaining the cross-condition logic"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I swap to ensure binary search on smaller array?",
      "Did I handle empty array cases with sentinels?",
      "Did I check both cross-conditions (maxL1\u2264minR2 AND maxL2\u2264minR1)?",
      "Did I handle even vs odd total length correctly?",
      "Did I trace through at least one example?",
      "Did I state time O(log(min(m,n))) and space O(1)?"
    ],
    "quick_code_review": [
      "Sentinels for boundaries",
      "Correct median formula",
      "Binary search direction",
      "Swap at beginning",
      "Return type is float"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation for null/empty arrays",
      "Assertion that arrays are actually sorted",
      "Handling potential integer overflow for very large arrays",
      "Unit tests covering all edge cases",
      "Documentation with complexity analysis"
    ],
    "why_not_in_interview": "Keep focus on algorithm correctness. Mention these verbally as 'things I'd add in production'.",
    "how_to_mention": "Say: 'In production, I'd add validation that arrays are sorted and handle null inputs, but for this interview I'll assume valid input.'"
  },
  "generated_at": "2026-01-19T04:02:48.942969",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}