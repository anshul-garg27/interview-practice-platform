{
  "problem_title": "Task Scheduling with Dependencies - Part 4: Dynamic Task Addition",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 computed everything in a single batch pass. Part 4 requires maintaining scheduler state and supporting incremental additions. Key shift: from batch processing to online/incremental updates.",
    "new_requirements": [
      "Initialize scheduler with tasks and dependencies, storing state for future updates",
      "Add new tasks dynamically without recomputing everything from scratch",
      "Query estimated completion time in O(1)",
      "Validate new tasks (no duplicates, no self-dependency, valid prerequisites)"
    ],
    "new_constraints": [
      "addTask must be O(p) where p = number of prerequisites, not O(V+E)",
      "getEstimatedCompletion must be O(1)",
      "Cannot restart already-computed tasks"
    ],
    "key_insight": "Once we have completion times for existing tasks, a new task's completion time is simply max(completion_time[prereq]) + duration. We only need to update if this exceeds the current maximum. No graph traversal needed!"
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Initialize with batch of tasks",
        "how_met": "initialize() runs topo sort once, stores completion_times in instance state",
        "gotchas": [
          "Must reset state on re-initialization",
          "Handle cycles in initial data"
        ]
      },
      {
        "requirement": "Add task in O(p)",
        "how_met": "add_task() only iterates through prerequisites once, no BFS/DFS",
        "gotchas": [
          "Must validate prerequisites exist",
          "Check for self-dependency"
        ]
      },
      {
        "requirement": "Get completion in O(1)",
        "how_met": "Maintain total_completion variable, update on each add_task",
        "gotchas": [
          "Initialize to 0 for empty task list"
        ]
      },
      {
        "requirement": "Cycle detection for new tasks",
        "how_met": "Self-dependency check + prerequisite existence check sufficient since we only add dependents, not new edges to existing tasks",
        "gotchas": [
          "Cannot create cycle by adding task with only incoming edges"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "initialize",
        "target": "O(V+E)",
        "achieved": "O(V+E)",
        "why": "Standard topological sort"
      },
      {
        "operation": "add_task",
        "target": "O(p)",
        "achieved": "O(p)",
        "why": "Single pass through prerequisites to find max completion time"
      },
      {
        "operation": "get_estimated_completion",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Return stored variable"
      }
    ],
    "non_goals": [
      "Removing tasks",
      "Modifying existing dependencies",
      "Real-time simulation with workers"
    ]
  },
  "assumptions": [
    "Prerequisites in add_task must be existing task IDs (validated, return False otherwise)",
    "Task IDs are unique across all operations (initial + dynamic)",
    "Duration is always positive",
    "Cycle in initial data results in total_completion = -1",
    "Multiple critical paths: returning any valid estimate is acceptable"
  ],
  "tradeoffs": [
    {
      "decision": "Store completion_times for all tasks vs recompute",
      "chosen": "Store",
      "why": "Enables O(p) add_task instead of O(V+E)",
      "alternative": "Recompute",
      "when_to_switch": "Never for this problem - O(p) is explicitly required"
    },
    {
      "decision": "Track max_completion vs compute on demand",
      "chosen": "Track",
      "why": "Enables O(1) getEstimatedCompletion",
      "alternative": "max() over values",
      "when_to_switch": "If task removal added (max might decrease)"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1-3 methods unchanged",
      "Graph structure format (defaultdict of lists)"
    ],
    "what_to_change": [
      "Added __init__ with instance variables",
      "New methods for dynamic operations"
    ],
    "interfaces_and_boundaries": "Part 4 state is separate from Part 1-3 local computations. Could refactor to share graph building code if needed.",
    "invariants": [
      "completion_times[task] = max(completion_times[prereq]) + duration[task]",
      "total_completion = max(completion_times.values())",
      "All tasks in completion_times are valid (no cycles among them)",
      "task_graph and prereq_graph are consistent inverse views"
    ]
  },
  "visual_explanation": {
    "before_after": "Initial State (after initialize):\\n\\n  Task 1 (dur=5) --> Task 2 (dur=3)\\n  completion: {1: 5, 2: 8}\\n  total_completion: 8\\n\\nAfter add_task(3, 4, [1]):\\n\\n  Task 1 (dur=5) --> Task 2 (dur=3)\\n        \\\\\\n         --> Task 3 (dur=4) [NEW]\\n  \\n  completion: {1: 5, 2: 8, 3: 9}\\n  total_completion: max(8, 9) = 9\\n\\nKey: Task 3 starts at max(completion[1]) = 5\\n     Task 3 ends at 5 + 4 = 9",
    "algorithm_flow": "add_task(id, dur, prereqs):\\n1. Validate: id not exists, id not in prereqs, all prereqs exist\\n2. Store: task_durations[id] = dur\\n3. Update graphs: for each prereq p, add edge p->id\\n4. Compute: max_prereq = max(completion_times[p] for p in prereqs)\\n5. Set: completion_times[id] = max_prereq + dur\\n6. Update: total_completion = max(total_completion, completion_times[id])\\n7. Return True"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Re-run full topological sort on every add_task, recomputing all completion times",
      "time_complexity": "O(V+E) per add_task",
      "space_complexity": "O(V+E)",
      "why_not_optimal": "Problem requires O(p) for add_task. Full topo sort visits all nodes/edges unnecessarily when only one task is added."
    },
    {
      "name": "Optimal Incremental Update",
      "description": "Store completion times persistently. New task's time depends only on its prerequisites (already computed). Update global max in O(1).",
      "time_complexity": "O(p) per add_task, O(1) for get",
      "space_complexity": "O(V+E) total",
      "key_insight": "A new task with only incoming edges cannot affect existing tasks' completion times. Its completion time is fully determined by looking up prerequisite completions."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The key insight is that **completion times are monotonically determined** by the DAG structure. When we add a new task:\n\n1. **No backward propagation needed**: The new task only has prerequisites (incoming edges), not dependents. Existing tasks' completion times don't change.\n\n2. **Direct computation**: `new_completion = max(completion[prereq] for prereq in prerequisites) + duration`\n\n3. **O(1) max update**: Simply check if `new_completion > total_completion`\n\n**Why this works**: In a DAG, adding a node with only incoming edges from existing nodes creates a new \"leaf\" in topological order. The new node's completion time depends only on its direct prerequisites, which are already computed. No ripple effects backward.",
    "data_structures": [
      {
        "structure": "HashMap (task_durations)",
        "purpose": "Store duration for each task"
      },
      {
        "structure": "HashMap (completion_times)",
        "purpose": "Store computed completion time for each task"
      },
      {
        "structure": "HashMap of Lists (task_graph)",
        "purpose": "Forward adjacency: task -> dependents"
      },
      {
        "structure": "HashMap of Lists (prereq_graph)",
        "purpose": "Reverse adjacency: task -> prerequisites"
      },
      {
        "structure": "int (total_completion)",
        "purpose": "Running max for O(1) query"
      }
    ],
    "algorithm_steps": [
      "initialize: Build graphs, run topo sort, compute all completion_times, set total_completion",
      "add_task: Validate inputs, add to graphs, compute completion = max(prereqs) + duration, update total_completion",
      "get_estimated_completion: Return total_completion"
    ]
  },
  "solution_python_lines": [
    "from collections import defaultdict, deque",
    "from typing import List, Tuple",
    "import heapq",
    "",
    "class TaskScheduler:",
    "    \"\"\"Task scheduling with dependencies, workers, critical path, and dynamic additions.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize Part 4 dynamic scheduling state.\"\"\"",
    "        self.task_durations = {}",
    "        self.task_graph = defaultdict(list)",
    "        self.prereq_graph = defaultdict(list)",
    "        self.completion_times = {}",
    "        self.total_completion = 0",
    "    ",
    "    def schedule_tasks(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "        \"\"\"Part 1: Unlimited workers. Returns (min_time, order) or (-1, []) if cycle.\"\"\"",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            max_prereq_time = max((completion_time[p] for p in reverse_graph[task]), default=0)",
    "            completion_time[task] = max_prereq_time + duration[task]",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return (-1, [])",
    "        return (max(completion_time.values()), order)",
    "    ",
    "    def schedule_tasks_with_workers(self, task_list: List[List[int]], dependency_list: List[List[int]], k: int) -> int:",
    "        \"\"\"Part 2: Schedule with k limited workers. Returns min time or -1 if cycle.\"\"\"",
    "        if not task_list:",
    "            return 0",
    "        ",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        worker_heap = [0] * k",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            prereq_done = max((completion_time[p] for p in reverse_graph[task]), default=0)",
    "            worker_free = heapq.heappop(worker_heap)",
    "            start_time = max(prereq_done, worker_free)",
    "            completion_time[task] = start_time + duration[task]",
    "            heapq.heappush(worker_heap, completion_time[task])",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return -1",
    "        return max(completion_time.values())",
    "    ",
    "    def find_critical_path(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "        \"\"\"Part 3: Find critical path - longest dependency chain.\"\"\"",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        predecessor = {}",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            max_prereq_time, max_prereq_task = 0, None",
    "            for p in reverse_graph[task]:",
    "                if completion_time[p] > max_prereq_time:",
    "                    max_prereq_time, max_prereq_task = completion_time[p], p",
    "            predecessor[task] = max_prereq_task",
    "            completion_time[task] = max_prereq_time + duration[task]",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return (-1, [])",
    "        ",
    "        end_task = max(completion_time, key=completion_time.get)",
    "        critical_path = []",
    "        current = end_task",
    "        while current is not None:",
    "            critical_path.append(current)",
    "            current = predecessor[current]",
    "        critical_path.reverse()",
    "        return (max(completion_time.values()), critical_path)",
    "    ",
    "    # ==================== PART 4: Dynamic Task Addition ====================",
    "    ",
    "    def initialize(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> None:",
    "        \"\"\"",
    "        Part 4: Initialize scheduler with tasks and dependencies.",
    "        Stores state for incremental updates. Time: O(V+E), Space: O(V+E)",
    "        \"\"\"",
    "        self.task_durations = {}",
    "        self.task_graph = defaultdict(list)",
    "        self.prereq_graph = defaultdict(list)",
    "        self.completion_times = {}",
    "        ",
    "        if not task_list:",
    "            self.total_completion = 0",
    "            return",
    "        ",
    "        for task_id, dur in task_list:",
    "            self.task_durations[task_id] = dur",
    "        ",
    "        in_degree = {task_id: 0 for task_id in self.task_durations}",
    "        for task_a, task_b in dependency_list:",
    "            self.task_graph[task_a].append(task_b)",
    "            self.prereq_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(tid for tid in self.task_durations if in_degree[tid] == 0)",
    "        processed = 0",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            processed += 1",
    "            max_prereq = max((self.completion_times[p] for p in self.prereq_graph[task]), default=0)",
    "            self.completion_times[task] = max_prereq + self.task_durations[task]",
    "            for dep in self.task_graph[task]:",
    "                in_degree[dep] -= 1",
    "                if in_degree[dep] == 0:",
    "                    queue.append(dep)",
    "        ",
    "        if processed != len(self.task_durations):",
    "            self.total_completion = -1  # Cycle detected",
    "        else:",
    "            self.total_completion = max(self.completion_times.values()) if self.completion_times else 0",
    "    ",
    "    def add_task(self, task_id: int, duration: int, prerequisites: List[int]) -> bool:",
    "        \"\"\"",
    "        Part 4: Add task dynamically. O(p) where p = len(prerequisites).",
    "        Returns False if duplicate, self-dependency, or invalid prerequisite.",
    "        \"\"\"",
    "        # Validation",
    "        if task_id in self.task_durations:",
    "            return False  # Duplicate",
    "        if task_id in prerequisites:",
    "            return False  # Self-dependency",
    "        for p in prerequisites:",
    "            if p not in self.completion_times:",
    "                return False  # Invalid prerequisite",
    "        ",
    "        # Add task to state",
    "        self.task_durations[task_id] = duration",
    "        for p in prerequisites:",
    "            self.task_graph[p].append(task_id)",
    "            self.prereq_graph[task_id].append(p)",
    "        ",
    "        # Compute completion time: O(p)",
    "        max_prereq = max((self.completion_times[p] for p in prerequisites), default=0)",
    "        self.completion_times[task_id] = max_prereq + duration",
    "        ",
    "        # Update total: O(1)",
    "        self.total_completion = max(self.total_completion, self.completion_times[task_id])",
    "        return True",
    "    ",
    "    def get_estimated_completion(self) -> int:",
    "        \"\"\"Part 4: Get total completion time. O(1).\"\"\"",
    "        return self.total_completion",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 4: Dynamic Task Addition Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    scheduler = TaskScheduler()",
    "    ",
    "    # Example 1: From problem statement",
    "    print(\"\\n--- Example 1: Basic dynamic addition ---\")",
    "    scheduler.initialize([[1, 5], [2, 3]], [[1, 2]])",
    "    print(f\"After init with 1->2: estimated = {scheduler.get_estimated_completion()}\")",
    "    print(\"Expected: 8 (task 1: 5, task 2: 5+3=8)\")",
    "    ",
    "    result = scheduler.add_task(3, 4, [1])",
    "    print(f\"add_task(3, 4, [1]) = {result}\")",
    "    print(f\"New estimated = {scheduler.get_estimated_completion()}\")",
    "    print(\"Expected: 9 (task 3: 5+4=9 > 8)\")",
    "    ",
    "    # Example 2: Chain building",
    "    print(\"\\n--- Example 2: Building a chain ---\")",
    "    scheduler.initialize([[1, 5]], [])",
    "    print(f\"Init with task 1: estimated = {scheduler.get_estimated_completion()}\")",
    "    scheduler.add_task(2, 3, [1])",
    "    print(f\"After adding 2 (dep on 1): {scheduler.get_estimated_completion()}\")",
    "    scheduler.add_task(3, 2, [2])",
    "    print(f\"After adding 3 (dep on 2): {scheduler.get_estimated_completion()}\")",
    "    print(\"Expected: 5 -> 8 -> 10\")",
    "    ",
    "    # Example 3: Validation cases",
    "    print(\"\\n--- Example 3: Validation ---\")",
    "    scheduler.initialize([[1, 5]], [])",
    "    print(f\"Duplicate task: {scheduler.add_task(1, 3, [])}  # Expected: False\")",
    "    print(f\"Self-dependency: {scheduler.add_task(2, 3, [2])}  # Expected: False\")",
    "    print(f\"Invalid prereq: {scheduler.add_task(2, 3, [99])}  # Expected: False\")",
    "    print(f\"Valid add: {scheduler.add_task(2, 3, [1])}  # Expected: True\")",
    "    ",
    "    # Example 4: Parallel paths",
    "    print(\"\\n--- Example 4: Parallel with dynamic ---\")",
    "    scheduler.initialize([[1, 10], [2, 5]], [])",
    "    print(f\"Two parallel tasks: {scheduler.get_estimated_completion()}\")",
    "    scheduler.add_task(3, 3, [1, 2])  # Depends on both",
    "    print(f\"After adding task depending on both: {scheduler.get_estimated_completion()}\")",
    "    print(\"Expected: 10 -> 13 (must wait for task 1)\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class TaskScheduler {",
    "    // Part 4 state",
    "    private Map<Integer, Integer> taskDurations = new HashMap<>();",
    "    private Map<Integer, List<Integer>> taskGraph = new HashMap<>();",
    "    private Map<Integer, List<Integer>> prereqGraph = new HashMap<>();",
    "    private Map<Integer, Integer> completionTimes = new HashMap<>();",
    "    private int totalCompletion = 0;",
    "    ",
    "    /** Part 1: Unlimited workers. Returns [totalTime, order...] or [-1] if cycle. */",
    "    public int[] scheduleTasks(int[][] taskList, int[][] dependencyList) {",
    "        if (taskList == null || taskList.length == 0) return new int[]{0};",
    "        ",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            int maxPrereq = reverseGraph.get(task).stream()",
    "                .mapToInt(completionTime::get).max().orElse(0);",
    "            completionTime.put(task, maxPrereq + duration.get(task));",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        if (order.size() != duration.size()) return new int[]{-1};",
    "        int total = Collections.max(completionTime.values());",
    "        int[] result = new int[order.size() + 1];",
    "        result[0] = total;",
    "        for (int i = 0; i < order.size(); i++) result[i + 1] = order.get(i);",
    "        return result;",
    "    }",
    "    ",
    "    /** Part 2: Schedule with k limited workers. */",
    "    public int scheduleTasksWithWorkers(int[][] taskList, int[][] dependencyList, int k) {",
    "        if (taskList == null || taskList.length == 0) return 0;",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        PriorityQueue<Integer> workerHeap = new PriorityQueue<>();",
    "        for (int i = 0; i < k; i++) workerHeap.offer(0);",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            int prereqDone = reverseGraph.get(task).stream().mapToInt(completionTime::get).max().orElse(0);",
    "            int workerFree = workerHeap.poll();",
    "            completionTime.put(task, Math.max(prereqDone, workerFree) + duration.get(task));",
    "            workerHeap.offer(completionTime.get(task));",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        if (order.size() != duration.size()) return -1;",
    "        return Collections.max(completionTime.values());",
    "    }",
    "    ",
    "    /** Part 3: Find critical path. */",
    "    public Object[] findCriticalPath(int[][] taskList, int[][] dependencyList) {",
    "        if (taskList == null || taskList.length == 0) return new Object[]{0, new int[]{}};",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        Map<Integer, Integer> predecessor = new HashMap<>();",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            int maxTime = 0;",
    "            Integer maxPred = null;",
    "            for (int p : reverseGraph.get(task)) {",
    "                if (completionTime.get(p) > maxTime) {",
    "                    maxTime = completionTime.get(p);",
    "                    maxPred = p;",
    "                }",
    "            }",
    "            predecessor.put(task, maxPred);",
    "            completionTime.put(task, maxTime + duration.get(task));",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        if (order.size() != duration.size()) return new Object[]{-1, new int[]{}};",
    "        ",
    "        int endTask = Collections.max(completionTime.entrySet(), Map.Entry.comparingByValue()).getKey();",
    "        List<Integer> path = new ArrayList<>();",
    "        Integer cur = endTask;",
    "        while (cur != null) { path.add(cur); cur = predecessor.get(cur); }",
    "        Collections.reverse(path);",
    "        return new Object[]{Collections.max(completionTime.values()), path.stream().mapToInt(i->i).toArray()};",
    "    }",
    "    ",
    "    // ==================== PART 4: Dynamic Task Addition ====================",
    "    ",
    "    /** Part 4: Initialize scheduler with tasks. O(V+E) */",
    "    public void initialize(int[][] taskList, int[][] dependencyList) {",
    "        taskDurations = new HashMap<>();",
    "        taskGraph = new HashMap<>();",
    "        prereqGraph = new HashMap<>();",
    "        completionTimes = new HashMap<>();",
    "        ",
    "        if (taskList == null || taskList.length == 0) {",
    "            totalCompletion = 0;",
    "            return;",
    "        }",
    "        ",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        for (int[] task : taskList) {",
    "            taskDurations.put(task[0], task[1]);",
    "            taskGraph.put(task[0], new ArrayList<>());",
    "            prereqGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            taskGraph.get(dep[0]).add(dep[1]);",
    "            prereqGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : taskDurations.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        int processed = 0;",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            processed++;",
    "            int maxPrereq = prereqGraph.get(task).stream().mapToInt(completionTimes::get).max().orElse(0);",
    "            completionTimes.put(task, maxPrereq + taskDurations.get(task));",
    "            for (int dep : taskGraph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        totalCompletion = (processed != taskDurations.size()) ? -1 :",
    "            completionTimes.values().stream().max(Integer::compare).orElse(0);",
    "    }",
    "    ",
    "    /** Part 4: Add task dynamically. O(p) where p = prerequisites.length */",
    "    public boolean addTask(int taskId, int duration, int[] prerequisites) {",
    "        if (taskDurations.containsKey(taskId)) return false;",
    "        for (int p : prerequisites) {",
    "            if (p == taskId || !completionTimes.containsKey(p)) return false;",
    "        }",
    "        ",
    "        taskDurations.put(taskId, duration);",
    "        taskGraph.put(taskId, new ArrayList<>());",
    "        prereqGraph.put(taskId, new ArrayList<>());",
    "        ",
    "        int maxPrereq = 0;",
    "        for (int p : prerequisites) {",
    "            taskGraph.get(p).add(taskId);",
    "            prereqGraph.get(taskId).add(p);",
    "            maxPrereq = Math.max(maxPrereq, completionTimes.get(p));",
    "        }",
    "        ",
    "        completionTimes.put(taskId, maxPrereq + duration);",
    "        totalCompletion = Math.max(totalCompletion, completionTimes.get(taskId));",
    "        return true;",
    "    }",
    "    ",
    "    /** Part 4: Get estimated completion. O(1) */",
    "    public int getEstimatedCompletion() {",
    "        return totalCompletion;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        TaskScheduler s = new TaskScheduler();",
    "        ",
    "        System.out.println(\"=== Part 4: Dynamic Task Addition ===\");",
    "        ",
    "        // Example 1",
    "        s.initialize(new int[][]{{1,5}, {2,3}}, new int[][]{{1,2}});",
    "        System.out.println(\"Init 1->2: \" + s.getEstimatedCompletion() + \" (expected 8)\");",
    "        System.out.println(\"addTask(3,4,[1]): \" + s.addTask(3, 4, new int[]{1}));",
    "        System.out.println(\"After add: \" + s.getEstimatedCompletion() + \" (expected 9)\");",
    "        ",
    "        // Example 2: chain",
    "        s.initialize(new int[][]{{1,5}}, new int[][]{});",
    "        s.addTask(2, 3, new int[]{1});",
    "        s.addTask(3, 2, new int[]{2});",
    "        System.out.println(\"\\nChain 1->2->3: \" + s.getEstimatedCompletion() + \" (expected 10)\");",
    "        ",
    "        // Validation",
    "        s.initialize(new int[][]{{1,5}}, new int[][]{});",
    "        System.out.println(\"\\nDuplicate: \" + s.addTask(1, 3, new int[]{}) + \" (expected false)\");",
    "        System.out.println(\"Self-dep: \" + s.addTask(2, 3, new int[]{2}) + \" (expected false)\");",
    "        System.out.println(\"Invalid prereq: \" + s.addTask(2, 3, new int[]{99}) + \" (expected false)\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-7 (Python)",
      "explanation": "Imports and class definition with __init__ setting up Part 4 instance state"
    },
    {
      "lines": "8-15",
      "explanation": "Instance variables for dynamic scheduling: durations, graphs, completion times, and running max"
    },
    {
      "lines": "120-145",
      "explanation": "initialize(): Reset state, build graphs, run topo sort, compute completion times, handle cycles"
    },
    {
      "lines": "147-168",
      "explanation": "add_task(): Validate (duplicate, self-dep, invalid prereq), add to state, compute completion in O(p), update max"
    },
    {
      "lines": "170-172",
      "explanation": "get_estimated_completion(): Simple O(1) return of stored max"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "initialize": {
          "complexity": "O(V + E)",
          "explanation": "Standard topological sort over all tasks and dependencies"
        },
        "add_task": {
          "complexity": "O(p)",
          "explanation": "Single pass through p prerequisites to find max and update graphs"
        },
        "get_estimated_completion": {
          "complexity": "O(1)",
          "explanation": "Return stored variable"
        }
      },
      "overall_change": "Part 4 adds amortized efficiency for dynamic updates. N add_task calls cost O(sum of all prereqs) instead of O(N*(V+E))."
    },
    "space": {
      "additional_space": "O(V + E)",
      "explanation": "Instance variables store: task_durations O(V), task_graph O(E), prereq_graph O(E), completion_times O(V), total_completion O(1)"
    }
  },
  "dry_run": {
    "example_input": "initialize([[1,5], [2,3]], [[1,2]]), then add_task(3, 4, [1])",
    "steps": [
      {
        "step": 1,
        "action": "initialize",
        "state": "task_durations={1:5, 2:3}, in_degree={1:0, 2:1}",
        "explanation": "Build initial structures"
      },
      {
        "step": 2,
        "action": "topo sort: process task 1",
        "state": "completion_times={1:5}, in_degree={2:0}",
        "explanation": "Task 1 has no prereqs, completion=0+5=5"
      },
      {
        "step": 3,
        "action": "topo sort: process task 2",
        "state": "completion_times={1:5, 2:8}",
        "explanation": "Task 2 prereq is 1, completion=5+3=8"
      },
      {
        "step": 4,
        "action": "set total_completion",
        "state": "total_completion=8",
        "explanation": "max(5,8)=8"
      },
      {
        "step": 5,
        "action": "add_task(3, 4, [1])",
        "state": "Validate: 3 not in durations, 3 not in [1], 1 exists",
        "explanation": "All validations pass"
      },
      {
        "step": 6,
        "action": "compute new task",
        "state": "completion_times[3]=5+4=9",
        "explanation": "max_prereq=completion_times[1]=5"
      },
      {
        "step": 7,
        "action": "update total",
        "state": "total_completion=max(8,9)=9",
        "explanation": "New task extends critical path"
      }
    ],
    "final_output": "get_estimated_completion() returns 9"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Empty task list returns 0",
      "Single task returns its duration",
      "add_task with no prereqs starts at time 0"
    ],
    "likely_bugs": [
      "Forgetting to add task to both graphs",
      "Not checking self-dependency",
      "Using wrong graph for prereq lookup"
    ],
    "recommended_logs_or_asserts": [
      "assert task_id not in task_durations before add",
      "log completion_times after each add_task"
    ],
    "how_to_localize": "If total_completion is wrong: 1) Check completion_times for the new task, 2) Verify max_prereq calculation, 3) Check if graphs are updated correctly"
  },
  "edge_cases": [
    {
      "case": "Empty task list",
      "handling": "total_completion=0, add_task fails (no valid prereqs)",
      "gotcha": "Don't call max() on empty dict"
    },
    {
      "case": "Duplicate task ID",
      "handling": "Return False immediately",
      "gotcha": "Check before any modifications"
    },
    {
      "case": "Self-dependency",
      "handling": "Return False if taskId in prerequisites",
      "gotcha": "Task depending on itself is a trivial cycle"
    },
    {
      "case": "Invalid prerequisite",
      "handling": "Return False if any prereq not in completion_times",
      "gotcha": "Check ALL prereqs, not just first"
    },
    {
      "case": "Cycle in initial data",
      "handling": "total_completion=-1",
      "gotcha": "add_task should probably also return False"
    },
    {
      "case": "Task with no prerequisites (after init)",
      "handling": "max_prereq defaults to 0, task starts immediately",
      "gotcha": "Use default=0 in max()"
    }
  ],
  "test_cases": [
    {
      "name": "Basic chain extension",
      "input": "init([[1,5],[2,3]], [[1,2]]), add(3,4,[2])",
      "expected": "true, completion=12 (5+3+4)",
      "explanation": "Extends existing chain"
    },
    {
      "name": "Parallel branch",
      "input": "init([[1,10],[2,5]], []), add(3,3,[1,2])",
      "expected": "true, completion=13",
      "explanation": "New task waits for longer prereq (task 1)"
    },
    {
      "name": "Multiple adds",
      "input": "init([[1,5]],[]), add(2,3,[1]), add(3,2,[1])",
      "expected": "true, true, completion=8",
      "explanation": "Two branches from task 1, longer branch wins"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Recomputing all completion times on each add",
      "why_wrong": "Violates O(p) requirement, unnecessary work",
      "correct_approach": "Only compute for new task using existing completion times",
      "code_example_wrong": "# Re-run topo sort on all tasks",
      "code_example_correct": "max_prereq = max(completion_times[p] for p in prereqs)"
    },
    {
      "mistake": "Not maintaining graph structure",
      "why_wrong": "Future operations might need the graph (e.g., Part 5)",
      "correct_approach": "Update both task_graph and prereq_graph on add_task",
      "code_example_wrong": "# Skip updating graphs, only compute completion",
      "code_example_correct": "task_graph[p].append(task_id); prereq_graph[task_id].append(p)"
    },
    {
      "mistake": "Forgetting default for max() with empty prereqs",
      "why_wrong": "max() on empty sequence raises ValueError",
      "correct_approach": "Use default=0",
      "code_example_wrong": "max(completion_times[p] for p in [])",
      "code_example_correct": "max((completion_times[p] for p in []), default=0)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Emphasize the key insight: new tasks only add incoming edges, so existing completion times are unchanged. This enables O(p) updates.",
    "what_to_mention": [
      "Storing state enables incremental updates vs batch recompute",
      "No cycle can be created when only adding tasks with prerequisites",
      "O(1) max tracking via running variable"
    ],
    "time_allocation": "2 min understand, 3 min explain approach, 8 min code, 2 min test",
    "if_stuck": [
      "Think about what changes when you add a node with only incoming edges",
      "Can existing tasks' completion times change?"
    ]
  },
  "connection_to_next_part": "Part 5 might add task removal or dependency modification, which would require more complex updates (potentially invalidating downstream tasks). The graph structure we maintain enables this.",
  "communication_script": {
    "transition_from_previous": "Part 3 computed everything in one pass. For Part 4, I need to support adding tasks after initialization. The key insight is that new tasks don't affect existing completion times.",
    "explaining_changes": "I'll add instance variables to store state between calls. initialize() does the initial topo sort. add_task() just looks up prerequisite completion times - O(p) not O(V+E).",
    "while_extending_code": [
      "Adding __init__ for Part 4 state...",
      "initialize() is similar to Part 1 but stores in instance vars...",
      "add_task() validates then computes in one prereq pass..."
    ],
    "after_completing": "Part 4 complete. initialize is O(V+E), add_task is O(p), get_estimated_completion is O(1). Ready for Part 5 if there is one."
  },
  "time_milestones": {
    "time_budget": "10-15 minutes for this part",
    "by_2_min": "Understand that dynamic = incremental, need to store state",
    "by_5_min": "Explain O(p) insight, start coding initialize()",
    "by_10_min": "Have add_task() and get_estimated_completion() done",
    "warning_signs": "If still designing at 5 min, simplify. Ask if you're overcomplicating."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 4 state is separate from Parts 1-3. If earlier parts have bugs, they don't affect Part 4 correctness.",
    "if_new_requirement_unclear": "Ask: 'Does add_task need to handle the case where initial data had a cycle?'",
    "if_running_behind": "Skip validation edge cases in code, mention verbally. Focus on the happy path."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing that new task = new leaf in DAG = no backward propagation",
      "Mentioning that graph structure is maintained for future extensibility",
      "Discussing what would change if task removal were added",
      "Noting that O(p) is achieved by leveraging stored computation"
    ]
  },
  "pattern_recognition": {
    "pattern": "Incremental Graph Update / Online Algorithm",
    "indicators": [
      "Dynamic addition",
      "Efficient per-operation complexity",
      "Don't recompute everything"
    ],
    "similar_problems": [
      "Online MST",
      "Incremental shortest paths",
      "Dynamic connectivity"
    ],
    "template": "Store computed results, new operation updates only affected portions"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'dynamic addition' with O(p) requirement, I think incremental update",
      "why": "O(V+E) per add means naive recompute, O(p) means leveraging existing work"
    },
    {
      "step": 2,
      "thought": "What can a new task affect?",
      "why": "Only things downstream, but new task has no dependents yet - it's a new leaf"
    },
    {
      "step": 3,
      "thought": "So existing completion times are stable",
      "why": "No backward propagation in DAG when adding leaf"
    },
    {
      "step": 4,
      "thought": "Just compute new task's completion from its prereqs",
      "why": "All prereqs already have computed completion times"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you transition from batch to online/incremental thinking?",
      "Do you recognize what computation can be reused?",
      "Clean code organization with state management"
    ],
    "bonus_points": [
      "Discussing amortized complexity",
      "Mentioning what would change for task removal",
      "Recognizing the pattern applies to other graph problems"
    ],
    "red_flags": [
      "Rerunning topo sort on every add_task",
      "Not validating inputs",
      "Breaking Parts 1-3 by changing their code"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with boilerplate validation code",
      "Use AI for consistent naming with previous parts"
    ],
    "what_not_to_do": [
      "Don't let AI suggest O(V+E) recompute approach",
      "Verify the O(p) complexity yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Taking too long to realize state needs to be stored",
      "Not asking about edge cases like cycles"
    ],
    "technical": [
      "Modifying Part 1-3 methods unnecessarily",
      "Using O(V) space per add_task"
    ],
    "communication": [
      "Not explaining why O(p) is achievable",
      "Forgetting to mention validation"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "initialize() handles empty input",
      "add_task() validates all three conditions (duplicate, self-dep, invalid prereq)",
      "get_estimated_completion() is truly O(1)",
      "Parts 1-3 still work unchanged"
    ],
    "quick_code_review": [
      "Instance variables properly initialized in __init__",
      "Consistent naming with existing code",
      "Type hints on new methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Thread safety if concurrent adds",
      "Logging for debugging task additions",
      "Metrics on add_task latency"
    ],
    "why_not_in_interview": "Focus on algorithm correctness and complexity",
    "how_to_mention": "Say: 'In production, I'd add locking if multiple threads could call add_task simultaneously.'"
  },
  "generated_at": "2026-01-19T05:15:26.018438",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}