{
  "problem_title": "2D Canvas / Drawing Application",
  "difficulty": "medium",
  "category": "Frontend/LLD",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **OOP Design + Geometry** problem. We need to model shapes with polymorphic behavior (each shape type has its own containment logic) and maintain z-ordering for hit testing. The pattern is common in graphics editors like Figma, MS Paint, and CAD tools.",
    "pattern_recognition": "**OOP Polymorphism** (abstract Shape with `contains()`) + **List for Z-Order** (creation order = layer order) + **Geometry Hit Testing** (point-in-rectangle, point-in-circle)",
    "key_constraints": [
      "O(1) for shape creation - just append to list, no complex processing",
      "O(n) for getShapeAt - must check each shape, but iterate newest-to-oldest for topmost",
      "Boundary points are INSIDE shapes - use <= not <",
      "Avoid sqrt for circle check - use squared distance for precision"
    ],
    "clarifying_questions": [
      "Are shape IDs auto-generated or provided by caller? \u2192 Auto-generated (rect_1, circle_1)",
      "Do boundary points count as inside? \u2192 Yes, use inclusive bounds (<=)",
      "What coordinate system? Standard or inverted Y? \u2192 Standard (Y increases downward)",
      "Can shapes have zero or negative dimensions? \u2192 No, constraints say dimensions \u2265 1",
      "Do we need to support shape deletion in Part 1? \u2192 No, that's Part 3",
      "Should circle check use floating point or integer math? \u2192 Use integer squared comparison"
    ],
    "edge_cases_to_consider": [
      "Empty canvas - getShapeAt returns null",
      "Point exactly on shape boundary - should return shape",
      "Multiple overlapping shapes - return topmost (most recently created)",
      "Point inside circle but not in any rectangle",
      "Large coordinates near 10^4 limit"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "createRectangle returns unique ID",
        "how_met": "Counter-based ID generation (rect_1, rect_2, ...)",
        "gotchas": [
          "Don't reset counter on deletion in future parts"
        ]
      },
      {
        "requirement": "createCircle returns unique ID",
        "how_met": "Separate counter for circles (circle_1, circle_2, ...)",
        "gotchas": [
          "Keep separate counters for rect and circle"
        ]
      },
      {
        "requirement": "getShapeAt returns topmost shape",
        "how_met": "Iterate shapes in reverse order (newest first)",
        "gotchas": [
          "Don't iterate forward and track - iterate backward and return early"
        ]
      },
      {
        "requirement": "Boundary points are inside",
        "how_met": "Use <= for all boundary comparisons",
        "gotchas": [
          "Easy to use < instead of <="
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "createRectangle",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "List append is O(1) amortized"
      },
      {
        "operation": "createCircle",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "List append is O(1) amortized"
      },
      {
        "operation": "getShapeAt",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Must check each shape, early exit on match"
      }
    ],
    "non_goals": [
      "Move/delete shapes (Part 2-3)",
      "Spatial indexing for sub-linear queries (advanced optimization)",
      "Undo/redo (Part 4)",
      "Shape styling/colors"
    ]
  },
  "assumptions": [
    "All coordinates and dimensions are non-negative integers",
    "Shape IDs should follow pattern rect_N and circle_N",
    "Counters are 1-indexed (first rect is rect_1, not rect_0)",
    "Canvas is conceptually infinite (no bounds checking needed)",
    "Single-threaded execution (no concurrent modifications)"
  ],
  "tradeoffs": [
    {
      "decision": "List vs HashMap for shape storage",
      "chosen": "List (ArrayList)",
      "why": "Natural z-ordering by insertion index, easy reverse iteration",
      "alternative": "LinkedHashMap for ordered storage + O(1) ID lookup",
      "when_to_switch": "If Part 2+ requires frequent ID-based lookups"
    },
    {
      "decision": "Class hierarchy vs composition",
      "chosen": "Inheritance (Shape \u2192 Rectangle/Circle)",
      "why": "Natural polymorphism for contains() method, clean design",
      "alternative": "Composition with ShapeType enum and contains function",
      "when_to_switch": "If many shape types with complex combinations"
    },
    {
      "decision": "Integer vs floating-point geometry",
      "chosen": "Integer math with squared distance",
      "why": "Avoids precision issues, faster, given integer inputs",
      "alternative": "Double with epsilon comparison",
      "when_to_switch": "If fractional coordinates are needed"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Polymorphism**: Each shape owns its contains() logic - easy to add new shapes",
      "**Encapsulation**: Shape internals hidden, Canvas manages z-ordering",
      "**Single Responsibility**: Canvas manages collection, Shapes manage geometry"
    ],
    "why_this_design_scales": "Adding new shape types (Triangle, Polygon) only requires implementing `contains()`. Z-order changes (Part 3) only modify Canvas iteration. Move operations (Part 2) only need position updates in shapes.",
    "expected_followup_hooks": [
      "Part 2 (Move): Add `moveShape(shapeId, dx, dy)` - shapes need position setters",
      "Part 3 (Delete/Z-Order): Add `deleteShape(shapeId)` - need ID\u2192Shape map",
      "Part 4 (Undo/Redo): Command pattern wrapping all operations"
    ],
    "invariants": [
      "Shapes list order equals z-order (index 0 = bottom, last = top)",
      "Shape IDs are globally unique and never reused",
      "contains() is pure function based on current position"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     CANVAS                            \u2502\n\u2502  (0,0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba X+       \u2502\n\u2502    \u2502                                                  \u2502\n\u2502    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                               \u2502\n\u2502    \u2502   \u2502   rect_1    \u2502      \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e             \u2502\n\u2502    \u2502   \u2502  (10,10)    \u2502      \u2502 circle_1 \u2502             \u2502\n\u2502    \u2502   \u2502   40x30     \u2502      \u2502 (60,30)  \u2502             \u2502\n\u2502    \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502  r=20    \u2502             \u2502\n\u2502    \u2502                        \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f             \u2502\n\u2502    \u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n\u2502    \u2502        \u2502      rect_2        \u2502 \u2190 Created later   \u2502\n\u2502    \u2502        \u2502     (30,25)        \u2502   (ON TOP)        \u2502\n\u2502    \u2502        \u2502      50x40         \u2502                   \u2502\n\u2502    \u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2502    \u2502                                                  \u2502\n\u2502    \u25bc Y+                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nZ-ORDER STACK (bottom to top):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  rect_2   \u2502 \u2190 Index 2 (TOP - checked first)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 circle_1  \u2502 \u2190 Index 1\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  rect_1   \u2502 \u2190 Index 0 (BOTTOM - checked last)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\nAfter: createRectangle(10,10,40,30), createCircle(60,30,20), createRectangle(30,25,50,40)\n\nshapes: List<Shape>\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [0] \u2502 Rectangle(id=\"rect_1\", x=10, y=10, w=40, h=30) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1] \u2502 Circle(id=\"circle_1\", cx=60, cy=30, r=20)    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [2] \u2502 Rectangle(id=\"rect_2\", x=30, y=25, w=50, h=40) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCounters: rect_count=2, circle_count=1\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "createRectangle(10, 10, 40, 30)",
        "visualization": "```\nrect_count: 0 \u2192 1\nid = \"rect_1\"\nshapes: [] \u2192 [Rectangle(rect_1, 10, 10, 40, 30)]\n```",
        "key_point": "Increment counter BEFORE creating ID"
      },
      {
        "step": 2,
        "description": "getShapeAt(35, 30) with overlapping shapes",
        "visualization": "```\nIterate REVERSE: [2] \u2192 [1] \u2192 [0]\n\n[2] rect_2: (30,25,50,40)\n    30 \u2264 35 \u2264 80? YES\n    25 \u2264 30 \u2264 65? YES\n    \u2192 CONTAINS! Return \"rect_2\" immediately\n\n[1] circle_1: Never checked\n[0] rect_1: Never checked\n```",
        "key_point": "Reverse iteration + early return = topmost shape"
      }
    ],
    "dry_run_table": "| Step | Operation | Action | shapes List | rect_count | circle_count | Result |\n|------|-----------|--------|-------------|------------|--------------|--------|\n| 1 | Canvas() | Initialize | [] | 0 | 0 | null |\n| 2 | createRectangle(0,0,50,50) | Add rect | [R1] | 1 | 0 | \"rect_1\" |\n| 3 | createRectangle(25,25,50,50) | Add rect | [R1,R2] | 2 | 0 | \"rect_2\" |\n| 4 | getShapeAt(30,30) | Check R2\u2192R1 | - | - | - | \"rect_2\" |\n| 5 | getShapeAt(10,10) | Check R2(no)\u2192R1(yes) | - | - | - | \"rect_1\" |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'shapes on canvas'**, I think of OOP with polymorphism - each shape type should know how to check if it contains a point",
      "**When I see 'topmost shape'**, I think of z-ordering - need to maintain creation order and iterate newest-first",
      "**The key insight**: Store shapes in a list (natural z-order), iterate in reverse for getShapeAt to find topmost first",
      "**For hit testing**: Rectangle is simple bounds check with <=. Circle uses squared distance to avoid sqrt precision issues",
      "**I should use polymorphism** because adding new shape types (triangles, polygons) should only require implementing `contains()`"
    ],
    "key_insight": "**Reverse iteration gives us O(1) for common case** - when user clicks, they usually click on a visible (top) shape. By checking newest-first, we return early most of the time.",
    "why_this_works": "The list maintains insertion order = z-order. Shapes at higher indices were created later, so they're 'on top'. Reverse iteration from the end finds the topmost shape first."
  },
  "approaches": [
    {
      "name": "Brute Force - Forward Iteration with Tracking",
      "description": "Iterate through all shapes, track the last one that contains the point",
      "pseudocode": "def get_shape_at(x, y):\n    result = None\n    for shape in shapes:  # Forward\n        if shape.contains(x, y):\n            result = shape  # Keep updating\n    return result",
      "time_complexity": "O(n) - always checks ALL shapes",
      "space_complexity": "O(1)",
      "pros": [
        "Simple logic",
        "Easy to understand"
      ],
      "cons": [
        "Always O(n) even if topmost shape is last",
        "Unnecessary checks"
      ],
      "when_to_use": "Never - reverse iteration is strictly better"
    },
    {
      "name": "Optimal: Reverse Iteration with Early Return",
      "description": "Iterate from newest to oldest, return immediately on first match",
      "pseudocode": "def get_shape_at(x, y):\n    for shape in reversed(shapes):  # Newest first\n        if shape.contains(x, y):\n            return shape.id  # Early exit!\n    return None",
      "time_complexity": "O(n) worst case, O(1) best case",
      "space_complexity": "O(1)",
      "pros": [
        "Early exit for common case",
        "Clean logic",
        "Matches user expectation"
      ],
      "cons": [
        "Still O(n) if point is in bottom shape only"
      ],
      "key_insight": "Users typically click on visible (top) shapes, so checking top-first is practically faster"
    }
  ],
  "optimal_solution": {
    "name": "Polymorphic Shapes with Reverse Z-Order Iteration",
    "explanation_md": "## Approach\n\nWe use **OOP polymorphism** with an abstract `Shape` class that each shape type extends. Each shape implements its own `contains(x, y)` method.\n\n### Key Design Decisions\n\n1. **List for Z-Ordering**: Shapes stored in creation order. Index 0 = bottom, last = top.\n\n2. **Reverse Iteration**: For `getShapeAt()`, we iterate from end to start, returning the first match. This gives us the topmost shape.\n\n3. **Integer Math for Circles**: Instead of `sqrt(dx\u00b2 + dy\u00b2) <= r`, we use `dx\u00b2 + dy\u00b2 <= r\u00b2`. Avoids floating-point precision issues.\n\n### Why This Works\n\n- **Polymorphism**: Adding a new shape (e.g., Triangle) only requires implementing `contains()`\n- **Encapsulation**: Canvas manages collection, shapes manage their own geometry\n- **Efficient hit testing**: Early return on first match",
    "data_structures": [
      {
        "structure": "List<Shape> shapes",
        "purpose": "Maintains z-order by insertion order"
      },
      {
        "structure": "int rectCount, circleCount",
        "purpose": "Generate unique IDs (rect_1, rect_2, circle_1, ...)"
      },
      {
        "structure": "Abstract Shape class",
        "purpose": "Polymorphic contains() for hit testing"
      }
    ],
    "algorithm_steps": [
      "1. **createRectangle**: Increment rect counter, create Rectangle, append to list, return ID",
      "2. **createCircle**: Increment circle counter, create Circle, append to list, return ID",
      "3. **getShapeAt**: Iterate shapes in REVERSE, return first shape where contains(x,y) is true",
      "4. **Rectangle.contains**: Check x \u2264 px \u2264 x+width AND y \u2264 py \u2264 y+height",
      "5. **Circle.contains**: Check (px-cx)\u00b2 + (py-cy)\u00b2 \u2264 r\u00b2"
    ],
    "why_decimal": "Not needed here - all inputs are integers and we use squared comparison for circles"
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all shapes on the canvas.\"\"\"",
    "    def __init__(self, shape_id: str):",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains(self, x: int, y: int) -> bool:",
    "        \"\"\"Check if point (x, y) is inside this shape (boundary inclusive).\"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"Rectangle defined by top-left corner and dimensions.\"\"\"",
    "    def __init__(self, shape_id: str, x: int, y: int, width: int, height: int):",
    "        super().__init__(shape_id)",
    "        self.x, self.y = x, y",
    "        self.width, self.height = width, height",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        # Boundary inclusive: use <=",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"Circle defined by center and radius.\"\"\"",
    "    def __init__(self, shape_id: str, center_x: int, center_y: int, radius: int):",
    "        super().__init__(shape_id)",
    "        self.cx, self.cy = center_x, center_y",
    "        self.radius = radius",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        # Use squared distance to avoid sqrt precision issues",
    "        dx, dy = px - self.cx, py - self.cy",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "",
    "",
    "class Canvas:",
    "    \"\"\"2D drawing canvas supporting shape creation and hit testing.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.shapes: List[Shape] = []  # Maintains z-order",
    "        self.rect_count = 0",
    "        self.circle_count = 0",
    "    ",
    "    def create_rectangle(self, x: int, y: int, width: int, height: int) -> str:",
    "        \"\"\"Create rectangle at (x,y) with given dimensions. O(1).\"\"\"",
    "        self.rect_count += 1",
    "        shape_id = f\"rect_{self.rect_count}\"",
    "        self.shapes.append(Rectangle(shape_id, x, y, width, height))",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: int, center_y: int, radius: int) -> str:",
    "        \"\"\"Create circle at center with given radius. O(1).\"\"\"",
    "        self.circle_count += 1",
    "        shape_id = f\"circle_{self.circle_count}\"",
    "        self.shapes.append(Circle(shape_id, center_x, center_y, radius))",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: int, y: int) -> Optional[str]:",
    "        \"\"\"Return topmost shape at point, or None. O(n).\"\"\"",
    "        # Iterate in reverse for z-order (newest = topmost)",
    "        for shape in reversed(self.shapes):",
    "            if shape.contains(x, y):",
    "                return shape.id",
    "        return None",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"TEST 1: Basic Shape Creation and Query\")",
    "    print(\"=\" * 60)",
    "    canvas = Canvas()",
    "    print(f\"createRectangle(10,10,40,30) -> {canvas.create_rectangle(10, 10, 40, 30)}\")",
    "    print(f\"createCircle(60,30,20) -> {canvas.create_circle(60, 30, 20)}\")",
    "    print(f\"getShapeAt(25,25) -> {canvas.get_shape_at(25, 25)}  (inside rect)\")",
    "    print(f\"getShapeAt(60,30) -> {canvas.get_shape_at(60, 30)}  (circle center)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 2: Overlapping Shapes - Topmost Wins\")",
    "    print(\"=\" * 60)",
    "    canvas2 = Canvas()",
    "    canvas2.create_rectangle(0, 0, 50, 50)   # rect_1 (bottom)",
    "    canvas2.create_rectangle(25, 25, 50, 50) # rect_2 (top)",
    "    print(f\"getShapeAt(30,30) -> {canvas2.get_shape_at(30, 30)}  (overlap: rect_2 wins)\")",
    "    print(f\"getShapeAt(10,10) -> {canvas2.get_shape_at(10, 10)}  (only rect_1)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 3: Circle Boundary Precision\")",
    "    print(\"=\" * 60)",
    "    canvas3 = Canvas()",
    "    canvas3.create_circle(0, 0, 5)  # Circle at origin, radius 5",
    "    print(f\"getShapeAt(3,4) -> {canvas3.get_shape_at(3, 4)}  (distance=5, ON boundary)\")",
    "    print(f\"getShapeAt(4,4) -> {canvas3.get_shape_at(4, 4)}  (distance=5.66, outside)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 4: Empty Point\")",
    "    print(\"=\" * 60)",
    "    print(f\"getShapeAt(1000,1000) -> {canvas.get_shape_at(1000, 1000)}  (no shape)\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "abstract class Shape {",
    "    protected String id;",
    "    ",
    "    public Shape(String id) { this.id = id; }",
    "    public String getId() { return id; }",
    "    public abstract boolean contains(int x, int y);",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private int x, y, width, height;",
    "    ",
    "    public Rectangle(String id, int x, int y, int width, int height) {",
    "        super(id);",
    "        this.x = x; this.y = y;",
    "        this.width = width; this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        return x <= px && px <= x + width && y <= py && py <= y + height;",
    "    }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private int cx, cy, radius;",
    "    ",
    "    public Circle(String id, int cx, int cy, int radius) {",
    "        super(id);",
    "        this.cx = cx; this.cy = cy; this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        long dx = px - cx, dy = py - cy;  // Use long to avoid overflow",
    "        return dx * dx + dy * dy <= (long) radius * radius;",
    "    }",
    "}",
    "",
    "public class Canvas {",
    "    private List<Shape> shapes = new ArrayList<>();",
    "    private int rectCount = 0, circleCount = 0;",
    "    ",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        String id = \"rect_\" + (++rectCount);",
    "        shapes.add(new Rectangle(id, x, y, width, height));",
    "        return id;",
    "    }",
    "    ",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        String id = \"circle_\" + (++circleCount);",
    "        shapes.add(new Circle(id, centerX, centerY, radius));",
    "        return id;",
    "    }",
    "    ",
    "    public String getShapeAt(int x, int y) {",
    "        // Iterate reverse for z-order (topmost first)",
    "        for (int i = shapes.size() - 1; i >= 0; i--) {",
    "            if (shapes.get(i).contains(x, y)) {",
    "                return shapes.get(i).getId();",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"TEST 1: Basic Shape Creation and Query\");",
    "        Canvas canvas = new Canvas();",
    "        System.out.println(\"createRectangle(10,10,40,30) -> \" + canvas.createRectangle(10, 10, 40, 30));",
    "        System.out.println(\"createCircle(60,30,20) -> \" + canvas.createCircle(60, 30, 20));",
    "        System.out.println(\"getShapeAt(25,25) -> \" + canvas.getShapeAt(25, 25));",
    "        System.out.println(\"getShapeAt(60,30) -> \" + canvas.getShapeAt(60, 30));",
    "        ",
    "        System.out.println(\"\\nTEST 2: Overlapping Shapes\");",
    "        Canvas canvas2 = new Canvas();",
    "        canvas2.createRectangle(0, 0, 50, 50);",
    "        canvas2.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"getShapeAt(30,30) -> \" + canvas2.getShapeAt(30, 30) + \" (rect_2 on top)\");",
    "        System.out.println(\"getShapeAt(10,10) -> \" + canvas2.getShapeAt(10, 10) + \" (only rect_1)\");",
    "        ",
    "        System.out.println(\"\\nTEST 3: Circle Boundary\");",
    "        Canvas canvas3 = new Canvas();",
    "        canvas3.createCircle(0, 0, 5);",
    "        System.out.println(\"getShapeAt(3,4) -> \" + canvas3.getShapeAt(3, 4) + \" (on boundary, d=5)\");",
    "        System.out.println(\"getShapeAt(4,4) -> \" + canvas3.getShapeAt(4, 4) + \" (outside, d=5.66)\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-13",
      "section": "Shape Abstract Base Class",
      "explanation": "Defines the contract all shapes must follow. The `contains(x, y)` method is abstract - each shape type implements its own hit testing logic. This is **polymorphism** in action."
    },
    {
      "lines": "16-26",
      "section": "Rectangle Class",
      "explanation": "Stores top-left corner (x, y) and dimensions. The `contains()` check uses **inclusive bounds** (<=) because boundary points are inside. Note: `x + width` is the right edge, `y + height` is the bottom edge."
    },
    {
      "lines": "29-39",
      "section": "Circle Class",
      "explanation": "Stores center (cx, cy) and radius. **Key insight**: We use `dx\u00b2 + dy\u00b2 <= r\u00b2` instead of `sqrt(dx\u00b2 + dy\u00b2) <= r` to avoid floating-point precision issues. This is a common interview gotcha!"
    },
    {
      "lines": "42-52",
      "section": "Canvas Initialization and Counters",
      "explanation": "The shapes list maintains **z-order** by insertion order. Separate counters for rectangles and circles generate unique IDs (rect_1, rect_2, circle_1, etc.)."
    },
    {
      "lines": "54-64",
      "section": "Shape Creation Methods",
      "explanation": "Both methods follow the same pattern: (1) increment counter, (2) generate ID, (3) create shape, (4) append to list, (5) return ID. All O(1) operations."
    },
    {
      "lines": "66-72",
      "section": "Hit Testing - getShapeAt",
      "explanation": "The **critical insight**: `reversed(self.shapes)` iterates from newest to oldest. The first shape that contains the point is the topmost one, so we return immediately. This is O(n) worst case but O(1) for the common case."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test Rectangle.contains() in isolation with boundary cases. 2. Test Circle.contains() with exact boundary distance. 3. Test Canvas with single shape. 4. Test overlapping shapes.",
    "what_to_print_or_assert": [
      "print(f'Checking shape {shape.id}: contains({x},{y}) = {shape.contains(x,y)}')",
      "assert canvas.get_shape_at(center_x, center_y) == circle_id  # Center must be inside",
      "assert canvas.get_shape_at(-1000, -1000) is None  # Empty point"
    ],
    "common_failure_modes": [
      "Using < instead of <= (boundary not included)",
      "Iterating forward instead of reversed (wrong z-order)",
      "Using sqrt for circle check (precision issues)",
      "Integer overflow in Java for large coordinates (use long)"
    ],
    "how_to_fix_fast": "If wrong shape returned: add debug print to show which shapes contain the point and their order. If boundary fails: verify <= vs <. If circle fails: print squared distance vs r\u00b2."
  },
  "complexity_analysis": {
    "time": {
      "create_rectangle": {
        "complexity": "O(1)",
        "explanation": "Counter increment + object creation + list append"
      },
      "create_circle": {
        "complexity": "O(1)",
        "explanation": "Same as rectangle - all constant time operations"
      },
      "get_shape_at": {
        "complexity": "O(n)",
        "explanation": "Worst case checks all n shapes. Best case O(1) if topmost shape contains point."
      },
      "overall": "Shape creation O(1), hit testing O(n)"
    },
    "space": {
      "complexity": "O(n) where n = number of shapes",
      "breakdown": "- shapes list: O(n) Shape references\n- Each Shape: O(1) fixed fields\n- Counters: O(1)",
      "note": "No additional data structures needed for Part 1"
    },
    "can_we_do_better": "**Yes, with spatial indexing** (Quadtree, R-tree) we could achieve O(log n) for getShapeAt, but that's over-engineering for this problem. The O(n) solution is expected and meets requirements."
  },
  "dry_run": {
    "example": "createRectangle(0,0,50,50), createCircle(50,50,30), createRectangle(25,25,50,50), getShapeAt(40,40)",
    "trace_table": "| Step | Operation | shapes List | Counters | Result |\n|------|-----------|-------------|----------|--------|\n| 1 | createRectangle(0,0,50,50) | [R(0,0,50,50)] | rect=1, circ=0 | \"rect_1\" |\n| 2 | createCircle(50,50,30) | [R, C(50,50,30)] | rect=1, circ=1 | \"circle_1\" |\n| 3 | createRectangle(25,25,50,50) | [R, C, R2(25,25,50,50)] | rect=2, circ=1 | \"rect_2\" |\n| 4 | getShapeAt(40,40) | Check R2: 25\u226440\u226475, 25\u226440\u226475 \u2713 | - | \"rect_2\" |\n\n**Detail for step 4:**\n- Iterate from index 2 \u2192 0\n- [2] rect_2: contains(40,40)? 25\u226440\u226475 AND 25\u226440\u226475 \u2192 **YES** \u2192 return \"rect_2\"\n- Never check circle_1 or rect_1 (early exit)",
    "final_answer": "rect_2"
  },
  "test_cases": [
    {
      "name": "Single rectangle - point inside",
      "category": "Happy Path",
      "input": "createRectangle(10,10,40,30), getShapeAt(25,25)",
      "expected": "rect_1",
      "explanation": "10\u226425\u226450, 10\u226425\u226440 \u2192 inside"
    },
    {
      "name": "Rectangle boundary - all corners",
      "category": "Edge Case",
      "input": "createRectangle(0,0,100,100), getShapeAt(0,0), getShapeAt(100,100)",
      "expected": "rect_1 for both",
      "explanation": "Boundary points are inside (inclusive bounds)"
    },
    {
      "name": "Circle center",
      "category": "Happy Path",
      "input": "createCircle(50,50,20), getShapeAt(50,50)",
      "expected": "circle_1",
      "explanation": "Distance 0 \u2264 20"
    },
    {
      "name": "Circle boundary - Pythagorean triple",
      "category": "Precision",
      "input": "createCircle(0,0,5), getShapeAt(3,4)",
      "expected": "circle_1",
      "explanation": "3\u00b2 + 4\u00b2 = 25 = 5\u00b2. Exactly on boundary \u2192 inside"
    },
    {
      "name": "Circle just outside",
      "category": "Edge Case",
      "input": "createCircle(0,0,5), getShapeAt(4,4)",
      "expected": "null",
      "explanation": "4\u00b2 + 4\u00b2 = 32 > 25. Just outside"
    },
    {
      "name": "Overlapping - topmost wins",
      "category": "Z-Order",
      "input": "createRectangle(0,0,50,50), createRectangle(25,25,50,50), getShapeAt(30,30)",
      "expected": "rect_2",
      "explanation": "Both contain (30,30), but rect_2 created later = on top"
    },
    {
      "name": "Empty canvas",
      "category": "Edge Case",
      "input": "getShapeAt(50,50) on new Canvas",
      "expected": "null",
      "explanation": "No shapes exist"
    },
    {
      "name": "Point outside all shapes",
      "category": "Edge Case",
      "input": "createRectangle(0,0,10,10), getShapeAt(1000,1000)",
      "expected": "null",
      "explanation": "No shape contains this distant point"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using < instead of <= for boundaries",
      "why_wrong": "Problem states boundary points are INSIDE",
      "correct_approach": "Use inclusive bounds: x <= px <= x + width",
      "code_wrong": "return self.x < px < self.x + self.width",
      "code_correct": "return self.x <= px <= self.x + self.width"
    },
    {
      "mistake": "Forward iteration for z-order",
      "why_wrong": "Returns bottom shape instead of topmost",
      "correct_approach": "Iterate in REVERSE order",
      "code_wrong": "for shape in self.shapes:  # Returns first, not topmost",
      "code_correct": "for shape in reversed(self.shapes):  # Returns topmost"
    },
    {
      "mistake": "Using sqrt for circle containment",
      "why_wrong": "Floating-point precision issues, also slower",
      "correct_approach": "Compare squared distances",
      "code_wrong": "math.sqrt(dx*dx + dy*dy) <= self.radius",
      "code_correct": "dx*dx + dy*dy <= self.radius * self.radius"
    },
    {
      "mistake": "Integer overflow in Java",
      "why_wrong": "dx*dx can overflow int for large coordinates",
      "correct_approach": "Cast to long before multiplication",
      "code_wrong": "int distSq = dx * dx + dy * dy;",
      "code_correct": "long distSq = (long)dx * dx + (long)dy * dy;"
    },
    {
      "mistake": "Storing ID counters as strings",
      "why_wrong": "Harder to increment and maintain",
      "correct_approach": "Use integer counters, format ID on creation",
      "code_wrong": "self.rect_id = 'rect_1'  # How to increment?",
      "code_correct": "self.rect_count = 0  # Increment and format"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. I see it's about building a canvas for shape management - similar to what you'd find in tools like Figma or MS Paint. Before I start coding, let me ask a few clarifying questions...",
    "clarifying_questions_to_ask": [
      "Are boundary points considered inside shapes? (Yes - use <=)",
      "How should I generate shape IDs? (rect_1, rect_2, circle_1, ...)",
      "What should getShapeAt return for an empty point? (null/None)",
      "Should I use floating point or integer math for geometry? (Integer is fine)"
    ],
    "what_to_mention_proactively": [
      "I'll use polymorphism with an abstract Shape class for extensibility",
      "For z-ordering, I'll maintain shapes in a list by creation order",
      "I'll iterate in reverse for getShapeAt to find the topmost shape first",
      "For circles, I'll use squared distance comparison to avoid sqrt precision issues"
    ],
    "communication_during_coding": [
      "I'm creating an abstract base class Shape with a contains() method that each shape type will override",
      "Rectangle containment: checking if x \u2264 px \u2264 x+width AND y \u2264 py \u2264 y+height",
      "Circle containment: using dx\u00b2 + dy\u00b2 \u2264 r\u00b2 to avoid floating point issues",
      "In getShapeAt, I'm iterating reversed because shapes at the end were created later and are on top"
    ],
    "if_stuck": [
      "Step back: 'Let me think about what data structures maintain insertion order...'",
      "Simplify: 'Let me solve just rectangles first, then add circles'",
      "Ask: 'Can I assume the coordinate system has Y increasing downward?'"
    ],
    "time_management": "0-5min: Understand & clarify | 5-10min: Design classes | 10-25min: Code | 25-35min: Test & fix | 35-45min: Part 2"
  },
  "pattern_recognition": {
    "pattern_name": "OOP Polymorphism + List Z-Ordering",
    "indicators": [
      "Multiple entity types with shared behavior (shapes with contains())",
      "Layering/ordering requirement (z-order = creation order)",
      "Hit testing / point containment queries"
    ],
    "similar_problems": [
      "LC 850 - Rectangle Area II: Managing overlapping rectangles",
      "LC 223 - Rectangle Area: Geometric intersection",
      "Design Autocomplete System: Ranked results with polymorphic behavior",
      "Design File System: Hierarchical structure with polymorphism"
    ],
    "template": "Abstract base class with common interface \u2192 Concrete implementations with specific logic \u2192 Container manages collection and queries"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Move Shape**: Add `moveShape(shapeId, dx, dy)`. Need HashMap<id, Shape> for O(1) lookup. Shapes need setter methods for position.",
    "part_3_hint": "**Delete Shape**: Need to remove from list. Consider using LinkedHashMap or tracking deletion differently. Z-order control may need swap/reorder.",
    "data_structure_evolution": "Part 1: List<Shape> \u2192 Part 2: Add Map<id, Shape> \u2192 Part 3: Consider explicit z-index field"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. It's about building a 2D canvas like Figma or MS Paint. Before I dive in, I want to clarify a few things and share my initial approach.",
    "after_clarification": "Great, so to summarize: I need to support rectangles and circles, boundary points are inside, and later shapes are on top for z-ordering. My approach will use polymorphism with an abstract Shape class and a list to maintain z-order. I'll iterate in reverse for hit testing. Does that sound reasonable?",
    "while_coding": [
      "I'm starting with the Shape abstract class to define the common interface...",
      "For Rectangle, I'm using inclusive bounds - note the <= not <...",
      "For Circle, I'm using squared distance to avoid sqrt precision issues...",
      "In getShapeAt, I'm iterating reversed so topmost shapes are checked first..."
    ],
    "after_coding": "Let me trace through the overlapping example to verify this works correctly...",
    "when_stuck_verbatim": "I'm thinking about the best way to handle z-ordering... Let me consider how the list order relates to visual layering...",
    "after_mistake": "Ah, I see the issue - I used < instead of <=. Let me fix that since boundary points should be inside.",
    "before_moving_on": "Part 1 is complete. Time and space are O(1) for creation, O(n) for queries. Ready for Part 2 about moving shapes?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you model the domain with appropriate OOP design?",
      "Do you understand coordinate geometry and hit testing?",
      "Can you handle the z-ordering requirement correctly?",
      "Do you catch precision issues (sqrt vs squared)?",
      "Can you communicate your approach clearly?"
    ],
    "bonus_points": [
      "Mentioning squared distance for circles before being prompted",
      "Drawing a quick coordinate diagram",
      "Identifying boundary conditions (<=) immediately",
      "Proactively testing edge cases",
      "Clean code with meaningful method names"
    ],
    "red_flags": [
      "Not clarifying boundary inclusion",
      "Iterating forward and tracking last match (inefficient)",
      "Using sqrt for circle check (precision)",
      "Forgetting null return for empty canvas",
      "Hardcoding shape IDs instead of using counters"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize this as an OOP design problem, draw a quick diagram, identify the z-order insight (reverse iteration), and mention the sqrt precision issue for circles. They test their code with boundary cases and overlapping shapes."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions (boundaries? IDs? coordinate system?)",
    "by_10_min": "Explain approach: abstract Shape class, list for z-order, reverse iteration",
    "by_20_min": "Shape classes implemented, Canvas creation methods done",
    "by_25_min": "getShapeAt implemented with reverse iteration",
    "by_30_min": "Testing complete, edge cases verified, ready for Part 2",
    "warning_signs": "If still discussing approach at 15 min, speed up. If still coding at 35 min, you're behind."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Say: 'Actually, I see an issue - I used < instead of <=. The problem says boundaries are inside, so let me fix that.' Stay calm, fix it, move on.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for abstract classes in Python, but I need a base class with a method that subclasses must implement. Let me write it approximately.'",
    "when_approach_is_wrong": "Say: 'Wait, iterating forward won't work because I need the topmost shape, not the first. Let me reverse the iteration.'",
    "when_completely_stuck": "Say: 'I'm stuck on how to determine which shape is on top. Could you give me a hint about z-ordering?' It's okay to ask.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on the core hit testing logic and explain what I'd add for edge cases.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "AI tools can scaffold the class structure quickly. Use them for boilerplate but understand every line.",
    "what_to_do": [
      "Let AI generate the abstract class structure",
      "Use AI for syntax (e.g., Python ABC import)",
      "Accept obvious completions (return statements, simple math)"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and accept the solution",
      "Don't accept contains() implementation without verifying boundary logic",
      "Don't let AI choose forward vs reverse iteration - you decide"
    ],
    "how_to_demonstrate_understanding": "If AI suggests code, explain WHY it works: 'The AI generated squared distance comparison, which is correct because it avoids sqrt precision issues.'",
    "expectation_adjustment": "With AI tools, you should complete Part 1 in 20 minutes, leaving time for Parts 2-3."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing a coordinate diagram unprompted",
      "Immediately mentioning squared distance for circles",
      "Asking about boundary inclusion before coding",
      "Testing with Pythagorean triple (3,4,5) for circle boundary",
      "Mentioning this is similar to Figma/CAD architecture"
    ],
    "subtle_signals_of_experience": [
      "Using descriptive variable names (px, py for point, cx, cy for center)",
      "Separating shape logic from canvas logic (single responsibility)",
      "Thinking about extensibility ('if we add triangles later...')",
      "Testing incrementally, not just at the end"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Coding silently for more than 2 minutes",
      "Getting defensive when boundary bug is pointed out",
      "Not testing with overlapping shapes",
      "Rushing without explaining approach"
    ],
    "technical": [
      "Using sqrt for circle check (precision issues)",
      "Exclusive bounds (< instead of <=)",
      "Forward iteration (returns bottom shape, not top)",
      "Forgetting to handle empty canvas case"
    ],
    "communication": [
      "Not drawing any diagram",
      "Using 'it just works' instead of explaining why",
      "Not asking any clarifying questions",
      "Ignoring interviewer's hints"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2705 Rectangle containment uses inclusive bounds (<=)",
      "\u2705 Circle containment uses squared distance (no sqrt)",
      "\u2705 getShapeAt iterates in REVERSE order",
      "\u2705 Empty canvas returns null/None",
      "\u2705 Tested with overlapping shapes",
      "\u2705 Tested boundary points",
      "\u2705 Explained time and space complexity"
    ],
    "quick_code_review": [
      "No magic numbers (except the obvious +1 for counter)",
      "Consistent naming (x,y for rectangle corner, cx,cy for circle center)",
      "Contains method is clean and readable",
      "ID generation is correct (rect_1, rect_2, circle_1)"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation (negative dimensions, null checks)",
      "Spatial indexing (Quadtree) for large canvases with many shapes",
      "Thread-safety for concurrent shape creation",
      "Event system for shape changes (observer pattern)",
      "Serialization for save/load functionality"
    ],
    "why_not_in_interview": "Keep interview code focused on the core algorithm. Mention these verbally to show production awareness.",
    "how_to_mention": "Say: 'In production, I'd add a Quadtree for O(log n) hit testing with thousands of shapes, but for this interview the O(n) solution is appropriate.'"
  },
  "generated_at": "2026-01-19T03:58:19.916549",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}