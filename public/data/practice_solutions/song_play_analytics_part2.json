{
  "problem_title": "Song Play Analytics System - Part 2: Recent Plays (With Duplicates)",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 tracked UNIQUE listeners per song (deduplicating plays). Part 2 adds a new requirement: track the FULL play history with duplicates, so we can answer 'what were the N most recent plays?'. This requires a completely separate data structure from the Set-based listener tracking.",
    "new_requirements": [
      "Track every play event in chronological order (duplicates allowed)",
      "Return most recent N plays in reverse chronological order (newest first)",
      "Return song names, not IDs",
      "Handle case where fewer than N plays exist gracefully"
    ],
    "new_constraints": [
      "Must maintain O(1) for play_song",
      "get_recent_plays should be O(count)"
    ],
    "key_insight": "The existing Set-based listener tracking is for UNIQUE users per song. For recent plays with duplicates, we need a separate List that appends EVERY valid play. Two parallel data structures serving different purposes."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Track play history with duplicates",
        "how_met": "New `recent_plays` List[str] that appends song name on every valid play",
        "gotchas": [
          "Only append on VALID plays (after song existence check)",
          "Store name not ID to avoid lookup later"
        ]
      },
      {
        "requirement": "Return in reverse chronological order",
        "how_met": "Slice from end of list, then reverse the slice",
        "gotchas": [
          "Don't reverse in-place, return a new list",
          "Slice with [-count:] handles count > size gracefully"
        ]
      },
      {
        "requirement": "Handle fewer plays than requested",
        "how_met": "Python slice [-count:] returns up to count elements, never fails",
        "gotchas": [
          "Don't throw exception for count > size"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "play_song",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "List append is O(1) amortized"
      },
      {
        "operation": "get_recent_plays",
        "target": "O(count)",
        "achieved": "O(count)",
        "why": "Slice and reverse of count elements"
      }
    ],
    "non_goals": [
      "Limiting history size (unbounded growth)",
      "Filtering by user or time range",
      "Efficient removal of old plays"
    ]
  },
  "assumptions": [
    "Play history can grow unbounded (no limit on total plays)",
    "count parameter is non-negative (0 or positive)",
    "Memory is sufficient to store all play events",
    "No need to persist history across restarts"
  ],
  "tradeoffs": [
    {
      "decision": "Store song names vs song IDs in history",
      "chosen": "Store names directly",
      "why": "Avoid O(1) lookup per item in get_recent_plays; names are immutable anyway",
      "alternative": "Store IDs and lookup names",
      "when_to_switch": "If songs could be renamed, storing IDs would be safer"
    },
    {
      "decision": "List vs Deque for history",
      "chosen": "Simple List/ArrayList",
      "why": "Both have O(1) append; List is simpler and sufficient since we never remove from front",
      "alternative": "Deque with max size",
      "when_to_switch": "If we needed to limit history to last N plays to bound memory"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Song class (unchanged)",
      "All Part 1 method signatures",
      "HashMap for song lookup"
    ],
    "what_to_change": [
      "Added recent_plays list to SongAnalytics",
      "Modified play_song to also append to history"
    ],
    "interfaces_and_boundaries": "recent_plays is private implementation detail; public API is get_recent_plays(count)",
    "invariants": [
      "recent_plays.length == total number of valid play_song calls",
      "recent_plays contains only names of songs that existed at play time",
      "Order in recent_plays matches chronological play order"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1 only):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 songs: {1: Song(A), 2: Song(B)}         \u2502\n\u2502   Song A: listeners = {1, 2}            \u2502\n\u2502   Song B: listeners = {1}               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 2 added):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 songs: {1: Song(A), 2: Song(B)}         \u2502\n\u2502   Song A: listeners = {1, 2}            \u2502  \u2190 Same as before\n\u2502   Song B: listeners = {1}               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 recent_plays: [A, B, A, A]              \u2502  \u2190 NEW! All plays\n\u2502                \u2191        \u2191               \u2502\n\u2502             oldest   newest             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nget_recent_plays(3):\n\nrecent_plays = [\"A\", \"B\", \"A\", \"A\"]\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        last 3: [\"B\", \"A\", \"A\"]\n                        reverse: [\"A\", \"A\", \"B\"]\n                                  \u2193\n                        return [\"A\", \"A\", \"B\"]\n```"
  },
  "approaches": [
    {
      "name": "Naive: Iterate all plays and filter",
      "description": "Store full play event objects with timestamps, then filter/sort on each query",
      "time_complexity": "O(P) per query where P is total plays",
      "space_complexity": "O(P)",
      "why_not_optimal": "Unnecessary overhead; we just need order, not timestamps"
    },
    {
      "name": "Optimal: Simple List Append",
      "description": "Append song name to a list on each play. For recent N, slice from end and reverse.",
      "time_complexity": "O(1) play, O(count) query",
      "space_complexity": "O(P) for history",
      "key_insight": "List maintains insertion order naturally; slicing from end gives most recent"
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution is elegantly simple:\n\n1. **Add a `recent_plays` list** to `SongAnalytics.__init__`\n2. **Modify `play_song`** to append the song's **name** (not ID) after validation\n3. **Implement `get_recent_plays(count)`** using list slicing:\n   - `recent_plays[-count:]` gets the last `count` elements\n   - `[::-1]` reverses to get newest-first order\n\n**Why store names not IDs?**\nAvoids extra lookup in get_recent_plays. Since song names are immutable in this design, storing names directly is both correct and efficient.\n\n**Edge case handling:**\n- Python slice `[-count:]` gracefully handles `count > len(list)` by returning all elements\n- `count = 0` returns empty list\n- No plays yet returns empty list",
    "data_structures": [
      {
        "structure": "List<String> recent_plays",
        "purpose": "Maintain chronological order of all plays with duplicates"
      }
    ],
    "algorithm_steps": [
      "1. On play_song(song_id, user_id): validate song exists",
      "2. Add user to song's listener Set (Part 1 logic)",
      "3. NEW: Append song.name to recent_plays list",
      "4. On get_recent_plays(count): slice last 'count' items from list",
      "5. Reverse the slice to get newest-first order",
      "6. Return the reversed list"
    ]
  },
  "solution_python_lines": [
    "from typing import Set, List",
    "",
    "",
    "class Song:",
    "    \"\"\"Song with unique listener tracking via Set.\"\"\"",
    "    ",
    "    def __init__(self, name: str) -> None:",
    "        self.name = name",
    "        self.listeners: Set[int] = set()",
    "    ",
    "    def add_listener(self, user_id: int) -> None:",
    "        self.listeners.add(user_id)",
    "    ",
    "    def get_listener_count(self) -> int:",
    "        return len(self.listeners)",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    Music streaming analytics system.",
    "    Tracks unique listeners AND recent play history (with duplicates).",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        self.songs: dict[int, Song] = {}",
    "        self.next_id = 1",
    "        self.recent_plays: List[str] = []  # Part 2: chronological play history",
    "    ",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"Add song with auto-assigned ID. Returns the assigned ID.\"\"\"",
    "        song_id = self.next_id",
    "        self.songs[song_id] = Song(name)",
    "        self.next_id += 1",
    "        return song_id",
    "    ",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"Record a play event. Updates unique listeners AND play history.\"\"\"",
    "        if song_id not in self.songs:",
    "            print(f\"Error: Song ID {song_id} does not exist.\")",
    "            return",
    "        song = self.songs[song_id]",
    "        song.add_listener(user_id)",
    "        self.recent_plays.append(song.name)  # Part 2: track every play",
    "    ",
    "    def print_analytics(self) -> None:",
    "        \"\"\"Print songs sorted by unique listeners (desc), then name (asc).\"\"\"",
    "        sorted_songs = sorted(",
    "            self.songs.values(),",
    "            key=lambda s: (-s.get_listener_count(), s.name)",
    "        )",
    "        for song in sorted_songs:",
    "            print(f\"{song.name} ({song.get_listener_count()} unique listeners)\")",
    "    ",
    "    def get_recent_plays(self, count: int) -> List[str]:",
    "        \"\"\"",
    "        Return most recent 'count' plays in reverse chronological order.",
    "        Returns fewer if not enough plays exist.",
    "        \"\"\"",
    "        if count <= 0:",
    "            return []",
    "        # Slice last 'count' elements, reverse for newest-first",
    "        return self.recent_plays[-count:][::-1]",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 2 Example 1: Recent Plays with Duplicates\")",
    "    print(\"=\" * 60)",
    "    analytics = SongAnalytics()",
    "    ",
    "    analytics.add_song(\"Alpha\")  # ID: 1",
    "    analytics.add_song(\"Beta\")   # ID: 2",
    "    ",
    "    # Play sequence: Alpha -> Beta -> Alpha -> Alpha",
    "    analytics.play_song(1, 1)  # Alpha by user 1",
    "    analytics.play_song(2, 1)  # Beta by user 1",
    "    analytics.play_song(1, 2)  # Alpha by user 2",
    "    analytics.play_song(1, 1)  # Alpha by user 1 again",
    "    ",
    "    print(f\"Recent 3: {analytics.get_recent_plays(3)}\")",
    "    # Expected: ['Alpha', 'Alpha', 'Beta']",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Part 2 Example 2: Fewer plays than requested\")",
    "    print(\"=\" * 60)",
    "    analytics2 = SongAnalytics()",
    "    analytics2.add_song(\"Only\")",
    "    analytics2.play_song(1, 1)",
    "    print(f\"Request 5, only 1 exists: {analytics2.get_recent_plays(5)}\")",
    "    # Expected: ['Only']",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Part 2 Example 3: Edge cases\")",
    "    print(\"=\" * 60)",
    "    analytics3 = SongAnalytics()",
    "    print(f\"No plays, request 3: {analytics3.get_recent_plays(3)}\")",
    "    print(f\"Request 0: {analytics3.get_recent_plays(0)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Verify Part 1 still works\")",
    "    print(\"=\" * 60)",
    "    analytics.print_analytics()",
    "    # Alpha has 2 unique listeners, Beta has 1"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Song with unique listener tracking via HashSet.",
    " */",
    "class Song {",
    "    private String name;",
    "    private Set<Integer> listeners;",
    "    ",
    "    public Song(String name) {",
    "        this.name = name;",
    "        this.listeners = new HashSet<>();",
    "    }",
    "    ",
    "    public void addListener(int userId) {",
    "        listeners.add(userId);",
    "    }",
    "    ",
    "    public int getListenerCount() {",
    "        return listeners.size();",
    "    }",
    "    ",
    "    public String getName() {",
    "        return name;",
    "    }",
    "}",
    "",
    "/**",
    " * Music streaming analytics system.",
    " * Tracks unique listeners AND recent play history (with duplicates).",
    " */",
    "public class SongAnalytics {",
    "    private Map<Integer, Song> songs;",
    "    private int nextId;",
    "    private List<String> recentPlays;  // Part 2: chronological play history",
    "    ",
    "    public SongAnalytics() {",
    "        this.songs = new HashMap<>();",
    "        this.nextId = 1;",
    "        this.recentPlays = new ArrayList<>();",
    "    }",
    "    ",
    "    public int addSong(String name) {",
    "        int songId = nextId;",
    "        songs.put(songId, new Song(name));",
    "        nextId++;",
    "        return songId;",
    "    }",
    "    ",
    "    public void playSong(int songId, int userId) {",
    "        if (!songs.containsKey(songId)) {",
    "            System.out.println(\"Error: Song ID \" + songId + \" does not exist.\");",
    "            return;",
    "        }",
    "        Song song = songs.get(songId);",
    "        song.addListener(userId);",
    "        recentPlays.add(song.getName());  // Part 2: track every play",
    "    }",
    "    ",
    "    public void printAnalytics() {",
    "        List<Song> sortedSongs = new ArrayList<>(songs.values());",
    "        sortedSongs.sort((a, b) -> {",
    "            int countCompare = Integer.compare(b.getListenerCount(), a.getListenerCount());",
    "            if (countCompare != 0) return countCompare;",
    "            return a.getName().compareTo(b.getName());",
    "        });",
    "        ",
    "        for (Song song : sortedSongs) {",
    "            System.out.println(song.getName() + \" (\" +",
    "                song.getListenerCount() + \" unique listeners)\");",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Return most recent 'count' plays in reverse chronological order.",
    "     * Returns fewer if not enough plays exist.",
    "     */",
    "    public List<String> getRecentPlays(int count) {",
    "        List<String> result = new ArrayList<>();",
    "        int size = recentPlays.size();",
    "        int start = Math.max(0, size - count);",
    "        ",
    "        // Iterate backwards from end to get newest first",
    "        for (int i = size - 1; i >= start; i--) {",
    "            result.add(recentPlays.get(i));",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Part 2 Example 1: Recent Plays with Duplicates\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        analytics.addSong(\"Alpha\");  // ID: 1",
    "        analytics.addSong(\"Beta\");   // ID: 2",
    "        ",
    "        // Play sequence: Alpha -> Beta -> Alpha -> Alpha",
    "        analytics.playSong(1, 1);",
    "        analytics.playSong(2, 1);",
    "        analytics.playSong(1, 2);",
    "        analytics.playSong(1, 1);",
    "        ",
    "        System.out.println(\"Recent 3: \" + analytics.getRecentPlays(3));",
    "        // Expected: [Alpha, Alpha, Beta]",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"Part 2 Example 2: Fewer plays than requested\");",
    "        System.out.println(\"============================================================\");",
    "        SongAnalytics analytics2 = new SongAnalytics();",
    "        analytics2.addSong(\"Only\");",
    "        analytics2.playSong(1, 1);",
    "        System.out.println(\"Request 5, only 1: \" + analytics2.getRecentPlays(5));",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"Verify Part 1 still works\");",
    "        System.out.println(\"============================================================\");",
    "        analytics.printAnalytics();",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-2",
      "explanation": "Imports: Added List to typing imports for the new return type"
    },
    {
      "lines": "23-26",
      "explanation": "__init__: Added recent_plays list to track chronological play history"
    },
    {
      "lines": "35-41",
      "explanation": "play_song: After validation and adding listener (Part 1), append song name to recent_plays"
    },
    {
      "lines": "50-57",
      "explanation": "get_recent_plays: Slice last 'count' elements, reverse for newest-first order"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_recent_plays": {
          "complexity": "O(count)",
          "explanation": "Slice creates list of 'count' elements, reverse is also O(count)"
        }
      },
      "modified_methods": {
        "play_song": {
          "complexity": "O(1)",
          "explanation": "List append is O(1) amortized, no change to overall complexity"
        }
      },
      "overall_change": "add_song and print_analytics unchanged. play_song still O(1). New method is O(count)."
    },
    "space": {
      "additional_space": "O(P) where P = total number of valid play events",
      "explanation": "Each play stores one string reference. P can be >> S*L since same (song, user) pair can have unlimited plays."
    }
  },
  "dry_run": {
    "example_input": "add_song(Alpha), add_song(Beta), play(1,1), play(2,1), play(1,2), play(1,1), get_recent_plays(3)",
    "steps": [
      {
        "step": 1,
        "action": "add_song('Alpha')",
        "state": "songs={1:Song(Alpha)}, recent_plays=[]",
        "explanation": "Song added with ID 1"
      },
      {
        "step": 2,
        "action": "add_song('Beta')",
        "state": "songs={1:Song(A), 2:Song(B)}, recent_plays=[]",
        "explanation": "Song added with ID 2"
      },
      {
        "step": 3,
        "action": "play_song(1, 1)",
        "state": "Alpha.listeners={1}, recent_plays=['Alpha']",
        "explanation": "User 1 plays Alpha, appended to history"
      },
      {
        "step": 4,
        "action": "play_song(2, 1)",
        "state": "Beta.listeners={1}, recent_plays=['Alpha','Beta']",
        "explanation": "User 1 plays Beta"
      },
      {
        "step": 5,
        "action": "play_song(1, 2)",
        "state": "Alpha.listeners={1,2}, recent_plays=['Alpha','Beta','Alpha']",
        "explanation": "User 2 plays Alpha"
      },
      {
        "step": 6,
        "action": "play_song(1, 1)",
        "state": "Alpha.listeners={1,2}, recent_plays=['Alpha','Beta','Alpha','Alpha']",
        "explanation": "User 1 plays Alpha again (duplicate play, but unique listener unchanged)"
      },
      {
        "step": 7,
        "action": "get_recent_plays(3)",
        "state": "Slice: ['Beta','Alpha','Alpha'], Reverse: ['Alpha','Alpha','Beta']",
        "explanation": "Last 3 elements reversed for newest-first"
      }
    ],
    "final_output": "['Alpha', 'Alpha', 'Beta']"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "get_recent_plays(0) should return []",
      "get_recent_plays(1) after one play should return that song"
    ],
    "likely_bugs": [
      "Forgetting to reverse - returns oldest-first instead of newest-first",
      "Using ID instead of name in history",
      "Appending to history before validation (invalid song adds ghost entry)"
    ],
    "recommended_logs_or_asserts": [
      "assert len(recent_plays) == total_valid_plays",
      "log f'After play: history length = {len(recent_plays)}'"
    ],
    "how_to_localize": "Print recent_plays after each play_song call. Verify length increases by 1 for valid plays, unchanged for invalid."
  },
  "edge_cases": [
    {
      "case": "count = 0",
      "handling": "Return empty list immediately",
      "gotcha": "Don't slice with [-0:] which gives full list!"
    },
    {
      "case": "count > total plays",
      "handling": "Python slice gracefully returns all available",
      "gotcha": "Java needs Math.max(0, size-count) to avoid negative index"
    },
    {
      "case": "No plays yet",
      "handling": "Empty list, slice returns empty",
      "gotcha": "Don't throw exception"
    },
    {
      "case": "Same song played multiple times",
      "handling": "Each play appears separately in history",
      "gotcha": "This is intentional - different from unique listeners"
    },
    {
      "case": "Invalid song_id play attempt",
      "handling": "Don't add to history (validation happens first)",
      "gotcha": "Order of operations matters"
    }
  ],
  "test_cases": [
    {
      "name": "Basic recent plays",
      "input": "add(A), add(B), play(1,1), play(2,1), play(1,2), play(1,1), get_recent_plays(3)",
      "expected": "['Alpha', 'Alpha', 'Beta']",
      "explanation": "Last 3 plays in reverse order"
    },
    {
      "name": "Request more than available",
      "input": "add(Only), play(1,1), get_recent_plays(5)",
      "expected": "['Only']",
      "explanation": "Only 1 play exists, return that"
    },
    {
      "name": "Empty history",
      "input": "add(A), get_recent_plays(3)",
      "expected": "[]",
      "explanation": "No plays yet"
    },
    {
      "name": "Invalid play doesn't affect history",
      "input": "add(A), play(999,1), get_recent_plays(1)",
      "expected": "[]",
      "explanation": "Invalid song ID doesn't add to history"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Storing song ID instead of name in history",
      "why_wrong": "Requires extra lookup in get_recent_plays, slows down query",
      "correct_approach": "Store name directly since it's immutable",
      "code_example_wrong": "self.recent_plays.append(song_id)",
      "code_example_correct": "self.recent_plays.append(song.name)"
    },
    {
      "mistake": "Forgetting to reverse the result",
      "why_wrong": "Returns oldest-first instead of newest-first",
      "correct_approach": "Slice then reverse, or iterate backwards",
      "code_example_wrong": "return self.recent_plays[-count:]",
      "code_example_correct": "return self.recent_plays[-count:][::-1]"
    },
    {
      "mistake": "Adding to history before validation",
      "why_wrong": "Ghost entries for invalid song IDs",
      "correct_approach": "Append only after confirming song exists",
      "code_example_wrong": "self.recent_plays.append(name); if song_id not in self.songs: return",
      "code_example_correct": "if song_id not in self.songs: return; self.recent_plays.append(song.name)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by noting the key difference: Part 1 tracks UNIQUE listeners (Set), Part 2 tracks ALL plays (List). Explain that these serve different purposes and need separate data structures.",
    "what_to_mention": [
      "Why a simple List is sufficient (maintains insertion order)",
      "Why storing names is better than IDs (avoids lookup)",
      "How Python slice handles edge cases gracefully"
    ],
    "time_allocation": "2 min understand, 5 min implement, 3 min test",
    "if_stuck": [
      "Think about what data structure maintains order with duplicates",
      "Consider: where do you get the song name? From the Song object after lookup"
    ]
  },
  "connection_to_next_part": "This establishes a pattern of maintaining parallel data structures for different views of the same data. Part 3 might add user-specific history, time-based filtering, or bounded history (keeping only last N plays).",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 handles unique listeners. For Part 2, I need to track the actual play sequence with duplicates. This is fundamentally different - a Set won't work because I need to preserve order and duplicates.",
    "explaining_changes": "I'll add a simple list that appends the song name on every valid play. For recent plays, I just slice from the end and reverse.",
    "while_extending_code": [
      "Adding recent_plays list in init...",
      "Modifying play_song to append after validation...",
      "New method slices and reverses..."
    ],
    "after_completing": "Now we track both unique listeners AND full play history. play_song is still O(1), get_recent_plays is O(count). Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "8-10 minutes for this part",
    "by_2_min": "Understand that we need a new List for play history, separate from the Set",
    "by_5_min": "Have the list added and play_song modified",
    "by_8_min": "get_recent_plays implemented and tested",
    "warning_signs": "If confused about List vs Set purpose at 3 min, clarify the difference immediately"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has a bug, fix it first. Say: 'Let me verify the song lookup works before adding history.'",
    "if_new_requirement_unclear": "Ask: 'Just to confirm, duplicates are allowed in the history, and we return newest first?'",
    "if_running_behind": "Focus on the core: add list, append in play_song, slice and reverse in getter. Edge cases can be mentioned verbally."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing Set vs List for different requirements",
      "Mentioning that storing names avoids O(count) lookups",
      "Proactively noting unbounded growth as a production concern",
      "Suggesting bounded deque for memory-constrained scenarios"
    ]
  },
  "pattern_recognition": {
    "pattern": "Parallel Data Structures for Different Views",
    "indicators": [
      "Need both unique count AND ordered history",
      "Different query patterns on same events"
    ],
    "similar_problems": [
      "LRU Cache (HashMap + Doubly Linked List)",
      "Twitter feed (user tweets + follower timeline)"
    ],
    "template": "Maintain separate structures optimized for each query type; update all on write operations"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Part 1 uses Set for uniqueness. Part 2 needs duplicates and order.",
      "why": "Set explicitly removes duplicates, so won't work for this"
    },
    {
      "step": 2,
      "thought": "List maintains insertion order and allows duplicates.",
      "why": "Perfect fit for 'recent plays' requirement"
    },
    {
      "step": 3,
      "thought": "Store names not IDs to avoid lookup in get_recent_plays.",
      "why": "Optimizes read path; names are immutable anyway"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you identify when Set vs List is appropriate?",
      "Do you understand that different queries need different data structures?",
      "Can you extend cleanly without breaking Part 1?"
    ],
    "bonus_points": [
      "Mentioning amortized O(1) for list append",
      "Noting potential memory growth",
      "Clean slice + reverse idiom"
    ],
    "red_flags": [
      "Trying to use the same Set for history",
      "Breaking existing play_song logic",
      "Not handling edge cases for count"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for Python slice syntax if unsure",
      "Let it help with Java's backwards iteration"
    ],
    "what_not_to_do": [
      "Don't blindly accept if it modifies existing working code",
      "Verify the reverse order logic yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not explaining WHY you need a new data structure",
      "Jumping to code without planning"
    ],
    "technical": [
      "Modifying Song class unnecessarily",
      "Using wrong data structure for ordered history"
    ],
    "communication": [
      "Not mentioning how this differs from Part 1",
      "Not testing the new method"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does get_recent_plays return newest-first order?",
      "Does play_song still update unique listeners correctly?",
      "Are edge cases (count=0, count>size) handled?",
      "Is print_analytics still working?"
    ],
    "quick_code_review": [
      "List import added",
      "recent_plays initialized in __init__",
      "Append happens AFTER validation in play_song",
      "Slice and reverse in get_recent_plays"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Bounded history (e.g., last 10000 plays) using collections.deque(maxlen=N)",
      "Logging for debugging play history",
      "Metrics on history size"
    ],
    "why_not_in_interview": "Focus on correctness first; mention these as production enhancements",
    "how_to_mention": "Say: 'In production, I'd use a bounded deque to prevent unbounded memory growth.'"
  },
  "generated_at": "2026-01-19T04:48:51.759964",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}