{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 3: Concurrency and Race Conditions",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds thread-safety to handle concurrent booking requests. The existing `book_tickets` method has a race condition where multiple threads can read the same availability count simultaneously, leading to overselling. We need to make the check-then-act pattern atomic.",
    "new_requirements": [
      "Thread-safe booking that prevents overselling under concurrent load",
      "Ability to simulate concurrent booking scenarios for testing",
      "Proper handling of race conditions when multiple users book the last tickets"
    ],
    "new_constraints": [
      "Availability check AND decrement must be atomic (cannot be separated)",
      "Must return 409 INSUFFICIENT_TICKETS to all but one requester when only 1 ticket remains and 3 users request",
      "Response ordering should match request ordering in simulation"
    ],
    "key_insight": "The check-then-act pattern (read availability \u2192 verify \u2192 decrement) MUST be atomic. Using pessimistic locking, we hold a lock during the entire sequence so no other thread can read stale availability data."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Thread-safe booking prevents double-selling",
        "how_met": "Pessimistic lock held from availability check through decrement",
        "gotchas": [
          "Checking availability OUTSIDE lock is a bug - must check INSIDE"
        ]
      },
      {
        "requirement": "Concurrent simulation returns correct mix of 201/409",
        "how_met": "ThreadPoolExecutor runs all requests simultaneously",
        "gotchas": [
          "Order must be preserved in response list"
        ]
      },
      {
        "requirement": "Per-event locking for better throughput",
        "how_met": "Separate locks per event allow concurrent bookings to different events",
        "gotchas": [
          "Still need global lock for booking ID generation"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "book_tickets_atomic",
        "target": "O(1) + lock wait",
        "achieved": "O(1) + lock wait",
        "why": "Dict lookups are O(1), lock contention depends on traffic"
      },
      {
        "operation": "simulate_concurrent_bookings",
        "target": "O(n) where n = requests",
        "achieved": "O(n) parallel",
        "why": "Threads run in parallel, wall-clock time is max(thread times)"
      }
    ],
    "non_goals": [
      "Distributed locking across multiple servers",
      "Database-level row locking",
      "Deadlock detection (simple lock hierarchy prevents it)"
    ]
  },
  "assumptions": [
    "In-memory locking is sufficient (ask: 'Should I consider distributed locks for multi-server deployment?')",
    "Per-event granularity is fine (ask: 'Do we need seat-level locking for assigned seating?')",
    "Simple threading model without async/await (ask: 'Should I use asyncio instead of threads?')"
  ],
  "tradeoffs": [
    {
      "decision": "Pessimistic vs Optimistic locking",
      "chosen": "Pessimistic",
      "why": "Simpler, always correct, good for high-contention scenarios like flash sales",
      "alternative": "Optimistic with version/CAS",
      "when_to_switch": "Read-heavy workloads with infrequent conflicts"
    },
    {
      "decision": "Global vs Per-event locks",
      "chosen": "Per-event locks",
      "why": "Allows concurrent bookings to different events for better throughput",
      "alternative": "Single global lock",
      "when_to_switch": "If lock management overhead exceeds benefits"
    },
    {
      "decision": "Threading vs Async",
      "chosen": "Threading",
      "why": "More straightforward for interview, matches existing code style",
      "alternative": "asyncio",
      "when_to_switch": "High-volume I/O-bound operations"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1/2 method signatures",
      "Response format",
      "Error codes"
    ],
    "what_to_change": [
      "Added _event_locks dict for per-event locking",
      "Added version field to Event (for potential optimistic locking)"
    ],
    "interfaces_and_boundaries": "book_tickets_atomic is a clean parallel to book_tickets; simulation method is purely for testing",
    "invariants": [
      "available_tickets >= 0 always (never negative)",
      "Sum of all confirmed booking tickets <= total_tickets",
      "Lock ordering: event lock \u2192 global lock (prevents deadlock)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Race Condition):\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nThread A              Thread B              available\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nread: 1                                     1\n                      read: 1               1\navailable >= 1? YES                         1\n                      available >= 1? YES   1\navailable -= 1                              0\ncreate booking                              0\n                      available -= 1        -1 \u2190 BUG!\n                      create booking        OVERSOLD!\n\nAFTER (With Lock):\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nThread A              Thread B              available\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nACQUIRE LOCK          (waiting...)          1\nread: 1                                     1\navailable >= 1? YES                         1\navailable -= 1                              0\ncreate booking                              0\nRELEASE LOCK                                0\n                      ACQUIRE LOCK          0\n                      read: 0               0\n                      available >= 0? NO    0\n                      return 409            0\n                      RELEASE LOCK          0\n```",
    "algorithm_flow": "```\nbook_tickets_atomic(request):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Validate request (outside lock)      \u2502\n\u2502    - Check required fields              \u2502\n\u2502    - Verify event exists                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. ACQUIRE per-event lock               \u2502\u25c4\u2500\u2500 Thread waits here if locked\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. INSIDE LOCK (atomic section):        \u2502\n\u2502    - Read available_tickets             \u2502\n\u2502    - Check if enough tickets            \u2502\n\u2502    - If not: return 409, release lock   \u2502\n\u2502    - Generate booking ID (with global)  \u2502\n\u2502    - Create booking                     \u2502\n\u2502    - Decrement available_tickets        \u2502\n\u2502    - Increment version                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. RELEASE lock, return 201 success     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (No Additional Locking)",
      "description": "Assume existing book_tickets is already safe because it has a lock",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "why_not_optimal": "While existing code has locking, we need per-event locks for better concurrency, and explicit simulation testing is missing"
    },
    {
      "name": "Optimal: Pessimistic Per-Event Locking",
      "description": "Use separate lock per event. All operations on an event serialize, but different events can process concurrently",
      "time_complexity": "O(1) per operation + lock wait time",
      "space_complexity": "O(e) where e = number of events (one lock each)",
      "key_insight": "Fine-grained locking: Event A and Event B can be booked simultaneously, only multiple bookings to same event serialize"
    },
    {
      "name": "Alternative: Optimistic Locking with Version",
      "description": "Read version, do work, CAS (compare-and-swap) on commit. Retry if version changed",
      "time_complexity": "O(r) where r = retries (usually 1-3)",
      "space_complexity": "O(1)",
      "key_insight": "Better for read-heavy workloads; flash sales with high contention favor pessimistic"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Solution: Pessimistic Per-Event Locking\n\n### Why Pessimistic?\nFor ticket booking flash sales, **contention is high** - many users compete for few tickets. Pessimistic locking guarantees correctness with no retries.\n\n### Why Per-Event?\nA **global lock** would serialize ALL bookings. With per-event locks, users booking different events proceed in parallel.\n\n### Implementation Details:\n1. **Lock hierarchy** prevents deadlock: always acquire event lock before global lock\n2. **Validation outside lock** - no need to hold lock during input validation\n3. **Check inside lock** - availability check MUST be inside lock to prevent TOCTOU race\n4. **Version field** - tracks modifications (useful for debugging, enables optimistic later)\n\n### Thread-Safety Checklist:\n- \u2705 Availability check atomic with decrement\n- \u2705 Booking ID generation protected by global lock\n- \u2705 Event lock dict access synchronized\n- \u2705 No deadlock (consistent lock ordering)",
    "data_structures": [
      {
        "structure": "Dict[str, Lock] _event_locks",
        "purpose": "Per-event lock for fine-grained concurrency"
      },
      {
        "structure": "ThreadPoolExecutor",
        "purpose": "Simulate concurrent requests for testing"
      },
      {
        "structure": "Event.version",
        "purpose": "Track modifications (enables optimistic locking if needed)"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate request structure and event existence (no lock needed)",
      "Step 2: Get or create per-event lock from _event_locks dict (use global lock for dict access)",
      "Step 3: Acquire event lock - threads for same event wait here",
      "Step 4: Inside lock: read available_tickets and verify sufficient",
      "Step 5: If insufficient, return 409 and release lock",
      "Step 6: Generate booking ID (brief global lock for counter)",
      "Step 7: Create booking, decrement availability, increment version",
      "Step 8: Release event lock, return 201 success"
    ]
  },
  "solution_python_lines": [
    "from decimal import Decimal",
    "from datetime import datetime, timedelta",
    "from typing import Dict, List, Optional, Any",
    "from enum import Enum",
    "from dataclasses import dataclass",
    "import threading",
    "import hashlib",
    "import secrets",
    "from concurrent.futures import ThreadPoolExecutor, as_completed",
    "",
    "",
    "class BookingStatus(Enum):",
    "    CONFIRMED = 'CONFIRMED'",
    "    CANCELLED = 'CANCELLED'",
    "",
    "",
    "class UserRole(Enum):",
    "    ADMIN = 'ADMIN'",
    "    USER = 'USER'",
    "    GUEST = 'GUEST'",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: Decimal",
    "    version: int = 0  # Part 3: For concurrency tracking",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    total_amount: Decimal",
    "    status: BookingStatus",
    "    created_at: datetime",
    "",
    "",
    "@dataclass",
    "class User:",
    "    id: str",
    "    username: str",
    "    password_hash: str",
    "    role: UserRole",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    status: int",
    "    body: dict",
    "",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Ticket Booking API with Concurrency Safety.",
    "    Part 3: Thread-safe booking prevents overselling.",
    "    \"\"\"",
    "    MAX_LOGIN_ATTEMPTS = 5",
    "    LOCKOUT_MINUTES = 15",
    "",
    "    def __init__(self):",
    "        # Part 1 state",
    "        self.events: Dict[str, Event] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "        self._lock = threading.Lock()",
    "        ",
    "        # Part 2 state - Auth",
    "        self.users: Dict[str, User] = {}",
    "        self.tokens: Dict[str, dict] = {}",
    "        self.login_attempts: Dict[str, List[datetime]] = {}",
    "        self._user_counter = 0",
    "        self._seed_users()",
    "        ",
    "        # Part 3 state - Concurrency",
    "        self._event_locks: Dict[str, threading.Lock] = {}",
    "",
    "    def _seed_users(self):",
    "        self._add_user('admin', 'admin123', UserRole.ADMIN)",
    "        self._add_user('user', 'user123', UserRole.USER)",
    "",
    "    def _add_user(self, username: str, password: str, role: UserRole) -> User:",
    "        self._user_counter += 1",
    "        user = User(",
    "            id=f'usr_{self._user_counter:03d}',",
    "            username=username,",
    "            password_hash=hashlib.sha256(password.encode()).hexdigest(),",
    "            role=role",
    "        )",
    "        self.users[username] = user",
    "        return user",
    "",
    "    def _generate_event_id(self) -> str:",
    "        self._event_counter += 1",
    "        return f'evt_{self._event_counter:03d}'",
    "",
    "    def _generate_booking_id(self) -> str:",
    "        self._booking_counter += 1",
    "        return f'bkg_{self._booking_counter:03d}'",
    "",
    "    def _error_response(self, status: int, code: str, message: str,",
    "                        details: List[dict] = None) -> Response:",
    "        body = {'success': False, 'error': {'code': code, 'message': message}}",
    "        if details:",
    "            body['error']['details'] = details",
    "        return Response(status=status, body=body)",
    "",
    "    # ========== Part 2: Auth Methods (unchanged) ==========",
    "",
    "    def _check_rate_limit(self, username: str) -> bool:",
    "        if username not in self.login_attempts:",
    "            return True",
    "        cutoff = datetime.now() - timedelta(minutes=self.LOCKOUT_MINUTES)",
    "        recent = [t for t in self.login_attempts[username] if t > cutoff]",
    "        self.login_attempts[username] = recent",
    "        return len(recent) < self.MAX_LOGIN_ATTEMPTS",
    "",
    "    def _record_failed_login(self, username: str):",
    "        if username not in self.login_attempts:",
    "            self.login_attempts[username] = []",
    "        self.login_attempts[username].append(datetime.now())",
    "",
    "    def _validate_token(self, token: str) -> Optional[dict]:",
    "        if not token or token not in self.tokens:",
    "            return None",
    "        info = self.tokens[token]",
    "        if datetime.now() > info['exp']:",
    "            del self.tokens[token]",
    "            return None",
    "        return info",
    "",
    "    def _authorize(self, token: str, required_role: str = 'USER') -> tuple:",
    "        auth = self._validate_token(token)",
    "        if not auth:",
    "            return None, self._error_response(401, 'UNAUTHORIZED', 'Invalid or expired token')",
    "        role_hierarchy = {'GUEST': 0, 'USER': 1, 'ADMIN': 2}",
    "        if role_hierarchy.get(auth['role'], 0) < role_hierarchy.get(required_role, 1):",
    "            return None, self._error_response(403, 'FORBIDDEN', f'{required_role} role required')",
    "        return auth, None",
    "",
    "    def login(self, request: dict) -> Response:",
    "        username = request.get('username', '')",
    "        password = request.get('password', '')",
    "        if not self._check_rate_limit(username):",
    "            return self._error_response(429, 'RATE_LIMITED', 'Too many login attempts')",
    "        user = self.users.get(username)",
    "        if not user or user.password_hash != hashlib.sha256(password.encode()).hexdigest():",
    "            self._record_failed_login(username)",
    "            return self._error_response(401, 'UNAUTHORIZED', 'Invalid credentials')",
    "        token = f'tok_{secrets.token_hex(16)}'",
    "        self.tokens[token] = {",
    "            'user_id': user.id, 'username': user.username,",
    "            'role': user.role.value, 'exp': datetime.now() + timedelta(hours=24)",
    "        }",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'token': token, 'userId': user.id, 'role': user.role.value}",
    "        })",
    "",
    "    def get_current_user(self, token: str) -> Response:",
    "        auth = self._validate_token(token)",
    "        if not auth:",
    "            return self._error_response(401, 'UNAUTHORIZED', 'Invalid or expired token')",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'userId': auth['user_id'], 'username': auth['username'], 'role': auth['role']}",
    "        })",
    "",
    "    def get_user_bookings(self, token: str, user_id: str) -> Response:",
    "        auth, err = self._authorize(token, 'USER')",
    "        if err:",
    "            return err",
    "        if auth['role'] != 'ADMIN' and auth['user_id'] != user_id:",
    "            return self._error_response(403, 'FORBIDDEN', 'Cannot view other users bookings')",
    "        user_bookings = [",
    "            {'bookingId': b.id, 'eventId': b.event_id, 'tickets': b.number_of_tickets,",
    "             'status': b.status.value}",
    "            for b in self.bookings.values() if b.user_id == user_id",
    "        ]",
    "        return Response(status=200, body={'success': True, 'data': {'bookings': user_bookings}})",
    "",
    "    # ========== Part 1 Methods (unchanged) ==========",
    "",
    "    def _validate_event_request(self, request: dict) -> List[dict]:",
    "        errors = []",
    "        required = ['name', 'date', 'venue', 'totalTickets', 'pricePerTicket']",
    "        for field in required:",
    "            if field not in request or request[field] is None:",
    "                errors.append({'field': field, 'issue': 'required'})",
    "        if errors:",
    "            return errors",
    "        if not isinstance(request['totalTickets'], int) or not (1 <= request['totalTickets'] <= 100000):",
    "            errors.append({'field': 'totalTickets', 'issue': 'must be 1-100000'})",
    "        return errors",
    "",
    "    def _validate_booking_request(self, request: dict) -> List[dict]:",
    "        errors = []",
    "        required = ['eventId', 'userId', 'numberOfTickets']",
    "        for field in required:",
    "            if field not in request or request[field] is None:",
    "                errors.append({'field': field, 'issue': 'required'})",
    "        if errors:",
    "            return errors",
    "        tickets = request['numberOfTickets']",
    "        if not isinstance(tickets, int) or not (1 <= tickets <= 10):",
    "            errors.append({'field': 'numberOfTickets', 'issue': 'must be 1-10'})",
    "        return errors",
    "",
    "    def create_event(self, request: dict, token: str = None) -> Response:",
    "        if token:",
    "            auth, err = self._authorize(token, 'ADMIN')",
    "            if err:",
    "                return err",
    "        errors = self._validate_event_request(request)",
    "        if errors:",
    "            return self._error_response(400, 'VALIDATION_ERROR', f\"Validation error: {errors[0]['issue']}\", errors)",
    "        event_id = self._generate_event_id()",
    "        event = Event(",
    "            id=event_id, name=request['name'],",
    "            date=datetime.fromisoformat(request['date'].replace('Z', '+00:00')),",
    "            venue=request['venue'], total_tickets=request['totalTickets'],",
    "            available_tickets=request['totalTickets'],",
    "            price_per_ticket=Decimal(str(request['pricePerTicket']))",
    "        )",
    "        self.events[event_id] = event",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {'eventId': event_id, 'name': event.name, 'availableTickets': event.available_tickets}",
    "        })",
    "",
    "    def get_event(self, event_id: str) -> Response:",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        e = self.events[event_id]",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {'eventId': e.id, 'name': e.name, 'availableTickets': e.available_tickets,",
    "                     'pricePerTicket': float(e.price_per_ticket)}",
    "        })",
    "",
    "    def list_events(self, filters: dict = None) -> Response:",
    "        filters = filters or {}",
    "        limit = min(filters.get('limit', 10), 100)",
    "        offset = max(filters.get('offset', 0), 0)",
    "        all_events = list(self.events.values())",
    "        paginated = all_events[offset:offset + limit]",
    "        return Response(status=200, body={",
    "            'success': True,",
    "            'data': {",
    "                'events': [{'eventId': e.id, 'name': e.name, 'availableTickets': e.available_tickets} for e in paginated],",
    "                'total': len(all_events), 'limit': limit, 'offset': offset",
    "            }",
    "        })",
    "",
    "    def book_tickets(self, request: dict, token: str = None) -> Response:",
    "        if token:",
    "            auth, err = self._authorize(token, 'USER')",
    "            if err:",
    "                return err",
    "        errors = self._validate_booking_request(request)",
    "        if errors:",
    "            return self._error_response(400, 'VALIDATION_ERROR', errors[0]['issue'], errors)",
    "        event_id = request['eventId']",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        with self._lock:",
    "            event = self.events[event_id]",
    "            num_tickets = request['numberOfTickets']",
    "            if event.available_tickets < num_tickets:",
    "                return self._error_response(409, 'INSUFFICIENT_TICKETS',",
    "                    f'Only {event.available_tickets} ticket(s) available')",
    "            booking_id = self._generate_booking_id()",
    "            total = event.price_per_ticket * num_tickets",
    "            booking = Booking(",
    "                id=booking_id, event_id=event_id, user_id=request['userId'],",
    "                number_of_tickets=num_tickets, total_amount=total,",
    "                status=BookingStatus.CONFIRMED, created_at=datetime.now()",
    "            )",
    "            event.available_tickets -= num_tickets",
    "            self.bookings[booking_id] = booking",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {'bookingId': booking_id, 'eventId': event_id,",
    "                     'numberOfTickets': num_tickets, 'totalAmount': float(total), 'status': 'CONFIRMED'}",
    "        })",
    "",
    "    def cancel_booking(self, booking_id: str, token: str = None) -> Response:",
    "        if booking_id not in self.bookings:",
    "            return self._error_response(404, 'NOT_FOUND', f'Booking {booking_id} not found')",
    "        if token:",
    "            auth, err = self._authorize(token, 'USER')",
    "            if err:",
    "                return err",
    "            if auth['role'] != 'ADMIN' and auth['user_id'] != self.bookings[booking_id].user_id:",
    "                return self._error_response(403, 'FORBIDDEN', 'Cannot cancel other users bookings')",
    "        with self._lock:",
    "            booking = self.bookings[booking_id]",
    "            if booking.status == BookingStatus.CANCELLED:",
    "                return self._error_response(409, 'ALREADY_CANCELLED', 'Booking already cancelled')",
    "            self.events[booking.event_id].available_tickets += booking.number_of_tickets",
    "            booking.status = BookingStatus.CANCELLED",
    "        return Response(status=200, body={'success': True, 'data': {'bookingId': booking_id, 'status': 'CANCELLED'}})",
    "",
    "    # ========== Part 3: Concurrency Methods ==========",
    "",
    "    def _get_event_lock(self, event_id: str) -> threading.Lock:",
    "        \"\"\"Get or create per-event lock for fine-grained concurrency.\"\"\"",
    "        with self._lock:",
    "            if event_id not in self._event_locks:",
    "                self._event_locks[event_id] = threading.Lock()",
    "            return self._event_locks[event_id]",
    "",
    "    def book_tickets_atomic(self, request: dict) -> Response:",
    "        \"\"\"",
    "        Thread-safe booking with per-event pessimistic locking.",
    "        Key insight: Check-then-act MUST be atomic to prevent overselling.",
    "        \"\"\"",
    "        errors = self._validate_booking_request(request)",
    "        if errors:",
    "            return self._error_response(400, 'VALIDATION_ERROR', errors[0]['issue'], errors)",
    "        ",
    "        event_id = request['eventId']",
    "        if event_id not in self.events:",
    "            return self._error_response(404, 'NOT_FOUND', f'Event {event_id} not found')",
    "        ",
    "        # Per-event lock: different events can book concurrently",
    "        event_lock = self._get_event_lock(event_id)",
    "        ",
    "        with event_lock:",
    "            event = self.events[event_id]",
    "            num_tickets = request['numberOfTickets']",
    "            ",
    "            # CRITICAL: Check inside lock prevents race condition",
    "            if event.available_tickets < num_tickets:",
    "                return self._error_response(409, 'INSUFFICIENT_TICKETS',",
    "                    f'Only {event.available_tickets} ticket(s) available')",
    "            ",
    "            # Protect counter with global lock (brief)",
    "            with self._lock:",
    "                booking_id = self._generate_booking_id()",
    "            ",
    "            total = event.price_per_ticket * num_tickets",
    "            booking = Booking(",
    "                id=booking_id, event_id=event_id, user_id=request['userId'],",
    "                number_of_tickets=num_tickets, total_amount=total,",
    "                status=BookingStatus.CONFIRMED, created_at=datetime.now()",
    "            )",
    "            event.available_tickets -= num_tickets",
    "            event.version += 1  # Track modifications",
    "            self.bookings[booking_id] = booking",
    "        ",
    "        return Response(status=201, body={",
    "            'success': True,",
    "            'data': {'bookingId': booking_id, 'eventId': event_id,",
    "                     'numberOfTickets': num_tickets, 'totalAmount': float(total), 'status': 'CONFIRMED'}",
    "        })",
    "",
    "    def simulate_concurrent_bookings(self, requests: List[dict]) -> List[Response]:",
    "        \"\"\"",
    "        Simulate concurrent booking requests for testing.",
    "        Uses ThreadPoolExecutor to run all requests simultaneously.",
    "        \"\"\"",
    "        responses = [None] * len(requests)",
    "        ",
    "        def execute(args):",
    "            idx, req = args",
    "            return idx, self.book_tickets_atomic(req)",
    "        ",
    "        with ThreadPoolExecutor(max_workers=len(requests)) as executor:",
    "            futures = [executor.submit(execute, (i, req)) for i, req in enumerate(requests)]",
    "            for future in as_completed(futures):",
    "                idx, resp = future.result()",
    "                responses[idx] = resp",
    "        ",
    "        return responses",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('\\n' + '=' * 60)",
    "    print('TICKET API - PART 3: CONCURRENCY DEMO')",
    "    print('=' * 60)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # Create event with limited tickets",
    "    print('\\n[1] Creating event with only 2 tickets...')",
    "    resp = api.create_event({",
    "        'name': 'Hot Concert', 'date': '2024-12-31T20:00:00Z',",
    "        'venue': 'Arena', 'totalTickets': 2, 'pricePerTicket': 150",
    "    })",
    "    event_id = resp.body['data']['eventId']",
    "    print(f'    Event {event_id} created with 2 tickets')",
    "    ",
    "    # Simulate 3 users trying to book 2 tickets each",
    "    print('\\n[2] Simulating 3 concurrent bookings (2 tickets each)...')",
    "    print('    Only 1 should succeed (2 available, each wants 2)')",
    "    ",
    "    requests = [",
    "        {'eventId': event_id, 'userId': 'usr_A', 'numberOfTickets': 2},",
    "        {'eventId': event_id, 'userId': 'usr_B', 'numberOfTickets': 2},",
    "        {'eventId': event_id, 'userId': 'usr_C', 'numberOfTickets': 2}",
    "    ]",
    "    ",
    "    responses = api.simulate_concurrent_bookings(requests)",
    "    ",
    "    success_count = sum(1 for r in responses if r.status == 201)",
    "    conflict_count = sum(1 for r in responses if r.status == 409)",
    "    ",
    "    print(f'    Results: {success_count} success, {conflict_count} conflicts')",
    "    for i, resp in enumerate(responses):",
    "        user = requests[i]['userId']",
    "        status = 'SUCCESS' if resp.status == 201 else 'INSUFFICIENT_TICKETS'",
    "        print(f'    User {user}: {status}')",
    "    ",
    "    # Verify no overselling",
    "    print('\\n[3] Verifying no overselling...')",
    "    event = api.events[event_id]",
    "    print(f'    Available tickets: {event.available_tickets}')",
    "    print(f'    Total bookings: {len(api.bookings)}')",
    "    assert event.available_tickets >= 0, 'OVERSOLD!'",
    "    print('    \u2713 No overselling occurred')",
    "    ",
    "    # Test concurrent bookings to different events (should all succeed)",
    "    print('\\n[4] Testing concurrent bookings to different events...')",
    "    api.create_event({'name': 'Event A', 'date': '2024-12-01T10:00:00Z',",
    "                      'venue': 'A', 'totalTickets': 10, 'pricePerTicket': 50})",
    "    api.create_event({'name': 'Event B', 'date': '2024-12-02T10:00:00Z',",
    "                      'venue': 'B', 'totalTickets': 10, 'pricePerTicket': 50})",
    "    ",
    "    multi_event_requests = [",
    "        {'eventId': 'evt_002', 'userId': 'usr_1', 'numberOfTickets': 2},",
    "        {'eventId': 'evt_003', 'userId': 'usr_2', 'numberOfTickets': 2},",
    "    ]",
    "    responses = api.simulate_concurrent_bookings(multi_event_requests)",
    "    all_success = all(r.status == 201 for r in responses)",
    "    print(f'    Both bookings succeeded: {all_success}')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('PART 3 DEMO COMPLETE!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.security.MessageDigest;",
    "import java.time.Instant;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "",
    "public class TicketAPI {",
    "    ",
    "    enum BookingStatus { CONFIRMED, CANCELLED }",
    "    enum UserRole { ADMIN, USER, GUEST }",
    "    ",
    "    static class Event {",
    "        String id, name, venue;",
    "        Instant date;",
    "        int totalTickets, availableTickets;",
    "        BigDecimal pricePerTicket;",
    "        int version = 0;  // Part 3: For concurrency tracking",
    "        Event(String id, String name, Instant date, String venue, int total, BigDecimal price) {",
    "            this.id = id; this.name = name; this.date = date; this.venue = venue;",
    "            this.totalTickets = total; this.availableTickets = total; this.pricePerTicket = price;",
    "        }",
    "    }",
    "    ",
    "    static class Booking {",
    "        String id, eventId, userId;",
    "        int numberOfTickets;",
    "        BigDecimal totalAmount;",
    "        BookingStatus status;",
    "        Instant createdAt;",
    "        Booking(String id, String eventId, String userId, int tickets, BigDecimal total) {",
    "            this.id = id; this.eventId = eventId; this.userId = userId;",
    "            this.numberOfTickets = tickets; this.totalAmount = total;",
    "            this.status = BookingStatus.CONFIRMED; this.createdAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    static class User {",
    "        String id, username, passwordHash;",
    "        UserRole role;",
    "        User(String id, String username, String passwordHash, UserRole role) {",
    "            this.id = id; this.username = username; this.passwordHash = passwordHash; this.role = role;",
    "        }",
    "    }",
    "    ",
    "    static class Response {",
    "        int status;",
    "        Map<String, Object> body;",
    "        Response(int status, Map<String, Object> body) { this.status = status; this.body = body; }",
    "    }",
    "    ",
    "    // State",
    "    private final Map<String, Event> events = new HashMap<>();",
    "    private final Map<String, Booking> bookings = new HashMap<>();",
    "    private final Map<String, User> users = new HashMap<>();",
    "    private final Map<String, Map<String, Object>> tokens = new HashMap<>();",
    "    private final Map<String, List<Instant>> loginAttempts = new HashMap<>();",
    "    private int eventCounter = 0, bookingCounter = 0, userCounter = 0;",
    "    private final ReentrantLock lock = new ReentrantLock();",
    "    private static final int MAX_ATTEMPTS = 5;",
    "    private static final int LOCKOUT_MINUTES = 15;",
    "    ",
    "    // Part 3: Per-event locks for fine-grained concurrency",
    "    private final Map<String, Object> eventLocks = new ConcurrentHashMap<>();",
    "    ",
    "    public TicketAPI() { seedUsers(); }",
    "    ",
    "    private void seedUsers() {",
    "        addUser(\"admin\", \"admin123\", UserRole.ADMIN);",
    "        addUser(\"user\", \"user123\", UserRole.USER);",
    "    }",
    "    ",
    "    private void addUser(String username, String password, UserRole role) {",
    "        String id = String.format(\"usr_%03d\", ++userCounter);",
    "        users.put(username, new User(id, username, hashPassword(password), role));",
    "    }",
    "    ",
    "    private String hashPassword(String password) {",
    "        try {",
    "            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");",
    "            byte[] hash = md.digest(password.getBytes());",
    "            StringBuilder sb = new StringBuilder();",
    "            for (byte b : hash) sb.append(String.format(\"%02x\", b));",
    "            return sb.toString();",
    "        } catch (Exception e) { return password; }",
    "    }",
    "    ",
    "    private Response errorResponse(int status, String code, String message) {",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", false);",
    "        Map<String, Object> error = new HashMap<>();",
    "        error.put(\"code\", code); error.put(\"message\", message);",
    "        body.put(\"error\", error);",
    "        return new Response(status, body);",
    "    }",
    "    ",
    "    private boolean checkRateLimit(String username) {",
    "        if (!loginAttempts.containsKey(username)) return true;",
    "        Instant cutoff = Instant.now().minus(LOCKOUT_MINUTES, ChronoUnit.MINUTES);",
    "        List<Instant> recent = new ArrayList<>();",
    "        for (Instant t : loginAttempts.get(username)) if (t.isAfter(cutoff)) recent.add(t);",
    "        loginAttempts.put(username, recent);",
    "        return recent.size() < MAX_ATTEMPTS;",
    "    }",
    "    ",
    "    private Map<String, Object> validateToken(String token) {",
    "        if (token == null || !tokens.containsKey(token)) return null;",
    "        Map<String, Object> info = tokens.get(token);",
    "        if (Instant.now().isAfter((Instant) info.get(\"exp\"))) {",
    "            tokens.remove(token); return null;",
    "        }",
    "        return info;",
    "    }",
    "    ",
    "    public Response login(Map<String, Object> request) {",
    "        String username = (String) request.getOrDefault(\"username\", \"\");",
    "        String password = (String) request.getOrDefault(\"password\", \"\");",
    "        if (!checkRateLimit(username))",
    "            return errorResponse(429, \"RATE_LIMITED\", \"Too many attempts\");",
    "        User user = users.get(username);",
    "        if (user == null || !user.passwordHash.equals(hashPassword(password))) {",
    "            loginAttempts.computeIfAbsent(username, k -> new ArrayList<>()).add(Instant.now());",
    "            return errorResponse(401, \"UNAUTHORIZED\", \"Invalid credentials\");",
    "        }",
    "        String token = \"tok_\" + UUID.randomUUID().toString().replace(\"-\", \"\").substring(0, 32);",
    "        Map<String, Object> tokenInfo = new HashMap<>();",
    "        tokenInfo.put(\"user_id\", user.id);",
    "        tokenInfo.put(\"username\", user.username);",
    "        tokenInfo.put(\"role\", user.role.name());",
    "        tokenInfo.put(\"exp\", Instant.now().plus(24, ChronoUnit.HOURS));",
    "        tokens.put(token, tokenInfo);",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"token\", token); data.put(\"userId\", user.id); data.put(\"role\", user.role.name());",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    public Response createEvent(Map<String, Object> request, String token) {",
    "        if (token != null) {",
    "            Map<String, Object> auth = validateToken(token);",
    "            if (auth == null) return errorResponse(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "            if (!\"ADMIN\".equals(auth.get(\"role\"))) return errorResponse(403, \"FORBIDDEN\", \"Admin required\");",
    "        }",
    "        String[] required = {\"name\", \"date\", \"venue\", \"totalTickets\", \"pricePerTicket\"};",
    "        for (String field : required)",
    "            if (!request.containsKey(field)) return errorResponse(400, \"VALIDATION_ERROR\", \"Missing: \" + field);",
    "        String eventId = String.format(\"evt_%03d\", ++eventCounter);",
    "        Event event = new Event(eventId, (String) request.get(\"name\"),",
    "            Instant.parse((String) request.get(\"date\")), (String) request.get(\"venue\"),",
    "            (Integer) request.get(\"totalTickets\"), new BigDecimal(request.get(\"pricePerTicket\").toString()));",
    "        events.put(eventId, event);",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", eventId); data.put(\"availableTickets\", event.availableTickets);",
    "        body.put(\"data\", data);",
    "        return new Response(201, body);",
    "    }",
    "    ",
    "    public Response getEvent(String eventId) {",
    "        if (!events.containsKey(eventId)) return errorResponse(404, \"NOT_FOUND\", \"Event not found\");",
    "        Event e = events.get(eventId);",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", e.id); data.put(\"availableTickets\", e.availableTickets);",
    "        body.put(\"data\", data);",
    "        return new Response(200, body);",
    "    }",
    "    ",
    "    // ========== Part 3: Concurrency Methods ==========",
    "    ",
    "    private Object getEventLock(String eventId) {",
    "        return eventLocks.computeIfAbsent(eventId, k -> new Object());",
    "    }",
    "    ",
    "    /**",
    "     * Thread-safe booking with per-event pessimistic locking.",
    "     * Key insight: Check-then-act MUST be atomic.",
    "     */",
    "    public Response bookTicketsAtomic(Map<String, Object> request) {",
    "        String eventId = (String) request.get(\"eventId\");",
    "        if (!events.containsKey(eventId)) {",
    "            return errorResponse(404, \"NOT_FOUND\", \"Event not found\");",
    "        }",
    "        ",
    "        Object eventLock = getEventLock(eventId);",
    "        ",
    "        synchronized (eventLock) {",
    "            Event event = events.get(eventId);",
    "            int num = (Integer) request.get(\"numberOfTickets\");",
    "            ",
    "            // CRITICAL: Check inside synchronized block",
    "            if (event.availableTickets < num) {",
    "                return errorResponse(409, \"INSUFFICIENT_TICKETS\",",
    "                    \"Only \" + event.availableTickets + \" ticket(s) available\");",
    "            }",
    "            ",
    "            String bookingId;",
    "            lock.lock();",
    "            try {",
    "                bookingId = String.format(\"bkg_%03d\", ++bookingCounter);",
    "            } finally {",
    "                lock.unlock();",
    "            }",
    "            ",
    "            BigDecimal total = event.pricePerTicket.multiply(new BigDecimal(num));",
    "            Booking booking = new Booking(bookingId, eventId, (String) request.get(\"userId\"), num, total);",
    "            event.availableTickets -= num;",
    "            event.version++;",
    "            bookings.put(bookingId, booking);",
    "            ",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"status\", \"CONFIRMED\");",
    "            body.put(\"data\", data);",
    "            return new Response(201, body);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Simulate concurrent booking requests for testing.",
    "     */",
    "    public List<Response> simulateConcurrentBookings(List<Map<String, Object>> requests) {",
    "        Response[] responses = new Response[requests.size()];",
    "        CountDownLatch latch = new CountDownLatch(requests.size());",
    "        ExecutorService executor = Executors.newFixedThreadPool(requests.size());",
    "        ",
    "        for (int i = 0; i < requests.size(); i++) {",
    "            final int idx = i;",
    "            final Map<String, Object> req = requests.get(i);",
    "            executor.submit(() -> {",
    "                try {",
    "                    responses[idx] = bookTicketsAtomic(req);",
    "                } finally {",
    "                    latch.countDown();",
    "                }",
    "            });",
    "        }",
    "        ",
    "        try {",
    "            latch.await();",
    "        } catch (InterruptedException e) {",
    "            Thread.currentThread().interrupt();",
    "        }",
    "        executor.shutdown();",
    "        ",
    "        return Arrays.asList(responses);",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\\n\" + \"=\".repeat(50));",
    "        System.out.println(\"TICKET API - PART 3: CONCURRENCY DEMO\");",
    "        System.out.println(\"=\".repeat(50));",
    "        ",
    "        TicketAPI api = new TicketAPI();",
    "        ",
    "        // Create event with limited tickets",
    "        System.out.println(\"\\n[1] Creating event with 2 tickets...\");",
    "        Map<String, Object> eventReq = new HashMap<>();",
    "        eventReq.put(\"name\", \"Hot Concert\");",
    "        eventReq.put(\"date\", \"2024-12-31T20:00:00Z\");",
    "        eventReq.put(\"venue\", \"Arena\");",
    "        eventReq.put(\"totalTickets\", 2);",
    "        eventReq.put(\"pricePerTicket\", 150);",
    "        Response resp = api.createEvent(eventReq, null);",
    "        String eventId = (String) ((Map) resp.body.get(\"data\")).get(\"eventId\");",
    "        System.out.println(\"    Event \" + eventId + \" created\");",
    "        ",
    "        // Simulate 3 concurrent bookings",
    "        System.out.println(\"\\n[2] Simulating 3 concurrent bookings (2 tickets each)...\");",
    "        List<Map<String, Object>> requests = new ArrayList<>();",
    "        for (String user : new String[]{\"usr_A\", \"usr_B\", \"usr_C\"}) {",
    "            Map<String, Object> req = new HashMap<>();",
    "            req.put(\"eventId\", eventId);",
    "            req.put(\"userId\", user);",
    "            req.put(\"numberOfTickets\", 2);",
    "            requests.add(req);",
    "        }",
    "        ",
    "        List<Response> responses = api.simulateConcurrentBookings(requests);",
    "        ",
    "        long successCount = responses.stream().filter(r -> r.status == 201).count();",
    "        long conflictCount = responses.stream().filter(r -> r.status == 409).count();",
    "        System.out.println(\"    Results: \" + successCount + \" success, \" + conflictCount + \" conflicts\");",
    "        ",
    "        // Verify no overselling",
    "        System.out.println(\"\\n[3] Verifying no overselling...\");",
    "        Event event = api.events.get(eventId);",
    "        System.out.println(\"    Available tickets: \" + event.availableTickets);",
    "        if (event.availableTickets >= 0) {",
    "            System.out.println(\"    \u2713 No overselling occurred\");",
    "        }",
    "        ",
    "        System.out.println(\"\\nDemo complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Imports including concurrent.futures for thread simulation"
    },
    {
      "lines": "60-77",
      "explanation": "Init adds _event_locks dict for per-event locking"
    },
    {
      "lines": "210-217",
      "explanation": "_get_event_lock: Lazily creates per-event locks, protected by global lock"
    },
    {
      "lines": "219-251",
      "explanation": "book_tickets_atomic: Core concurrent booking with per-event lock and nested global lock for ID"
    },
    {
      "lines": "253-270",
      "explanation": "simulate_concurrent_bookings: ThreadPoolExecutor runs all requests in parallel"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "book_tickets_atomic": {
          "complexity": "O(1) + lock wait",
          "explanation": "Dict operations O(1), but threads may wait for lock"
        },
        "simulate_concurrent_bookings": {
          "complexity": "O(n) parallel",
          "explanation": "n requests run concurrently, wall-clock is max individual time"
        },
        "_get_event_lock": {
          "complexity": "O(1)",
          "explanation": "Dict lookup/insert with brief global lock"
        }
      },
      "overall_change": "Same O(1) per booking, but with serialization on same-event bookings"
    },
    "space": {
      "additional_space": "O(e) where e = number of events",
      "explanation": "One Lock object per event in _event_locks dict"
    }
  },
  "dry_run": {
    "example_input": "3 concurrent requests for 2 tickets each, only 2 available",
    "steps": [
      {
        "step": 1,
        "action": "All 3 threads start simultaneously",
        "state": "available=2, all waiting for event lock",
        "explanation": "ThreadPoolExecutor launches all at once"
      },
      {
        "step": 2,
        "action": "Thread A acquires event lock first",
        "state": "Thread A inside lock, B/C waiting",
        "explanation": "Race to acquire lock, one wins"
      },
      {
        "step": 3,
        "action": "Thread A reads available=2, checks 2>=2 \u2713",
        "state": "Still in lock",
        "explanation": "Check inside lock is critical"
      },
      {
        "step": 4,
        "action": "Thread A decrements to 0, creates booking",
        "state": "available=0, version=1",
        "explanation": "Atomic update"
      },
      {
        "step": 5,
        "action": "Thread A releases lock, returns 201",
        "state": "Lock released",
        "explanation": "First request succeeds"
      },
      {
        "step": 6,
        "action": "Thread B acquires lock, reads available=0",
        "state": "0 < 2, fails check",
        "explanation": "Sees updated availability"
      },
      {
        "step": 7,
        "action": "Thread B returns 409 INSUFFICIENT_TICKETS",
        "state": "Lock released",
        "explanation": "Correctly rejected"
      },
      {
        "step": 8,
        "action": "Thread C same as B, returns 409",
        "state": "Final: 1 success, 2 conflicts",
        "explanation": "No overselling"
      }
    ],
    "final_output": "[Response(201), Response(409), Response(409)]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single booking should succeed",
      "Booking more than available should fail"
    ],
    "likely_bugs": [
      "Checking availability outside lock (race)",
      "Forgetting to decrement inside lock",
      "Lock not released on error path"
    ],
    "recommended_logs_or_asserts": [
      "assert event.available_tickets >= 0",
      "log thread ID + event + action"
    ],
    "how_to_localize": "Add logging inside lock: 'Thread X: read available=Y'. If two threads log same value, lock isn't working."
  },
  "edge_cases": [
    {
      "case": "Exactly enough tickets for one request",
      "handling": "First to lock succeeds, others get 409",
      "gotcha": "Must check >= not > for boundary"
    },
    {
      "case": "Request for 0 tickets",
      "handling": "Validation rejects (1-10 range)",
      "gotcha": "Don't let 0-ticket bookings through"
    },
    {
      "case": "Event doesn't exist",
      "handling": "404 before attempting lock",
      "gotcha": "Check existence before lock to avoid locking non-existent event"
    },
    {
      "case": "Different events concurrently",
      "handling": "Different locks, both succeed",
      "gotcha": "Per-event locking enables this parallelism"
    }
  ],
  "test_cases": [
    {
      "name": "Race condition prevention - same event",
      "input": "3 requests for 2 tickets, only 2 available",
      "expected": "Exactly 1 success (201), 2 failures (409)",
      "explanation": "Pessimistic locking ensures only first-to-lock succeeds"
    },
    {
      "name": "Concurrent different events",
      "input": "2 requests to different events with sufficient tickets",
      "expected": "Both succeed (201, 201)",
      "explanation": "Per-event locking allows parallel processing"
    },
    {
      "name": "Available tickets never negative",
      "input": "Many concurrent requests exceeding capacity",
      "expected": "available_tickets >= 0 always",
      "explanation": "Invariant maintained by atomic check-then-decrement"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking availability outside the lock",
      "why_wrong": "Another thread can change availability between check and decrement",
      "correct_approach": "Check AND decrement must both be inside the lock",
      "code_example_wrong": "# WRONG\\nif event.available >= n:  # Outside lock!\\n    with lock:\\n        event.available -= n",
      "code_example_correct": "# CORRECT\\nwith lock:\\n    if event.available >= n:\\n        event.available -= n"
    },
    {
      "mistake": "Using global lock for all events",
      "why_wrong": "Serializes all bookings, poor concurrency for different events",
      "correct_approach": "Use per-event locks for fine-grained concurrency",
      "code_example_wrong": "# Coarse-grained\\nwith self.global_lock:\\n    # book any event",
      "code_example_correct": "# Fine-grained\\nwith self.event_locks[event_id]:\\n    # book specific event"
    },
    {
      "mistake": "Not protecting booking ID generation",
      "why_wrong": "Counter increment isn't atomic, could get duplicate IDs",
      "correct_approach": "Use separate lock for shared counter",
      "code_example_wrong": "booking_id = self._generate_booking_id()  # Not protected",
      "code_example_correct": "with self._lock:\\n    booking_id = self._generate_booking_id()"
    }
  ],
  "interview_tips": {
    "how_to_present": "Draw the race condition timeline first, then explain how locking fixes it. Show you understand the 'check-then-act' problem.",
    "what_to_mention": [
      "TOCTOU (Time-of-check to time-of-use) race condition",
      "Pessimistic vs optimistic locking tradeoffs",
      "Per-event locking for better throughput",
      "Database-level solutions in production"
    ],
    "time_allocation": "2 min explain problem, 3 min design, 8 min implement, 2 min test",
    "if_stuck": [
      "Start with simplest solution: global lock",
      "Then optimize to per-event locks",
      "Mention optimistic as alternative"
    ]
  },
  "connection_to_next_part": "Part 4 could add rate limiting, retries with backoff, or database integration where locking becomes SELECT FOR UPDATE or optimistic locking with version columns.",
  "communication_script": {
    "transition_from_previous": "Part 2's auth is working. For Part 3, I need to handle the case where multiple users try to book the last tickets simultaneously. This is a classic race condition problem.",
    "explaining_changes": "The key change is making the availability check and ticket decrement atomic. I'll use pessimistic locking - acquire a lock before reading, hold it through the update.",
    "while_extending_code": [
      "I'm adding per-event locks to allow concurrent bookings to different events",
      "The critical section is here - check AND decrement inside the lock",
      "I'll also add a simulation method using ThreadPoolExecutor to test this"
    ],
    "after_completing": "Now concurrent bookings are safe. Only one thread can access an event's tickets at a time. The operations are still O(1) but with lock wait time in high contention."
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Explain the race condition problem with check-then-act",
    "by_5_min": "Design decision: pessimistic with per-event locks",
    "by_12_min": "Implementation complete with both methods",
    "by_15_min": "Demo running, showing 1 success + 2 failures",
    "warning_signs": "If struggling with threading concepts at 8 min, simplify to global lock"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 booking has bugs, fix the core logic first. Concurrency won't help broken logic.",
    "if_new_requirement_unclear": "Ask: 'Should I also handle retry logic for failed bookings, or just return 409?'",
    "if_running_behind": "Skip per-event optimization, use global lock. Mention the optimization verbally."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Drawing the race condition timeline clearly",
      "Immediately identifying TOCTOU pattern",
      "Mentioning optimistic locking as alternative with tradeoffs",
      "Noting that in production you'd use database transactions",
      "Per-event locking for better concurrency"
    ]
  },
  "pattern_recognition": {
    "pattern": "Pessimistic Locking / Mutex Guard",
    "indicators": [
      "Shared mutable state",
      "Check-then-act sequence",
      "High contention expected"
    ],
    "similar_problems": [
      "Bank account transfers",
      "Inventory management",
      "Seat reservation systems"
    ],
    "template": "with lock:\\n    if check_condition():\\n        perform_action()\\n        update_state()"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'concurrent booking' and 'overselling', I immediately think race condition",
      "why": "Classic TOCTOU (time-of-check-time-of-use) bug pattern"
    },
    {
      "step": 2,
      "thought": "The key constraint is available_tickets >= 0 must always hold",
      "why": "This invariant can only be maintained if check+decrement is atomic"
    },
    {
      "step": 3,
      "thought": "Should I use pessimistic or optimistic locking?",
      "why": "Flash sale = high contention = pessimistic is simpler and guaranteed correct"
    },
    {
      "step": 4,
      "thought": "Can I improve on global locking?",
      "why": "Per-event locks allow different events to be booked in parallel"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Understanding of race conditions",
      "Correct lock placement (check inside lock)",
      "Awareness of performance tradeoffs"
    ],
    "bonus_points": [
      "Mentioning database-level locking for production",
      "Drawing timeline diagram",
      "Testing with simulation"
    ],
    "red_flags": [
      "Checking availability outside lock",
      "Not understanding why lock is needed",
      "Over-engineering with complex retry logic"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for ThreadPoolExecutor boilerplate",
      "Let it help with lock syntax"
    ],
    "what_not_to_do": [
      "Don't let AI put the check outside the lock",
      "Verify the lock placement manually"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not explaining why locking is needed",
      "Jumping to code without explaining the race"
    ],
    "technical": [
      "Lock check outside locked section",
      "Using global lock when per-event would be better"
    ],
    "communication": [
      "Not testing with concurrent simulation",
      "Forgetting to explain the 409 response"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Availability check is INSIDE the lock?",
      "Booking ID generation is thread-safe?",
      "Simulation method runs requests concurrently?",
      "Demo shows 1 success + N-1 failures for limited tickets?"
    ],
    "quick_code_review": [
      "with lock: before if check",
      "ThreadPoolExecutor with max_workers = len(requests)",
      "Responses preserved in original order"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Database transactions with SELECT FOR UPDATE",
      "Distributed locking (Redis/ZooKeeper) for multi-server",
      "Retry with exponential backoff for optimistic locking"
    ],
    "why_not_in_interview": "Focus on demonstrating understanding of the core concurrency problem",
    "how_to_mention": "Say: 'In production, I'd use database row-level locking or Redis distributed locks for horizontal scaling.'"
  },
  "generated_at": "2026-01-19T04:59:02.455888",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}