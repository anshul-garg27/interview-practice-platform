{
  "problem_title": "Task Scheduling with Dependencies - Part 3: Find Critical Path",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 extends the solution to identify the **critical path** - the specific sequence of tasks that determines the minimum project duration. While Parts 1-2 calculated the minimum time, Part 3 must also return which tasks form the longest dependency chain. This requires tracking predecessors during topological sort and backtracking to reconstruct the path.",
    "new_requirements": [
      "Track which predecessor determined each task's earliest start time",
      "Backtrack from the task with maximum completion time to build the critical path",
      "Return both the duration AND the path (not just duration)"
    ],
    "new_constraints": [
      "Must return a valid path (sequence of connected tasks)",
      "Path must start from a task with no prerequisites",
      "Path must end at a task with no dependents",
      "If multiple critical paths exist, return any one"
    ],
    "key_insight": "During topological processing, when we compute max(completion_time[prereq]), we also record WHICH prerequisite gave us that maximum. This creates a 'predecessor chain' we can follow backwards from the final task to reconstruct the critical path."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Find critical path (longest dependency chain)",
        "how_met": "Track predecessor for each task during topo sort, then backtrack from max completion task",
        "gotchas": [
          "Tasks with no prereqs have None/null predecessor",
          "Must reverse the backtracked path"
        ]
      },
      {
        "requirement": "Return both duration and path",
        "how_met": "Return tuple (max_completion_time, critical_path_list)",
        "gotchas": [
          "Empty task list returns (0, [])",
          "Cycle returns (-1, [])"
        ]
      },
      {
        "requirement": "Handle independent tasks",
        "how_met": "Independent tasks each form their own 1-task critical path; return any with max duration",
        "gotchas": [
          "Multiple valid answers possible - any is acceptable"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "find_critical_path",
        "target": "O(V+E)",
        "achieved": "O(V+E)",
        "why": "Topo sort is O(V+E), backtracking is O(V)"
      }
    ],
    "non_goals": [
      "Finding ALL critical paths (just need one)",
      "Calculating slack times for non-critical tasks"
    ]
  },
  "assumptions": [
    "If multiple critical paths exist with same length, returning any one is acceptable",
    "Task IDs in dependencies exist in task_list (validated by Part 1 behavior)",
    "No duplicate tasks in task_list",
    "Durations are positive integers"
  ],
  "tradeoffs": [
    {
      "decision": "Single predecessor map vs storing all predecessors",
      "chosen": "Single predecessor (the one that determines start time)",
      "why": "We only need ONE critical path, not all of them. Storing one predecessor per task is O(V) space and sufficient.",
      "alternative": "Store all predecessors with same max time",
      "when_to_switch": "If requirement changes to 'find all critical paths' or 'count critical paths'"
    },
    {
      "decision": "Inline predecessor tracking vs separate pass",
      "chosen": "Inline during topo sort",
      "why": "O(V+E) single pass instead of O(V+E) topo sort + O(V+E) separate predecessor calculation",
      "alternative": "Run topo sort first, then compute predecessors in second pass",
      "when_to_switch": "If code needs to be more modular or predecessor logic is complex"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "schedule_tasks signature",
      "schedule_tasks_with_workers signature",
      "Graph building pattern"
    ],
    "what_to_change": [
      "Add predecessor map during topo sort",
      "Add backtracking logic after topo sort"
    ],
    "interfaces_and_boundaries": "find_critical_path is independent of Part 2 (doesn't use workers). It's a variant of Part 1 with additional tracking.",
    "invariants": [
      "predecessor[task] is either None (no prereqs) or a valid task ID that is a direct prerequisite",
      "Following predecessor chain always leads to a task with predecessor=None",
      "Critical path length equals max(completion_time)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1/2): Just compute completion times\n  completion_time = {1: 3, 2: 5, 3: 8, 4: 11}\n  Result: min_time = 11\n\nAFTER (Part 3): Also track predecessors\n  completion_time = {1: 3, 2: 5, 3: 8, 4: 11}\n  predecessor = {1: None, 2: 1, 3: 1, 4: 3}  \u2190 NEW!\n  \n  Backtrack from task 4 (max completion):\n    4 \u2192 predecessor[4]=3 \u2192 predecessor[3]=1 \u2192 predecessor[1]=None \u2192 STOP\n  \n  Critical Path: [1, 3, 4] (reversed)\n  Result: (11, [1, 3, 4])\n```",
    "algorithm_flow": "```\nStep 1: Build graph (same as Part 1)\n        1(3) \u2192 2(2) \u2192 4(3)\n          \u2514\u2500\u2500\u2192 3(5) \u2500\u2500\u2518\n\nStep 2: Topo sort with predecessor tracking\n        Process 1: completion=3, pred=None\n        Process 2: completion=5, pred=1 (only prereq)\n        Process 3: completion=8, pred=1 (only prereq)\n        Process 4: completion=11, pred=3 (3 gives max: 8 > 5)\n\nStep 3: Find max completion \u2192 task 4 (11)\n\nStep 4: Backtrack: 4\u21923\u21921\u2192None\n        Path: [1, 3, 4]\n```"
  },
  "approaches": [
    {
      "name": "Naive: Enumerate All Paths",
      "description": "DFS to enumerate all paths from sources to sinks, compute length of each, return longest",
      "time_complexity": "O(V! or 2^V)",
      "space_complexity": "O(V) for recursion",
      "why_not_optimal": "Exponential time - a DAG can have exponentially many paths. For V=20 tasks, this could mean millions of paths."
    },
    {
      "name": "Optimal: Predecessor Tracking + Backtrack",
      "description": "During topological sort, record which predecessor gave max completion time. After finding task with max completion, backtrack through predecessors.",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V) additional for predecessor map",
      "key_insight": "We already compute max(completion_time[prereq]) - we just need to remember WHICH prereq gave that max. This is the classic 'parent pointer' technique for path reconstruction."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The optimal solution leverages **dynamic programming on DAG** with **predecessor tracking**:\n\n1. **During topo sort**: When computing `completion_time[task] = max(completion_time[prereq]) + duration[task]`, also record `predecessor[task] = argmax(completion_time[prereq])`\n\n2. **Find endpoint**: The task with maximum completion time is the end of the critical path\n\n3. **Backtrack**: Follow predecessor pointers from end task until reaching a task with no predecessor (None)\n\n4. **Reverse**: The backtracked path is in reverse order; reverse it to get start\u2192end order\n\n**Why this works**: The predecessor chain captures the \"longest path prefix\" for each task. The maximum completion task must be at the end of SOME longest path, and its predecessors trace back along that path.",
    "data_structures": [
      {
        "structure": "HashMap (predecessor)",
        "purpose": "Map each task to the prerequisite that determined its start time"
      },
      {
        "structure": "List (critical_path)",
        "purpose": "Collect tasks during backtracking, then reverse"
      }
    ],
    "algorithm_steps": [
      "Step 1: Build graph and reverse_graph (same as Part 1)",
      "Step 2: Initialize predecessor map (all tasks map to None initially)",
      "Step 3: During topo sort, for each task find the prereq with max completion time",
      "Step 4: Record that prereq as predecessor[task]",
      "Step 5: After topo sort, find task with maximum completion_time",
      "Step 6: Backtrack through predecessor pointers until None",
      "Step 7: Reverse the collected path and return (max_time, path)"
    ]
  },
  "solution_python_lines": [
    "from collections import defaultdict, deque",
    "from typing import List, Tuple",
    "import heapq",
    "",
    "class TaskScheduler:",
    "    \"\"\"Task scheduling with dependencies, workers, and critical path.\"\"\"",
    "    ",
    "    def schedule_tasks(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "        \"\"\"Part 1: Unlimited workers. Returns (min_time, order) or (-1, []) if cycle.\"\"\"",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            max_prereq_time = max((completion_time[p] for p in reverse_graph[task]), default=0)",
    "            completion_time[task] = max_prereq_time + duration[task]",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return (-1, [])",
    "        return (max(completion_time.values()), order)",
    "    ",
    "    def schedule_tasks_with_workers(self, task_list: List[List[int]], dependency_list: List[List[int]], k: int) -> int:",
    "        \"\"\"Part 2: Schedule with k limited workers. Returns min time or -1 if cycle.\"\"\"",
    "        if not task_list:",
    "            return 0",
    "        ",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        worker_heap = [0] * k",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            prereq_done = max((completion_time[p] for p in reverse_graph[task]), default=0)",
    "            worker_free = heapq.heappop(worker_heap)",
    "            start_time = max(prereq_done, worker_free)",
    "            completion_time[task] = start_time + duration[task]",
    "            heapq.heappush(worker_heap, completion_time[task])",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return -1",
    "        return max(completion_time.values())",
    "    ",
    "    def find_critical_path(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "        \"\"\"",
    "        Part 3: Find critical path - longest dependency chain.",
    "        Track predecessor during topo sort, then backtrack from max completion task.",
    "        Time: O(V+E), Space: O(V+E)",
    "        \"\"\"",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        # Build graph (same as Part 1)",
    "        duration = {task_id: dur for task_id, dur in task_list}",
    "        graph = defaultdict(list)",
    "        reverse_graph = defaultdict(list)",
    "        in_degree = {task_id: 0 for task_id in duration}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            reverse_graph[task_b].append(task_a)",
    "            in_degree[task_b] += 1",
    "        ",
    "        queue = deque(task_id for task_id in duration if in_degree[task_id] == 0)",
    "        order = []",
    "        completion_time = {}",
    "        predecessor = {}  # NEW: task -> prereq that determined its start time",
    "        ",
    "        while queue:",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            ",
    "            # Find max prereq AND which task gave it",
    "            max_prereq_time = 0",
    "            max_prereq_task = None",
    "            for p in reverse_graph[task]:",
    "                if completion_time[p] > max_prereq_time:",
    "                    max_prereq_time = completion_time[p]",
    "                    max_prereq_task = p",
    "            ",
    "            predecessor[task] = max_prereq_task",
    "            completion_time[task] = max_prereq_time + duration[task]",
    "            ",
    "            for dependent in graph[task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        if len(order) != len(duration):",
    "            return (-1, [])",
    "        ",
    "        # Find task with max completion time",
    "        end_task = max(completion_time, key=completion_time.get)",
    "        ",
    "        # Backtrack to build critical path",
    "        critical_path = []",
    "        current = end_task",
    "        while current is not None:",
    "            critical_path.append(current)",
    "            current = predecessor[current]",
    "        ",
    "        critical_path.reverse()",
    "        return (max(completion_time.values()), critical_path)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 3: Find Critical Path Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    scheduler = TaskScheduler()",
    "    ",
    "    # Example 1: Diamond pattern",
    "    tasks1 = [[1, 3], [2, 2], [3, 5], [4, 3]]",
    "    deps1 = [[1, 2], [1, 3], [2, 4], [3, 4]]",
    "    print(\"\\nDiamond Pattern:\")",
    "    print(f\"  Tasks: {tasks1}\")",
    "    print(f\"  Deps: {deps1}\")",
    "    result1 = scheduler.find_critical_path(tasks1, deps1)",
    "    print(f\"  Critical Path: {result1}\")",
    "    print(\"  Expected: (11, [1, 3, 4])\")",
    "    print(\"  Paths: 1->2->4 = 3+2+3=8, 1->3->4 = 3+5+3=11\")",
    "    ",
    "    # Example 2: Independent tasks",
    "    tasks2 = [[1, 5], [2, 5]]",
    "    deps2 = []",
    "    print(\"\\nIndependent Tasks:\")",
    "    result2 = scheduler.find_critical_path(tasks2, deps2)",
    "    print(f\"  Critical Path: {result2}\")",
    "    print(\"  Expected: (5, [1]) or (5, [2]) - either valid\")",
    "    ",
    "    # Example 3: Linear chain",
    "    tasks3 = [[1, 2], [2, 3], [3, 4]]",
    "    deps3 = [[1, 2], [2, 3]]",
    "    print(\"\\nLinear Chain:\")",
    "    result3 = scheduler.find_critical_path(tasks3, deps3)",
    "    print(f\"  Critical Path: {result3}\")",
    "    print(\"  Expected: (9, [1, 2, 3])\")",
    "    ",
    "    # Example 4: Cycle detection",
    "    tasks4 = [[1, 2], [2, 3], [3, 1]]",
    "    deps4 = [[1, 2], [2, 3], [3, 1]]",
    "    print(\"\\nCycle Detection:\")",
    "    result4 = scheduler.find_critical_path(tasks4, deps4)",
    "    print(f\"  Critical Path: {result4}\")",
    "    print(\"  Expected: (-1, [])\")",
    "    ",
    "    # Example 5: Single task",
    "    tasks5 = [[42, 10]]",
    "    deps5 = []",
    "    print(\"\\nSingle Task:\")",
    "    result5 = scheduler.find_critical_path(tasks5, deps5)",
    "    print(f\"  Critical Path: {result5}\")",
    "    print(\"  Expected: (10, [42])\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class TaskScheduler {",
    "    ",
    "    /** Part 1: Unlimited workers. Returns [totalTime, order...] or [-1] if cycle. */",
    "    public int[] scheduleTasks(int[][] taskList, int[][] dependencyList) {",
    "        if (taskList == null || taskList.length == 0) return new int[]{0};",
    "        ",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            int maxPrereq = reverseGraph.get(task).stream()",
    "                .mapToInt(completionTime::get).max().orElse(0);",
    "            completionTime.put(task, maxPrereq + duration.get(task));",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        if (order.size() != duration.size()) return new int[]{-1};",
    "        int total = Collections.max(completionTime.values());",
    "        int[] result = new int[order.size() + 1];",
    "        result[0] = total;",
    "        for (int i = 0; i < order.size(); i++) result[i + 1] = order.get(i);",
    "        return result;",
    "    }",
    "    ",
    "    /** Part 2: Schedule with k limited workers. Returns min time or -1 if cycle. */",
    "    public int scheduleTasksWithWorkers(int[][] taskList, int[][] dependencyList, int k) {",
    "        if (taskList == null || taskList.length == 0) return 0;",
    "        ",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) if (inDegree.get(id) == 0) queue.offer(id);",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        PriorityQueue<Integer> workerHeap = new PriorityQueue<>();",
    "        for (int i = 0; i < k; i++) workerHeap.offer(0);",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            int prereqDone = reverseGraph.get(task).stream()",
    "                .mapToInt(completionTime::get).max().orElse(0);",
    "            int workerFree = workerHeap.poll();",
    "            int startTime = Math.max(prereqDone, workerFree);",
    "            completionTime.put(task, startTime + duration.get(task));",
    "            workerHeap.offer(completionTime.get(task));",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        if (order.size() != duration.size()) return -1;",
    "        return Collections.max(completionTime.values());",
    "    }",
    "    ",
    "    /**",
    "     * Part 3: Find critical path - longest dependency chain.",
    "     * Track predecessor during topo sort, then backtrack from max completion task.",
    "     * Time: O(V+E), Space: O(V+E)",
    "     * @return Object[] where [0]=totalTime (Integer), [1]=criticalPath (int[])",
    "     */",
    "    public Object[] findCriticalPath(int[][] taskList, int[][] dependencyList) {",
    "        if (taskList == null || taskList.length == 0) {",
    "            return new Object[]{0, new int[]{}};",
    "        }",
    "        ",
    "        // Build graph (same as Part 1)",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            graph.put(task[0], new ArrayList<>());",
    "            reverseGraph.put(task[0], new ArrayList<>());",
    "            inDegree.put(task[0], 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            reverseGraph.get(dep[1]).add(dep[0]);",
    "            inDegree.merge(dep[1], 1, Integer::sum);",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int id : duration.keySet()) {",
    "            if (inDegree.get(id) == 0) queue.offer(id);",
    "        }",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        Map<Integer, Integer> predecessor = new HashMap<>();  // NEW: track critical predecessor",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            ",
    "            // Find max prereq AND which task gave it",
    "            int maxPrereqTime = 0;",
    "            Integer maxPrereqTask = null;",
    "            for (int p : reverseGraph.get(task)) {",
    "                if (completionTime.get(p) > maxPrereqTime) {",
    "                    maxPrereqTime = completionTime.get(p);",
    "                    maxPrereqTask = p;",
    "                }",
    "            }",
    "            ",
    "            predecessor.put(task, maxPrereqTask);",
    "            completionTime.put(task, maxPrereqTime + duration.get(task));",
    "            ",
    "            for (int dep : graph.get(task)) {",
    "                inDegree.merge(dep, -1, Integer::sum);",
    "                if (inDegree.get(dep) == 0) queue.offer(dep);",
    "            }",
    "        }",
    "        ",
    "        if (order.size() != duration.size()) {",
    "            return new Object[]{-1, new int[]{}};",
    "        }",
    "        ",
    "        // Find task with max completion time",
    "        int endTask = Collections.max(completionTime.entrySet(),",
    "            Map.Entry.comparingByValue()).getKey();",
    "        ",
    "        // Backtrack to build critical path",
    "        List<Integer> criticalPath = new ArrayList<>();",
    "        Integer current = endTask;",
    "        while (current != null) {",
    "            criticalPath.add(current);",
    "            current = predecessor.get(current);",
    "        }",
    "        Collections.reverse(criticalPath);",
    "        ",
    "        int[] pathArray = criticalPath.stream().mapToInt(i -> i).toArray();",
    "        return new Object[]{Collections.max(completionTime.values()), pathArray};",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        TaskScheduler s = new TaskScheduler();",
    "        ",
    "        // Diamond pattern",
    "        int[][] t1 = {{1,3}, {2,2}, {3,5}, {4,3}};",
    "        int[][] d1 = {{1,2}, {1,3}, {2,4}, {3,4}};",
    "        Object[] r1 = s.findCriticalPath(t1, d1);",
    "        System.out.println(\"Diamond: time=\" + r1[0] + \", path=\" + Arrays.toString((int[])r1[1]));",
    "        System.out.println(\"Expected: time=11, path=[1, 3, 4]\");",
    "        ",
    "        // Independent tasks",
    "        int[][] t2 = {{1,5}, {2,5}};",
    "        int[][] d2 = {};",
    "        Object[] r2 = s.findCriticalPath(t2, d2);",
    "        System.out.println(\"\\nIndependent: time=\" + r2[0] + \", path=\" + Arrays.toString((int[])r2[1]));",
    "        System.out.println(\"Expected: time=5, path=[1] or [2]\");",
    "        ",
    "        // Linear chain",
    "        int[][] t3 = {{1,2}, {2,3}, {3,4}};",
    "        int[][] d3 = {{1,2}, {2,3}};",
    "        Object[] r3 = s.findCriticalPath(t3, d3);",
    "        System.out.println(\"\\nLinear: time=\" + r3[0] + \", path=\" + Arrays.toString((int[])r3[1]));",
    "        System.out.println(\"Expected: time=9, path=[1, 2, 3]\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-5",
      "explanation": "Imports and class definition - extends existing TaskScheduler"
    },
    {
      "lines": "7-36",
      "explanation": "Part 1: schedule_tasks - unchanged from previous solution"
    },
    {
      "lines": "38-67",
      "explanation": "Part 2: schedule_tasks_with_workers - unchanged from previous solution"
    },
    {
      "lines": "69-77",
      "explanation": "Part 3 docstring and edge case handling for empty input"
    },
    {
      "lines": "79-94",
      "explanation": "Graph building - identical to Part 1, creates forward/reverse edges and in-degrees"
    },
    {
      "lines": "96-99",
      "explanation": "Initialize topo sort structures PLUS new predecessor map"
    },
    {
      "lines": "101-115",
      "explanation": "Core change: During topo sort, explicitly loop through prereqs to find BOTH the max time AND which task gave it"
    },
    {
      "lines": "117-125",
      "explanation": "Standard topo sort continuation - process dependents"
    },
    {
      "lines": "127-128",
      "explanation": "Cycle detection - if not all tasks processed, return failure"
    },
    {
      "lines": "130-131",
      "explanation": "Find endpoint - task with maximum completion time"
    },
    {
      "lines": "133-139",
      "explanation": "Backtrack through predecessor chain until None"
    },
    {
      "lines": "141-142",
      "explanation": "Reverse path (was built backwards) and return result tuple"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "find_critical_path": {
          "complexity": "O(V + E)",
          "explanation": "Topo sort is O(V+E). Finding max prereq per task visits all edges once (total O(E)). Backtracking is O(V) worst case. Overall: O(V+E)."
        }
      },
      "overall_change": "No change to overall complexity compared to Part 1. Part 3 is O(V+E), same as Part 1."
    },
    "space": {
      "additional_space": "O(V)",
      "explanation": "predecessor map stores one entry per task. critical_path list is at most O(V). Total additional: O(V)."
    }
  },
  "dry_run": {
    "example_input": "tasks=[[1,3], [2,2], [3,5], [4,3]], deps=[[1,2], [1,3], [2,4], [3,4]]",
    "steps": [
      {
        "step": 1,
        "action": "Build graph",
        "state": "graph={1:[2,3], 2:[4], 3:[4], 4:[]}, reverse_graph={1:[], 2:[1], 3:[1], 4:[2,3]}, in_degree={1:0, 2:1, 3:1, 4:2}",
        "explanation": "Standard graph construction"
      },
      {
        "step": 2,
        "action": "Init queue with in_degree=0",
        "state": "queue=[1], completion_time={}, predecessor={}",
        "explanation": "Task 1 has no prereqs"
      },
      {
        "step": 3,
        "action": "Process task 1",
        "state": "completion_time={1:3}, predecessor={1:None}",
        "explanation": "No prereqs, so max_prereq_time=0, predecessor=None"
      },
      {
        "step": 4,
        "action": "Queue update",
        "state": "queue=[2,3], in_degree={2:0, 3:0, 4:2}",
        "explanation": "Decrement in_degree for tasks 2,3; both become 0"
      },
      {
        "step": 5,
        "action": "Process task 2",
        "state": "completion_time={1:3, 2:5}, predecessor={1:None, 2:1}",
        "explanation": "Prereq 1 has completion=3, so predecessor=1, completion=3+2=5"
      },
      {
        "step": 6,
        "action": "Process task 3",
        "state": "completion_time={1:3, 2:5, 3:8}, predecessor={..., 3:1}",
        "explanation": "Prereq 1 has completion=3, so predecessor=1, completion=3+5=8"
      },
      {
        "step": 7,
        "action": "Process task 4",
        "state": "completion_time={1:3, 2:5, 3:8, 4:11}, predecessor={..., 4:3}",
        "explanation": "Prereqs: 2(5), 3(8). Max=8 from task 3, so predecessor=3, completion=8+3=11"
      },
      {
        "step": 8,
        "action": "Find max completion",
        "state": "end_task=4 (completion=11)",
        "explanation": "Task 4 has highest completion time"
      },
      {
        "step": 9,
        "action": "Backtrack",
        "state": "4\u2192predecessor[4]=3\u2192predecessor[3]=1\u2192predecessor[1]=None",
        "explanation": "Follow predecessor chain until None"
      },
      {
        "step": 10,
        "action": "Build and reverse path",
        "state": "path=[4,3,1] \u2192 reversed \u2192 [1,3,4]",
        "explanation": "Collected backwards, so reverse for correct order"
      }
    ],
    "final_output": "(11, [1, 3, 4])"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single task [[1, 5]] with no deps \u2192 should return (5, [1])",
      "Two independent tasks [[1, 5], [2, 3]] \u2192 should return (5, [1]) since 1 has longer duration"
    ],
    "likely_bugs": [
      "Forgetting to initialize predecessor[task] = None for tasks with no prereqs",
      "Not reversing the backtracked path",
      "Using >= instead of > when finding max prereq (could affect which path is returned)",
      "Off-by-one in completion time calculation"
    ],
    "recommended_logs_or_asserts": [
      "assert len(predecessor) == len(duration) after topo sort",
      "log predecessor map after topo sort to verify chain",
      "log backtrack steps: 'current={}, predecessor={}'",
      "assert critical_path[0] has predecessor[critical_path[0]] == None"
    ],
    "how_to_localize": "If path is wrong: 1) Check predecessor map - is each predecessor correct? 2) Check backtracking - does it follow chain correctly? 3) Check reversal."
  },
  "edge_cases": [
    {
      "case": "Empty task list",
      "handling": "Return (0, [])",
      "gotcha": "Don't try to find max of empty completion_time"
    },
    {
      "case": "Single task",
      "handling": "Return (duration, [task_id])",
      "gotcha": "Predecessor is None, path has one element"
    },
    {
      "case": "All independent tasks",
      "handling": "Return (max_duration, [task_with_max])",
      "gotcha": "Any single task with max duration is valid"
    },
    {
      "case": "Cycle in dependencies",
      "handling": "Return (-1, [])",
      "gotcha": "Same detection as Part 1 - order length != task count"
    },
    {
      "case": "Multiple critical paths of same length",
      "handling": "Return any one",
      "gotcha": "Algorithm naturally picks one based on processing order"
    }
  ],
  "test_cases": [
    {
      "name": "Diamond pattern",
      "input": "tasks=[[1,3], [2,2], [3,5], [4,3]], deps=[[1,2], [1,3], [2,4], [3,4]]",
      "expected": "(11, [1, 3, 4])",
      "explanation": "Path 1\u21923\u21924 = 3+5+3 = 11 is longest"
    },
    {
      "name": "Independent tasks",
      "input": "tasks=[[1,5], [2,5]], deps=[]",
      "expected": "(5, [1]) or (5, [2])",
      "explanation": "Either single task is a valid critical path"
    },
    {
      "name": "Linear chain",
      "input": "tasks=[[1,2], [2,3], [3,4]], deps=[[1,2], [2,3]]",
      "expected": "(9, [1, 2, 3])",
      "explanation": "Only one path exists, it's critical"
    },
    {
      "name": "Cycle detection",
      "input": "tasks=[[1,2], [2,3], [3,1]], deps=[[1,2], [2,3], [3,1]]",
      "expected": "(-1, [])",
      "explanation": "Cycle means no valid schedule"
    },
    {
      "name": "Wide diamond (multiple mid-level tasks)",
      "input": "tasks=[[1,1], [2,5], [3,2], [4,3], [5,1]], deps=[[1,2], [1,3], [1,4], [2,5], [3,5], [4,5]]",
      "expected": "(7, [1, 2, 5])",
      "explanation": "Path 1\u21922\u21925 = 1+5+1 = 7 is longest"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using max() with default but not tracking which element gave max",
      "why_wrong": "max(completion_time[p] for p in prereqs) gives the value but not which p gave it",
      "correct_approach": "Explicit loop to track both max value and corresponding task",
      "code_example_wrong": "max_prereq = max((completion_time[p] for p in reverse_graph[task]), default=0)  # Lost which p!",
      "code_example_correct": "max_prereq_time, max_prereq_task = 0, None\\nfor p in reverse_graph[task]:\\n    if completion_time[p] > max_prereq_time:\\n        max_prereq_time, max_prereq_task = completion_time[p], p"
    },
    {
      "mistake": "Forgetting to reverse the backtracked path",
      "why_wrong": "Backtracking builds path from end to start",
      "correct_approach": "Always reverse after collecting via predecessor chain",
      "code_example_wrong": "return (max_time, critical_path)  # Path is reversed!",
      "code_example_correct": "critical_path.reverse()\\nreturn (max_time, critical_path)"
    },
    {
      "mistake": "Not handling tasks with no prerequisites",
      "why_wrong": "These tasks have predecessor=None and are potential path starts",
      "correct_approach": "Initialize predecessor to None, backtrack loop terminates on None",
      "code_example_wrong": "predecessor[task] = max_prereq_task  # Undefined if no prereqs!",
      "code_example_correct": "max_prereq_task = None\\nfor p in reverse_graph[task]: ...\\npredecessor[task] = max_prereq_task  # Correctly None if no prereqs"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by recognizing this is 'longest path in DAG' - a classic DP problem. Explain that you'll leverage the existing topo sort but add predecessor tracking. Emphasize O(V+E) stays same.",
    "what_to_mention": [
      "This is essentially 'path reconstruction' pattern - common in DP",
      "Critical path analysis is fundamental in project management (PERT/CPM)",
      "Single predecessor per task is sufficient since we need ONE critical path"
    ],
    "time_allocation": "2 min to explain approach, 5 min to implement, 3 min to test/verify",
    "if_stuck": [
      "Think: 'How do I reconstruct paths in DP?' \u2192 Parent pointers!",
      "Ask: 'I want to record which prereq determined start time - is that the right direction?'",
      "Draw the example graph and manually trace which task 'caused' each completion time"
    ]
  },
  "connection_to_next_part": "Part 4 might ask for: finding ALL critical paths, calculating slack/float for non-critical tasks, or handling task priorities. The predecessor tracking infrastructure sets up for slack calculation (slack = latest_start - earliest_start).",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 handles limited workers. For Part 3, I need to find the critical path - which specific sequence of tasks determines the minimum duration. The key insight is to track predecessors during topo sort.",
    "explaining_changes": "The change is minimal: when I find max(completion_time[prereq]), I also record WHICH prereq gave that max. Then I backtrack from the end task to reconstruct the path.",
    "while_extending_code": [
      "Adding a predecessor map to track which prereq determined each task's start",
      "Changing from one-liner max() to explicit loop to capture both value and source",
      "Adding backtracking logic after topo sort completes"
    ],
    "after_completing": "This returns both duration and path in O(V+E). The predecessor chain efficiently captures the critical path without enumerating all paths."
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for Part 3",
    "by_2_min": "Recognize 'path reconstruction' pattern, explain predecessor tracking approach",
    "by_5_min": "Modify topo sort loop to track predecessors, start backtracking logic",
    "by_10_min": "Complete implementation, trace through diamond example to verify",
    "warning_signs": "If struggling with how to track predecessors at 4 min, simplify: 'I'll loop through prereqs explicitly instead of using max()'"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 3 uses same graph building as Part 1. If Part 1 works, Part 3 should work. Isolate the new code (predecessor tracking + backtracking).",
    "if_new_requirement_unclear": "Ask: 'For the critical path, do you want start\u2192end order or end\u2192start? And if multiple paths exist, any one is acceptable?'",
    "if_running_behind": "Focus on: (1) predecessor map, (2) find max completion task, (3) simple while loop backtrack. Skip fancy edge case handling."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning this is 'longest path in DAG' - shows pattern recognition",
      "Connecting to PERT/CPM from operations research",
      "Noting that slack calculation would be a natural extension",
      "Discussing how to find ALL critical paths if needed"
    ]
  },
  "pattern_recognition": {
    "pattern": "Path Reconstruction in Dynamic Programming",
    "indicators": [
      "Need to find not just optimal VALUE but optimal SOLUTION",
      "DP on DAG structure (topological order)",
      "Longest path instead of shortest path"
    ],
    "similar_problems": [
      "LC 1857 - Largest Color Value in Directed Graph",
      "LC 329 - Longest Increasing Path in Matrix",
      "Classic PERT/CPM in project management"
    ],
    "template": "# Path reconstruction template\\nparent = {}\\nfor node in topo_order:\\n    best_val, best_parent = find_best(predecessors)\\n    parent[node] = best_parent\\n    value[node] = best_val + ...\\n# Backtrack\\npath = []\\ncurr = end_node\\nwhile curr:\\n    path.append(curr)\\n    curr = parent[curr]\\npath.reverse()"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'find the path' not just 'find the length', I immediately think parent pointers",
      "why": "It's the standard way to reconstruct solutions in DP"
    },
    {
      "step": 2,
      "thought": "Critical path = longest path in DAG = can be solved with topo sort",
      "why": "DAGs allow linear-time longest path via DP"
    },
    {
      "step": 3,
      "thought": "I already have topo sort from Part 1 - just need to add predecessor tracking",
      "why": "Minimal code change, same complexity"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you recognize the path reconstruction pattern?",
      "Can you extend existing code cleanly without rewriting?",
      "Do you understand the algorithm well enough to modify it?"
    ],
    "bonus_points": [
      "Mentioning this is a classic DP pattern",
      "Noting O(V+E) complexity stays same",
      "Discussing extensions (all paths, slack times)"
    ],
    "red_flags": [
      "Trying to enumerate all paths (exponential)",
      "Rewriting topo sort from scratch",
      "Not understanding why backtracking works"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for the backtracking boilerplate",
      "Let it help with the max-finding loop syntax"
    ],
    "what_not_to_do": [
      "Don't accept exponential path enumeration solutions",
      "Verify the predecessor map initialization is correct"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Spending too long on approach without starting code",
      "Not testing with the diamond example"
    ],
    "technical": [
      "Enumerating all paths (exponential time)",
      "Forgetting to handle no-predecessor case",
      "Not reversing the backtracked path"
    ],
    "communication": [
      "Not explaining why predecessor tracking gives the critical path",
      "Forgetting to mention complexity stays O(V+E)"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does find_critical_path return (int, list) tuple?",
      "Is predecessor map correctly populated for all tasks?",
      "Did I test with diamond example: (11, [1,3,4])?",
      "Did I handle empty input and cycle cases?"
    ],
    "quick_code_review": [
      "predecessor initialized before loop",
      "Backtrack loop terminates on None",
      "Path is reversed before return",
      "Type hints on new method"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging for debugging path reconstruction",
      "Option to return all critical paths",
      "Slack time calculation for non-critical tasks"
    ],
    "why_not_in_interview": "Focus on core algorithm; mention these as extensions",
    "how_to_mention": "Say: 'In production, I'd add options to find all critical paths and calculate slack times for resource planning.'"
  },
  "generated_at": "2026-01-19T05:10:25.719943",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}