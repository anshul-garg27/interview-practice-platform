{
  "problem_title": "Lowest Common Ancestor in N-ary Tree - Part 4: Distance Between Nodes Using LCA",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 adds distance calculation between any two nodes using the LCA as a pivot point. Instead of just finding the common ancestor, we now need to measure the path length (edge count) between nodes.",
    "new_requirements": [
      "Implement get_depth(root, target) to find a node's depth via DFS",
      "Implement distance(root, p, q) using the formula: depth(p) + depth(q) - 2*depth(LCA)",
      "Reuse existing LCA implementation from Part 1"
    ],
    "new_constraints": [
      "Must return edge count, not node count",
      "Root has depth 0",
      "Distance of node to itself is 0"
    ],
    "key_insight": "The LCA is the 'turning point' in the path between p and q. The distance formula cleverly computes path length by adding depths and subtracting the shared portion (from root to LCA) twice."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Calculate distance between any two nodes",
        "how_met": "distance() method using LCA formula",
        "gotchas": [
          "Must use LCA not just depths"
        ]
      },
      {
        "requirement": "Find depth of any node",
        "how_met": "get_depth() with DFS traversal",
        "gotchas": [
          "Return -1 if not found, but assume valid input"
        ]
      },
      {
        "requirement": "Reuse existing LCA",
        "how_met": "distance() calls lowest_common_ancestor()",
        "gotchas": [
          "Don't recompute LCA logic"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "get_depth",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Single DFS traversal"
      },
      {
        "operation": "distance",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "LCA is O(n), depth calls are O(n), combined still O(n)"
      }
    ],
    "non_goals": [
      "O(log n) queries (would need preprocessing)",
      "Binary Lifting optimization",
      "Euler tour + RMQ approach"
    ]
  },
  "assumptions": [
    "Both p and q exist in the tree (valid nodes)",
    "Tree is valid with no cycles",
    "Root is correctly identified (has no parent)",
    "Input nodes are not null"
  ],
  "tradeoffs": [
    {
      "decision": "DFS for depth vs Parent pointer traversal",
      "chosen": "DFS",
      "why": "Method signature includes root, making DFS natural; parent pointers may not always be set",
      "alternative": "Parent traversal O(h)",
      "when_to_switch": "When parent pointers guaranteed and h << n"
    },
    {
      "decision": "Separate depth calls vs combined traversal",
      "chosen": "Separate calls for clarity",
      "why": "Cleaner code, easier to debug, same asymptotic complexity",
      "alternative": "Single DFS computing all depths",
      "when_to_switch": "For performance-critical multiple queries"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "lowest_common_ancestor signature",
      "Node class structure",
      "All Part 1-3 methods"
    ],
    "what_to_change": [
      "Added get_depth helper",
      "Added distance method"
    ],
    "interfaces_and_boundaries": "distance() depends on LCA and depth - could be extended to support preprocessing for multiple queries",
    "invariants": [
      "depth(root) = 0",
      "distance(x, x) = 0",
      "distance(p, q) = distance(q, p)"
    ]
  },
  "visual_explanation": {
    "before_after": "Before: Only had LCA finding capability\\nAfter: Can measure actual path length between any nodes\\n\\n        1 (d=0)\\n     /  |  \\\\\\n    2   3   4 (d=1)\\n   /|       |\\n  5 6       8 (d=2)\\n\\ndistance(5, 8):\\n  Path: 5 \u2192 2 \u2192 1 \u2192 4 \u2192 8 = 4 edges\\n  Formula: 2 + 2 - 2*0 = 4 \u2713",
    "algorithm_flow": "Step 1: Find LCA(p, q) using Part 1 method\\nStep 2: Compute depth(p) via DFS\\nStep 3: Compute depth(q) via DFS\\nStep 4: Compute depth(LCA) via DFS\\nStep 5: Apply formula: d_p + d_q - 2*d_lca"
  },
  "approaches": [
    {
      "name": "Naive - BFS Path Finding",
      "description": "Use BFS to find the actual path between p and q",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "why_not_optimal": "More complex, builds explicit path, doesn't leverage LCA insight"
    },
    {
      "name": "Optimal - LCA Formula",
      "description": "Use depth formula: depth(p) + depth(q) - 2*depth(LCA)",
      "time_complexity": "O(n)",
      "space_complexity": "O(h) recursion stack",
      "key_insight": "LCA is the pivot point - distance is sum of depths minus twice the common prefix"
    }
  ],
  "optimal_solution": {
    "explanation_md": "The **distance formula** is elegant: `distance(p,q) = depth(p) + depth(q) - 2*depth(LCA)`\\n\\n**Why it works:**\\n- `depth(p)` = edges from root to p\\n- `depth(q)` = edges from root to q\\n- Path from p to q goes **up** to LCA, then **down** to q\\n- We subtract `2*depth(LCA)` because that portion (root\u2192LCA) is counted twice but not part of the p\u2192q path\\n\\n**Implementation Strategy:**\\n1. Reuse existing `lowest_common_ancestor()` from Part 1\\n2. Add helper `get_depth()` using DFS\\n3. Combine in `distance()` method",
    "data_structures": [
      {
        "structure": "Recursion stack",
        "purpose": "DFS for depth finding"
      },
      {
        "structure": "Existing LCA method",
        "purpose": "Find the lowest common ancestor"
      }
    ],
    "algorithm_steps": [
      "Step 1: If p == q, return 0 (same node)",
      "Step 2: Call lowest_common_ancestor(root, p, q) to find LCA",
      "Step 3: Compute depth of p using DFS from root",
      "Step 4: Compute depth of q using DFS from root",
      "Step 5: Compute depth of LCA using DFS from root",
      "Step 6: Return depth_p + depth_q - 2 * depth_lca"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Optional",
    "",
    "class Node:",
    "    \"\"\"N-ary tree node with children and parent pointer.\"\"\"",
    "    def __init__(self, val: int = 0, children: List['Node'] = None, parent: 'Node' = None):",
    "        self.val = val",
    "        self.children = children if children else []",
    "        self.parent = parent",
    "",
    "",
    "class Solution:",
    "    def lowest_common_ancestor(self, root: Node, p: Node, q: Node) -> Node:",
    "        \"\"\"Part 1: Single-pass DFS with bottom-up propagation.\"\"\"",
    "        if root is None:",
    "            return None",
    "        if root == p or root == q:",
    "            return root",
    "        ",
    "        count = 0",
    "        result = None",
    "        for child in root.children:",
    "            found = self.lowest_common_ancestor(child, p, q)",
    "            if found:",
    "                count += 1",
    "                result = found",
    "                if count >= 2:",
    "                    return root",
    "        return result",
    "",
    "    def lowest_common_ancestor_k(self, root: Node, nodes: List[Node]) -> Node:",
    "        \"\"\"Part 2: LCA of k nodes using DFS with counting.\"\"\"",
    "        target_set = set(nodes)",
    "        k = len(nodes)",
    "        result = [None]",
    "        ",
    "        def dfs(node: Node) -> int:",
    "            if node is None:",
    "                return 0",
    "            count = 1 if node in target_set else 0",
    "            for child in node.children:",
    "                count += dfs(child)",
    "            if count == k and result[0] is None:",
    "                result[0] = node",
    "            return count",
    "        ",
    "        dfs(root)",
    "        return result[0]",
    "",
    "    def lca_with_parent(self, p: Node, q: Node) -> Node:",
    "        \"\"\"Part 3: LCA using two-pointer technique. Time: O(h), Space: O(1)\"\"\"",
    "        ptr_a, ptr_b = p, q",
    "        while ptr_a != ptr_b:",
    "            ptr_a = ptr_a.parent if ptr_a else q",
    "            ptr_b = ptr_b.parent if ptr_b else p",
    "        return ptr_a",
    "",
    "    def get_depth(self, root: Node, target: Node) -> int:",
    "        \"\"\"",
    "        Part 4: Find depth of target node using DFS.",
    "        Root has depth 0. Returns -1 if target not found.",
    "        Time: O(n), Space: O(h)",
    "        \"\"\"",
    "        def dfs(node: Node, depth: int) -> int:",
    "            if node is None:",
    "                return -1",
    "            if node == target:",
    "                return depth",
    "            for child in node.children:",
    "                result = dfs(child, depth + 1)",
    "                if result != -1:",
    "                    return result",
    "            return -1",
    "        ",
    "        return dfs(root, 0)",
    "",
    "    def distance(self, root: Node, p: Node, q: Node) -> int:",
    "        \"\"\"",
    "        Part 4: Calculate distance (edge count) between p and q.",
    "        Formula: depth(p) + depth(q) - 2 * depth(LCA(p, q))",
    "        Time: O(n), Space: O(h)",
    "        \"\"\"",
    "        if p == q:",
    "            return 0",
    "        ",
    "        lca = self.lowest_common_ancestor(root, p, q)",
    "        depth_p = self.get_depth(root, p)",
    "        depth_q = self.get_depth(root, q)",
    "        depth_lca = self.get_depth(root, lca)",
    "        ",
    "        return depth_p + depth_q - 2 * depth_lca",
    "",
    "",
    "def build_tree_with_parents() -> tuple:",
    "    \"\"\"Build test tree with parent pointers set.\"\"\"",
    "    #       1 (d=0)",
    "    #    /  |  \\",
    "    #   2   3   4 (d=1)",
    "    #  /|       |",
    "    # 5 6       8 (d=2)",
    "    node5 = Node(5)",
    "    node6 = Node(6)",
    "    node8 = Node(8)",
    "    node2 = Node(2, [node5, node6])",
    "    node3 = Node(3)",
    "    node4 = Node(4, [node8])",
    "    root = Node(1, [node2, node3, node4])",
    "    ",
    "    root.parent = None",
    "    node2.parent = node3.parent = node4.parent = root",
    "    node5.parent = node6.parent = node2",
    "    node8.parent = node4",
    "    ",
    "    return root, node2, node3, node4, node5, node6, node8",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 4: Distance Between Nodes - Test Cases\")",
    "    print(\"=\" * 60)",
    "    ",
    "    root, node2, node3, node4, node5, node6, node8 = build_tree_with_parents()",
    "    sol = Solution()",
    "    ",
    "    # Test get_depth",
    "    print(\"\\n--- Testing get_depth ---\")",
    "    print(f\"depth(root=1) = {sol.get_depth(root, root)}\")",
    "    print(f\"depth(5) = {sol.get_depth(root, node5)}\")",
    "    print(f\"depth(8) = {sol.get_depth(root, node8)}\")",
    "    ",
    "    # Test 1: Different subtrees -> path through root",
    "    dist = sol.distance(root, node5, node8)",
    "    print(f\"\\nTest 1: distance(5, 8) = {dist}\")",
    "    print(\"  Path: 5 -> 2 -> 1 -> 4 -> 8\")",
    "    print(\"  Formula: 2 + 2 - 2*0 = 4\")",
    "    assert dist == 4",
    "    ",
    "    # Test 2: Siblings -> through parent",
    "    dist = sol.distance(root, node5, node6)",
    "    print(f\"\\nTest 2: distance(5, 6) = {dist}\")",
    "    print(\"  Path: 5 -> 2 -> 6\")",
    "    print(\"  Formula: 2 + 2 - 2*1 = 2\")",
    "    assert dist == 2",
    "    ",
    "    # Test 3: Ancestor relationship",
    "    dist = sol.distance(root, node2, node5)",
    "    print(f\"\\nTest 3: distance(2, 5) = {dist}\")",
    "    print(\"  Path: 2 -> 5\")",
    "    print(\"  Formula: 1 + 2 - 2*1 = 1\")",
    "    assert dist == 1",
    "    ",
    "    # Test 4: Same node",
    "    dist = sol.distance(root, node5, node5)",
    "    print(f\"\\nTest 4: distance(5, 5) = {dist}\")",
    "    print(\"  Same node -> 0\")",
    "    assert dist == 0",
    "    ",
    "    # Test 5: Different depths",
    "    dist = sol.distance(root, node5, node3)",
    "    print(f\"\\nTest 5: distance(5, 3) = {dist}\")",
    "    print(\"  Path: 5 -> 2 -> 1 -> 3\")",
    "    print(\"  Formula: 2 + 1 - 2*0 = 3\")",
    "    assert dist == 3",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 4 tests passed! \u2713\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "class Node {",
    "    public int val;",
    "    public List<Node> children;",
    "    public Node parent;",
    "    ",
    "    public Node() { children = new ArrayList<>(); }",
    "    public Node(int val) { this.val = val; this.children = new ArrayList<>(); }",
    "    public Node(int val, List<Node> children) { ",
    "        this.val = val; ",
    "        this.children = children; ",
    "    }",
    "}",
    "",
    "class Solution {",
    "    /** Part 1: Single-pass DFS with bottom-up propagation. */",
    "    public Node lowestCommonAncestor(Node root, Node p, Node q) {",
    "        if (root == null) return null;",
    "        if (root == p || root == q) return root;",
    "        ",
    "        int count = 0;",
    "        Node result = null;",
    "        for (Node child : root.children) {",
    "            Node found = lowestCommonAncestor(child, p, q);",
    "            if (found != null) {",
    "                count++;",
    "                result = found;",
    "                if (count >= 2) return root;",
    "            }",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    /** Part 2: LCA of k nodes using DFS with counting. */",
    "    public Node lowestCommonAncestorK(Node root, List<Node> nodes) {",
    "        Set<Node> targetSet = new HashSet<>(nodes);",
    "        int k = nodes.size();",
    "        Node[] result = new Node[1];",
    "        dfsCount(root, targetSet, k, result);",
    "        return result[0];",
    "    }",
    "    ",
    "    private int dfsCount(Node node, Set<Node> targetSet, int k, Node[] result) {",
    "        if (node == null) return 0;",
    "        int count = targetSet.contains(node) ? 1 : 0;",
    "        for (Node child : node.children) {",
    "            count += dfsCount(child, targetSet, k, result);",
    "        }",
    "        if (count == k && result[0] == null) {",
    "            result[0] = node;",
    "        }",
    "        return count;",
    "    }",
    "    ",
    "    /** Part 3: LCA using two-pointer technique. Time: O(h), Space: O(1) */",
    "    public Node lcaWithParent(Node p, Node q) {",
    "        Node ptrA = p, ptrB = q;",
    "        while (ptrA != ptrB) {",
    "            ptrA = (ptrA != null) ? ptrA.parent : q;",
    "            ptrB = (ptrB != null) ? ptrB.parent : p;",
    "        }",
    "        return ptrA;",
    "    }",
    "    ",
    "    /**",
    "     * Part 4: Find depth of target node using DFS.",
    "     * Root has depth 0. Returns -1 if target not found.",
    "     * Time: O(n), Space: O(h)",
    "     */",
    "    public int getDepth(Node root, Node target) {",
    "        return dfsDepth(root, target, 0);",
    "    }",
    "    ",
    "    private int dfsDepth(Node node, Node target, int depth) {",
    "        if (node == null) return -1;",
    "        if (node == target) return depth;",
    "        for (Node child : node.children) {",
    "            int result = dfsDepth(child, target, depth + 1);",
    "            if (result != -1) return result;",
    "        }",
    "        return -1;",
    "    }",
    "    ",
    "    /**",
    "     * Part 4: Calculate distance (edge count) between p and q.",
    "     * Formula: depth(p) + depth(q) - 2 * depth(LCA(p, q))",
    "     * Time: O(n), Space: O(h)",
    "     */",
    "    public int distance(Node root, Node p, Node q) {",
    "        if (p == q) return 0;",
    "        ",
    "        Node lca = lowestCommonAncestor(root, p, q);",
    "        int depthP = getDepth(root, p);",
    "        int depthQ = getDepth(root, q);",
    "        int depthLca = getDepth(root, lca);",
    "        ",
    "        return depthP + depthQ - 2 * depthLca;",
    "    }",
    "}",
    "",
    "public class Main {",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Part 4: Distance Between Nodes - Test Cases\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Build tree:     1",
    "        //              /  |  \\",
    "        //             2   3   4",
    "        //            /|       |",
    "        //           5 6       8",
    "        Node node5 = new Node(5);",
    "        Node node6 = new Node(6);",
    "        Node node8 = new Node(8);",
    "        Node node2 = new Node(2, Arrays.asList(node5, node6));",
    "        Node node3 = new Node(3);",
    "        Node node4 = new Node(4, Arrays.asList(node8));",
    "        Node root = new Node(1, Arrays.asList(node2, node3, node4));",
    "        ",
    "        root.parent = null;",
    "        node2.parent = node3.parent = node4.parent = root;",
    "        node5.parent = node6.parent = node2;",
    "        node8.parent = node4;",
    "        ",
    "        Solution sol = new Solution();",
    "        ",
    "        // Test depths",
    "        System.out.println(\"\\n--- Testing getDepth ---\");",
    "        System.out.println(\"depth(root=1) = \" + sol.getDepth(root, root));",
    "        System.out.println(\"depth(5) = \" + sol.getDepth(root, node5));",
    "        System.out.println(\"depth(8) = \" + sol.getDepth(root, node8));",
    "        ",
    "        // Test 1: Different subtrees",
    "        int dist = sol.distance(root, node5, node8);",
    "        System.out.println(\"\\nTest 1: distance(5, 8) = \" + dist);",
    "        System.out.println(\"  Path: 5 -> 2 -> 1 -> 4 -> 8 = 4 edges\");",
    "        assert dist == 4;",
    "        ",
    "        // Test 2: Siblings",
    "        dist = sol.distance(root, node5, node6);",
    "        System.out.println(\"\\nTest 2: distance(5, 6) = \" + dist);",
    "        System.out.println(\"  Path: 5 -> 2 -> 6 = 2 edges\");",
    "        assert dist == 2;",
    "        ",
    "        // Test 3: Ancestor relationship",
    "        dist = sol.distance(root, node2, node5);",
    "        System.out.println(\"\\nTest 3: distance(2, 5) = \" + dist);",
    "        System.out.println(\"  Path: 2 -> 5 = 1 edge\");",
    "        assert dist == 1;",
    "        ",
    "        // Test 4: Same node",
    "        dist = sol.distance(root, node5, node5);",
    "        System.out.println(\"\\nTest 4: distance(5, 5) = \" + dist);",
    "        assert dist == 0;",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All Part 4 tests passed!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Node class and imports - unchanged from Part 3"
    },
    {
      "lines": "12-28",
      "explanation": "Part 1 LCA method - preserved exactly"
    },
    {
      "lines": "30-45",
      "explanation": "Part 2 LCA for K nodes - preserved exactly"
    },
    {
      "lines": "47-53",
      "explanation": "Part 3 two-pointer LCA - preserved exactly"
    },
    {
      "lines": "55-70",
      "explanation": "NEW: get_depth() - DFS traversal tracking depth, returns when target found"
    },
    {
      "lines": "72-85",
      "explanation": "NEW: distance() - applies the formula using LCA and three depth calculations"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_depth": {
          "complexity": "O(n)",
          "explanation": "DFS visits each node at most once until target found"
        },
        "distance": {
          "complexity": "O(n)",
          "explanation": "Calls LCA O(n) + 3 depth calls O(n) each = O(4n) = O(n)"
        }
      },
      "overall_change": "Part 4 methods are O(n) per call, consistent with Parts 1-2. For m queries, total is O(mn)."
    },
    "space": {
      "additional_space": "O(h)",
      "explanation": "Recursion stack depth is bounded by tree height. No new persistent data structures."
    }
  },
  "dry_run": {
    "example_input": "distance(5, 8) on tree: 1->[2->[5,6], 3, 4->[8]]",
    "steps": [
      {
        "step": 1,
        "action": "Check if p == q",
        "state": "5 != 8, continue",
        "explanation": "Early exit for same node"
      },
      {
        "step": 2,
        "action": "Find LCA(5, 8)",
        "state": "DFS returns 1 (root)",
        "explanation": "5 under node 2, 8 under node 4, LCA is their common ancestor"
      },
      {
        "step": 3,
        "action": "get_depth(root, 5)",
        "state": "DFS: 1(d=0)->2(d=1)->5(d=2), return 2",
        "explanation": "Follow path to node 5"
      },
      {
        "step": 4,
        "action": "get_depth(root, 8)",
        "state": "DFS: 1->4->8(d=2), return 2",
        "explanation": "Follow path to node 8"
      },
      {
        "step": 5,
        "action": "get_depth(root, lca=1)",
        "state": "1==target, return 0",
        "explanation": "Root has depth 0"
      },
      {
        "step": 6,
        "action": "Apply formula",
        "state": "2 + 2 - 2*0 = 4",
        "explanation": "depth_p + depth_q - 2*depth_lca"
      }
    ],
    "final_output": "4 (path: 5\u21922\u21921\u21924\u21928)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "distance(node, node) should be 0",
      "distance(root, leaf) should equal depth(leaf)"
    ],
    "likely_bugs": [
      "Off-by-one in depth (root should be 0)",
      "Returning node count instead of edge count",
      "Not handling LCA properly when one node is ancestor"
    ],
    "recommended_logs_or_asserts": [
      "assert depth >= 0",
      "print LCA value before computing distance",
      "verify depth_lca <= min(depth_p, depth_q)"
    ],
    "how_to_localize": "1. Print depths of p, q, and LCA. 2. Manually verify formula. 3. Check if LCA is correct using Part 1 tests."
  },
  "edge_cases": [
    {
      "case": "p == q (same node)",
      "handling": "Return 0 immediately",
      "gotcha": "Don't call LCA unnecessarily"
    },
    {
      "case": "p is ancestor of q",
      "handling": "LCA = p, formula gives depth(q) - depth(p)",
      "gotcha": "LCA can be one of the input nodes"
    },
    {
      "case": "p and q are siblings",
      "handling": "LCA = parent, distance = 2",
      "gotcha": "Common case, verify formula works"
    },
    {
      "case": "p or q is root",
      "handling": "depth(root) = 0, formula handles naturally",
      "gotcha": "Root as LCA means formula simplifies"
    }
  ],
  "test_cases": [
    {
      "name": "Different subtrees",
      "input": "distance(5, 8)",
      "expected": "4",
      "explanation": "Path crosses root: 5\u21922\u21921\u21924\u21928"
    },
    {
      "name": "Siblings",
      "input": "distance(5, 6)",
      "expected": "2",
      "explanation": "Path through parent: 5\u21922\u21926"
    },
    {
      "name": "Ancestor-descendant",
      "input": "distance(2, 5)",
      "expected": "1",
      "explanation": "Direct parent-child: 2\u21925"
    },
    {
      "name": "Same node",
      "input": "distance(5, 5)",
      "expected": "0",
      "explanation": "No edges to traverse"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Computing depth as node count instead of edge count",
      "why_wrong": "Root should have depth 0, not 1",
      "correct_approach": "Start DFS with depth=0 at root",
      "code_example_wrong": "// dfs(root, target, 1) - wrong!",
      "code_example_correct": "// dfs(root, target, 0) - correct"
    },
    {
      "mistake": "Not using LCA, just computing depths",
      "why_wrong": "depth(p) + depth(q) alone overcounts the shared path",
      "correct_approach": "Must subtract 2*depth(LCA) to remove double-counted portion",
      "code_example_wrong": "return depth_p + depth_q;",
      "code_example_correct": "return depth_p + depth_q - 2 * depth_lca;"
    },
    {
      "mistake": "Rewriting LCA logic instead of reusing Part 1",
      "why_wrong": "Duplicates code, risks bugs, wastes time",
      "correct_approach": "Call self.lowest_common_ancestor(root, p, q)",
      "code_example_wrong": "// 20 lines of custom LCA...",
      "code_example_correct": "lca = self.lowest_common_ancestor(root, p, q)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by stating the distance formula and WHY it works. Then explain you'll add two methods: get_depth helper and distance that combines everything.",
    "what_to_mention": [
      "The formula is a classic tree technique",
      "Time is O(n) per query, could optimize with preprocessing for multiple queries",
      "Reusing Part 1 LCA implementation"
    ],
    "time_allocation": "2 min understand formula, 3 min implement get_depth, 3 min implement distance, 2 min test",
    "if_stuck": [
      "Draw the tree and trace the path manually",
      "Remember: LCA is where paths from p and q first meet",
      "Formula subtracts the shared prefix twice"
    ]
  },
  "connection_to_next_part": "Part 5 could add preprocessing for multiple queries using Binary Lifting or Euler Tour + RMQ, reducing per-query time to O(log n).",
  "communication_script": {
    "transition_from_previous": "Great, Part 3 gave us O(h) LCA with parent pointers. For Part 4, I need to calculate the actual distance between nodes. Let me explain my approach...",
    "explaining_changes": "The key insight is the distance formula: depth(p) + depth(q) - 2*depth(LCA). I'll add a get_depth helper and a distance method that uses our existing LCA.",
    "while_extending_code": [
      "Adding get_depth using DFS to find node depth...",
      "Now implementing distance using the formula and reusing Part 1's LCA..."
    ],
    "after_completing": "This handles Part 4. Single queries are O(n). For multiple queries, we could precompute depths or use Binary Lifting for O(log n) per query."
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Understand distance formula, identify we need get_depth helper",
    "by_5_min": "get_depth implemented and tested",
    "by_10_min": "distance implemented, all tests passing",
    "warning_signs": "If formula unclear at 3 min, draw tree and trace manually"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 LCA has bugs, fix those first. Distance depends on correct LCA.",
    "if_new_requirement_unclear": "Ask: 'Is distance measured in edges or nodes?' (Answer: edges)",
    "if_running_behind": "Skip optimization discussion, focus on getting basic distance working"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing the distance formula pattern",
      "Mentioning Binary Lifting for O(log n) queries",
      "Noting space-time tradeoff with depth precomputation",
      "Cleanly reusing existing LCA implementation"
    ]
  },
  "pattern_recognition": {
    "pattern": "Tree Distance via LCA",
    "indicators": [
      "Finding path length between tree nodes",
      "Nodes not necessarily on same path from root",
      "Tree structure (not graph)"
    ],
    "similar_problems": [
      "LC 1740 - Find Distance in a Binary Tree",
      "LC 236 - LCA of Binary Tree",
      "Tree queries in competitive programming"
    ],
    "template": "distance(p, q) = depth(p) + depth(q) - 2*depth(LCA(p,q))"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Path between p and q must go through their LCA",
      "why": "In a tree, there's exactly one path between any two nodes"
    },
    {
      "step": 2,
      "thought": "The path can be split: p\u2192LCA and LCA\u2192q",
      "why": "LCA is the turning point"
    },
    {
      "step": 3,
      "thought": "Each segment length is depth difference from LCA",
      "why": "depth(x) - depth(LCA) = edges from LCA to x"
    },
    {
      "step": 4,
      "thought": "Formula emerges: (d_p - d_lca) + (d_q - d_lca)",
      "why": "Sum of both path segments"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you derive/apply the distance formula?",
      "Do you reuse existing code appropriately?",
      "Clean implementation of helper function"
    ],
    "bonus_points": [
      "Mentioning O(1) query optimization",
      "Discussing multiple query scenarios",
      "Recognizing this as a classic technique"
    ],
    "red_flags": [
      "Not knowing the formula",
      "Implementing BFS for path finding instead",
      "Duplicating LCA code"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with get_depth DFS boilerplate",
      "Verify formula syntax"
    ],
    "what_not_to_do": [
      "Don't let AI overcomplicate with unnecessary optimization",
      "Verify AI uses existing LCA method"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not explaining why the formula works",
      "Rushing without drawing examples"
    ],
    "technical": [
      "Wrong depth calculation (off-by-one)",
      "Not handling p==q edge case"
    ],
    "communication": [
      "Not mentioning reuse of Part 1",
      "Forgetting to test with examples"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does distance(5, 5) return 0?",
      "Does get_depth(root, root) return 0?",
      "Is the formula correctly implemented?",
      "Did I trace through one example?"
    ],
    "quick_code_review": [
      "Type hints on new methods",
      "Docstrings explain purpose",
      "No code duplication with Part 1"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Caching depths for repeated queries",
      "Input validation for null nodes",
      "Metrics on query latency"
    ],
    "why_not_in_interview": "Core algorithm is the focus; mention these verbally",
    "how_to_mention": "In production, I'd precompute depths during tree construction for O(1) depth lookups."
  },
  "generated_at": "2026-01-19T05:04:29.981352",
  "_meta": {
    "problem_id": "lca_nary_tree",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}