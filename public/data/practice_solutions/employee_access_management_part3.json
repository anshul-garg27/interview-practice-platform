{
  "problem_title": "Employee Access Management System - Part 3: Time-Based Access Control",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds temporal dimension to access control. Access can now be granted with an expiry timestamp, and queries must filter out expired entries. This requires tracking when each access grant expires and evaluating validity at query time.",
    "new_requirements": [
      "Grant access with an expiry timestamp",
      "Query access valid at a specific point in time",
      "Cleanup expired entries efficiently",
      "Support both permanent (no expiry) and temporary access"
    ],
    "new_constraints": [
      "Time-based queries must not return expired access",
      "Existing permanent access methods must remain unchanged",
      "Efficient cleanup without scanning all entries (ideally)"
    ],
    "key_insight": "Store expiry timestamps alongside access types in a separate map. Use lazy evaluation at query time - only filter by expiry when explicitly asked via retrieve_access_at_time. This keeps existing methods O(1) while new methods are O(k) where k = access types per resource (max 3)."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Grant time-limited access",
        "how_met": "grant_access_with_expiry stores in timed_access_map with expiry timestamp",
        "gotchas": [
          "Don't forget -1 means permanent - delegate to grant_access"
        ]
      },
      {
        "requirement": "Query access at specific time",
        "how_met": "retrieve_access_at_time unions permanent + valid timed access",
        "gotchas": [
          "Use < not <= for expiry check: access expires AT the timestamp"
        ]
      },
      {
        "requirement": "Cleanup expired entries",
        "how_met": "cleanup_expired iterates timed_access_map and removes entries where expiry <= current_time",
        "gotchas": [
          "Clean up empty nested dicts to avoid memory leak"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "grant_access_with_expiry",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap nested lookups and set"
      },
      {
        "operation": "retrieve_access_at_time",
        "target": "O(k)",
        "achieved": "O(k)",
        "why": "k = access types per resource, max 3, so effectively O(1)"
      },
      {
        "operation": "cleanup_expired",
        "target": "O(expired entries)",
        "achieved": "O(n)",
        "why": "Must scan all timed entries; could optimize with TreeMap by expiry"
      }
    ],
    "non_goals": [
      "Time-based group access (only direct access has expiry)",
      "Automatic background cleanup",
      "Access that starts in the future"
    ]
  },
  "assumptions": [
    "Timestamps are non-negative integers (Unix-style)",
    "expiry_timestamp = -1 means permanent access (same as grant_access)",
    "Access expires exactly at the timestamp (< not <=)",
    "Multiple grants of same access type overwrite expiry (latest wins)",
    "Time-based queries only check direct access, not group inheritance"
  ],
  "tradeoffs": [
    {
      "decision": "Separate map vs modifying existing structure",
      "chosen": "Separate timed_access_map",
      "why": "Backward compatibility - existing methods unchanged, cleaner separation of concerns",
      "alternative": "Modify access_map to Dict[AccessType, int] for all",
      "when_to_switch": "If majority of access is time-limited"
    },
    {
      "decision": "Lazy vs eager expiry cleanup",
      "chosen": "Lazy (filter at query time)",
      "why": "Simpler, no background threads, always consistent",
      "alternative": "Eager with TreeMap/heap index by expiry",
      "when_to_switch": "If memory is critical and many expired entries accumulate"
    },
    {
      "decision": "Include group access in time queries",
      "chosen": "No - only direct access",
      "why": "Problem doesn't specify timed group access, keeps it simple",
      "alternative": "Add timed_group_access_map",
      "when_to_switch": "If requirements expand to timed group permissions"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1 & 2 method signatures",
      "access_map and group_access_map structures",
      "Cleanup of empty nested dicts pattern"
    ],
    "what_to_change": [
      "Added timed_access_map: employee_id \u2192 resource_id \u2192 AccessType \u2192 expiry"
    ],
    "interfaces_and_boundaries": "Time-based logic is isolated to new methods and new data structure. Part 4 could add audit logging, access policies, or hierarchical resources without touching this.",
    "invariants": [
      "timed_access_map[e][r] exists only if e has at least one timed access to r",
      "Expiry timestamp of -1 is never stored in timed_access_map (delegated to permanent)",
      "All timestamps > 0 in timed_access_map"
    ]
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURE CHANGE                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PART 2 (before):                                           \u2502\n\u2502   access_map:       E1 \u2192 {R1: {READ, WRITE}}               \u2502\n\u2502   group_access_map: G1 \u2192 {R1: {ADMIN}}                     \u2502\n\u2502   employee_groups:  E1 \u2192 {G1}                              \u2502\n\u2502                                                             \u2502\n\u2502 PART 3 (after - adds):                                      \u2502\n\u2502   timed_access_map: E1 \u2192 {R1: {READ: 3000, WRITE: 5000}}   \u2502\n\u2502                          ^                                  \u2502\n\u2502                          \u2514\u2500\u2500 expiry timestamps              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              retrieve_access_at_time(E1, R1, 4000)          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502   Step 1: Get permanent access                              \u2502\n\u2502   access_map[E1][R1] = {ADMIN}                             \u2502\n\u2502   result = {ADMIN}                                          \u2502\n\u2502                                                             \u2502\n\u2502   Step 2: Filter timed access by current_time              \u2502\n\u2502   timed_access_map[E1][R1] = {READ: 3000, WRITE: 5000}     \u2502\n\u2502                                                             \u2502\n\u2502   READ:  4000 < 3000? NO  \u2192 expired, skip                  \u2502\n\u2502   WRITE: 4000 < 5000? YES \u2192 valid, add                     \u2502\n\u2502                                                             \u2502\n\u2502   result = {ADMIN, WRITE}                                  \u2502\n\u2502                                                             \u2502\n\u2502   Return: [ADMIN, WRITE]                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive: Modify Existing Structure",
      "description": "Change access_map from Set[AccessType] to Dict[AccessType, int] where int is expiry (-1 for permanent). Every existing method must check for -1.",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(E \u00d7 R \u00d7 A)",
      "why_not_optimal": "Breaks backward compatibility. All existing methods need modification. Permanent access check overhead on every operation. Higher risk of bugs."
    },
    {
      "name": "Optimal: Parallel Timed Access Map",
      "description": "Add separate timed_access_map for time-limited access. Existing permanent access unchanged. New methods union permanent + filtered timed access.",
      "time_complexity": "O(1) grant, O(k) query where k \u2264 3",
      "space_complexity": "O(E \u00d7 R \u00d7 A) additional for timed entries",
      "key_insight": "Separation of concerns. Permanent access = always valid. Timed access = needs filtering. Union at query time. Zero changes to existing code."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution adds a **parallel data structure** `timed_access_map` that mirrors the existing `access_map` but stores **expiry timestamps** instead of just presence.\n\n**Key Design:**\n- `timed_access_map[employee_id][resource_id][access_type] = expiry_timestamp`\n- Permanent access (-1) is delegated to existing `grant_access` method\n- Query-time filtering: only return access where `current_time < expiry`\n\n**Why This Works:**\n1. **Backward compatible** - existing methods untouched\n2. **Clean separation** - permanent vs timed in different structures\n3. **Efficient** - O(1) grants, O(k) queries where k \u2264 3\n4. **Maintainable** - easy to understand and extend",
    "data_structures": [
      {
        "structure": "Dict[str, Dict[str, Dict[AccessType, int]]]",
        "purpose": "timed_access_map - stores employee \u2192 resource \u2192 access_type \u2192 expiry_timestamp"
      }
    ],
    "algorithm_steps": [
      "grant_access_with_expiry: If expiry=-1, delegate to grant_access. Else, store in timed_access_map.",
      "retrieve_access_at_time: Start with permanent access from access_map. Filter timed_access_map by current_time < expiry. Return union.",
      "cleanup_expired: Iterate timed_access_map, delete entries where expiry <= current_time. Clean up empty nested dicts."
    ]
  },
  "solution_python_lines": [
    "from enum import Enum",
    "from typing import Dict, Set, List, Optional",
    "",
    "",
    "class AccessType(Enum):",
    "    READ = \"READ\"",
    "    WRITE = \"WRITE\"",
    "    ADMIN = \"ADMIN\"",
    "",
    "",
    "class AccessManager:",
    "    \"\"\"Access manager with groups and time-based access.\"\"\"",
    "",
    "    def __init__(self):",
    "        # Part 1: permanent direct access",
    "        self.access_map: Dict[str, Dict[str, Set[AccessType]]] = {}",
    "        # Part 2: group access",
    "        self.group_access_map: Dict[str, Dict[str, Set[AccessType]]] = {}",
    "        self.employee_groups: Dict[str, Set[str]] = {}",
    "        # Part 3: time-limited access (employee -> resource -> type -> expiry)",
    "        self.timed_access_map: Dict[str, Dict[str, Dict[AccessType, int]]] = {}",
    "",
    "    # ===== Part 1 methods (unchanged) =====",
    "",
    "    def grant_access(self, employee_id: str, resource_id: str,",
    "                     access_type: AccessType) -> None:",
    "        self.access_map.setdefault(employee_id, {}).setdefault(",
    "            resource_id, set()).add(access_type)",
    "",
    "    def revoke_access(self, employee_id: str, resource_id: str,",
    "                      access_type: Optional[AccessType]) -> None:",
    "        if employee_id not in self.access_map:",
    "            return",
    "        if resource_id not in self.access_map[employee_id]:",
    "            return",
    "        if access_type is None:",
    "            del self.access_map[employee_id][resource_id]",
    "        else:",
    "            self.access_map[employee_id][resource_id].discard(access_type)",
    "            if not self.access_map[employee_id][resource_id]:",
    "                del self.access_map[employee_id][resource_id]",
    "        if not self.access_map[employee_id]:",
    "            del self.access_map[employee_id]",
    "",
    "    def retrieve_access(self, employee_id: str, resource_id: str) -> List[AccessType]:",
    "        if employee_id not in self.access_map:",
    "            return []",
    "        if resource_id not in self.access_map[employee_id]:",
    "            return []",
    "        return list(self.access_map[employee_id][resource_id])",
    "",
    "    def retrieve_resources(self, employee_id: str) -> List[str]:",
    "        if employee_id not in self.access_map:",
    "            return []",
    "        return list(self.access_map[employee_id].keys())",
    "",
    "    # ===== Part 2 methods (unchanged) =====",
    "",
    "    def add_employee_to_group(self, employee_id: str, group_id: str) -> None:",
    "        self.employee_groups.setdefault(employee_id, set()).add(group_id)",
    "",
    "    def remove_employee_from_group(self, employee_id: str, group_id: str) -> None:",
    "        if employee_id not in self.employee_groups:",
    "            return",
    "        self.employee_groups[employee_id].discard(group_id)",
    "        if not self.employee_groups[employee_id]:",
    "            del self.employee_groups[employee_id]",
    "",
    "    def grant_group_access(self, group_id: str, resource_id: str,",
    "                           access_type: AccessType) -> None:",
    "        self.group_access_map.setdefault(group_id, {}).setdefault(",
    "            resource_id, set()).add(access_type)",
    "",
    "    def revoke_group_access(self, group_id: str, resource_id: str,",
    "                            access_type: Optional[AccessType]) -> None:",
    "        if group_id not in self.group_access_map:",
    "            return",
    "        if resource_id not in self.group_access_map[group_id]:",
    "            return",
    "        if access_type is None:",
    "            del self.group_access_map[group_id][resource_id]",
    "        else:",
    "            self.group_access_map[group_id][resource_id].discard(access_type)",
    "            if not self.group_access_map[group_id][resource_id]:",
    "                del self.group_access_map[group_id][resource_id]",
    "        if not self.group_access_map[group_id]:",
    "            del self.group_access_map[group_id]",
    "",
    "    def get_effective_access(self, employee_id: str, resource_id: str) -> List[AccessType]:",
    "        result: Set[AccessType] = set()",
    "        if employee_id in self.access_map:",
    "            if resource_id in self.access_map[employee_id]:",
    "                result.update(self.access_map[employee_id][resource_id])",
    "        for group_id in self.employee_groups.get(employee_id, set()):",
    "            if group_id in self.group_access_map:",
    "                if resource_id in self.group_access_map[group_id]:",
    "                    result.update(self.group_access_map[group_id][resource_id])",
    "        return list(result)",
    "",
    "    def get_effective_resources(self, employee_id: str) -> List[str]:",
    "        result: Set[str] = set()",
    "        if employee_id in self.access_map:",
    "            result.update(self.access_map[employee_id].keys())",
    "        for group_id in self.employee_groups.get(employee_id, set()):",
    "            if group_id in self.group_access_map:",
    "                result.update(self.group_access_map[group_id].keys())",
    "        return list(result)",
    "",
    "    # ===== Part 3 methods (new) =====",
    "",
    "    def grant_access_with_expiry(self, employee_id: str, resource_id: str,",
    "                                  access_type: AccessType, expiry_timestamp: int) -> None:",
    "        \"\"\"Grant time-limited access. -1 means permanent (delegates to grant_access).\"\"\"",
    "        if expiry_timestamp == -1:",
    "            self.grant_access(employee_id, resource_id, access_type)",
    "            return",
    "        self.timed_access_map.setdefault(employee_id, {}).setdefault(",
    "            resource_id, {})[access_type] = expiry_timestamp",
    "",
    "    def retrieve_access_at_time(self, employee_id: str, resource_id: str,",
    "                                 current_time: int) -> List[AccessType]:",
    "        \"\"\"Return direct access valid at given time (permanent + non-expired timed).\"\"\"",
    "        result: Set[AccessType] = set()",
    "        ",
    "        # Permanent direct access (always valid)",
    "        if employee_id in self.access_map:",
    "            if resource_id in self.access_map[employee_id]:",
    "                result.update(self.access_map[employee_id][resource_id])",
    "        ",
    "        # Timed access (filter by expiry)",
    "        if employee_id in self.timed_access_map:",
    "            if resource_id in self.timed_access_map[employee_id]:",
    "                for access_type, expiry in self.timed_access_map[employee_id][resource_id].items():",
    "                    if current_time < expiry:",
    "                        result.add(access_type)",
    "        ",
    "        return list(result)",
    "",
    "    def cleanup_expired(self, current_time: int) -> None:",
    "        \"\"\"Remove all expired entries from timed_access_map.\"\"\"",
    "        employees_to_remove = []",
    "        ",
    "        for emp_id, resources in self.timed_access_map.items():",
    "            resources_to_remove = []",
    "            for res_id, access_types in resources.items():",
    "                expired = [at for at, exp in access_types.items() if exp <= current_time]",
    "                for at in expired:",
    "                    del access_types[at]",
    "                if not access_types:",
    "                    resources_to_remove.append(res_id)",
    "            for rid in resources_to_remove:",
    "                del resources[rid]",
    "            if not resources:",
    "                employees_to_remove.append(emp_id)",
    "        ",
    "        for eid in employees_to_remove:",
    "            del self.timed_access_map[eid]",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 3: Time-Based Access Control Demo\")",
    "    print(\"=\" * 60)",
    "",
    "    manager = AccessManager()",
    "",
    "    # Test 1: Basic timed access",
    "    print(\"\\n[Test 1] Timed access - before and after expiry\")",
    "    manager.grant_access_with_expiry(\"E1\", \"R1\", AccessType.READ, 1000)",
    "    print(f\"At t=500:  {manager.retrieve_access_at_time('E1', 'R1', 500)}\")",
    "    print(f\"At t=1500: {manager.retrieve_access_at_time('E1', 'R1', 1500)}\")",
    "    # Expected: [READ], []",
    "",
    "    # Test 2: Mix permanent and timed",
    "    print(\"\\n[Test 2] Permanent + timed access\")",
    "    manager.grant_access(\"E1\", \"R1\", AccessType.WRITE)  # permanent",
    "    manager.grant_access_with_expiry(\"E1\", \"R1\", AccessType.ADMIN, 2000)",
    "    print(f\"At t=1500: {manager.retrieve_access_at_time('E1', 'R1', 1500)}\")",
    "    print(f\"At t=2500: {manager.retrieve_access_at_time('E1', 'R1', 2500)}\")",
    "    # Expected: [WRITE, ADMIN], [WRITE]",
    "",
    "    # Test 3: -1 means permanent",
    "    print(\"\\n[Test 3] expiry=-1 delegates to permanent\")",
    "    manager.grant_access_with_expiry(\"E2\", \"R2\", AccessType.READ, -1)",
    "    print(f\"At t=999999: {manager.retrieve_access_at_time('E2', 'R2', 999999)}\")",
    "    # Expected: [READ]",
    "",
    "    # Test 4: Cleanup expired",
    "    print(\"\\n[Test 4] Cleanup expired entries\")",
    "    manager.grant_access_with_expiry(\"E3\", \"R3\", AccessType.READ, 100)",
    "    manager.grant_access_with_expiry(\"E3\", \"R3\", AccessType.WRITE, 500)",
    "    print(f\"Before cleanup (t=200): {manager.retrieve_access_at_time('E3', 'R3', 200)}\")",
    "    manager.cleanup_expired(200)",
    "    print(f\"After cleanup (t=200):  READ entry removed, WRITE still valid\")",
    "    print(f\"Query at t=200: {manager.retrieve_access_at_time('E3', 'R3', 200)}\")",
    "    # Expected: [WRITE], [WRITE]",
    "",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 3 tests passed!\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "enum AccessType {",
    "    READ, WRITE, ADMIN",
    "}",
    "",
    "public class AccessManager {",
    "    // Part 1: permanent direct access",
    "    private Map<String, Map<String, Set<AccessType>>> accessMap;",
    "    // Part 2: group access",
    "    private Map<String, Map<String, Set<AccessType>>> groupAccessMap;",
    "    private Map<String, Set<String>> employeeGroups;",
    "    // Part 3: time-limited access (employee -> resource -> type -> expiry)",
    "    private Map<String, Map<String, Map<AccessType, Long>>> timedAccessMap;",
    "",
    "    public AccessManager() {",
    "        this.accessMap = new HashMap<>();",
    "        this.groupAccessMap = new HashMap<>();",
    "        this.employeeGroups = new HashMap<>();",
    "        this.timedAccessMap = new HashMap<>();",
    "    }",
    "",
    "    // ===== Part 1 methods (unchanged) =====",
    "",
    "    public void grantAccess(String employeeId, String resourceId, AccessType accessType) {",
    "        accessMap.computeIfAbsent(employeeId, k -> new HashMap<>())",
    "                 .computeIfAbsent(resourceId, k -> new HashSet<>())",
    "                 .add(accessType);",
    "    }",
    "",
    "    public void revokeAccess(String employeeId, String resourceId, AccessType accessType) {",
    "        Map<String, Set<AccessType>> resourceMap = accessMap.get(employeeId);",
    "        if (resourceMap == null) return;",
    "        Set<AccessType> accessSet = resourceMap.get(resourceId);",
    "        if (accessSet == null) return;",
    "        if (accessType == null) {",
    "            resourceMap.remove(resourceId);",
    "        } else {",
    "            accessSet.remove(accessType);",
    "            if (accessSet.isEmpty()) resourceMap.remove(resourceId);",
    "        }",
    "        if (resourceMap.isEmpty()) accessMap.remove(employeeId);",
    "    }",
    "",
    "    public List<AccessType> retrieveAccess(String employeeId, String resourceId) {",
    "        Map<String, Set<AccessType>> resourceMap = accessMap.get(employeeId);",
    "        if (resourceMap == null) return new ArrayList<>();",
    "        Set<AccessType> accessSet = resourceMap.get(resourceId);",
    "        if (accessSet == null) return new ArrayList<>();",
    "        return new ArrayList<>(accessSet);",
    "    }",
    "",
    "    public List<String> retrieveResources(String employeeId) {",
    "        Map<String, Set<AccessType>> resourceMap = accessMap.get(employeeId);",
    "        if (resourceMap == null) return new ArrayList<>();",
    "        return new ArrayList<>(resourceMap.keySet());",
    "    }",
    "",
    "    // ===== Part 2 methods (unchanged) =====",
    "",
    "    public void addEmployeeToGroup(String employeeId, String groupId) {",
    "        employeeGroups.computeIfAbsent(employeeId, k -> new HashSet<>()).add(groupId);",
    "    }",
    "",
    "    public void removeEmployeeFromGroup(String employeeId, String groupId) {",
    "        Set<String> groups = employeeGroups.get(employeeId);",
    "        if (groups == null) return;",
    "        groups.remove(groupId);",
    "        if (groups.isEmpty()) employeeGroups.remove(employeeId);",
    "    }",
    "",
    "    public void grantGroupAccess(String groupId, String resourceId, AccessType accessType) {",
    "        groupAccessMap.computeIfAbsent(groupId, k -> new HashMap<>())",
    "                      .computeIfAbsent(resourceId, k -> new HashSet<>())",
    "                      .add(accessType);",
    "    }",
    "",
    "    public void revokeGroupAccess(String groupId, String resourceId, AccessType accessType) {",
    "        Map<String, Set<AccessType>> resourceMap = groupAccessMap.get(groupId);",
    "        if (resourceMap == null) return;",
    "        Set<AccessType> accessSet = resourceMap.get(resourceId);",
    "        if (accessSet == null) return;",
    "        if (accessType == null) {",
    "            resourceMap.remove(resourceId);",
    "        } else {",
    "            accessSet.remove(accessType);",
    "            if (accessSet.isEmpty()) resourceMap.remove(resourceId);",
    "        }",
    "        if (resourceMap.isEmpty()) groupAccessMap.remove(groupId);",
    "    }",
    "",
    "    public List<AccessType> getEffectiveAccess(String employeeId, String resourceId) {",
    "        Set<AccessType> result = new HashSet<>();",
    "        Map<String, Set<AccessType>> empResources = accessMap.get(employeeId);",
    "        if (empResources != null && empResources.containsKey(resourceId)) {",
    "            result.addAll(empResources.get(resourceId));",
    "        }",
    "        for (String groupId : employeeGroups.getOrDefault(employeeId, Collections.emptySet())) {",
    "            Map<String, Set<AccessType>> grpResources = groupAccessMap.get(groupId);",
    "            if (grpResources != null && grpResources.containsKey(resourceId)) {",
    "                result.addAll(grpResources.get(resourceId));",
    "            }",
    "        }",
    "        return new ArrayList<>(result);",
    "    }",
    "",
    "    public List<String> getEffectiveResources(String employeeId) {",
    "        Set<String> result = new HashSet<>();",
    "        Map<String, Set<AccessType>> empResources = accessMap.get(employeeId);",
    "        if (empResources != null) {",
    "            result.addAll(empResources.keySet());",
    "        }",
    "        for (String groupId : employeeGroups.getOrDefault(employeeId, Collections.emptySet())) {",
    "            Map<String, Set<AccessType>> grpResources = groupAccessMap.get(groupId);",
    "            if (grpResources != null) {",
    "                result.addAll(grpResources.keySet());",
    "            }",
    "        }",
    "        return new ArrayList<>(result);",
    "    }",
    "",
    "    // ===== Part 3 methods (new) =====",
    "",
    "    /** Grant time-limited access. -1 means permanent. */",
    "    public void grantAccessWithExpiry(String employeeId, String resourceId,",
    "                                       AccessType accessType, long expiryTimestamp) {",
    "        if (expiryTimestamp == -1) {",
    "            grantAccess(employeeId, resourceId, accessType);",
    "            return;",
    "        }",
    "        timedAccessMap.computeIfAbsent(employeeId, k -> new HashMap<>())",
    "                      .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "                      .put(accessType, expiryTimestamp);",
    "    }",
    "",
    "    /** Return direct access valid at given time (permanent + non-expired timed). */",
    "    public List<AccessType> retrieveAccessAtTime(String employeeId, String resourceId,",
    "                                                  long currentTime) {",
    "        Set<AccessType> result = new HashSet<>();",
    "        ",
    "        // Permanent direct access",
    "        Map<String, Set<AccessType>> empResources = accessMap.get(employeeId);",
    "        if (empResources != null && empResources.containsKey(resourceId)) {",
    "            result.addAll(empResources.get(resourceId));",
    "        }",
    "        ",
    "        // Timed access (filter by expiry)",
    "        Map<String, Map<AccessType, Long>> timedResources = timedAccessMap.get(employeeId);",
    "        if (timedResources != null && timedResources.containsKey(resourceId)) {",
    "            for (Map.Entry<AccessType, Long> entry : timedResources.get(resourceId).entrySet()) {",
    "                if (currentTime < entry.getValue()) {",
    "                    result.add(entry.getKey());",
    "                }",
    "            }",
    "        }",
    "        return new ArrayList<>(result);",
    "    }",
    "",
    "    /** Remove all expired entries from timedAccessMap. */",
    "    public void cleanupExpired(long currentTime) {",
    "        Iterator<Map.Entry<String, Map<String, Map<AccessType, Long>>>> empIt = ",
    "            timedAccessMap.entrySet().iterator();",
    "        ",
    "        while (empIt.hasNext()) {",
    "            Map<String, Map<AccessType, Long>> resources = empIt.next().getValue();",
    "            Iterator<Map.Entry<String, Map<AccessType, Long>>> resIt = ",
    "                resources.entrySet().iterator();",
    "            ",
    "            while (resIt.hasNext()) {",
    "                Map<AccessType, Long> accessTypes = resIt.next().getValue();",
    "                accessTypes.entrySet().removeIf(e -> e.getValue() <= currentTime);",
    "                if (accessTypes.isEmpty()) resIt.remove();",
    "            }",
    "            if (resources.isEmpty()) empIt.remove();",
    "        }",
    "    }",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Part 3: Time-Based Access Control Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "",
    "        AccessManager manager = new AccessManager();",
    "",
    "        // Test 1: Basic timed access",
    "        System.out.println(\"\\n[Test 1] Timed access - before and after expiry\");",
    "        manager.grantAccessWithExpiry(\"E1\", \"R1\", AccessType.READ, 1000);",
    "        System.out.println(\"At t=500:  \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 500));",
    "        System.out.println(\"At t=1500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 1500));",
    "",
    "        // Test 2: Mix permanent and timed",
    "        System.out.println(\"\\n[Test 2] Permanent + timed access\");",
    "        manager.grantAccess(\"E1\", \"R1\", AccessType.WRITE);",
    "        manager.grantAccessWithExpiry(\"E1\", \"R1\", AccessType.ADMIN, 2000);",
    "        System.out.println(\"At t=1500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 1500));",
    "        System.out.println(\"At t=2500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 2500));",
    "",
    "        // Test 3: -1 means permanent",
    "        System.out.println(\"\\n[Test 3] expiry=-1 delegates to permanent\");",
    "        manager.grantAccessWithExpiry(\"E2\", \"R2\", AccessType.READ, -1);",
    "        System.out.println(\"At t=999999: \" + manager.retrieveAccessAtTime(\"E2\", \"R2\", 999999));",
    "",
    "        // Test 4: Cleanup",
    "        System.out.println(\"\\n[Test 4] Cleanup expired entries\");",
    "        manager.grantAccessWithExpiry(\"E3\", \"R3\", AccessType.READ, 100);",
    "        manager.grantAccessWithExpiry(\"E3\", \"R3\", AccessType.WRITE, 500);",
    "        System.out.println(\"Before cleanup: \" + manager.retrieveAccessAtTime(\"E3\", \"R3\", 200));",
    "        manager.cleanupExpired(200);",
    "        System.out.println(\"After cleanup:  \" + manager.retrieveAccessAtTime(\"E3\", \"R3\", 200));",
    "",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All Part 3 tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "explanation": "Class setup with Part 1, 2, and new Part 3 data structure (timed_access_map)"
    },
    {
      "lines": "100-107",
      "explanation": "grant_access_with_expiry: If -1, delegate to permanent. Otherwise store expiry timestamp in nested map."
    },
    {
      "lines": "109-122",
      "explanation": "retrieve_access_at_time: Union permanent access + timed access where current_time < expiry"
    },
    {
      "lines": "124-140",
      "explanation": "cleanup_expired: Iterate all timed entries, remove expired, clean up empty dicts"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "grant_access_with_expiry": {
          "complexity": "O(1)",
          "explanation": "HashMap computeIfAbsent + put"
        },
        "retrieve_access_at_time": {
          "complexity": "O(k)",
          "explanation": "k = access types per resource, max 3. Effectively O(1)"
        },
        "cleanup_expired": {
          "complexity": "O(n)",
          "explanation": "n = total timed entries. Must scan all to find expired."
        }
      },
      "overall_change": "Part 1 & 2 methods unchanged. New queries are O(1) effective. Cleanup is O(n) but called infrequently."
    },
    "space": {
      "additional_space": "O(E \u00d7 R \u00d7 A)",
      "explanation": "timed_access_map mirrors access_map size. Each timed access entry stores one long/int for expiry."
    }
  },
  "dry_run": {
    "example_input": "grantAccessWithExpiry(E1, R1, READ, 1000) then retrieveAccessAtTime(E1, R1, 500) and (E1, R1, 1500)",
    "steps": [
      {
        "step": 1,
        "action": "grantAccessWithExpiry(E1, R1, READ, 1000)",
        "state": "timed_access_map = {E1: {R1: {READ: 1000}}}",
        "explanation": "1000 != -1, so store in timed_access_map"
      },
      {
        "step": 2,
        "action": "retrieveAccessAtTime(E1, R1, 500)",
        "state": "Check: 500 < 1000 \u2192 true",
        "explanation": "READ not expired, return [READ]"
      },
      {
        "step": 3,
        "action": "retrieveAccessAtTime(E1, R1, 1500)",
        "state": "Check: 1500 < 1000 \u2192 false",
        "explanation": "READ expired, return []"
      }
    ],
    "final_output": "[READ] at t=500, [] at t=1500"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Grant with expiry=1000, query at t=500 should include it",
      "Query at t=1000 should NOT include it (< not <=)"
    ],
    "likely_bugs": [
      "Using <= instead of < for expiry check",
      "Forgetting to handle -1 as permanent",
      "Not cleaning up empty nested maps"
    ],
    "recommended_logs_or_asserts": [
      "assert expiry > 0 or expiry == -1",
      "log timed_access_map state after mutations"
    ],
    "how_to_localize": "1. Print timed_access_map after grant. 2. Print each expiry comparison in retrieve. 3. Verify permanent vs timed separation."
  },
  "edge_cases": [
    {
      "case": "expiry_timestamp = -1",
      "handling": "Delegate to permanent grant_access, not stored in timed_access_map",
      "gotcha": "Don't store -1 in timed map"
    },
    {
      "case": "Query at exact expiry time",
      "handling": "current_time < expiry, so at expiry it's already invalid",
      "gotcha": "Use < not <="
    },
    {
      "case": "Same access type granted permanent and timed",
      "handling": "Stored separately, permanent always valid",
      "gotcha": "Union at query time handles this"
    },
    {
      "case": "Cleanup when all entries expired",
      "handling": "Remove empty dicts at all levels",
      "gotcha": "Memory leak if empty dicts left"
    }
  ],
  "test_cases": [
    {
      "name": "Basic expiry",
      "input": "grant_access_with_expiry(E1, R1, READ, 1000), retrieve at t=500 and t=1500",
      "expected": "[READ], []",
      "explanation": "Before expiry returns access, after expiry returns empty"
    },
    {
      "name": "Permanent + timed mix",
      "input": "grant_access(E1, R1, WRITE), grant_access_with_expiry(E1, R1, READ, 1000), retrieve at t=1500",
      "expected": "[WRITE]",
      "explanation": "Permanent WRITE survives, timed READ expired"
    },
    {
      "name": "-1 as permanent",
      "input": "grant_access_with_expiry(E1, R1, READ, -1), retrieve at t=999999",
      "expected": "[READ]",
      "explanation": "-1 delegates to permanent, always valid"
    },
    {
      "name": "Cleanup removes expired only",
      "input": "grant with expiry 100 and 500, cleanup at 200, query at 200",
      "expected": "Only expiry=500 remains",
      "explanation": "Cleanup removes expiry<=200, keeps expiry>200"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using <= instead of < for expiry check",
      "why_wrong": "Access should be invalid AT the expiry timestamp",
      "correct_approach": "Use current_time < expiry (strict less than)",
      "code_example_wrong": "if current_time <= expiry:  # Wrong",
      "code_example_correct": "if current_time < expiry:  # Correct"
    },
    {
      "mistake": "Storing -1 in timed_access_map",
      "why_wrong": "-1 means permanent, should use existing access_map",
      "correct_approach": "Check for -1 first and delegate to grant_access",
      "code_example_wrong": "timed_map[e][r][type] = -1  # Wrong",
      "code_example_correct": "if expiry == -1: grant_access(...); return"
    },
    {
      "mistake": "Not cleaning up empty nested dicts",
      "why_wrong": "Memory leak over time as entries expire",
      "correct_approach": "After removing entries, check if parent dict is empty and remove it",
      "code_example_wrong": "del access_types[at]  # Stop here",
      "code_example_correct": "del access_types[at]; if not access_types: del resources[res_id]"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the design decision: separate timed_access_map keeps existing code unchanged. Then walk through the expiry check logic.",
    "what_to_mention": [
      "Why < not <= for expiry",
      "Why -1 delegates to permanent",
      "O(1) grants, O(k) queries",
      "Cleanup is O(n) but infrequent"
    ],
    "time_allocation": "15-20 min: 3 min understand, 5 min design, 10 min implement, 2 min test",
    "if_stuck": [
      "Think: what data do I need to store?",
      "Start with the simplest query: just check one timestamp",
      "Don't optimize cleanup yet, get basic version working"
    ]
  },
  "connection_to_next_part": "Part 4 could add: audit logging (who granted access when), access policies (conditions beyond time), or resource hierarchies (folder contains files). The clean separation in Part 3 makes these extensions straightforward.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 handles group inheritance. For Part 3, I need to add time-based expiry. The key insight is to keep a separate map for timed access so existing permanent access logic is unchanged.",
    "explaining_changes": "I'll add timed_access_map with structure employee \u2192 resource \u2192 accessType \u2192 expiryTimestamp. New grant stores there, new query filters by current_time < expiry.",
    "while_extending_code": [
      "Adding timed_access_map initialization...",
      "New grant method checks -1 for permanent delegation...",
      "Query unions permanent + valid timed..."
    ],
    "after_completing": "This handles time-based access. Grants are O(1), queries are O(k) where k \u2264 3. Cleanup is O(n) but only called when needed. Ready for Part 4?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes",
    "by_2_min": "Understand: expiry stored per access type, filter at query time",
    "by_5_min": "Design: separate timed_access_map, explain < vs <= for expiry",
    "by_12_min": "Implementation complete, basic tests passing",
    "warning_signs": "If still designing at 7 min, simplify. Skip cleanup optimization if behind."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Time-based logic is isolated. If Part 2 group access has bugs, they won't affect Part 3 direct access. Fix Part 2 first if needed.",
    "if_new_requirement_unclear": "Ask: 'Should retrieve_access_at_time include group access, or just direct?' (Answer: just direct for simplicity)",
    "if_running_behind": "Implement grant + retrieve first. Cleanup can be mentioned as 'I'd add cleanup_expired that scans timed_access_map'."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing separate map for backward compatibility",
      "Mentioning < vs <= distinction for expiry semantics",
      "Discussing TreeMap optimization for O(log n) cleanup by expiry time",
      "Proactively handling -1 as permanent delegation"
    ]
  },
  "pattern_recognition": {
    "pattern": "Time-based invalidation / TTL (Time-To-Live)",
    "indicators": [
      "Expiry timestamp",
      "Valid at time T",
      "Automatic cleanup",
      "Lazy vs eager expiration"
    ],
    "similar_problems": [
      "LRU Cache with TTL",
      "Session management",
      "DNS record expiry",
      "Certificate validity checking"
    ],
    "template": "Store (value, expiry) pairs. Query: return if current_time < expiry. Cleanup: iterate and remove expired."
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'expiry timestamp', I think TTL pattern - store expiry alongside data",
      "why": "Common pattern in caches, sessions, certificates"
    },
    {
      "step": 2,
      "thought": "Keep existing structure unchanged, add parallel timed map",
      "why": "Backward compatibility, cleaner separation"
    },
    {
      "step": 3,
      "thought": "Filter at query time, not grant time",
      "why": "Lazy evaluation - simpler, always consistent"
    },
    {
      "step": 4,
      "thought": "-1 should delegate to permanent",
      "why": "Problem hint says -1 means permanent, avoid special-casing everywhere"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend without breaking existing code?",
      "Do you handle edge cases (expiry boundary, -1)?",
      "Is your complexity analysis correct?"
    ],
    "bonus_points": [
      "Mentioning TreeMap optimization for cleanup",
      "Discussing whether group access should also be time-based",
      "Clean separation of concerns"
    ],
    "red_flags": [
      "Modifying existing access_map structure",
      "Using <= instead of <",
      "Forgetting to handle -1 case",
      "Not cleaning up empty maps"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI generate the nested map boilerplate",
      "Use AI for Iterator-based cleanup in Java"
    ],
    "what_not_to_do": [
      "Don't let AI decide the data structure - that's your design",
      "Verify the expiry comparison operator"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining the approach",
      "Not asking about edge cases like exact expiry time"
    ],
    "technical": [
      "Modifying existing methods unnecessarily",
      "Storing -1 in timed_access_map",
      "Wrong comparison operator"
    ],
    "communication": [
      "Not explaining why separate map is better",
      "Forgetting to walk through an example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does grant_access_with_expiry handle -1 correctly?",
      "Does retrieve_access_at_time use < not <=?",
      "Are empty nested maps cleaned up in cleanup_expired?",
      "Did I test before/at/after expiry timestamp?"
    ],
    "quick_code_review": [
      "timed_access_map initialized in __init__",
      "Type hints on new methods",
      "Docstrings explain key behavior"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "TreeMap index by expiry for O(log n) cleanup",
      "Background thread for automatic expiry",
      "Metrics on expired entry rate",
      "Logging for security audit"
    ],
    "why_not_in_interview": "Focus on core algorithm. O(n) cleanup is fine for interview scope.",
    "how_to_mention": "Say: 'In production, I'd add a TreeMap index by expiry time for efficient cleanup, and possibly a background thread for automatic expiry.'"
  },
  "generated_at": "2026-01-19T04:40:22.029232",
  "_meta": {
    "problem_id": "employee_access_management",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}