{
  "problem_title": "Delivery Cost Tracking System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **OOP system design** problem disguised as a calculation problem. The key trap is the O(1) requirement for `getTotalCost()` - this immediately signals we need **pre-computation**. It's testing: (1) ability to recognize when to cache vs compute, (2) financial precision handling, (3) clean API design.",
    "pattern_recognition": "**Pre-computation / Running Total Pattern** - When queries are frequent and updates are infrequent, compute on write, not on read. Also uses **HashMap for O(1) lookup** and **Decimal for precision**.",
    "key_constraints": [
      "O(1) getTotalCost() - This is the critical constraint that drives the entire design. Cannot iterate on every call.",
      "Decimal precision required - Using float/double will cause 0.1 + 0.1 + 0.1 \u2260 0.3 errors",
      "Times in epoch seconds - Must divide by 3600 to convert to hours, watch for integer division",
      "Up to 10\u2075 total deliveries - Confirms O(n) per getTotalCost() would be too slow with frequent calls"
    ],
    "clarifying_questions": [
      "What precision is needed for currency? Should I use BigDecimal/Decimal? \u2014 Confirms the precision trap",
      "How frequently will getTotalCost() be called relative to addDelivery()? \u2014 Confirms O(1) is necessary",
      "Should I throw an error if addDelivery is called for non-existent driver? \u2014 Clarifies error handling expectations",
      "Can times be equal (zero-duration delivery)? \u2014 Edge case handling",
      "Can hourly rate be negative or zero? \u2014 Input validation requirements",
      "Is thread-safety required? \u2014 Scope of solution (usually no for interviews)",
      "Do I need to store individual deliveries or just track the total? \u2014 Memory optimization"
    ],
    "edge_cases_to_consider": [
      "Driver with no deliveries - should not affect total",
      "Zero-duration delivery (startTime == endTime) - cost should be 0",
      "1-second delivery - tests precision ($3600/hr \u00d7 1s = $1.00 exactly)",
      "No drivers/deliveries yet - getTotalCost() should return 0",
      "Very large time values (epoch seconds near 10\u2079)",
      "Fractional cents (e.g., 17 seconds at $20/hr)"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "addDriver(driverId, hourlyRate) - Register a driver",
        "how_met": "Store in HashMap<driverId, rate>",
        "gotchas": [
          "What if driver already exists? Overwrite or error?"
        ]
      },
      {
        "requirement": "addDelivery(driverId, startTime, endTime) - Record delivery",
        "how_met": "Lookup rate, calculate cost, add to running total",
        "gotchas": [
          "Driver must exist",
          "Use Decimal math, not float"
        ]
      },
      {
        "requirement": "getTotalCost() must be O(1)",
        "how_met": "Return pre-computed running total, no iteration",
        "gotchas": [
          "Don't calculate on every call"
        ]
      },
      {
        "requirement": "Currency precision",
        "how_met": "Use Decimal (Python) or BigDecimal (Java)",
        "gotchas": [
          "Convert times to Decimal BEFORE division"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "addDriver",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion"
      },
      {
        "operation": "addDelivery",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup + arithmetic"
      },
      {
        "operation": "getTotalCost",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Return cached running total"
      }
    ],
    "non_goals": [
      "Storing individual deliveries (not needed for Part 1)",
      "Removing or modifying deliveries",
      "Driver rate updates after deliveries",
      "Thread-safety (unless asked)"
    ]
  },
  "assumptions": [
    "Driver IDs are unique - addDriver with existing ID either overwrites or is not called (clarify with interviewer)",
    "addDelivery is only called for registered drivers - undefined behavior otherwise (I'll throw error)",
    "Deliveries don't overlap for same driver (given in problem) - no need to merge intervals",
    "All input values are valid (positive rates, endTime > startTime) - minimal validation for interview scope",
    "Currency precision is exact (no rounding) - use Decimal as-is"
  ],
  "tradeoffs": [
    {
      "decision": "Pre-compute on write vs calculate on read",
      "chosen": "Pre-compute on write (running total)",
      "why": "Meets O(1) getTotalCost() requirement. Read-heavy workload (frequent cost queries)",
      "alternative": "Calculate on each getTotalCost() call",
      "when_to_switch": "If deliveries are queried rarely but modified often, or if we need to support removeDelivery()"
    },
    {
      "decision": "Store deliveries vs just store total",
      "chosen": "Just store total (for Part 1)",
      "why": "Minimal memory, simple design, meets requirements",
      "alternative": "Store all deliveries in a list",
      "when_to_switch": "Part 2+ will need delivery storage for payment tracking - extend then"
    },
    {
      "decision": "Decimal vs float for currency",
      "chosen": "Decimal/BigDecimal",
      "why": "Exact representation, no floating-point errors",
      "alternative": "Store as cents (integer)",
      "when_to_switch": "If performance critical and precision issues can be managed with careful rounding"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "Keep public API small - only expose required methods",
      "Single Responsibility - DeliveryCostTracker only tracks costs",
      "Encapsulate state - internal data structures are private",
      "Favor composition - Driver can be a separate class for extensibility"
    ],
    "why_this_design_scales": "The HashMap + running total design is a foundation. For Part 2 (payment tracking), we add a sorted structure (TreeMap) by endTime. For Part 3 (max concurrent drivers), we add event-based tracking. The core addDriver/getTotalCost stay stable.",
    "expected_followup_hooks": [
      "addDelivery will need to STORE deliveries (not just update total) for Part 2",
      "May need TreeMap<endTime, List<Delivery>> for efficient range queries",
      "Consider adding a Delivery class with (driverId, start, end, cost) fields",
      "getTotalCost stays O(1) and stable across all parts"
    ],
    "invariants": [
      "totalCost == sum of all delivery costs (maintained incrementally)",
      "Every delivery's driver must exist in drivers map",
      "All calculations use Decimal precision"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  DELIVERY COST TRACKER                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502   INPUT: Drivers & Deliveries          OUTPUT: Total Cost   \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502   \u2502 Driver 1: $20/hr     \u2502             \u2502                 \u2502  \u2502\n\u2502   \u2502   \u2514\u2500 Delivery: 1 hr  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502   getTotalCost  \u2502  \u2502\n\u2502   \u2502      Cost: $20       \u2502             \u2502   = $50.00      \u2502  \u2502\n\u2502   \u2502                      \u2502             \u2502                 \u2502  \u2502\n\u2502   \u2502 Driver 2: $30/hr     \u2502             \u2502   \u26a1 O(1) !!    \u2502  \u2502\n\u2502   \u2502   \u2514\u2500 Delivery: 1 hr  \u2502             \u2502                 \u2502  \u2502\n\u2502   \u2502      Cost: $30       \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2502\n\u2502                                                             \u2502\n\u2502   KEY INSIGHT: Don't calculate on read - cache running sum! \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURES                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502   drivers: HashMap<driverId, hourlyRate>                    \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502\n\u2502   \u2502 Driver 1\u2502 $20.00       \u2502                                \u2502\n\u2502   \u2502 Driver 2\u2502 $30.00       \u2502                                \u2502\n\u2502   \u2502 Driver 3\u2502 $25.50       \u2502                                \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502\n\u2502                                                             \u2502\n\u2502   totalCost: Decimal                                        \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2502\n\u2502   \u2502      $75.50          \u2502  \u25c4\u2500\u2500 Updated on EVERY addDelivery\u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2502\n\u2502                                                             \u2502\n\u2502   getTotalCost() just returns this value \u2192 O(1)!            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "addDriver(1, $20.00)",
        "visualization": "```\ndrivers: {1: $20.00}\ntotalCost: $0.00\n```",
        "key_point": "Just store the rate - O(1) HashMap insertion"
      },
      {
        "step": 2,
        "description": "addDelivery(1, 0, 3600) - 1 hour delivery",
        "visualization": "```\n1. Lookup rate: drivers[1] = $20.00    \u2190 O(1)\n2. Calculate: $20.00 \u00d7 (3600-0)/3600 = $20.00\n3. Update total: $0.00 + $20.00 = $20.00\n\ndrivers: {1: $20.00}\ntotalCost: $20.00  \u2190 UPDATED!\n```",
        "key_point": "Calculate cost NOW, add to running total"
      },
      {
        "step": 3,
        "description": "getTotalCost()",
        "visualization": "```\nreturn totalCost  \u2192 $20.00\n\nNo iteration! No calculation! Just return the cached value.\n```",
        "key_point": "O(1) - just return the pre-computed total"
      }
    ],
    "dry_run_table": "| Step | Operation | Rate Lookup | Calculation | totalCost |\n|------|-----------|-------------|-------------|----------|\n| 1 | addDriver(1, $20) | - | - | $0.00 |\n| 2 | addDriver(2, $30) | - | - | $0.00 |\n| 3 | addDelivery(1, 0, 3600) | $20 | $20 \u00d7 1hr | $20.00 |\n| 4 | addDelivery(2, 1800, 5400) | $30 | $30 \u00d7 1hr | $50.00 |\n| 5 | getTotalCost() | - | return cached | **$50.00** |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'getTotalCost() must be O(1)', I immediately think: **I cannot iterate through deliveries on every call**. This rules out the naive approach.",
      "The key insight is: **pre-compute on write, return cached on read**. If I maintain a running total, addDelivery becomes O(1) + O(1) arithmetic, and getTotalCost is just returning a variable.",
      "For data structure choice: I need O(1) lookup of driver rates \u2192 **HashMap<driverId, rate>**. I also need a **running total variable**.",
      "When I see currency calculations, I immediately think **precision**. Float/double have representation errors (0.1 + 0.1 + 0.1 \u2260 0.3). Must use **Decimal/BigDecimal**.",
      "The formula is `rate \u00d7 (endTime - startTime) / 3600`. Watch out for **integer division** - I must convert to Decimal BEFORE dividing.",
      "Error handling: What if addDelivery is called for non-existent driver? I'll check and raise an error.",
      "Do I need to store individual deliveries? For Part 1, **NO**. Just the running total. This saves memory and keeps things simple. Part 2+ may require storing deliveries."
    ],
    "key_insight": "**Shift computation from read to write.** Instead of O(n) on every getTotalCost() call, do O(1) work on each addDelivery() and cache the running total. This is the classic **amortized O(1)** pattern used in prefix sums, hit counters, and running statistics.",
    "why_this_works": "Each delivery's cost is independent - it only depends on the driver's rate and the delivery's duration. We can calculate it immediately when the delivery is added. The total is just the sum of all individual costs, and addition is associative, so we can accumulate incrementally."
  },
  "approaches": [
    {
      "name": "Brute Force: Calculate on Read",
      "description": "Store all deliveries in a list. On every getTotalCost() call, iterate through all deliveries and sum their costs.",
      "pseudocode": "class DeliveryCostTracker:\n    drivers = {}        # id -> rate\n    deliveries = []     # list of (driverId, start, end)\n    \n    def getTotalCost():\n        total = 0\n        for (driverId, start, end) in deliveries:  # O(n)!\n            rate = drivers[driverId]\n            total += rate * (end - start) / 3600\n        return total",
      "time_complexity": "O(n) per getTotalCost() call, where n = number of deliveries",
      "space_complexity": "O(n) to store all deliveries",
      "pros": [
        "Simple to implement",
        "Easy to understand",
        "Supports remove/modify operations easily"
      ],
      "cons": [
        "Violates O(1) requirement",
        "Too slow for frequent queries with many deliveries"
      ],
      "when_to_use": "Only if getTotalCost() is rarely called, or for debugging/verification"
    },
    {
      "name": "Optimal: Pre-compute Running Total",
      "description": "Maintain a running total. On addDelivery, calculate the cost and add it to the total immediately. On getTotalCost, just return the cached total.",
      "pseudocode": "class DeliveryCostTracker:\n    drivers = {}         # id -> rate\n    totalCost = 0        # running total\n    \n    def addDelivery(driverId, start, end):\n        rate = drivers[driverId]      # O(1) lookup\n        cost = rate * (end - start) / 3600\n        totalCost += cost             # O(1) update\n    \n    def getTotalCost():\n        return totalCost              # O(1)!",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(D) where D = number of drivers (no delivery storage needed)",
      "pros": [
        "Meets O(1) requirement",
        "Minimal memory",
        "Simple"
      ],
      "cons": [
        "Cannot easily undo/remove deliveries",
        "Slightly more logic in addDelivery"
      ],
      "key_insight": "Trade computation time from read to write. Since writes (addDelivery) happen once per delivery but reads (getTotalCost) can happen many times, this is optimal."
    }
  ],
  "optimal_solution": {
    "name": "Pre-computed Running Total with Decimal Precision",
    "explanation_md": "## Approach\n\nThe key insight is **pre-computation**: instead of calculating the total on every query, we maintain a running total that gets updated on every insert.\n\n### Data Structures\n1. **HashMap<driverId, hourlyRate>** - O(1) lookup of driver rates\n2. **Decimal totalCost** - Running sum of all delivery costs\n\n### Algorithm\n1. **addDriver**: Store rate in HashMap\n2. **addDelivery**: \n   - Lookup rate in O(1)\n   - Calculate: `cost = rate \u00d7 (endTime - startTime) / 3600`\n   - Add to running total: `totalCost += cost`\n3. **getTotalCost**: Return `totalCost` (pre-computed!)\n\n### Why Decimal?\nFloating-point arithmetic has precision errors:\n```python\n>>> 0.1 + 0.1 + 0.1\n0.30000000000000004  # NOT 0.3!\n```\nFor financial calculations, we MUST use exact decimal representation.",
    "data_structures": [
      {
        "structure": "HashMap<driverId, Decimal rate>",
        "purpose": "O(1) rate lookup when calculating delivery cost"
      },
      {
        "structure": "Decimal totalCost",
        "purpose": "Running total, updated on each addDelivery, returned in O(1)"
      }
    ],
    "algorithm_steps": [
      "1. **Initialize**: Create empty HashMap for drivers, set totalCost = 0",
      "2. **addDriver(id, rate)**: Store `drivers[id] = rate` in HashMap",
      "3. **addDelivery(id, start, end)**: Lookup rate, calculate `cost = rate \u00d7 duration / 3600`, add `totalCost += cost`",
      "4. **getTotalCost()**: Simply `return totalCost`"
    ],
    "why_decimal": "Using float causes precision errors. Example: `0.1 + 0.1 + 0.1 = 0.30000000000000004` in float, but `Decimal('0.1') + Decimal('0.1') + Decimal('0.1') = Decimal('0.3')` exactly. For financial systems, this precision is critical."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Delivery Cost Tracking System - Part 1",
    "",
    "Key Design Decisions:",
    "1. Pre-compute running total for O(1) getTotalCost()",
    "2. Use Decimal for exact currency arithmetic",
    "3. HashMap for O(1) driver rate lookup",
    "\"\"\"",
    "from decimal import Decimal",
    "from typing import Dict",
    "",
    "",
    "class DeliveryCostTracker:",
    "    \"\"\"Tracks delivery costs with O(1) total cost retrieval.\"\"\"",
    "    ",
    "    SECONDS_PER_HOUR = Decimal('3600')",
    "    ",
    "    def __init__(self):",
    "        self._drivers: Dict[int, Decimal] = {}  # driverId -> hourlyRate",
    "        self._total_cost: Decimal = Decimal('0')",
    "    ",
    "    def add_driver(self, driver_id: int, hourly_rate: Decimal) -> None:",
    "        \"\"\"Register a driver with their hourly rate. O(1)\"\"\"",
    "        self._drivers[driver_id] = hourly_rate",
    "    ",
    "    def add_delivery(self, driver_id: int, start_time: int, end_time: int) -> None:",
    "        \"\"\"",
    "        Record a delivery and update running total. O(1)",
    "        Cost = hourlyRate \u00d7 (endTime - startTime) / 3600",
    "        \"\"\"",
    "        if driver_id not in self._drivers:",
    "            raise ValueError(f\"Driver {driver_id} not registered\")",
    "        ",
    "        rate = self._drivers[driver_id]",
    "        duration = Decimal(end_time - start_time)",
    "        cost = rate * duration / self.SECONDS_PER_HOUR",
    "        self._total_cost += cost",
    "    ",
    "    def get_total_cost(self) -> Decimal:",
    "        \"\"\"Return total cost of all deliveries. O(1) - pre-computed!\"\"\"",
    "        return self._total_cost",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"DELIVERY COST TRACKER - DEMO\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Test 1: Basic usage from problem example",
    "    tracker = DeliveryCostTracker()",
    "    tracker.add_driver(1, Decimal('20'))  # $20/hr",
    "    tracker.add_driver(2, Decimal('30'))  # $30/hr",
    "    tracker.add_delivery(1, 0, 3600)      # 1 hour = $20",
    "    tracker.add_delivery(2, 1800, 5400)   # 1 hour = $30",
    "    print(f\"Test 1 - Basic: ${tracker.get_total_cost()} (expected: $50)\")",
    "    ",
    "    # Test 2: Fractional hours",
    "    tracker2 = DeliveryCostTracker()",
    "    tracker2.add_driver(1, Decimal('24'))",
    "    tracker2.add_delivery(1, 0, 1800)     # 0.5 hours = $12",
    "    print(f\"Test 2 - Fractional: ${tracker2.get_total_cost()} (expected: $12)\")",
    "    ",
    "    # Test 3: Precision test - 1 second at $3600/hr = $1.00 exactly",
    "    tracker3 = DeliveryCostTracker()",
    "    tracker3.add_driver(1, Decimal('3600'))",
    "    tracker3.add_delivery(1, 0, 1)",
    "    print(f\"Test 3 - Precision: ${tracker3.get_total_cost()} (expected: $1)\")",
    "    ",
    "    # Test 4: Float precision trap",
    "    tracker4 = DeliveryCostTracker()",
    "    tracker4.add_driver(1, Decimal('0.1'))",
    "    for _ in range(3):",
    "        tracker4.add_delivery(1, 0, 3600)  # 3 \u00d7 $0.10",
    "    result = tracker4.get_total_cost()",
    "    print(f\"Test 4 - Float trap: ${result} == 0.3? {result == Decimal('0.3')}\")",
    "    print(\"        (float would give 0.30000000000000004)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed! \u2713\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.HashMap;",
    "import java.util.Map;",
    "",
    "/**",
    " * Delivery Cost Tracking System - Part 1",
    " * ",
    " * Key Design: Pre-compute running total for O(1) getTotalCost()",
    " * Uses BigDecimal for exact currency arithmetic",
    " */",
    "public class DeliveryCostTracker {",
    "    ",
    "    private static final BigDecimal SECONDS_PER_HOUR = new BigDecimal(\"3600\");",
    "    ",
    "    private final Map<Integer, BigDecimal> drivers;  // driverId -> hourlyRate",
    "    private BigDecimal totalCost;",
    "    ",
    "    public DeliveryCostTracker() {",
    "        this.drivers = new HashMap<>();",
    "        this.totalCost = BigDecimal.ZERO;",
    "    }",
    "    ",
    "    /** Register a driver with their hourly rate. O(1) */",
    "    public void addDriver(int driverId, BigDecimal hourlyRate) {",
    "        drivers.put(driverId, hourlyRate);",
    "    }",
    "    ",
    "    /**",
    "     * Record a delivery and update running total. O(1)",
    "     * Cost = hourlyRate \u00d7 (endTime - startTime) / 3600",
    "     */",
    "    public void addDelivery(int driverId, long startTime, long endTime) {",
    "        BigDecimal rate = drivers.get(driverId);",
    "        if (rate == null) {",
    "            throw new IllegalArgumentException(\"Driver \" + driverId + \" not registered\");",
    "        }",
    "        ",
    "        BigDecimal duration = new BigDecimal(endTime - startTime);",
    "        BigDecimal cost = rate.multiply(duration).divide(SECONDS_PER_HOUR, 10, BigDecimal.ROUND_HALF_UP);",
    "        totalCost = totalCost.add(cost);",
    "    }",
    "    ",
    "    /** Return total cost of all deliveries. O(1) - pre-computed! */",
    "    public BigDecimal getTotalCost() {",
    "        return totalCost;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"DELIVERY COST TRACKER - DEMO\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Test 1: Basic usage",
    "        DeliveryCostTracker tracker = new DeliveryCostTracker();",
    "        tracker.addDriver(1, new BigDecimal(\"20\"));  // $20/hr",
    "        tracker.addDriver(2, new BigDecimal(\"30\"));  // $30/hr",
    "        tracker.addDelivery(1, 0, 3600);  // 1 hour = $20",
    "        tracker.addDelivery(2, 1800, 5400);  // 1 hour = $30",
    "        System.out.println(\"Test 1 - Basic: $\" + tracker.getTotalCost() + \" (expected: $50)\");",
    "        ",
    "        // Test 2: Fractional hours",
    "        DeliveryCostTracker tracker2 = new DeliveryCostTracker();",
    "        tracker2.addDriver(1, new BigDecimal(\"24\"));",
    "        tracker2.addDelivery(1, 0, 1800);  // 0.5 hours = $12",
    "        System.out.println(\"Test 2 - Fractional: $\" + tracker2.getTotalCost() + \" (expected: $12)\");",
    "        ",
    "        // Test 3: Precision test",
    "        DeliveryCostTracker tracker3 = new DeliveryCostTracker();",
    "        tracker3.addDriver(1, new BigDecimal(\"3600\"));",
    "        tracker3.addDelivery(1, 0, 1);  // 1 second = $1.00",
    "        System.out.println(\"Test 3 - Precision: $\" + tracker3.getTotalCost() + \" (expected: $1)\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All tests passed!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "section": "Imports and Class Docstring",
      "explanation": "We import `Decimal` from Python's decimal module for exact currency arithmetic. The docstring summarizes the three key design decisions: pre-compute for O(1), use Decimal, use HashMap."
    },
    {
      "lines": "12-18",
      "section": "Class Definition and Constants",
      "explanation": "`SECONDS_PER_HOUR` is a Decimal constant (3600). Using a constant avoids magic numbers and ensures consistent precision. The `__init__` creates an empty drivers dict and sets total to zero."
    },
    {
      "lines": "20-23",
      "section": "add_driver method",
      "explanation": "Simple O(1) HashMap insertion. We store the driver's hourly rate keyed by their ID. No validation of duplicate IDs - in production, we might check this."
    },
    {
      "lines": "25-36",
      "section": "add_delivery method - THE CORE LOGIC",
      "explanation": "This is where the magic happens. We: (1) Validate driver exists, (2) Lookup rate in O(1), (3) Calculate duration as Decimal BEFORE division, (4) Compute cost using exact Decimal math, (5) ADD to running total immediately. This pre-computation is what makes getTotalCost O(1)."
    },
    {
      "lines": "38-40",
      "section": "get_total_cost method",
      "explanation": "Simply return the pre-computed total. No iteration, no calculation. This is O(1) because we did all the work in add_delivery. This is the payoff for the running total pattern."
    },
    {
      "lines": "43-70",
      "section": "Demo and Tests",
      "explanation": "Four test cases: (1) Basic usage from problem, (2) Fractional hours, (3) 1-second precision test, (4) Float precision trap demonstrating why Decimal matters. Each test prints expected vs actual for verification."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "After implementing each method, test it: (1) addDriver - print drivers dict to confirm insertion, (2) addDelivery - print the cost calculation before adding to total, (3) getTotalCost - verify matches sum of individual costs",
    "what_to_print_or_assert": [
      "print(f'Driver {driver_id} rate: {self._drivers.get(driver_id)}')",
      "print(f'Delivery cost: {cost} (rate={rate}, duration={duration})')",
      "assert self.get_total_cost() == expected_total, f'Expected {expected_total}, got {self.get_total_cost()}'"
    ],
    "common_failure_modes": [
      "Driver not found - forgot to add driver before delivery",
      "Integer division - (end-start)//3600 loses precision, use Decimal",
      "Float precision - using float instead of Decimal",
      "Wrong formula - forgetting to divide by 3600"
    ],
    "how_to_fix_fast": "If result is wrong: (1) Print intermediate values (rate, duration, cost) to find which step is wrong, (2) Check types - is everything Decimal?, (3) Verify formula matches spec: rate \u00d7 duration / 3600"
  },
  "complexity_analysis": {
    "time": {
      "add_driver": {
        "complexity": "O(1)",
        "explanation": "HashMap put() is O(1) average case"
      },
      "add_delivery": {
        "complexity": "O(1)",
        "explanation": "HashMap get() O(1) + Decimal arithmetic O(1) + addition O(1)"
      },
      "get_total_cost": {
        "complexity": "O(1)",
        "explanation": "Simply return the cached running total - no iteration!"
      },
      "overall": "All operations are **O(1)**. This meets the critical requirement that getTotalCost must be O(1)."
    },
    "space": {
      "complexity": "O(D) where D = number of drivers",
      "breakdown": "- HashMap for driver rates: O(D) - one entry per driver\n- Running total (Decimal): O(1) - single number\n- **No delivery storage** - we don't store individual deliveries in Part 1",
      "note": "This is optimal. We cannot do better than O(D) since we must store all driver rates."
    },
    "can_we_do_better": "No. O(1) for all operations is theoretically optimal. Space O(D) is necessary since we must store driver rates. We achieve the minimum possible complexity."
  },
  "dry_run": {
    "example": "addDriver(1, $20), addDriver(2, $30), addDelivery(1, 0, 3600), addDelivery(2, 1800, 5400), getTotalCost()",
    "trace_table": "| Step | Operation | drivers Dict | Calculation | totalCost |\n|------|-----------|-------------|-------------|----------|\n| 0 | __init__ | `{}` | - | `Decimal('0')` |\n| 1 | addDriver(1, $20) | `{1: 20}` | - | `Decimal('0')` |\n| 2 | addDriver(2, $30) | `{1: 20, 2: 30}` | - | `Decimal('0')` |\n| 3 | addDelivery(1, 0, 3600) | `{1: 20, 2: 30}` | `20 \u00d7 3600/3600 = $20` | `Decimal('20')` |\n| 4 | addDelivery(2, 1800, 5400) | `{1: 20, 2: 30}` | `30 \u00d7 3600/3600 = $30` | `Decimal('50')` |\n| 5 | getTotalCost() | - | return cached | **`Decimal('50')`** |",
    "final_answer": "$50.00"
  },
  "test_cases": [
    {
      "name": "Basic - Single driver, single delivery",
      "category": "Happy Path",
      "input": "addDriver(1, 20), addDelivery(1, 0, 3600), getTotalCost()",
      "expected": "Decimal('20')",
      "explanation": "1 hour at $20/hr = $20. Simplest possible case."
    },
    {
      "name": "Two drivers, one delivery each",
      "category": "Happy Path",
      "input": "addDriver(1, 20), addDriver(2, 30), addDelivery(1, 0, 3600), addDelivery(2, 0, 3600)",
      "expected": "Decimal('50')",
      "explanation": "Driver 1: $20, Driver 2: $30, Total: $50"
    },
    {
      "name": "Fractional hours - 30 minutes",
      "category": "Precision",
      "input": "addDriver(1, 24), addDelivery(1, 0, 1800), getTotalCost()",
      "expected": "Decimal('12')",
      "explanation": "1800s = 0.5hr, $24 \u00d7 0.5 = $12. Tests non-integer hours."
    },
    {
      "name": "1-second precision test",
      "category": "Edge Case",
      "input": "addDriver(1, 3600), addDelivery(1, 0, 1), getTotalCost()",
      "expected": "Decimal('1')",
      "explanation": "$3600/hr \u00d7 (1/3600)hr = $1.00 exactly. Tests finest granularity."
    },
    {
      "name": "Float precision trap",
      "category": "Gotcha",
      "input": "addDriver(1, 0.1), 3 deliveries of 1 hour each, getTotalCost()",
      "expected": "Decimal('0.3')",
      "gotcha": "Using float: 0.1 + 0.1 + 0.1 = 0.30000000000000004. Decimal gives exactly 0.3."
    },
    {
      "name": "Driver with no deliveries",
      "category": "Edge Case",
      "input": "addDriver(1, 20), addDriver(2, 30), addDelivery(1, 0, 3600), getTotalCost()",
      "expected": "Decimal('20')",
      "explanation": "Driver 2 registered but has no deliveries. Only Driver 1's $20 counted."
    },
    {
      "name": "Zero deliveries",
      "category": "Edge Case",
      "input": "addDriver(1, 20), getTotalCost()",
      "expected": "Decimal('0')",
      "explanation": "No deliveries yet. Total should be zero."
    },
    {
      "name": "Multiple deliveries same driver",
      "category": "Medium",
      "input": "addDriver(1, 18), 3 deliveries: (0,3600), (7200,9000), (10800,14400)",
      "expected": "Decimal('45')",
      "explanation": "1hr + 0.5hr + 1hr = 2.5hr, $18 \u00d7 2.5 = $45"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float/double for currency",
      "why_wrong": "Floating-point has representation errors. 0.1 + 0.1 + 0.1 = 0.30000000000000004, not 0.3",
      "correct_approach": "Use Decimal (Python) or BigDecimal (Java) for exact representation",
      "code_wrong": "self._total_cost = 0.0\ncost = float(rate) * (end - start) / 3600",
      "code_correct": "self._total_cost = Decimal('0')\ncost = rate * Decimal(end - start) / Decimal('3600')"
    },
    {
      "mistake": "Calculating total in getTotalCost()",
      "why_wrong": "O(n) per call, doesn't meet the O(1) requirement. Will be too slow for frequent queries.",
      "correct_approach": "Maintain a running total, update in addDelivery, just return in getTotalCost",
      "code_wrong": "def get_total_cost(self):\n    return sum(d.cost for d in self.deliveries)  # O(n)!",
      "code_correct": "def get_total_cost(self):\n    return self._total_cost  # O(1)"
    },
    {
      "mistake": "Integer division losing precision",
      "why_wrong": "In Python 2 or explicit //, 1800 // 3600 = 0, losing the fractional hour",
      "correct_approach": "Convert to Decimal BEFORE division to preserve precision",
      "code_wrong": "cost = rate * ((end - start) // 3600)  # 30 min becomes 0 hours!",
      "code_correct": "cost = rate * Decimal(end - start) / Decimal('3600')  # 30 min = 0.5 hours"
    },
    {
      "mistake": "Not validating driver exists",
      "why_wrong": "addDelivery for non-existent driver causes KeyError or returns None, leading to crash or wrong calculation",
      "correct_approach": "Check if driver exists, raise descriptive error if not",
      "code_wrong": "rate = self._drivers[driver_id]  # KeyError if not exists",
      "code_correct": "if driver_id not in self._drivers:\n    raise ValueError(f'Driver {driver_id} not registered')\nrate = self._drivers[driver_id]"
    },
    {
      "mistake": "Storing Decimal as string constructor wrong",
      "why_wrong": "Decimal(0.1) creates Decimal from float 0.1, which is already imprecise!",
      "correct_approach": "Use Decimal('0.1') with string argument for exact representation",
      "code_wrong": "rate = Decimal(0.1)  # Creates Decimal('0.1000000000000000055511151231...')",
      "code_correct": "rate = Decimal('0.1')  # Creates exactly Decimal('0.1')"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to understand a few things and share my initial thoughts.",
    "clarifying_questions_to_ask": [
      "What precision is needed for currency? Can I use BigDecimal/Decimal? (Confirms precision requirement)",
      "How frequently will getTotalCost() be called? The O(1) requirement suggests I should pre-compute. (Shows you noticed the key constraint)",
      "Are times in epoch seconds? I see the formula divides by 3600. (Confirms units)",
      "Should I throw an error if addDelivery is called for a non-existent driver? (Clarifies error handling)",
      "Do deliveries for the same driver ever overlap? (Given they don't, simplifies design)"
    ],
    "what_to_mention_proactively": [
      "I'll use Decimal/BigDecimal for currency - floats have precision issues",
      "Since getTotalCost needs to be O(1), I'll maintain a running total updated on each addDelivery",
      "I'll use a HashMap for O(1) driver rate lookup",
      "Let me trace through an example after coding to verify correctness"
    ],
    "communication_during_coding": [
      "I'm creating a HashMap to store driver rates for O(1) lookup",
      "Here in addDelivery, I calculate the cost and add it to the running total immediately",
      "Notice getTotalCost just returns the cached value - that's how we achieve O(1)",
      "Using Decimal here to avoid float precision errors"
    ],
    "if_stuck": [
      "Step back: What's the key constraint? O(1) getTotalCost - this tells me I need to pre-compute",
      "Ask: When should I compute? On write, not on read - that's the pattern",
      "Draw it: Visualize the data flow with a simple diagram",
      "Simplify: What if there was just one driver? Start there and generalize"
    ],
    "time_management": "0-5min: Clarify & understand | 5-10min: Explain approach, get buy-in | 10-25min: Code core solution | 25-30min: Test with examples | 30-35min: Complexity analysis | 35-45min: Follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Pre-computation / Running Total / Amortized O(1)",
    "indicators": [
      "O(1) requirement for frequent query operation",
      "Updates (writes) less frequent than reads",
      "Query result is an aggregation (sum, count, max) of all data",
      "No need to modify or delete individual records"
    ],
    "similar_problems": [
      "LC 303 - Range Sum Query (Immutable): Pre-compute prefix sums for O(1) range queries",
      "LC 304 - Range Sum Query 2D: Pre-compute 2D prefix sums",
      "Design Hit Counter: Maintain running count of hits",
      "Design TinyURL: Pre-generate mappings for O(1) lookup",
      "LRU Cache: Maintain O(1) access with HashMap + doubly-linked list"
    ],
    "template": "```python\nclass PrecomputePattern:\n    def __init__(self):\n        self.running_aggregate = initial_value\n    \n    def add(self, item):\n        # Compute contribution and add to aggregate\n        contribution = calculate(item)\n        self.running_aggregate += contribution  # O(1)\n    \n    def query(self):\n        return self.running_aggregate  # O(1)!\n```"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Payment Settlement Tracking** - You'll need to track which deliveries are paid. This requires storing individual deliveries sorted by end time. Add a `TreeMap<endTime, List<Delivery>>` and a `markPaid(timestamp)` method that settles all deliveries ending before that time.",
    "part_3_hint": "**Part 3: Maximum Active Drivers** - Classic line sweep / Meeting Rooms II pattern. Store (time, +1/-1) events for each delivery start/end. Sort events and sweep to find max concurrent. Uses the same interval overlap logic as LC 253.",
    "data_structure_evolution": "```\nPart 1: HashMap<driverId, rate> + Decimal totalCost\n        \u2193\nPart 2: + TreeMap<endTime, List<Delivery>>  (for payment tracking)\n        + Decimal unpaidTotal\n        \u2193\nPart 3: + List<Event> for (time, driverId, +1/-1)  (for line sweep)\n        + Counter/HashMap for active drivers at any time\n```"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. Before I start coding, I'd like to make sure I understand the requirements correctly. I notice that getTotalCost must be O(1) - this tells me I should pre-compute the total rather than calculating it on every call. I also see we're dealing with currency, so I'll use Decimal for precision. Let me ask a few clarifying questions...",
    "after_clarification": "Great, so to summarize: I need to track drivers with hourly rates, record their deliveries, and return the total cost in O(1) time. I'll use a HashMap to store driver rates and maintain a running total that I update on each addDelivery. Does this approach sound right before I start coding?",
    "while_coding": [
      "I'm creating a HashMap here for O(1) rate lookups...",
      "In addDelivery, I calculate the cost immediately and add it to the running total - this is what makes getTotalCost O(1)...",
      "Notice I'm using Decimal('3600') not just 3600 to ensure consistent precision..."
    ],
    "after_coding": "Let me trace through this with the example to verify it works. Starting with empty state, after addDriver(1, 20) we have drivers = {1: 20}. Then addDelivery(1, 0, 3600) calculates 20 \u00d7 3600/3600 = 20, so totalCost becomes 20. getTotalCost returns 20. That matches the expected output.",
    "when_stuck_verbatim": "I'm thinking about this... Let me step back and focus on the key constraint: O(1) getTotalCost. This means I need to have the answer ready, not calculate it on demand. So I should update the total whenever I add a delivery.",
    "after_mistake": "Actually, I see an issue here - I forgot to convert to Decimal before division, which could cause precision errors. Let me fix that by wrapping the duration in Decimal().",
    "before_moving_on": "This handles Part 1 completely. Time complexity is O(1) for all operations, space is O(D) for D drivers. I'm ready for the follow-up whenever you'd like to proceed."
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem decomposition** - Can you break down requirements and identify the key insight (O(1) \u2192 pre-compute)?",
      "**Communication** - Do you think out loud and explain your reasoning?",
      "**Code quality** - Is your code clean, readable, well-named, and correct?",
      "**Testing instinct** - Do you verify with examples and consider edge cases?",
      "**Adaptability** - Can you extend your design for follow-up parts?"
    ],
    "bonus_points": [
      "Mentioning Decimal/BigDecimal for currency BEFORE being asked",
      "Drawing a quick ASCII diagram to explain your approach",
      "Identifying the O(1) insight immediately from the constraints",
      "Writing clean code with good variable names on the first pass",
      "Proactively mentioning what you'd add for production (logging, thread-safety, metrics)"
    ],
    "red_flags": [
      "Coding silently for more than 30 seconds without explaining",
      "Not asking any clarifying questions",
      "Jumping to code without explaining approach first",
      "Ignoring the stated O(1) requirement",
      "Not testing after completing the code",
      "Using float for currency without acknowledging the issue"
    ],
    "what_differentiates_strong_candidates": "Strong candidates treat this as a conversation, not an exam. They think out loud, explain WHY not just WHAT, anticipate edge cases before being asked, and write clean maintainable code. They catch their own mistakes and fix them calmly. They ask smart questions that show they're thinking about real-world implications."
  },
  "time_milestones": {
    "by_5_min": "Understand the problem completely. Ask clarifying questions. Identify the key constraint (O(1) getTotalCost \u2192 pre-compute). Confirm you understand the formula.",
    "by_10_min": "Explain your approach clearly. Get interviewer buy-in. Identify data structures: HashMap for drivers, Decimal for running total. Start coding.",
    "by_20_min": "Core implementation complete. All three methods written. Basic structure in place.",
    "by_25_min": "Code complete and tested. Trace through at least one example. Handle edge cases (driver not found, zero deliveries).",
    "by_30_min": "Part 1 finished. Complexity analysis complete. Ready for Part 2. If you have extra time, discuss production considerations.",
    "warning_signs": "If you're still clarifying at 10 min, or still writing core code at 25 min, you're behind. Speed up your explanations or simplify your approach."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'Actually, I see an issue here - let me fix it.' Fix it, briefly explain why you made the error, and move on. Interviewers expect some bugs; they evaluate how you handle them. Staying calm and systematic is more impressive than perfect code.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for BigDecimal division, but conceptually I need to divide with a specified precision. Let me write it as I think it works and we can look it up if needed.' This is completely acceptable.",
    "when_approach_is_wrong": "Say: 'Actually, I realize this approach won't meet the O(1) requirement because I'm iterating on every call. Let me reconsider.' Then pivot to the running total approach. Catching your own mistake is a positive signal.",
    "when_completely_stuck": "Say: 'I'm stuck on how to achieve O(1) for getTotalCost. Could you give me a hint about when I should do the calculation?' Asking for targeted help shows self-awareness and is better than floundering silently.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on the core logic and explain what I'd add given more time.' Prioritize: (1) working addDelivery with running total, (2) working getTotalCost, (3) addDriver. Skip validation/error handling if needed."
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them strategically - they should ACCELERATE you, not REPLACE your thinking.",
    "what_to_do": [
      "Use AI for boilerplate: imports, class structure, main function template",
      "Use for syntax you forgot: 'How do I divide BigDecimal with precision?'",
      "Use for generating test cases quickly",
      "Let it autocomplete obvious code like getters/setters"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and ask for the solution",
      "Don't accept suggestions without understanding them",
      "Don't let AI drive your approach - YOU decide, AI assists",
      "Don't rely on AI for the core algorithmic insight (O(1) \u2192 pre-compute)"
    ],
    "how_to_demonstrate_understanding": "If AI suggests something, explain WHY it works to the interviewer. Say: 'The AI suggested using a running total here, which works because we need O(1) queries and the sum is associative.' The interviewer is evaluating YOUR understanding, not the AI's.",
    "expectation_adjustment": "Using AI means you should complete MORE parts, not the same amount. If you're not faster with AI, don't use it - the overhead of prompting may not be worth it for a 45-min interview."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately saying 'O(1) getTotalCost means I need a running total' - shows pattern recognition",
      "Mentioning Decimal/BigDecimal before being prompted - shows financial systems awareness",
      "Drawing a quick diagram unprompted - shows communication skills",
      "Saying 'In production I'd also add logging and input validation, but I'll focus on the core logic for now' - shows senior-level thinking",
      "Catching your own bug before the interviewer mentions it - shows attention to detail"
    ],
    "subtle_signals_of_experience": [
      "Using constants like SECONDS_PER_HOUR instead of magic number 3600",
      "Adding type hints without being asked",
      "Considering thread-safety even if not implementing it",
      "Asking about expected query vs write ratio",
      "Mentioning that the design is extensible for future requirements"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Staying silent for more than 30 seconds - always think out loud",
      "Getting defensive when interviewer points out an issue - thank them and fix it",
      "Blaming the problem for being ambiguous - ask clarifying questions instead",
      "Not making eye contact or engaging with the interviewer"
    ],
    "technical": [
      "Hardcoding the example values instead of using parameters",
      "Not considering what happens with zero deliveries",
      "Writing code that only works for the given example",
      "Ignoring the O(1) complexity requirement completely",
      "Using float for currency without any acknowledgment"
    ],
    "communication": [
      "Using jargon like 'memoization' without explaining what you mean",
      "Going off on tangents about premature optimization",
      "Not summarizing your approach before starting to code",
      "Not asking if the interviewer wants to see you trace through an example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2705 Did I implement all three methods: addDriver, addDelivery, getTotalCost?",
      "\u2705 Is getTotalCost O(1)? (Just returns cached value, no iteration)",
      "\u2705 Am I using Decimal/BigDecimal for currency precision?",
      "\u2705 Did I trace through at least one example end-to-end?",
      "\u2705 Did I mention time complexity: O(1) for all operations?",
      "\u2705 Did I mention space complexity: O(D) for D drivers?",
      "\u2705 Did I consider edge cases: zero deliveries, driver not found?",
      "\u2705 Is my code readable with meaningful variable names?"
    ],
    "quick_code_review": [
      "No magic numbers (use SECONDS_PER_HOUR constant)",
      "Consistent naming (either camelCase or snake_case, not mixed)",
      "Proper indentation",
      "No unused variables or imports",
      "Error handling for driver not found"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Input validation** with descriptive error messages (negative rates, invalid times)",
      "**Logging** for debugging and audit trail",
      "**Thread-safety** if concurrent access is possible (use locks or atomic operations)",
      "**Metrics/telemetry** for monitoring (count of drivers, deliveries, average cost)",
      "**Configuration** for precision/rounding rules",
      "**Persistence** - storing data to database",
      "**Idempotency** - handling duplicate delivery submissions"
    ],
    "why_not_in_interview": "Keep interview code focused on demonstrating algorithmic thinking and clean code. Mention these verbally to show you think like a senior engineer, but don't implement them unless asked.",
    "how_to_mention": "Say: 'In production, I'd also add input validation, logging for debugging, and consider thread-safety if this is accessed concurrently. But for this interview, I'll focus on the core logic to meet the O(1) requirement.'"
  },
  "generated_at": "2026-01-19T03:59:32.854858",
  "_meta": {
    "problem_id": "delivery_cost_tracking",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}