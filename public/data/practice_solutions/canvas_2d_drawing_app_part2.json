{
  "problem_title": "2D Canvas / Drawing Application - Part 2: Move Shape",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 adds the ability to move existing shapes to new positions. This requires O(1) lookup by shape ID (currently impossible with just a list) and in-place position updates while preserving z-order.",
    "new_requirements": [
      "moveShape(shapeId, newX, newY) method to relocate shapes",
      "O(1) shape lookup by ID (implies HashMap)",
      "Z-order must be preserved when moving (list position unchanged)",
      "Rectangle moves by top-left corner, Circle by center"
    ],
    "new_constraints": [
      "Moving a shape does NOT change its z-order (it stays at same list index)",
      "Position updates must be in-place (don't recreate shapes)",
      "Invalid shape IDs should be handled gracefully"
    ],
    "key_insight": "Add a HashMap<String, Shape> for O(1) ID lookup. The list maintains z-order, the map enables fast access. Update position directly on the Shape object without changing its list position."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "O(1) shape lookup by ID",
        "how_met": "Added shapes_by_id HashMap that maps shapeId \u2192 Shape reference",
        "gotchas": [
          "Must update HashMap in BOTH createRectangle and createCircle"
        ]
      },
      {
        "requirement": "Z-order preserved when moving",
        "how_met": "Only update shape's position fields; never touch shapes list order",
        "gotchas": [
          "Don't remove and re-add shape to list - this would change z-order"
        ]
      },
      {
        "requirement": "Rectangle vs Circle position semantics",
        "how_met": "Each shape class has move_to() that updates the correct fields (x,y for rect; cx,cy for circle)",
        "gotchas": [
          "Circle center vs Rectangle top-left corner"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "moveShape",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup + direct field update"
      }
    ],
    "non_goals": [
      "Deleting shapes",
      "Changing z-order",
      "Resizing shapes"
    ]
  },
  "assumptions": [
    "Invalid shape IDs are silently ignored (no exception thrown)",
    "Shapes can be moved to negative coordinates",
    "Moving to same position is a no-op (but still valid)",
    "Shape references are same objects in both list and HashMap"
  ],
  "tradeoffs": [
    {
      "decision": "HashMap vs Linear Search for ID lookup",
      "chosen": "HashMap",
      "why": "O(1) vs O(n) lookup - critical for responsive UI when moving shapes frequently",
      "alternative": "Linear search through list",
      "when_to_switch": "Never for this use case - HashMap is strictly better"
    },
    {
      "decision": "Abstract move_to vs type checking",
      "chosen": "Abstract move_to method",
      "why": "Polymorphism is cleaner, type-safe, and follows Open/Closed principle",
      "alternative": "isinstance() checks in Canvas.moveShape",
      "when_to_switch": "If shapes had vastly different move semantics"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "shapes list order = z-order invariant",
      "Shape.contains() signature unchanged",
      "ID format (rect_N, circle_N) unchanged"
    ],
    "what_to_change": [
      "Added shapes_by_id HashMap",
      "Added abstract move_to() to Shape",
      "Updated create methods to populate HashMap"
    ],
    "interfaces_and_boundaries": "Shape class now has both contains() and move_to() as abstract methods. Adding new shapes only requires implementing these two methods.",
    "invariants": [
      "shapes_by_id.keys() == {s.id for s in shapes}",
      "shapes_by_id[id] is shapes[i] for some i (same object reference)",
      "Moving shape preserves its index in shapes list"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE moveShape(\"rect_1\", 80, 80):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502  \u2502rect1\u2502 at (10,10)      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502         \u25cb circle_1       \u2502\n\u2502           (on top)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                          \u2502\n\u2502         \u25cb circle_1       \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502              \u2502rect1\u2502     \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502              at (80,80)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nZ-order unchanged: circle_1 still on top!",
    "algorithm_flow": "moveShape(shapeId, newX, newY):\n1. [O(1)] Lookup shape in HashMap \u2192 shapes_by_id[shapeId]\n2. [O(1)] If found, call shape.move_to(newX, newY)\n3. [O(1)] Shape updates its position fields\n\nNo list modification \u2192 z-order preserved!"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Linear search through shapes list to find shape by ID, then update position",
      "time_complexity": "O(n) for moveShape",
      "space_complexity": "O(n) - no change",
      "why_not_optimal": "O(n) lookup is unacceptable for interactive applications where user might drag shapes rapidly"
    },
    {
      "name": "Optimal Approach",
      "description": "Add HashMap<String, Shape> for O(1) ID lookup. Store same object references in both list and map. Update position in-place via polymorphic move_to() method.",
      "time_complexity": "O(1) for moveShape",
      "space_complexity": "O(n) - HashMap adds O(n) space but with same n objects",
      "key_insight": "Dual data structures: List for z-order, HashMap for lookup. Same Shape objects referenced by both."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The key insight is using **dual data structures** that serve different purposes:\n\n1. **shapes list** - Maintains z-order (index 0 = bottom)\n2. **shapes_by_id HashMap** - Enables O(1) lookup by ID\n\nBoth reference the **same Shape objects**, so updating via the HashMap updates what's in the list.\n\n**Adding move_to() as abstract method** ensures each shape knows how to relocate itself:\n- Rectangle updates its `(x, y)` top-left corner\n- Circle updates its `(cx, cy)` center\n\nThis is **cleaner than type checking** and follows the Open/Closed Principle.",
    "data_structures": [
      {
        "structure": "List<Shape> shapes",
        "purpose": "Z-order maintenance (from Part 1)"
      },
      {
        "structure": "Dict[str, Shape] shapes_by_id",
        "purpose": "O(1) lookup by shape ID (new in Part 2)"
      }
    ],
    "algorithm_steps": [
      "Step 1: On shape creation, add to BOTH shapes list AND shapes_by_id map",
      "Step 2: moveShape() looks up shape in HashMap O(1)",
      "Step 3: Call shape.move_to(newX, newY) to update position",
      "Step 4: List order unchanged \u2192 z-order preserved"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List, Dict",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all shapes on the canvas.\"\"\"",
    "    def __init__(self, shape_id: str):",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains(self, x: int, y: int) -> bool:",
    "        \"\"\"Check if point (x, y) is inside this shape (boundary inclusive).\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move shape to new position.\"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"Rectangle defined by top-left corner and dimensions.\"\"\"",
    "    def __init__(self, shape_id: str, x: int, y: int, width: int, height: int):",
    "        super().__init__(shape_id)",
    "        self.x, self.y = x, y",
    "        self.width, self.height = width, height",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move top-left corner to (new_x, new_y).\"\"\"",
    "        self.x, self.y = new_x, new_y",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"Circle defined by center and radius.\"\"\"",
    "    def __init__(self, shape_id: str, center_x: int, center_y: int, radius: int):",
    "        super().__init__(shape_id)",
    "        self.cx, self.cy = center_x, center_y",
    "        self.radius = radius",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        dx, dy = px - self.cx, py - self.cy",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move center to (new_x, new_y).\"\"\"",
    "        self.cx, self.cy = new_x, new_y",
    "",
    "",
    "class Canvas:",
    "    \"\"\"2D drawing canvas supporting shape creation, hit testing, and movement.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.shapes: List[Shape] = []           # Z-order: index 0 = bottom",
    "        self.shapes_by_id: Dict[str, Shape] = {}  # O(1) lookup by ID",
    "        self.rect_count = 0",
    "        self.circle_count = 0",
    "    ",
    "    def create_rectangle(self, x: int, y: int, width: int, height: int) -> str:",
    "        \"\"\"Create rectangle at (x,y) with given dimensions. O(1).\"\"\"",
    "        self.rect_count += 1",
    "        shape_id = f\"rect_{self.rect_count}\"",
    "        shape = Rectangle(shape_id, x, y, width, height)",
    "        self.shapes.append(shape)",
    "        self.shapes_by_id[shape_id] = shape  # Part 2: add to lookup map",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: int, center_y: int, radius: int) -> str:",
    "        \"\"\"Create circle at center with given radius. O(1).\"\"\"",
    "        self.circle_count += 1",
    "        shape_id = f\"circle_{self.circle_count}\"",
    "        shape = Circle(shape_id, center_x, center_y, radius)",
    "        self.shapes.append(shape)",
    "        self.shapes_by_id[shape_id] = shape  # Part 2: add to lookup map",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: int, y: int) -> Optional[str]:",
    "        \"\"\"Return topmost shape at point, or None. O(n).\"\"\"",
    "        for shape in reversed(self.shapes):",
    "            if shape.contains(x, y):",
    "                return shape.id",
    "        return None",
    "    ",
    "    def move_shape(self, shape_id: str, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move shape to new position. Z-order preserved. O(1).\"\"\"",
    "        if shape_id in self.shapes_by_id:",
    "            self.shapes_by_id[shape_id].move_to(new_x, new_y)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"TEST 1: Move Rectangle Away - Z-Order Preserved\")",
    "    print(\"=\" * 60)",
    "    canvas = Canvas()",
    "    canvas.create_rectangle(0, 0, 50, 50)   # rect_1 (bottom)",
    "    canvas.create_rectangle(25, 25, 50, 50) # rect_2 (top)",
    "    print(f\"Before move: getShapeAt(30,30) = {canvas.get_shape_at(30, 30)}  (rect_2 on top)\")",
    "    canvas.move_shape(\"rect_1\", 100, 100)  # Move rect_1 away",
    "    print(f\"After move:  getShapeAt(30,30) = {canvas.get_shape_at(30, 30)}  (only rect_2 now)\")",
    "    print(f\"Moved rect:  getShapeAt(110,110) = {canvas.get_shape_at(110, 110)}  (rect_1 at new pos)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 2: Circle Moves to Overlap - Z-Order Wins\")",
    "    print(\"=\" * 60)",
    "    canvas2 = Canvas()",
    "    canvas2.create_rectangle(0, 0, 40, 40)   # rect_1 (bottom)",
    "    canvas2.create_circle(100, 100, 20)      # circle_1 (top)",
    "    print(f\"Before: getShapeAt(20,20) = {canvas2.get_shape_at(20, 20)}  (rect_1)\")",
    "    canvas2.move_shape(\"circle_1\", 20, 20)   # Move circle to overlap",
    "    print(f\"After:  getShapeAt(20,20) = {canvas2.get_shape_at(20, 20)}  (circle_1 on top!)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 3: Move Invalid ID - Silently Ignored\")",
    "    print(\"=\" * 60)",
    "    canvas3 = Canvas()",
    "    canvas3.create_rectangle(10, 10, 30, 30)",
    "    canvas3.move_shape(\"invalid_id\", 0, 0)  # Should not crash",
    "    print(f\"No error for invalid ID. rect_1 unchanged at (10,10).\")",
    "    print(f\"getShapeAt(20,20) = {canvas3.get_shape_at(20, 20)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"TEST 4: Multiple Moves\")",
    "    print(\"=\" * 60)",
    "    canvas4 = Canvas()",
    "    canvas4.create_circle(0, 0, 10)",
    "    print(f\"Created at (0,0): getShapeAt(5,5) = {canvas4.get_shape_at(5, 5)}\")",
    "    canvas4.move_shape(\"circle_1\", 50, 50)",
    "    print(f\"Moved to (50,50): getShapeAt(5,5) = {canvas4.get_shape_at(5, 5)}\")",
    "    print(f\"New position:     getShapeAt(55,55) = {canvas4.get_shape_at(55, 55)}\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "abstract class Shape {",
    "    protected String id;",
    "    ",
    "    public Shape(String id) { this.id = id; }",
    "    public String getId() { return id; }",
    "    public abstract boolean contains(int x, int y);",
    "    public abstract void moveTo(int newX, int newY);  // Part 2",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private int x, y, width, height;",
    "    ",
    "    public Rectangle(String id, int x, int y, int width, int height) {",
    "        super(id);",
    "        this.x = x; this.y = y;",
    "        this.width = width; this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        return x <= px && px <= x + width && y <= py && py <= y + height;",
    "    }",
    "    ",
    "    @Override",
    "    public void moveTo(int newX, int newY) {",
    "        this.x = newX;",
    "        this.y = newY;",
    "    }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private int cx, cy, radius;",
    "    ",
    "    public Circle(String id, int cx, int cy, int radius) {",
    "        super(id);",
    "        this.cx = cx; this.cy = cy; this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        long dx = px - cx, dy = py - cy;",
    "        return dx * dx + dy * dy <= (long) radius * radius;",
    "    }",
    "    ",
    "    @Override",
    "    public void moveTo(int newX, int newY) {",
    "        this.cx = newX;",
    "        this.cy = newY;",
    "    }",
    "}",
    "",
    "public class Canvas {",
    "    private List<Shape> shapes = new ArrayList<>();",
    "    private Map<String, Shape> shapesById = new HashMap<>();  // Part 2",
    "    private int rectCount = 0, circleCount = 0;",
    "    ",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        String id = \"rect_\" + (++rectCount);",
    "        Shape shape = new Rectangle(id, x, y, width, height);",
    "        shapes.add(shape);",
    "        shapesById.put(id, shape);  // Part 2: add to lookup map",
    "        return id;",
    "    }",
    "    ",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        String id = \"circle_\" + (++circleCount);",
    "        Shape shape = new Circle(id, centerX, centerY, radius);",
    "        shapes.add(shape);",
    "        shapesById.put(id, shape);  // Part 2: add to lookup map",
    "        return id;",
    "    }",
    "    ",
    "    public String getShapeAt(int x, int y) {",
    "        for (int i = shapes.size() - 1; i >= 0; i--) {",
    "            if (shapes.get(i).contains(x, y)) {",
    "                return shapes.get(i).getId();",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    // Part 2: Move shape to new position. Z-order preserved. O(1).",
    "    public void moveShape(String shapeId, int newX, int newY) {",
    "        Shape shape = shapesById.get(shapeId);",
    "        if (shape != null) {",
    "            shape.moveTo(newX, newY);",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"TEST 1: Move Rectangle Away - Z-Order Preserved\");",
    "        Canvas canvas = new Canvas();",
    "        canvas.createRectangle(0, 0, 50, 50);   // rect_1 (bottom)",
    "        canvas.createRectangle(25, 25, 50, 50); // rect_2 (top)",
    "        System.out.println(\"Before: getShapeAt(30,30) = \" + canvas.getShapeAt(30, 30));",
    "        canvas.moveShape(\"rect_1\", 100, 100);",
    "        System.out.println(\"After:  getShapeAt(30,30) = \" + canvas.getShapeAt(30, 30));",
    "        System.out.println(\"Moved:  getShapeAt(110,110) = \" + canvas.getShapeAt(110, 110));",
    "        ",
    "        System.out.println(\"\\nTEST 2: Circle Moves to Overlap\");",
    "        Canvas canvas2 = new Canvas();",
    "        canvas2.createRectangle(0, 0, 40, 40);",
    "        canvas2.createCircle(100, 100, 20);",
    "        System.out.println(\"Before: getShapeAt(20,20) = \" + canvas2.getShapeAt(20, 20));",
    "        canvas2.moveShape(\"circle_1\", 20, 20);",
    "        System.out.println(\"After:  getShapeAt(20,20) = \" + canvas2.getShapeAt(20, 20));",
    "        ",
    "        System.out.println(\"\\nTEST 3: Invalid ID Handling\");",
    "        Canvas canvas3 = new Canvas();",
    "        canvas3.createRectangle(10, 10, 30, 30);",
    "        canvas3.moveShape(\"invalid_id\", 0, 0);  // Should not crash",
    "        System.out.println(\"No error. getShapeAt(20,20) = \" + canvas3.getShapeAt(20, 20));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-18 (Python)",
      "explanation": "Shape ABC extended with abstract move_to() method - each shape must implement its own movement logic"
    },
    {
      "lines": "20-34 (Python)",
      "explanation": "Rectangle.move_to() updates top-left corner (x, y) to new position"
    },
    {
      "lines": "37-48 (Python)",
      "explanation": "Circle.move_to() updates center (cx, cy) to new position"
    },
    {
      "lines": "53-56 (Python)",
      "explanation": "Canvas.__init__ now includes shapes_by_id HashMap for O(1) ID lookup"
    },
    {
      "lines": "58-65, 67-74 (Python)",
      "explanation": "create_rectangle/create_circle updated to add shape to BOTH shapes list AND shapes_by_id map"
    },
    {
      "lines": "83-86 (Python)",
      "explanation": "move_shape: O(1) HashMap lookup, call polymorphic move_to() if found"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "moveShape": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup O(1) + move_to field update O(1)"
        }
      },
      "overall_change": "No change to existing methods. moveShape adds O(1) operation."
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "shapes_by_id HashMap stores n references (same objects as list, so no duplication of Shape data)"
    }
  },
  "dry_run": {
    "example_input": "createRectangle(0,0,50,50), createRectangle(25,25,50,50), getShapeAt(30,30), moveShape(rect_1,100,100), getShapeAt(30,30)",
    "steps": [
      {
        "step": 1,
        "action": "createRectangle(0,0,50,50)",
        "state": "shapes=[rect_1], shapes_by_id={rect_1:Shape}",
        "explanation": "rect_1 added to both list and map"
      },
      {
        "step": 2,
        "action": "createRectangle(25,25,50,50)",
        "state": "shapes=[rect_1,rect_2], shapes_by_id={rect_1,rect_2}",
        "explanation": "rect_2 on top (last in list)"
      },
      {
        "step": 3,
        "action": "getShapeAt(30,30)",
        "state": "Check rect_2 (contains? yes) \u2192 return rect_2",
        "explanation": "Reverse iteration finds rect_2 first"
      },
      {
        "step": 4,
        "action": "moveShape(rect_1,100,100)",
        "state": "rect_1.x=100, rect_1.y=100, list order unchanged",
        "explanation": "O(1) lookup, update position in-place"
      },
      {
        "step": 5,
        "action": "getShapeAt(30,30)",
        "state": "rect_2 contains (30,30)? yes \u2192 return rect_2",
        "explanation": "rect_1 moved away, only rect_2 covers point"
      }
    ],
    "final_output": "[null, rect_1, rect_2, rect_2, null, rect_2]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Move shape, query old position (should miss)",
      "Move shape, query new position (should hit)"
    ],
    "likely_bugs": [
      "Forgetting to add shape to HashMap in create methods",
      "Updating wrong fields in move_to (x,y vs cx,cy)",
      "Recreating shape instead of updating in-place (breaks z-order)"
    ],
    "recommended_logs_or_asserts": [
      "assert len(shapes) == len(shapes_by_id)",
      "print(f'Moving {shape_id} from ({old_x},{old_y}) to ({new_x},{new_y})')"
    ],
    "how_to_localize": "1. Check if shape exists in HashMap. 2. Verify position before/after move. 3. Confirm z-order unchanged by checking list indices."
  },
  "edge_cases": [
    {
      "case": "Invalid shape ID",
      "handling": "Silently ignore (check if exists before moving)",
      "gotcha": "Don't throw exception - user may click on deleted shape"
    },
    {
      "case": "Move to same position",
      "handling": "Works correctly, just a no-op update",
      "gotcha": "No special handling needed"
    },
    {
      "case": "Move to negative coordinates",
      "handling": "Allowed - canvas is conceptually infinite",
      "gotcha": "No bounds checking required"
    },
    {
      "case": "Move overlapping shape",
      "handling": "Z-order preserved - list order unchanged",
      "gotcha": "Don't confuse visual overlap with z-order"
    }
  ],
  "test_cases": [
    {
      "name": "Basic move rectangle",
      "input": "create rect at (0,0), move to (50,50), query (25,25)",
      "expected": "null (rect no longer at original position)",
      "explanation": "Shape moved away from query point"
    },
    {
      "name": "Z-order preserved after move",
      "input": "create rect_1, create rect_2 (overlapping), move rect_1 to overlap rect_2, query overlap",
      "expected": "rect_2 (created later, still on top)",
      "explanation": "Moving doesn't change z-order"
    },
    {
      "name": "Circle move center semantics",
      "input": "create circle center (100,100) radius 20, move to (0,0), query (10,10)",
      "expected": "circle_1 (now centered at origin)",
      "explanation": "Circle's center moved, not edge"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Linear search for shape by ID",
      "why_wrong": "O(n) per move operation - unacceptable for interactive UI",
      "correct_approach": "Use HashMap for O(1) lookup",
      "code_example_wrong": "for shape in shapes: if shape.id == shape_id: ...",
      "code_example_correct": "shape = shapes_by_id.get(shape_id)"
    },
    {
      "mistake": "Removing and re-adding shape to move it",
      "why_wrong": "Changes z-order - shape would go to top",
      "correct_approach": "Update position fields in-place",
      "code_example_wrong": "shapes.remove(shape); shape.x = newX; shapes.append(shape)",
      "code_example_correct": "shape.move_to(newX, newY)  # Update in-place"
    },
    {
      "mistake": "Forgetting to update HashMap in create methods",
      "why_wrong": "moveShape won't find newly created shapes",
      "correct_approach": "Add to both list AND map in every create method",
      "code_example_wrong": "shapes.append(shape)  # Missing: shapes_by_id[id] = shape",
      "code_example_correct": "shapes.append(shape)\\nshapes_by_id[shape_id] = shape"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by identifying the problem: 'Currently we have O(n) lookup by ID. For interactive apps, we need O(1).' Then propose HashMap solution.",
    "what_to_mention": [
      "Dual data structures serve different purposes (list for z-order, map for lookup)",
      "Same object references in both - no data duplication",
      "Polymorphic move_to follows Open/Closed principle"
    ],
    "time_allocation": "~2 min to explain approach, ~8 min to implement, ~2 min to test",
    "if_stuck": [
      "Think about what data structure gives O(1) lookup by key",
      "Remember you can store same object in multiple collections"
    ]
  },
  "connection_to_next_part": "Part 3 likely adds delete_shape or bring_to_front. The HashMap enables O(1) delete (remove from both structures). Bring-to-front would modify list order while keeping same object in map.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 is working with shape creation and hit testing. For Part 2, I need to add moveShape with O(1) complexity. The key insight is that our current list-only approach requires O(n) to find a shape by ID.",
    "explaining_changes": "I'll add a HashMap that maps shape ID to Shape object. Same object is stored in both list and map. The list maintains z-order, the map enables fast lookup. When moving, I look up in the map O(1) and update position directly.",
    "while_extending_code": [
      "Adding shapes_by_id HashMap to Canvas...",
      "Updating create methods to populate both structures...",
      "Adding abstract move_to to Shape class...",
      "Implementing move_shape using HashMap lookup..."
    ],
    "after_completing": "Done! moveShape is O(1). The key is that moving only updates position fields - it doesn't touch the list order, so z-order is preserved. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "10-12 minutes for Part 2",
    "by_2_min": "Identify need for HashMap, explain dual data structure approach",
    "by_5_min": "Added HashMap field, updated create methods",
    "by_10_min": "Implemented move_shape and move_to, testing with examples",
    "warning_signs": "If still deciding on approach at 4 min, just go with HashMap. It's the standard solution."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has a bug, fix it first. Common issue: shapes list order is wrong.",
    "if_new_requirement_unclear": "Ask: 'For moveShape, does moving change z-order? Should it bring shape to front?' (Answer: No, z-order preserved)",
    "if_running_behind": "Skip edge cases like invalid ID handling. Get the core move working first, then add safety checks."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing the O(n) \u2192 O(1) lookup problem",
      "Mentioning that same object is referenced by both structures",
      "Using polymorphism for move_to instead of isinstance checks",
      "Proactively discussing that z-order is preserved"
    ]
  },
  "pattern_recognition": {
    "pattern": "Dual Data Structures / Index + Storage",
    "indicators": [
      "Need fast lookup by different criteria (z-order vs ID)",
      "Update operation that shouldn't change ordering"
    ],
    "similar_problems": [
      "LRU Cache (HashMap + DoublyLinkedList)",
      "Stock Price (HashMap + TreeMap)",
      "Design Twitter (HashMap + Priority Queue)"
    ],
    "template": "Use HashMap<K, V> for O(1) lookup + List/other structure for ordering. Store same object references in both."
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "moveShape needs to find shape by ID. Currently O(n) with list iteration.",
      "why": "This is the core bottleneck to address."
    },
    {
      "step": 2,
      "thought": "HashMap gives O(1) lookup by key. Use shape ID as key.",
      "why": "Standard approach for ID-based retrieval."
    },
    {
      "step": 3,
      "thought": "Store same object in both list and map. No data duplication.",
      "why": "Updating via map updates what's in list automatically."
    },
    {
      "step": 4,
      "thought": "Each shape needs move_to method. Use polymorphism.",
      "why": "Rectangle/Circle have different position semantics."
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you identify the need for a new data structure?",
      "Do you understand reference semantics (same object in both collections)?",
      "Can you extend existing code cleanly without breaking Part 1?"
    ],
    "bonus_points": [
      "Mentioning O(n) space for HashMap is acceptable tradeoff for O(1) time",
      "Explaining why polymorphic move_to is better than type checking",
      "Proactively testing z-order preservation"
    ],
    "red_flags": [
      "Linear search through list for moveShape",
      "Recreating shape objects instead of updating in-place",
      "Breaking Part 1 functionality while adding Part 2"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with HashMap syntax if unsure",
      "Use AI to generate test cases"
    ],
    "what_not_to_do": [
      "Don't let AI suggest removing and re-adding shapes",
      "Verify AI doesn't change Part 1 method signatures"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining the HashMap approach",
      "Not testing z-order preservation"
    ],
    "technical": [
      "O(n) moveShape when O(1) is achievable",
      "Breaking the shapes list z-order invariant"
    ],
    "communication": [
      "Not explaining why HashMap is needed",
      "Not mentioning that objects are shared between structures"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "moveShape is O(1) using HashMap lookup",
      "Both create methods update the HashMap",
      "move_to is polymorphic (abstract in Shape, implemented in subclasses)",
      "Z-order preserved after moving (verified with test)"
    ],
    "quick_code_review": [
      "shapes_by_id declared and initialized",
      "All create methods add to shapes_by_id",
      "move_shape handles invalid ID gracefully"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging shape movements for undo/redo support",
      "Validation of new coordinates (optional bounds)",
      "Event emission for UI updates"
    ],
    "why_not_in_interview": "Focus on core algorithm - O(1) lookup pattern",
    "how_to_mention": "Say: 'In production, I'd add event emission here so the UI layer knows to redraw.'"
  },
  "generated_at": "2026-01-19T04:19:54.801060",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}