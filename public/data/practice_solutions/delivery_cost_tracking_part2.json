{
  "problem_title": "Delivery Cost Tracking System - Part 2: Payment Settlement Tracking",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "In Part 1, we only tracked the total cost of all deliveries using a running sum. Now we need to distinguish between **paid** and **unpaid** deliveries. This requires storing individual delivery information (specifically end_time and cost) so we can mark deliveries as paid when their end_time falls within the payment window.",
    "new_requirements": [
      "pay_up_to_time(upToTime): Mark all deliveries ending at or before upToTime as paid",
      "get_cost_to_be_paid(): Return total cost of unpaid deliveries in O(1)"
    ],
    "new_constraints": [
      "pay_up_to_time must be O(log n) or better amortized, not O(n)",
      "get_cost_to_be_paid must be O(1)",
      "A delivery is paid only when completely finished (endTime <= upToTime)"
    ],
    "key_insight": "Store deliveries in a **sorted structure by end_time** (heap or TreeMap). Maintain a **paid_cost** running total. When paying, pop/remove deliveries from the sorted structure and add to paid_cost. The unpaid cost is simply `total_cost - paid_cost`, making get_cost_to_be_paid O(1)."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "pay_up_to_time must be O(log n) amortized",
        "how_met": "Use min-heap (Python) or TreeMap (Java) sorted by end_time. Each delivery is added once O(log n) and removed once O(log n), giving O(log n) amortized per delivery",
        "gotchas": [
          "Don't use a list and iterate through all - that's O(n)",
          "Remember to actually REMOVE paid deliveries to avoid re-paying"
        ]
      },
      {
        "requirement": "get_cost_to_be_paid must be O(1)",
        "how_met": "Maintain paid_cost running total. Return total_cost - paid_cost (simple subtraction)",
        "gotchas": [
          "Don't recalculate by summing unpaid deliveries - that's O(n)"
        ]
      },
      {
        "requirement": "Delivery paid only when completely finished",
        "how_met": "Check endTime <= upToTime when processing payments",
        "gotchas": [
          "Using startTime instead of endTime is a common mistake"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "pay_up_to_time",
        "target": "O(log n) amortized",
        "achieved": "O(k log n) where k = deliveries paid",
        "why": "Each delivery removed costs O(log n), but each is removed at most once"
      },
      {
        "operation": "get_cost_to_be_paid",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Simple subtraction of two pre-computed values"
      },
      {
        "operation": "add_delivery",
        "target": "O(log n)",
        "achieved": "O(log n)",
        "why": "Now includes heap push/TreeMap insert"
      }
    ],
    "non_goals": [
      "Querying which specific deliveries are unpaid",
      "Undo/reverse a payment",
      "Payment by driver (only by time)"
    ]
  },
  "assumptions": [
    "pay_up_to_time can be called multiple times with increasing or same times (already-paid deliveries won't be re-paid)",
    "Time never goes backwards (we don't need to 'unpay' deliveries)",
    "Multiple deliveries can have the same end_time - all should be paid together",
    "pay_up_to_time(T) with T before all deliveries is a valid no-op"
  ],
  "tradeoffs": [
    {
      "decision": "Min-Heap vs TreeMap for storing unpaid deliveries",
      "chosen": "Min-Heap for Python, TreeMap for Java",
      "why": "Heap: Built-in heapq, simple push/pop. TreeMap: Java has excellent NavigableMap API with headMap(). Both achieve O(log n) operations.",
      "alternative": "SortedList/SortedDict",
      "when_to_switch": "If we need to query ranges without removing, TreeMap is better. If we need to update costs, neither is ideal - would need custom structure."
    },
    {
      "decision": "Store individual costs vs aggregate by end_time",
      "chosen": "TreeMap stores List<cost> per end_time; Heap stores individual (end_time, cost) tuples",
      "why": "Handles multiple deliveries with same end_time correctly",
      "alternative": "Sum costs at same end_time into single entry",
      "when_to_switch": "If memory is critical and many deliveries share end_times"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "add_driver API unchanged",
      "add_delivery signature unchanged",
      "get_total_cost unchanged",
      "All Part 1 invariants preserved"
    ],
    "what_to_change": [
      "add_delivery now also pushes to sorted structure",
      "New _paid_cost and _unpaid fields added"
    ],
    "interfaces_and_boundaries": "Payment logic is isolated to pay_up_to_time. The sorted structure is internal - could swap implementations without affecting API.",
    "invariants": [
      "total_cost == sum of ALL delivery costs (paid + unpaid)",
      "paid_cost == sum of paid delivery costs",
      "total_cost - paid_cost == sum of unpaid delivery costs",
      "Each delivery in sorted structure is unpaid",
      "paid_cost only increases (payments are irreversible)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE pay_up_to_time(5400):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _total_cost = $40                    \u2502\n\u2502 _paid_cost = $0                      \u2502\n\u2502 _unpaid (heap by end_time):          \u2502\n\u2502   (3600, $10) \u2190 min                  \u2502\n\u2502   (5400, $20)                        \u2502\n\u2502   (10800, $10)                       \u2502\n\u2502 get_cost_to_be_paid() = $40 - $0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER pay_up_to_time(5400):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _total_cost = $40 (unchanged)        \u2502\n\u2502 _paid_cost = $30 (added $10 + $20)   \u2502\n\u2502 _unpaid (heap):                      \u2502\n\u2502   (10800, $10) \u2190 only this remains   \u2502\n\u2502 get_cost_to_be_paid() = $40 - $30    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\npay_up_to_time(T):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 WHILE heap not empty                    \u2502\n\u2502   AND heap.peek().end_time <= T:        \u2502\n\u2502                                         \u2502\n\u2502   1. Pop minimum (earliest end_time)    \u2502\n\u2502   2. Add its cost to _paid_cost         \u2502\n\u2502   3. Repeat                             \u2502\n\u2502                                         \u2502\n\u2502 Each delivery: added once, removed once \u2502\n\u2502 Amortized O(log n) per delivery         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Store in List",
      "description": "Store all deliveries in a list. On pay_up_to_time, iterate through entire list to find deliveries to pay.",
      "time_complexity": "O(n) per pay_up_to_time call",
      "space_complexity": "O(n) for delivery list",
      "why_not_optimal": "Violates the O(log n) requirement. If called frequently with small increments, this becomes very slow."
    },
    {
      "name": "Optimal - Sorted Structure (Heap/TreeMap)",
      "description": "Store unpaid deliveries in a min-heap or TreeMap keyed by end_time. Pop/remove entries until we exceed the payment time.",
      "time_complexity": "O(k log n) per call where k = deliveries paid; O(log n) amortized per delivery",
      "space_complexity": "O(n) for delivery storage",
      "key_insight": "Each delivery is added once and removed once. The sorted structure ensures we process in time order, stopping early when we exceed the payment time."
    }
  ],
  "optimal_solution": {
    "explanation_md": "### The Key Insight\n\nWe need to **efficiently find all deliveries ending before time T**. This screams **sorted data structure**!\n\n### Data Structure Choice\n\n**Python**: Use `heapq` (min-heap) with tuples `(end_time, cost)`\n- `heappush`: O(log n)\n- `heappop`: O(log n)\n- Peek at minimum: O(1)\n\n**Java**: Use `TreeMap<Long, List<BigDecimal>>`\n- `headMap(T, true)`: Returns view of all entries \u2264 T\n- Removal via view: O(k log n)\n\n### Algorithm\n\n1. **On add_delivery**: Calculate cost, add to total_cost, **push (end_time, cost) to heap**\n2. **On pay_up_to_time(T)**: While heap's minimum end_time \u2264 T, pop and add to paid_cost\n3. **On get_cost_to_be_paid**: Return `total_cost - paid_cost`\n\n### Why This Works\n\n- Heap keeps deliveries sorted by end_time\n- We only pop deliveries we need to pay (no wasted iteration)\n- Each delivery is popped at most once \u2192 **amortized O(log n)**\n- paid_cost is a running total \u2192 **O(1) query**",
    "data_structures": [
      {
        "structure": "Min-Heap (Python) / TreeMap (Java)",
        "purpose": "Store unpaid deliveries sorted by end_time for efficient payment processing"
      },
      {
        "structure": "Decimal paid_cost",
        "purpose": "Running total of paid costs for O(1) unpaid calculation"
      }
    ],
    "algorithm_steps": [
      "Step 1: On add_delivery, after calculating cost, push (end_time, cost) to min-heap",
      "Step 2: On pay_up_to_time(T), while heap is non-empty AND heap[0].end_time <= T: pop and add cost to paid_cost",
      "Step 3: On get_cost_to_be_paid, return total_cost - paid_cost"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Delivery Cost Tracking System - Part 2: Payment Settlement",
    "Key insight: Min-heap by end_time for O(log n) payment processing.",
    "\"\"\"",
    "from decimal import Decimal",
    "from typing import Dict, List, Tuple",
    "import heapq",
    "",
    "",
    "class DeliveryCostTracker:",
    "    \"\"\"Tracks delivery costs with O(1) queries and O(log n) payments.\"\"\"",
    "    ",
    "    SECONDS_PER_HOUR = Decimal('3600')",
    "    ",
    "    def __init__(self):",
    "        self._drivers: Dict[int, Decimal] = {}",
    "        self._total_cost: Decimal = Decimal('0')",
    "        # Part 2: Payment tracking",
    "        self._paid_cost: Decimal = Decimal('0')",
    "        self._unpaid: List[Tuple[int, Decimal]] = []  # min-heap: (end_time, cost)",
    "    ",
    "    def add_driver(self, driver_id: int, hourly_rate: Decimal) -> None:",
    "        \"\"\"Register a driver with their hourly rate. O(1)\"\"\"",
    "        self._drivers[driver_id] = hourly_rate",
    "    ",
    "    def add_delivery(self, driver_id: int, start_time: int, end_time: int) -> None:",
    "        \"\"\"Record a delivery and update running total. O(log n) for heap push.\"\"\"",
    "        if driver_id not in self._drivers:",
    "            raise ValueError(f\"Driver {driver_id} not registered\")",
    "        ",
    "        rate = self._drivers[driver_id]",
    "        duration = Decimal(end_time - start_time)",
    "        cost = rate * duration / self.SECONDS_PER_HOUR",
    "        ",
    "        self._total_cost += cost",
    "        heapq.heappush(self._unpaid, (end_time, cost))  # Track for payment",
    "    ",
    "    def get_total_cost(self) -> Decimal:",
    "        \"\"\"Return total cost of all deliveries. O(1)\"\"\"",
    "        return self._total_cost",
    "    ",
    "    def pay_up_to_time(self, up_to_time: int) -> None:",
    "        \"\"\"",
    "        Pay all deliveries ending at or before up_to_time.",
    "        O(k log n) where k = deliveries paid, O(log n) amortized.",
    "        \"\"\"",
    "        while self._unpaid and self._unpaid[0][0] <= up_to_time:",
    "            _, cost = heapq.heappop(self._unpaid)",
    "            self._paid_cost += cost",
    "    ",
    "    def get_cost_to_be_paid(self) -> Decimal:",
    "        \"\"\"Return cost of unpaid deliveries. O(1)\"\"\"",
    "        return self._total_cost - self._paid_cost",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"PART 2: PAYMENT SETTLEMENT TRACKING\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Example 1: Basic payment flow",
    "    t = DeliveryCostTracker()",
    "    t.add_driver(1, Decimal('20'))",
    "    t.add_delivery(1, 0, 3600)      # $20, ends at 3600",
    "    t.add_delivery(1, 3600, 7200)   # $20, ends at 7200",
    "    print(f\"Total: ${t.get_total_cost()}  (expected: 40)\")",
    "    print(f\"Unpaid: ${t.get_cost_to_be_paid()}  (expected: 40)\")",
    "    t.pay_up_to_time(3600)",
    "    print(f\"After pay(3600): ${t.get_cost_to_be_paid()}  (expected: 20)\")",
    "    ",
    "    # Example 2: Multiple drivers, progressive payments",
    "    print(\"\\n\" + \"-\" * 40)",
    "    t2 = DeliveryCostTracker()",
    "    t2.add_driver(1, Decimal('10'))",
    "    t2.add_driver(2, Decimal('20'))",
    "    t2.add_delivery(1, 0, 3600)      # $10, ends 3600",
    "    t2.add_delivery(2, 1800, 5400)   # $20, ends 5400",
    "    t2.add_delivery(1, 7200, 10800)  # $10, ends 10800",
    "    t2.pay_up_to_time(5400)",
    "    print(f\"After pay(5400): ${t2.get_cost_to_be_paid()}  (expected: 10)\")",
    "    t2.pay_up_to_time(10800)",
    "    print(f\"After pay(10800): ${t2.get_cost_to_be_paid()}  (expected: 0)\")",
    "    ",
    "    # Example 3: Edge case - pay before any deliveries end",
    "    print(\"\\n\" + \"-\" * 40)",
    "    t3 = DeliveryCostTracker()",
    "    t3.add_driver(1, Decimal('30'))",
    "    t3.add_delivery(1, 1000, 5000)  # $33.33, ends 5000",
    "    t3.pay_up_to_time(500)  # No deliveries end before 500",
    "    print(f\"Pay before any end: ${t3.get_cost_to_be_paid():.2f}  (should be ~33.33)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 2 tests passed! \u2713\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "",
    "/**",
    " * Delivery Cost Tracking System - Part 2: Payment Settlement",
    " * Uses TreeMap for O(log n) payment by end_time.",
    " */",
    "public class DeliveryCostTracker {",
    "    ",
    "    private static final BigDecimal SECONDS_PER_HOUR = new BigDecimal(\"3600\");",
    "    ",
    "    private final Map<Integer, BigDecimal> drivers;",
    "    private BigDecimal totalCost;",
    "    // Part 2: Payment tracking",
    "    private BigDecimal paidCost;",
    "    private final TreeMap<Long, List<BigDecimal>> unpaid; // endTime -> costs",
    "    ",
    "    public DeliveryCostTracker() {",
    "        this.drivers = new HashMap<>();",
    "        this.totalCost = BigDecimal.ZERO;",
    "        this.paidCost = BigDecimal.ZERO;",
    "        this.unpaid = new TreeMap<>();",
    "    }",
    "    ",
    "    public void addDriver(int driverId, BigDecimal hourlyRate) {",
    "        drivers.put(driverId, hourlyRate);",
    "    }",
    "    ",
    "    public void addDelivery(int driverId, long startTime, long endTime) {",
    "        BigDecimal rate = drivers.get(driverId);",
    "        if (rate == null) {",
    "            throw new IllegalArgumentException(\"Driver \" + driverId + \" not registered\");",
    "        }",
    "        ",
    "        BigDecimal duration = new BigDecimal(endTime - startTime);",
    "        BigDecimal cost = rate.multiply(duration).divide(SECONDS_PER_HOUR, 10, BigDecimal.ROUND_HALF_UP);",
    "        totalCost = totalCost.add(cost);",
    "        ",
    "        // Track for payment settlement",
    "        unpaid.computeIfAbsent(endTime, k -> new ArrayList<>()).add(cost);",
    "    }",
    "    ",
    "    public BigDecimal getTotalCost() {",
    "        return totalCost;",
    "    }",
    "    ",
    "    /** Pay all deliveries ending at or before upToTime. O(k log n) */",
    "    public void payUpToTime(long upToTime) {",
    "        // headMap returns a view; modifications affect original TreeMap",
    "        NavigableMap<Long, List<BigDecimal>> toPay = unpaid.headMap(upToTime, true);",
    "        for (List<BigDecimal> costs : toPay.values()) {",
    "            for (BigDecimal cost : costs) {",
    "                paidCost = paidCost.add(cost);",
    "            }",
    "        }",
    "        toPay.clear(); // Removes paid entries from unpaid TreeMap",
    "    }",
    "    ",
    "    /** Return cost of unpaid deliveries. O(1) */",
    "    public BigDecimal getCostToBePaid() {",
    "        return totalCost.subtract(paidCost);",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"PART 2: PAYMENT SETTLEMENT TRACKING\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Example 1: Basic payment",
    "        DeliveryCostTracker t = new DeliveryCostTracker();",
    "        t.addDriver(1, new BigDecimal(\"20\"));",
    "        t.addDelivery(1, 0, 3600);",
    "        t.addDelivery(1, 3600, 7200);",
    "        System.out.println(\"Total: $\" + t.getTotalCost() + \" (expected: 40)\");",
    "        System.out.println(\"Unpaid: $\" + t.getCostToBePaid() + \" (expected: 40)\");",
    "        t.payUpToTime(3600);",
    "        System.out.println(\"After pay(3600): $\" + t.getCostToBePaid() + \" (expected: 20)\");",
    "        ",
    "        // Example 2: Multiple drivers",
    "        System.out.println(\"\\n----------------------------------------\");",
    "        DeliveryCostTracker t2 = new DeliveryCostTracker();",
    "        t2.addDriver(1, new BigDecimal(\"10\"));",
    "        t2.addDriver(2, new BigDecimal(\"20\"));",
    "        t2.addDelivery(1, 0, 3600);",
    "        t2.addDelivery(2, 1800, 5400);",
    "        t2.addDelivery(1, 7200, 10800);",
    "        t2.payUpToTime(5400);",
    "        System.out.println(\"After pay(5400): $\" + t2.getCostToBePaid() + \" (expected: 10)\");",
    "        t2.payUpToTime(10800);",
    "        System.out.println(\"After pay(10800): $\" + t2.getCostToBePaid() + \" (expected: 0)\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All Part 2 tests passed!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-7",
      "explanation": "Imports: Decimal for precision, heapq for min-heap, typing for type hints"
    },
    {
      "lines": "10-19",
      "explanation": "__init__ adds two new fields: _paid_cost (running total of paid deliveries) and _unpaid (min-heap storing (end_time, cost) tuples)"
    },
    {
      "lines": "25-34",
      "explanation": "add_delivery extended: after calculating cost and updating total, we now also push to the heap for payment tracking. Complexity increases from O(1) to O(log n)"
    },
    {
      "lines": "40-47",
      "explanation": "pay_up_to_time: The core new algorithm. While heap has items with end_time <= up_to_time, pop them and add to paid_cost. Each delivery is removed at most once."
    },
    {
      "lines": "49-51",
      "explanation": "get_cost_to_be_paid: Simple O(1) subtraction. This is why we maintain paid_cost as a running total."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "pay_up_to_time": {
          "complexity": "O(k log n) where k = deliveries paid",
          "explanation": "Each heappop is O(log n), and we pop k items. Amortized O(log n) per delivery since each is popped at most once."
        },
        "get_cost_to_be_paid": {
          "complexity": "O(1)",
          "explanation": "Simple subtraction of two pre-computed Decimal values"
        }
      },
      "modified_methods": {
        "add_delivery": {
          "complexity": "O(log n)",
          "explanation": "Was O(1) in Part 1, now includes heappush which is O(log n)"
        }
      },
      "overall_change": "add_delivery goes from O(1) to O(log n). New operations are O(log n) amortized and O(1) respectively."
    },
    "space": {
      "additional_space": "O(n) where n = number of deliveries",
      "explanation": "We now store each delivery in the heap until it's paid. In Part 1, we didn't store deliveries at all."
    }
  },
  "dry_run": {
    "example_input": "addDriver(1, 10), addDriver(2, 20), addDelivery(1, 0, 3600), addDelivery(2, 1800, 5400), addDelivery(1, 7200, 10800), payUpToTime(5400), getCostToBePaid()",
    "steps": [
      {
        "step": 1,
        "action": "addDriver(1, 10)",
        "state": "drivers={1: 10}, total=0, paid=0, heap=[]",
        "explanation": "Register driver 1 at $10/hr"
      },
      {
        "step": 2,
        "action": "addDriver(2, 20)",
        "state": "drivers={1: 10, 2: 20}, total=0, paid=0, heap=[]",
        "explanation": "Register driver 2 at $20/hr"
      },
      {
        "step": 3,
        "action": "addDelivery(1, 0, 3600)",
        "state": "total=10, paid=0, heap=[(3600, 10)]",
        "explanation": "D1: 1hr \u00d7 $10 = $10, ends at 3600"
      },
      {
        "step": 4,
        "action": "addDelivery(2, 1800, 5400)",
        "state": "total=30, paid=0, heap=[(3600, 10), (5400, 20)]",
        "explanation": "D2: 1hr \u00d7 $20 = $20, ends at 5400"
      },
      {
        "step": 5,
        "action": "addDelivery(1, 7200, 10800)",
        "state": "total=40, paid=0, heap=[(3600, 10), (5400, 20), (10800, 10)]",
        "explanation": "D3: 1hr \u00d7 $10 = $10, ends at 10800"
      },
      {
        "step": 6,
        "action": "payUpToTime(5400)",
        "state": "total=40, paid=30, heap=[(10800, 10)]",
        "explanation": "Pop (3600, 10): paid=10. Pop (5400, 20): paid=30. Stop since 10800 > 5400."
      },
      {
        "step": 7,
        "action": "getCostToBePaid()",
        "state": "return 40 - 30 = 10",
        "explanation": "D3 ($10) remains unpaid"
      }
    ],
    "final_output": "10"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single delivery, pay after it ends: should have 0 unpaid",
      "Single delivery, pay before it ends: should have full cost unpaid"
    ],
    "likely_bugs": [
      "Using startTime instead of endTime for payment check",
      "Forgetting to remove paid items from heap (double-paying)",
      "Off-by-one: using < instead of <= for endTime comparison",
      "Not handling empty heap in pay_up_to_time"
    ],
    "recommended_logs_or_asserts": [
      "assert self._paid_cost <= self._total_cost",
      "Log: f'Paying delivery ending at {end_time}, cost={cost}'",
      "After pay_up_to_time: assert all remaining heap items have end_time > up_to_time"
    ],
    "how_to_localize": "1. Check total_cost is correct after adds. 2. Check heap contents before pay. 3. Verify each pop during pay. 4. Confirm paid_cost after."
  },
  "edge_cases": [
    {
      "case": "Pay before any deliveries exist",
      "handling": "Heap is empty, while-loop doesn't execute, no-op",
      "gotcha": "Don't crash on empty heap"
    },
    {
      "case": "Pay with time earlier than all end_times",
      "handling": "First item's end_time > up_to_time, loop doesn't execute",
      "gotcha": "Check condition BEFORE popping"
    },
    {
      "case": "Multiple deliveries with same end_time",
      "handling": "All are popped (both have end_time <= up_to_time)",
      "gotcha": "Using < instead of <= would miss exact matches"
    },
    {
      "case": "Call pay_up_to_time multiple times with same time",
      "handling": "Second call is no-op (items already removed)",
      "gotcha": "Don't re-add to paid_cost"
    },
    {
      "case": "Call get_cost_to_be_paid before any payments",
      "handling": "paid_cost=0, returns total_cost",
      "gotcha": "Initialize paid_cost to 0, not None"
    }
  ],
  "test_cases": [
    {
      "name": "Basic payment flow",
      "input": "addDriver(1, 20), addDelivery(1, 0, 3600), addDelivery(1, 3600, 7200), payUpToTime(3600), getCostToBePaid()",
      "expected": "20",
      "explanation": "Two $20 deliveries. Pay first (ends at 3600). $20 remains unpaid."
    },
    {
      "name": "Pay all at once",
      "input": "addDriver(1, 10), addDelivery(1, 0, 100), addDelivery(1, 0, 200), payUpToTime(200), getCostToBePaid()",
      "expected": "0",
      "explanation": "Both deliveries end at or before 200, both are paid."
    },
    {
      "name": "Progressive payments",
      "input": "3 deliveries ending at 1000, 2000, 3000. Pay(1500) then pay(2500) then pay(3500)",
      "expected": "After each pay: 2 unpaid, 1 unpaid, 0 unpaid",
      "explanation": "Each payment captures exactly the deliveries ending in that window."
    },
    {
      "name": "Same end_time multiple deliveries",
      "input": "addDriver(1, 10), addDriver(2, 20), addDelivery(1, 0, 3600), addDelivery(2, 0, 3600), payUpToTime(3600)",
      "expected": "getCostToBePaid() = 0",
      "explanation": "Both deliveries end at 3600, both are paid."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using startTime instead of endTime for payment eligibility",
      "why_wrong": "Problem says 'deliveries that END at or before upToTime'. A delivery in progress (started but not ended) shouldn't be paid.",
      "correct_approach": "Store and compare by end_time",
      "code_example_wrong": "heappush(self._unpaid, (start_time, cost))",
      "code_example_correct": "heappush(self._unpaid, (end_time, cost))"
    },
    {
      "mistake": "Iterating through all deliveries on each pay call",
      "why_wrong": "O(n) per call violates the O(log n) amortized requirement",
      "correct_approach": "Use sorted structure, process only relevant items",
      "code_example_wrong": "for delivery in all_deliveries: if delivery.end_time <= T: ...",
      "code_example_correct": "while heap and heap[0][0] <= T: heappop(heap)..."
    },
    {
      "mistake": "Not removing paid deliveries from the structure",
      "why_wrong": "Same delivery could be paid multiple times, corrupting paid_cost",
      "correct_approach": "Pop/remove items as you process them",
      "code_example_wrong": "for item in heap: if item[0] <= T: paid += item[1]  # heap unchanged!",
      "code_example_correct": "while heap and heap[0][0] <= T: _, cost = heappop(heap); paid += cost"
    },
    {
      "mistake": "Recalculating unpaid cost by summing heap",
      "why_wrong": "O(n) violates O(1) requirement",
      "correct_approach": "Maintain paid_cost running total, return total - paid",
      "code_example_wrong": "return sum(cost for _, cost in self._unpaid)",
      "code_example_correct": "return self._total_cost - self._paid_cost"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining: 'To meet the O(log n) requirement, I need a sorted structure. A min-heap by end_time lets me efficiently find and remove deliveries to pay.' Then walk through the algorithm before coding.",
    "what_to_mention": [
      "Explicitly state the amortized analysis: 'Each delivery is added once and removed once'",
      "Mention the space tradeoff: 'Part 1 was O(D) space, Part 2 is O(D + N) where N = deliveries'",
      "Note that add_delivery complexity changes from O(1) to O(log n)"
    ],
    "time_allocation": "2 min understand, 3 min explain approach, 5-7 min implement, 2 min test",
    "if_stuck": [
      "Think: 'What data structure lets me find all items less than X efficiently?' \u2192 Sorted structure",
      "Think: 'How can get_cost_to_be_paid be O(1)?' \u2192 Must be precomputed, use subtraction"
    ]
  },
  "connection_to_next_part": "Part 2 introduces delivery-level tracking with sorted storage. A potential Part 3 might add: query by driver (need driver_id in heap), time range queries (need interval tree), or refunds (need to reverse payments). The current structure can extend to these by storing more metadata per delivery.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 is working. For Part 2, I need to track which deliveries are paid vs unpaid. The key challenge is that pay_up_to_time needs to be O(log n), not O(n).",
    "explaining_changes": "I'll add a min-heap sorted by end_time to store unpaid deliveries. I'll also track paid_cost as a running total. This way, get_cost_to_be_paid is just total_cost minus paid_cost - O(1).",
    "while_extending_code": [
      "Adding _paid_cost initialized to zero...",
      "Adding _unpaid heap for deliveries...",
      "Modifying add_delivery to also push to heap - this changes it to O(log n)...",
      "Implementing pay_up_to_time with while loop..."
    ],
    "after_completing": "This handles Part 2. pay_up_to_time is O(k log n) where k is deliveries paid, amortized O(log n). get_cost_to_be_paid is O(1). Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Understand we need sorted structure for O(log n) payment. Decide heap vs TreeMap.",
    "by_5_min": "Explain approach clearly. Start modifying add_delivery and adding new fields.",
    "by_10_min": "Implementation complete. Test with example: add deliveries, pay, check unpaid cost.",
    "warning_signs": "If unsure about data structure at 4 min, just pick heap and go. If still coding at 12 min, wrap up and mention what's left."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has bugs (e.g., total_cost wrong), fix first. Say: 'Let me verify Part 1 is correct before extending.'",
    "if_new_requirement_unclear": "Ask: 'Does pay_up_to_time need to return anything? Can it be called with a time earlier than previous calls?'",
    "if_running_behind": "Focus on pay_up_to_time logic. get_cost_to_be_paid is just subtraction. Skip edge case handling but mention them."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately identifying heap/TreeMap as the right structure",
      "Explaining the amortized analysis clearly",
      "Noting the space-time tradeoff vs Part 1",
      "Proactively mentioning edge cases (empty heap, multiple same end_time)",
      "Smooth extension of existing code without rewriting"
    ]
  },
  "pattern_recognition": {
    "pattern": "Sweep Line / Event Processing with Priority Queue",
    "indicators": [
      "Need to process events in sorted order",
      "Events have a time/value that determines processing order",
      "Need efficient insertion and extraction of minimum",
      "Query asks about 'all items before time T'"
    ],
    "similar_problems": [
      "LC 253 - Meeting Rooms II (event sweep)",
      "LC 218 - The Skyline Problem",
      "LC 1094 - Car Pooling",
      "Any interval/event processing problem"
    ],
    "template": "```python\nimport heapq\nheap = []  # min-heap by event time\n# Add: heapq.heappush(heap, (time, data))\n# Process up to T: while heap and heap[0][0] <= T: heappop(heap)\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Need to find deliveries ending before time T efficiently",
      "why": "This is the core of pay_up_to_time"
    },
    {
      "step": 2,
      "thought": "A sorted structure by end_time lets me stop early",
      "why": "Once I hit end_time > T, I'm done - no need to check rest"
    },
    {
      "step": 3,
      "thought": "Heap gives O(log n) push and pop, perfect for this",
      "why": "I only need to access minimum, not arbitrary elements"
    },
    {
      "step": 4,
      "thought": "For O(1) get_cost_to_be_paid, I need precomputation",
      "why": "Can't sum heap items - that's O(n)"
    },
    {
      "step": 5,
      "thought": "total_cost - paid_cost = unpaid_cost",
      "why": "If I track paid_cost as I pay, the query becomes subtraction"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you recognize the sorted structure pattern?",
      "Do you understand amortized complexity?",
      "Can you extend existing code cleanly without rewriting?",
      "Do you maintain invariants from Part 1?"
    ],
    "bonus_points": [
      "Explaining why add_delivery is now O(log n) instead of O(1)",
      "Discussing Java TreeMap vs Python heap tradeoffs",
      "Mentioning that deliveries with same end_time need handling",
      "Clean separation - new methods don't break old ones"
    ],
    "red_flags": [
      "Rewriting Part 1 from scratch",
      "Using O(n) linear scan for payment",
      "Not understanding why O(1) get_cost_to_be_paid requires pre-computation",
      "Breaking Part 1 functionality (get_total_cost should still work)"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Ask AI for heapq syntax if unsure",
      "Let AI help with type hints for new fields",
      "Use AI to generate test cases"
    ],
    "what_not_to_do": [
      "Don't let AI pick the data structure - you should drive that decision",
      "Don't accept code without understanding the amortized analysis",
      "Don't let AI rewrite Part 1 - extend, don't replace"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking if pay_up_to_time can be called multiple times",
      "Staying silent while figuring out the data structure"
    ],
    "technical": [
      "Using a list and iterating through all deliveries",
      "Storing but never removing paid deliveries",
      "Modifying total_cost in pay_up_to_time (it tracks ALL deliveries)"
    ],
    "communication": [
      "Not explaining why heap/TreeMap meets O(log n) requirement",
      "Forgetting to trace through an example after implementation"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does pay_up_to_time achieve O(log n) amortized? (Yes - each delivery popped once)",
      "Is get_cost_to_be_paid O(1)? (Yes - just subtraction)",
      "Did I trace through Example 1 and 2?",
      "Does Part 1 functionality still work? (get_total_cost, add_driver unchanged)"
    ],
    "quick_code_review": [
      "Heap initialized in __init__",
      "heappush in add_delivery",
      "while loop with <= check in pay_up_to_time",
      "Subtraction in get_cost_to_be_paid"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging each payment batch: 'Paid N deliveries totaling $X up to time T'",
      "Metrics: payment_count, total_paid_cost",
      "Validation: up_to_time should be reasonable (not negative, not far future)"
    ],
    "why_not_in_interview": "Core algorithm is the focus. These are quick verbal mentions.",
    "how_to_mention": "Say: 'In production, I'd add logging here to track payment operations for auditing.'"
  },
  "generated_at": "2026-01-19T04:21:05.490939",
  "_meta": {
    "problem_id": "delivery_cost_tracking",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}