{
  "problem_title": "Design a Hotel Booking/Reservation System",
  "difficulty": "hard",
  "category": "HLD/System Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **distributed systems design** problem with a critical **concurrency challenge**. The core difficulty isn't CRUD operations\u2014it's preventing double-bookings when thousands of users try to book the same room simultaneously. This requires careful database design, transaction isolation, and understanding of locking strategies.",
    "pattern_recognition": "**Patterns**: Pessimistic/Optimistic Locking, Saga Pattern (for distributed transactions), CQRS (separate read/write paths), Database Constraints, Idempotency. **Similar to**: LC 253 Meeting Rooms II (overlap detection), LC 731/732 Calendar problems, but at distributed scale with real consistency requirements.",
    "key_constraints": [
      "**No double-bookings (CRITICAL)** - Must be enforced at database level, not application level. Race conditions WILL happen.",
      "**10K bookings/sec peak** - Need horizontal scaling for writes, but consistency is paramount",
      "**100K searches/sec** - Read-heavy workload requires separate optimization (caching, search indices)",
      "**<200ms search, <500ms booking** - Search must be fast (use denormalized data), booking can be slower (complex transaction)",
      "**99.99% uptime** - System must be highly available, but for bookings we choose consistency over availability (CP in CAP)"
    ],
    "clarifying_questions": [
      "**Q: How do we handle check-in/check-out boundaries?** - Can a new booking start on the same day another ends? (Usually yes: checkout 11am, checkin 3pm)",
      "**Q: What's the cancellation window?** - Can users cancel anytime? Different refund policies? This affects our transaction model.",
      "**Q: Do we support partial bookings?** - If user wants 5 nights but only 3 are available, do we offer partial?",
      "**Q: How is pricing determined?** - Static per room? Dynamic based on demand? Seasonal? This affects data model.",
      "**Q: Payment failure handling?** - If payment fails after we 'reserved', how long do we hold the room?",
      "**Q: Multi-room bookings?** - Can one booking include multiple rooms? This complicates atomicity.",
      "**Q: Overbooking policy?** - Some hotels intentionally overbook 5-10%. Should we support this?"
    ],
    "edge_cases_to_consider": [
      "Two users clicking 'Book' at exact same millisecond for same room/dates",
      "User A booking Jun 1-5, User B booking Jun 3-7 (partial overlap)",
      "Cancellation happening while another user is mid-booking-flow for same dates",
      "Payment timeout - room held but payment neither confirmed nor failed",
      "Same user accidentally double-submitting booking request",
      "Hotel removing room from inventory while bookings exist",
      "Timezone edge cases around midnight bookings"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "searchRooms with <200ms P95 latency",
        "how_met": "Elasticsearch index synced from primary DB, pre-computed availability bitmap, caching layer",
        "gotchas": [
          "Stale data in search (eventual consistency)",
          "Must re-validate availability on booking"
        ]
      },
      {
        "requirement": "createBooking with NO double-bookings",
        "how_met": "Database UNIQUE constraint on (room_id, date) in availability table + SELECT FOR UPDATE lock",
        "gotchas": [
          "Application-level check is NOT sufficient",
          "Must use serializable isolation or explicit locks"
        ]
      },
      {
        "requirement": "cancelBooking frees inventory immediately",
        "how_met": "Atomic transaction: update booking status + delete availability records",
        "gotchas": [
          "Race with concurrent booking attempt",
          "Refund is async - don't block on payment"
        ]
      },
      {
        "requirement": "10K bookings/sec throughput",
        "how_met": "Horizontal sharding by hotel_id/region, connection pooling, async payment processing",
        "gotchas": [
          "Hot hotels need special handling",
          "Lock contention on popular rooms"
        ]
      },
      {
        "requirement": "99.99% availability",
        "how_met": "Primary-replica DB setup, read replicas for search, circuit breakers, graceful degradation",
        "gotchas": [
          "For bookings, we sacrifice availability for consistency (can't double-book)"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "searchRooms",
        "target": "<200ms P95",
        "achieved": "~100ms with ES + cache",
        "why": "Denormalized search index, no joins at query time"
      },
      {
        "operation": "createBooking",
        "target": "<500ms P95",
        "achieved": "~300ms",
        "why": "Single DB transaction, async payment authorization"
      },
      {
        "operation": "cancelBooking",
        "target": "<500ms P95",
        "achieved": "~200ms",
        "why": "Simple status update + availability release"
      },
      {
        "operation": "getRoomDetails",
        "target": "<100ms",
        "achieved": "~50ms",
        "why": "Cached room data + real-time availability check"
      }
    ],
    "non_goals": [
      "Real-time chat with hotel (not in scope)",
      "Review/rating system (separate service)",
      "Loyalty points/rewards (separate service)",
      "Flight/car bundling (future extension)",
      "Price prediction/alerts (analytics service)"
    ]
  },
  "assumptions": [
    "**Timezone handling**: All dates stored as UTC date (no time component). Check-in is always 3PM local, check-out 11AM local.",
    "**Same-day turnover**: If booking ends on Jun 5, another can start on Jun 5 (checkout before checkin).",
    "**Single currency**: Prices stored in cents (integer) to avoid floating point issues. Currency conversion handled elsewhere.",
    "**Idempotency keys**: Clients must provide idempotency key for createBooking to handle retries safely.",
    "**Payment is external**: We integrate with payment gateway (Stripe, etc.) - not designing payment system itself."
  ],
  "tradeoffs": [
    {
      "decision": "Availability data model",
      "chosen": "Denormalized per-date rows (room_availability table)",
      "why": "O(1) conflict check with UNIQUE constraint, simpler queries, better for OLTP",
      "alternative": "Store only bookings, compute availability on read",
      "when_to_switch": "If storage becomes concern (millions of rooms \u00d7 365 days = billions of rows)"
    },
    {
      "decision": "Search architecture",
      "chosen": "Separate Elasticsearch cluster with async sync",
      "why": "100K searches/sec cannot hit transactional DB. Eventual consistency OK for search.",
      "alternative": "Read replicas of primary DB",
      "when_to_switch": "Smaller scale (<1K searches/sec) or if ES operational overhead too high"
    },
    {
      "decision": "Locking strategy for bookings",
      "chosen": "Pessimistic locking (SELECT FOR UPDATE) + UNIQUE constraint",
      "why": "High contention on popular rooms. Optimistic would have many retries.",
      "alternative": "Optimistic locking with version column",
      "when_to_switch": "Low contention scenarios, or if lock wait times become problematic"
    },
    {
      "decision": "Payment integration pattern",
      "chosen": "Two-phase: Authorize first, then capture after booking confirmed",
      "why": "Avoid charging customer if room unavailable. Avoid holding room without payment guarantee.",
      "alternative": "Saga pattern with compensating transactions",
      "when_to_switch": "If multiple services need coordination (multi-room, bundles)"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Separation of concerns**: Search service, Booking service, Payment service are independent",
      "**Database as source of truth**: All consistency guarantees come from DB constraints, not application logic",
      "**Idempotency everywhere**: All write operations use idempotency keys for safe retries",
      "**Event-driven updates**: Booking changes emit events for search index sync, notifications, analytics"
    ],
    "why_this_design_scales": "The architecture separates read path (Elasticsearch, caches) from write path (PostgreSQL with strong consistency). Booking logic is isolated so we can scale booking service horizontally while maintaining per-room consistency through database locks. The availability table can be sharded by hotel_id for horizontal write scaling.",
    "expected_followup_hooks": [
      "**Part 2 (Concurrent bookings)**: Deep dive into locking strategies - the AvailabilityService.lockDates() method is the extension point",
      "**Part 3 (High traffic scaling)**: Add sharding to booking DB, introduce Redis for distributed locks, implement reservation queue",
      "**Dynamic pricing**: Add PricingService that RoomDetails calls - doesn't affect core booking logic",
      "**Waitlist feature**: Add pending_requests table, notify when cancellation happens"
    ],
    "invariants": [
      "**INV1**: No two CONFIRMED bookings can have overlapping dates for same room",
      "**INV2**: Every availability row with booking_id has corresponding booking record",
      "**INV3**: Booking status transitions: PENDING \u2192 CONFIRMED | CANCELLED, CONFIRMED \u2192 COMPLETED | CANCELLED",
      "**INV4**: totalPrice = sum of nightly rates for all dates in booking"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    THE DOUBLE-BOOKING PROBLEM                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502   Time \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6           \u2502\n\u2502                                                                              \u2502\n\u2502   User A: \u2500\u2500[Check]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[Book]\u2500\u2500\u25b6 \u2713 SUCCESS                      \u2502\n\u2502                \u2502                      \u2502                                      \u2502\n\u2502                \u2502    Room 101          \u2502                                      \u2502\n\u2502                \u2502    Available? \u2713      \u2502    INSERT booking                   \u2502\n\u2502                \u2502                      \u2502                                      \u2502\n\u2502   User B: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[Check]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[Book]\u2500\u2500\u25b6 ??? CONFLICT!        \u2502\n\u2502                       \u2502                         \u2502                            \u2502\n\u2502                       \u2502    Room 101             \u2502                            \u2502\n\u2502                       \u2502    Available? \u2713         \u2502    INSERT fails!          \u2502\n\u2502                       \u2502    (stale!)             \u2502    UNIQUE violation        \u2502\n\u2502                                                                              \u2502\n\u2502   \u26a0\ufe0f  Without DB constraints, BOTH would succeed = DISASTER                 \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         CORE DATA MODEL                                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502      hotels      \u2502     \u2502      rooms       \u2502     \u2502    bookings      \u2502     \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2502\n\u2502  \u2502 id (PK)          \u2502\u2500\u2500\u2510  \u2502 id (PK)          \u2502\u2500\u2500\u2510  \u2502 id (PK)          \u2502     \u2502\n\u2502  \u2502 name             \u2502  \u2502  \u2502 hotel_id (FK)\u25c0\u2500\u2500\u2500\u2502\u2500\u2500\u2518  \u2502 user_id          \u2502     \u2502\n\u2502  \u2502 city             \u2502  \u2502  \u2502 room_number      \u2502     \u2502 room_id (FK)\u25c0\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2510  \u2502\n\u2502  \u2502 country          \u2502  \u2502  \u2502 type             \u2502     \u2502 check_in_date    \u2502  \u2502  \u2502\n\u2502  \u2502 latitude         \u2502  \u2514\u2500\u25b6\u2502 capacity         \u2502     \u2502 check_out_date   \u2502  \u2502  \u2502\n\u2502  \u2502 longitude        \u2502     \u2502 base_price_cents \u2502     \u2502 status           \u2502  \u2502  \u2502\n\u2502  \u2502 star_rating      \u2502     \u2502 amenities (JSON) \u2502     \u2502 total_price_cents\u2502  \u2502  \u2502\n\u2502  \u2502 amenities (JSON) \u2502     \u2502 is_active        \u2502     \u2502 created_at       \u2502  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502 idempotency_key  \u2502  \u2502  \u2502\n\u2502                                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502                                                                           \u2502  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502  \u2502\n\u2502  \u2502                    room_availability (CRITICAL)                     \u2502   \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502  \u2502\n\u2502  \u2502 room_id (PK, FK)\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2518  \u2502\n\u2502  \u2502 date (PK)         \u25c0\u2500\u2500 Composite Primary Key prevents duplicates    \u2502      \u2502\n\u2502  \u2502 booking_id (FK)   \u25c0\u2500\u2500 Which booking holds this date                \u2502      \u2502\n\u2502  \u2502 price_cents       \u25c0\u2500\u2500 Price for this specific night                \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                                              \u2502\n\u2502  \u26a1 KEY INSIGHT: Composite PK (room_id, date) = DB-enforced no duplicates   \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "User searches for rooms in NYC, Jun 15-18",
        "visualization": "```\n[Client] \u2500\u2500search(NYC, Jun15-18)\u2500\u2500\u25b6 [Search Service]\n                                          \u2502\n                                          \u25bc\n                                   [Elasticsearch]\n                                   Query: city=NYC AND\n                                   available[Jun15-17]=true\n                                          \u2502\n                                          \u25bc\n                                   Return 156 rooms\n```",
        "key_point": "Search hits Elasticsearch, NOT the booking database. Fast but eventually consistent."
      },
      {
        "step": 2,
        "description": "User selects room, views details with real-time availability",
        "visualization": "```\n[Client] \u2500\u2500getRoomDetails(R101)\u2500\u2500\u25b6 [Booking Service]\n                                          \u2502\n                                          \u25bc\n                                   [PostgreSQL]\n                                   SELECT * FROM room_availability\n                                   WHERE room_id='R101'\n                                   AND date IN ('Jun15','Jun16','Jun17')\n                                          \u2502\n                                          \u25bc\n                                   0 rows = AVAILABLE \u2713\n```",
        "key_point": "Details query hits PRIMARY database for real-time accuracy before booking."
      },
      {
        "step": 3,
        "description": "User clicks Book - system acquires lock and creates booking",
        "visualization": "```\n                    BEGIN TRANSACTION\n                           \u2502\n                           \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502  SELECT * FROM room_availability      \u2502\n        \u2502  WHERE room_id='R101'                 \u2502\n        \u2502  AND date BETWEEN 'Jun15' AND 'Jun17'\u2502\n        \u2502  FOR UPDATE NOWAIT;                   \u2502 \u25c0\u2500\u2500 Pessimistic Lock\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n          0 rows                    >0 rows\n          (available)               (conflict)\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n        INSERT INTO                ROLLBACK;\n        room_availability          RETURN ERROR;\n        (R101, Jun15, BK123),\n        (R101, Jun16, BK123),\n        (R101, Jun17, BK123);\n              \u2502\n              \u25bc\n        INSERT INTO bookings\n        (BK123, user, R101, ...);\n              \u2502\n              \u25bc\n        COMMIT TRANSACTION\n```",
        "key_point": "FOR UPDATE lock prevents concurrent inserts. UNIQUE constraint is backup protection."
      },
      {
        "step": 4,
        "description": "Payment authorization (async, outside main transaction)",
        "visualization": "```\n[Booking Service] \u2500\u2500authorize($750)\u2500\u2500\u25b6 [Payment Gateway]\n       \u2502                                      \u2502\n       \u2502   Booking status: PENDING            \u2502\n       \u2502   Room: HELD (availability rows)     \u2502\n       \u2502                                      \u25bc\n       \u2502                              [Stripe/Adyen]\n       \u2502                                      \u2502\n       \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500auth_success\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\nUPDATE bookings SET status='CONFIRMED'\nWHERE id='BK123';\n```",
        "key_point": "Payment is authorized (not captured) during booking. Capture happens at check-in."
      }
    ],
    "dry_run_table": "| Step | Operation | Database State | Result |\n|------|-----------|----------------|--------|\n| 1 | Search NYC Jun 15-18 | room_availability empty for R101 | R101 shown as available |\n| 2 | User A: BEGIN + FOR UPDATE R101 Jun15-17 | Lock acquired by User A | Lock held |\n| 3 | User B: BEGIN + FOR UPDATE R101 Jun16-18 | **BLOCKED** waiting for A's lock | Waiting... |\n| 4 | User A: INSERT availability rows | (R101,Jun15,BK_A), (R101,Jun16,BK_A), (R101,Jun17,BK_A) | 3 rows inserted |\n| 5 | User A: INSERT booking | BK_A created, status=PENDING | Booking created |\n| 6 | User A: COMMIT | Lock released | A SUCCESS \u2713 |\n| 7 | User B: Lock acquired (finally) | Sees A's availability rows | Conflict detected |\n| 8 | User B: ROLLBACK | No changes | B FAILED: Room not available |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'no double-bookings'**, I immediately think: this is NOT an application problem, it's a DATABASE constraint problem. Application checks are inherently racy.",
      "**When I see '10K bookings/sec'**, I think: we need horizontal scaling, but consistency is non-negotiable. This suggests sharding by hotel/region so locks are distributed.",
      "**When I see '100K searches/sec'**, I think: reads vastly exceed writes. Classic read/write separation pattern. Search can tolerate eventual consistency.",
      "**The key insight for availability**: Rather than computing 'is room X available?' by checking all bookings (O(bookings)), I'll denormalize into an availability table where each occupied night is a row. Checking availability becomes: does row exist? INSERT fails if yes.",
      "**For the race condition**: Two approaches - optimistic (try insert, handle constraint violation) or pessimistic (lock first, then insert). High contention on popular rooms \u2192 pessimistic is better to avoid retry storms.",
      "**Payment chicken-and-egg**: Can't charge without knowing room is available. Can't hold room without payment. Solution: two-phase - (1) Lock room with PENDING booking, (2) Authorize payment, (3) Confirm booking. Timeout releases lock if payment fails."
    ],
    "key_insight": "**The room_availability table with composite primary key (room_id, date) is the linchpin of the entire system.** By making each occupied night a row with unique constraint, the database itself becomes the arbiter of conflicts. No application-level race condition can cause double-booking because INSERT will simply fail if row exists. This moves consistency guarantees from 'hope the code is right' to 'mathematically impossible to violate'.",
    "why_this_works": "Database ACID guarantees + proper isolation level (SERIALIZABLE or SELECT FOR UPDATE) ensure that even with 1000 concurrent requests for the same room, exactly ONE will succeed in inserting the availability rows. All others will either (a) block waiting for lock, then see the rows and fail, or (b) get a constraint violation on insert. Either way, only one booking is created."
  },
  "approaches": [
    {
      "name": "Naive Approach: Application-Level Check",
      "description": "Check availability in application code, then insert booking if available",
      "pseudocode": "def create_booking(room_id, dates):\n    if database.count(availability, room_id, dates) == 0:\n        database.insert(booking)\n        database.insert(availability_rows)\n    else:\n        return 'Not available'",
      "time_complexity": "O(dates) for check + O(dates) for insert",
      "space_complexity": "O(1)",
      "pros": [
        "Simple to understand",
        "Easy to implement"
      ],
      "cons": [
        "**BROKEN**: Race condition between check and insert",
        "Two users can both see 'available' and both insert",
        "NEVER use this for bookings"
      ],
      "when_to_use": "NEVER for inventory/booking systems. Only for non-critical operations."
    },
    {
      "name": "Optimistic Locking: Insert and Handle Conflict",
      "description": "Try to insert availability rows, catch constraint violation",
      "pseudocode": "def create_booking(room_id, dates):\n    try:\n        database.insert(availability_rows)  # Has UNIQUE constraint\n        database.insert(booking)\n        database.commit()\n    except UniqueViolation:\n        database.rollback()\n        return 'Not available - conflict'",
      "time_complexity": "O(dates) for insert",
      "space_complexity": "O(dates)",
      "pros": [
        "No explicit locking overhead",
        "Works well with low contention",
        "Simple error handling"
      ],
      "cons": [
        "High contention = many failed attempts",
        "Wasted work on conflicts",
        "Partial insert cleanup needed"
      ],
      "when_to_use": "Low-contention scenarios, or combined with application-level pre-check as optimization"
    },
    {
      "name": "Optimal: Pessimistic Locking with SELECT FOR UPDATE",
      "description": "Acquire exclusive lock on the date range, then insert",
      "pseudocode": "def create_booking(room_id, dates):\n    BEGIN TRANSACTION\n    # Lock existing rows (or lock intention on empty range)\n    rows = SELECT * FROM room_availability\n           WHERE room_id = room_id AND date IN dates\n           FOR UPDATE NOWAIT\n    \n    if len(rows) > 0:\n        ROLLBACK\n        return 'Not available'\n    \n    INSERT INTO room_availability (...)\n    INSERT INTO bookings (...)\n    COMMIT\n    return 'Success'",
      "time_complexity": "O(dates) for lock + O(dates) for insert",
      "space_complexity": "O(dates)",
      "pros": [
        "**Guaranteed no double-booking**",
        "Clear conflict detection",
        "Works well under high contention",
        "Predictable behavior"
      ],
      "cons": [
        "Lock wait time under extreme contention",
        "Need to handle lock timeout",
        "Slightly more complex"
      ],
      "key_insight": "FOR UPDATE NOWAIT immediately fails if lock unavailable, preventing long waits. Combined with UNIQUE constraint as backup, this is bulletproof."
    },
    {
      "name": "Distributed: Redis Lock + DB Transaction",
      "description": "For multi-database or microservice scenarios",
      "pseudocode": "def create_booking(room_id, dates):\n    lock_key = f'booking_lock:{room_id}'\n    if not redis.setnx(lock_key, '1', ex=30):\n        return 'Room being booked, try again'\n    \n    try:\n        # Same DB transaction as above\n        result = db_create_booking(room_id, dates)\n    finally:\n        redis.delete(lock_key)\n    \n    return result",
      "time_complexity": "O(1) for Redis + O(dates) for DB",
      "space_complexity": "O(1) in Redis",
      "pros": [
        "Works across multiple services/databases",
        "Reduces DB lock contention",
        "Can implement queuing"
      ],
      "cons": [
        "Added Redis dependency",
        "Clock skew issues",
        "Must handle Redis failures gracefully"
      ],
      "when_to_use": "Very high scale (>50K bookings/sec), or when booking spans multiple databases/services"
    }
  ],
  "optimal_solution": {
    "name": "Pessimistic Locking with Denormalized Availability Table",
    "explanation_md": "## Approach\n\nThe optimal solution uses a **denormalized `room_availability` table** where each occupied night is a separate row, combined with **pessimistic locking** for the booking transaction.\n\n### Why Denormalized Availability?\n\nInstead of:\n```sql\n-- Checking ALL bookings for overlap (slow, complex)\nSELECT * FROM bookings \nWHERE room_id = ? \nAND NOT (check_out <= ? OR check_in >= ?)\n```\n\nWe have:\n```sql\n-- Simple existence check (fast, simple)\nSELECT * FROM room_availability\nWHERE room_id = ? AND date IN (?)\n```\n\n### Why Pessimistic Locking?\n\n1. **High contention** on popular rooms during peak booking times\n2. **Predictable latency** - either you get the lock or you don't\n3. **No retry storms** - optimistic would cause many failed attempts\n4. **NOWAIT option** - fail fast if lock unavailable\n\n### Transaction Flow\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    BOOKING TRANSACTION                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1. BEGIN TRANSACTION (SERIALIZABLE)                   \u2502\n\u2502  2. SELECT ... FOR UPDATE NOWAIT (acquire lock)        \u2502\n\u2502  3. IF rows exist \u2192 ROLLBACK, return conflict          \u2502\n\u2502  4. INSERT room_availability rows                      \u2502\n\u2502  5. INSERT booking with status=PENDING                 \u2502\n\u2502  6. COMMIT (release lock)                              \u2502\n\u2502  7. Async: authorize payment                           \u2502\n\u2502  8. UPDATE booking status=CONFIRMED                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### Why This is Bulletproof\n\n- **Level 1**: FOR UPDATE lock prevents concurrent transactions from proceeding\n- **Level 2**: UNIQUE constraint on (room_id, date) prevents insert even if lock fails\n- **Level 3**: Application logic checks row count before insert\n\nThree independent layers ensure NO double-booking is possible.",
    "data_structures": [
      {
        "structure": "room_availability table",
        "purpose": "Denormalized availability with composite PK (room_id, date) for O(1) conflict check"
      },
      {
        "structure": "bookings table",
        "purpose": "Booking records with status tracking (PENDING \u2192 CONFIRMED)"
      },
      {
        "structure": "Elasticsearch index",
        "purpose": "Fast search across millions of rooms, synced asynchronously"
      },
      {
        "structure": "Redis cache",
        "purpose": "Cache room details, rate limiting, session management"
      }
    ],
    "algorithm_steps": [
      "1. **Search**: Query Elasticsearch with filters, return paginated results (eventual consistency OK)",
      "2. **View Details**: Hit primary DB for real-time availability check before showing 'Book' button",
      "3. **Create Booking**: BEGIN transaction \u2192 FOR UPDATE lock \u2192 check availability \u2192 INSERT rows \u2192 COMMIT",
      "4. **Payment**: Authorize payment async after booking created with PENDING status",
      "5. **Confirm**: Update booking to CONFIRMED after payment success",
      "6. **Cancel**: Delete availability rows + update booking status in single transaction"
    ],
    "why_decimal": "All prices stored as **integer cents** (not floating point) to avoid precision issues. $250.00 stored as 25000. Display layer converts to dollars."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Hotel Booking System - Core Implementation",
    "Demonstrates: Concurrency handling, DB transactions, Search optimization",
    "\"\"\"",
    "from dataclasses import dataclass, field",
    "from datetime import date, timedelta",
    "from enum import Enum",
    "from typing import List, Optional, Dict, Any",
    "from decimal import Decimal",
    "import threading",
    "import uuid",
    "",
    "",
    "class BookingStatus(Enum):",
    "    PENDING = 'PENDING'",
    "    CONFIRMED = 'CONFIRMED'",
    "    CANCELLED = 'CANCELLED'",
    "    COMPLETED = 'COMPLETED'",
    "",
    "",
    "@dataclass",
    "class Hotel:",
    "    id: str",
    "    name: str",
    "    city: str",
    "    rating: float",
    "    amenities: List[str] = field(default_factory=list)",
    "",
    "",
    "@dataclass",
    "class Room:",
    "    id: str",
    "    hotel_id: str",
    "    room_type: str",
    "    capacity: int",
    "    price_cents: int  # Store as cents to avoid float issues",
    "    amenities: List[str] = field(default_factory=list)",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    id: str",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    status: BookingStatus",
    "    total_price_cents: int",
    "",
    "",
    "@dataclass",
    "class SearchRequest:",
    "    location: str",
    "    check_in: date",
    "    check_out: date",
    "    guests: int",
    "    price_max: Optional[int] = None",
    "",
    "",
    "@dataclass",
    "class SearchResponse:",
    "    rooms: List[Dict[str, Any]]",
    "    total_results: int",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    idempotency_key: str  # Critical for safe retries",
    "",
    "",
    "@dataclass",
    "class BookingResponse:",
    "    status: str",
    "    booking_id: Optional[str] = None",
    "    total_price: Optional[float] = None",
    "    error: Optional[str] = None",
    "    message: Optional[str] = None",
    "",
    "",
    "class HotelBookingSystem:",
    "    \"\"\"",
    "    Core booking system with concurrency-safe operations.",
    "    In production: hotels/rooms in DB, availability with row-level locks.",
    "    This demo uses in-memory structures with threading locks.",
    "    \"\"\"",
    "",
    "    def __init__(self):",
    "        # In-memory storage (production: PostgreSQL)",
    "        self.hotels: Dict[str, Hotel] = {}",
    "        self.rooms: Dict[str, Room] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        ",
    "        # KEY: Availability keyed by (room_id, date) - mirrors DB UNIQUE constraint",
    "        # Value is booking_id that owns this date",
    "        self.availability: Dict[tuple, str] = {}",
    "        ",
    "        # Idempotency tracking",
    "        self.processed_keys: Dict[str, str] = {}  # idempotency_key -> booking_id",
    "        ",
    "        # Lock per room for pessimistic locking simulation",
    "        self.room_locks: Dict[str, threading.Lock] = {}",
    "        self.global_lock = threading.Lock()  # For creating new room locks",
    "",
    "    def _get_room_lock(self, room_id: str) -> threading.Lock:",
    "        \"\"\"Get or create lock for a room (simulates row-level locking).\"\"\"",
    "        if room_id not in self.room_locks:",
    "            with self.global_lock:",
    "                if room_id not in self.room_locks:",
    "                    self.room_locks[room_id] = threading.Lock()",
    "        return self.room_locks[room_id]",
    "",
    "    def _get_date_range(self, check_in: date, check_out: date) -> List[date]:",
    "        \"\"\"Generate list of nights (check_out date is NOT included - that's checkout morning).\"\"\"",
    "        nights = []",
    "        current = check_in",
    "        while current < check_out:",
    "            nights.append(current)",
    "            current += timedelta(days=1)",
    "        return nights",
    "",
    "    def add_hotel(self, hotel: Hotel) -> None:",
    "        \"\"\"Add hotel to system.\"\"\"",
    "        self.hotels[hotel.id] = hotel",
    "",
    "    def add_room(self, room: Room) -> None:",
    "        \"\"\"Add room to hotel.\"\"\"",
    "        self.rooms[room.id] = room",
    "",
    "    def searchRooms(self, request: SearchRequest) -> SearchResponse:",
    "        \"\"\"",
    "        Search for available rooms. In production: hits Elasticsearch.",
    "        Returns rooms available for ALL nights in the date range.",
    "        \"\"\"",
    "        available_rooms = []",
    "        nights = self._get_date_range(request.check_in, request.check_out)",
    "        ",
    "        for room in self.rooms.values():",
    "            hotel = self.hotels.get(room.hotel_id)",
    "            if not hotel or hotel.city.lower() != request.location.lower():",
    "                continue",
    "            if room.capacity < request.guests:",
    "                continue",
    "            if request.price_max and room.price_cents > request.price_max * 100:",
    "                continue",
    "            ",
    "            # Check availability for all nights",
    "            is_available = all(",
    "                (room.id, night) not in self.availability",
    "                for night in nights",
    "            )",
    "            ",
    "            if is_available:",
    "                total_cents = room.price_cents * len(nights)",
    "                available_rooms.append({",
    "                    'id': room.id,",
    "                    'hotel': hotel.name,",
    "                    'type': room.room_type,",
    "                    'price_per_night': room.price_cents / 100,",
    "                    'total_price': total_cents / 100,",
    "                    'capacity': room.capacity,",
    "                })",
    "        ",
    "        return SearchResponse(rooms=available_rooms, total_results=len(available_rooms))",
    "",
    "    def getRoomDetails(self, room_id: str, check_in: date, check_out: date) -> Optional[Dict]:",
    "        \"\"\"Get room details with real-time availability check.\"\"\"",
    "        room = self.rooms.get(room_id)",
    "        if not room:",
    "            return None",
    "        ",
    "        hotel = self.hotels.get(room.hotel_id)",
    "        nights = self._get_date_range(check_in, check_out)",
    "        ",
    "        # Real-time availability check (hits primary DB in production)",
    "        is_available = all(",
    "            (room_id, night) not in self.availability",
    "            for night in nights",
    "        )",
    "        ",
    "        return {",
    "            'id': room.id,",
    "            'hotel': hotel.name if hotel else 'Unknown',",
    "            'type': room.room_type,",
    "            'capacity': room.capacity,",
    "            'price_per_night': room.price_cents / 100,",
    "            'total_price': (room.price_cents * len(nights)) / 100,",
    "            'amenities': room.amenities,",
    "            'available': is_available,",
    "        }",
    "",
    "    def createBooking(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Create booking with concurrency protection.",
    "        This is the CRITICAL method - must prevent double-bookings.",
    "        ",
    "        Production implementation:",
    "        - BEGIN TRANSACTION",
    "        - SELECT ... FOR UPDATE NOWAIT on room_availability",
    "        - Check if any rows returned (conflict)",
    "        - INSERT availability rows",
    "        - INSERT booking",
    "        - COMMIT",
    "        \"\"\"",
    "        # Idempotency check - return same result for duplicate requests",
    "        if request.idempotency_key in self.processed_keys:",
    "            existing_id = self.processed_keys[request.idempotency_key]",
    "            existing = self.bookings.get(existing_id)",
    "            if existing:",
    "                return BookingResponse(",
    "                    status='CONFIRMED',",
    "                    booking_id=existing_id,",
    "                    total_price=existing.total_price_cents / 100",
    "                )",
    "        ",
    "        room = self.rooms.get(request.room_id)",
    "        if not room:",
    "            return BookingResponse(status='FAILED', error='ROOM_NOT_FOUND')",
    "        ",
    "        nights = self._get_date_range(request.check_in, request.check_out)",
    "        if not nights:",
    "            return BookingResponse(status='FAILED', error='INVALID_DATES')",
    "        ",
    "        # CRITICAL: Acquire lock before checking/modifying availability",
    "        # This simulates SELECT ... FOR UPDATE in database",
    "        room_lock = self._get_room_lock(request.room_id)",
    "        ",
    "        # Use NOWAIT behavior - fail immediately if locked",
    "        acquired = room_lock.acquire(blocking=False)",
    "        if not acquired:",
    "            return BookingResponse(",
    "                status='FAILED',",
    "                error='ROOM_BUSY',",
    "                message='Room is being booked by another user. Please retry.'",
    "            )",
    "        ",
    "        try:",
    "            # Check availability (within lock - guaranteed consistent)",
    "            conflicting_dates = []",
    "            for night in nights:",
    "                if (request.room_id, night) in self.availability:",
    "                    conflicting_dates.append(night)",
    "            ",
    "            if conflicting_dates:",
    "                return BookingResponse(",
    "                    status='FAILED',",
    "                    error='ROOM_NOT_AVAILABLE',",
    "                    message=f'Room not available for: {conflicting_dates[0]}'",
    "                )",
    "            ",
    "            # All clear - create booking",
    "            booking_id = f'BK_{uuid.uuid4().hex[:8].upper()}'",
    "            total_cents = room.price_cents * len(nights)",
    "            ",
    "            # Insert availability rows (simulates DB INSERT)",
    "            for night in nights:",
    "                self.availability[(request.room_id, night)] = booking_id",
    "            ",
    "            # Create booking record",
    "            booking = Booking(",
    "                id=booking_id,",
    "                user_id=request.user_id,",
    "                room_id=request.room_id,",
    "                check_in=request.check_in,",
    "                check_out=request.check_out,",
    "                status=BookingStatus.CONFIRMED,",
    "                total_price_cents=total_cents,",
    "            )",
    "            self.bookings[booking_id] = booking",
    "            ",
    "            # Track idempotency",
    "            self.processed_keys[request.idempotency_key] = booking_id",
    "            ",
    "            return BookingResponse(",
    "                status='CONFIRMED',",
    "                booking_id=booking_id,",
    "                total_price=total_cents / 100",
    "            )",
    "        ",
    "        finally:",
    "            room_lock.release()  # Always release lock",
    "",
    "    def getBooking(self, booking_id: str) -> Optional[Booking]:",
    "        \"\"\"Retrieve booking details.\"\"\"",
    "        return self.bookings.get(booking_id)",
    "",
    "    def cancelBooking(self, booking_id: str, user_id: str) -> BookingResponse:",
    "        \"\"\"",
    "        Cancel booking and free up availability.",
    "        Must be atomic - release all dates together.",
    "        \"\"\"",
    "        booking = self.bookings.get(booking_id)",
    "        if not booking:",
    "            return BookingResponse(status='FAILED', error='BOOKING_NOT_FOUND')",
    "        ",
    "        if booking.user_id != user_id:",
    "            return BookingResponse(status='FAILED', error='UNAUTHORIZED')",
    "        ",
    "        if booking.status == BookingStatus.CANCELLED:",
    "            return BookingResponse(status='ALREADY_CANCELLED', booking_id=booking_id)",
    "        ",
    "        room_lock = self._get_room_lock(booking.room_id)",
    "        ",
    "        with room_lock:",
    "            # Remove availability rows",
    "            nights = self._get_date_range(booking.check_in, booking.check_out)",
    "            for night in nights:",
    "                key = (booking.room_id, night)",
    "                if key in self.availability and self.availability[key] == booking_id:",
    "                    del self.availability[key]",
    "            ",
    "            # Update booking status",
    "            booking.status = BookingStatus.CANCELLED",
    "        ",
    "        return BookingResponse(",
    "            status='CANCELLED',",
    "            booking_id=booking_id,",
    "            message='Booking cancelled. Refund will be processed within 5-7 days.'",
    "        )",
    "",
    "",
    "def demo_concurrent_booking():",
    "    \"\"\"Demonstrate race condition handling with concurrent bookings.\"\"\"",
    "    import concurrent.futures",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('DEMO: Concurrent Booking (Race Condition Test)')",
    "    print('=' * 60)",
    "    ",
    "    system = HotelBookingSystem()",
    "    ",
    "    # Setup",
    "    system.add_hotel(Hotel('H1', 'Grand Hotel', 'New York', 4.5))",
    "    system.add_room(Room('R101', 'H1', 'Deluxe King', 2, 25000))",
    "    ",
    "    # Simulate 5 users trying to book same room same dates",
    "    check_in = date(2024, 6, 15)",
    "    check_out = date(2024, 6, 18)",
    "    ",
    "    def attempt_booking(user_id: str):",
    "        request = BookingRequest(",
    "            user_id=user_id,",
    "            room_id='R101',",
    "            check_in=check_in,",
    "            check_out=check_out,",
    "            idempotency_key=f'key_{user_id}_{check_in}'",
    "        )",
    "        return (user_id, system.createBooking(request))",
    "    ",
    "    # Run concurrently",
    "    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:",
    "        futures = [executor.submit(attempt_booking, f'USER_{i}') for i in range(5)]",
    "        results = [f.result() for f in concurrent.futures.as_completed(futures)]",
    "    ",
    "    # Analyze results",
    "    successes = [(u, r) for u, r in results if r.status == 'CONFIRMED']",
    "    failures = [(u, r) for u, r in results if r.status == 'FAILED']",
    "    ",
    "    print(f'\\nResults: {len(successes)} success, {len(failures)} failures')",
    "    ",
    "    if successes:",
    "        user, resp = successes[0]",
    "        print(f'  \u2713 {user}: Booking {resp.booking_id} confirmed (${resp.total_price})')",
    "    ",
    "    for user, resp in failures:",
    "        print(f'  \u2717 {user}: {resp.error}')",
    "    ",
    "    # Verify: exactly one booking created",
    "    assert len(successes) == 1, 'ERROR: Multiple bookings created!'",
    "    print('\\n\u2713 Race condition handled correctly - only 1 booking created')",
    "",
    "",
    "def demo_overlap_detection():",
    "    \"\"\"Demonstrate partial date overlap detection.\"\"\"",
    "    print('\\n' + '=' * 60)",
    "    print('DEMO: Partial Date Overlap Detection')",
    "    print('=' * 60)",
    "    ",
    "    system = HotelBookingSystem()",
    "    system.add_hotel(Hotel('H1', 'Beach Resort', 'Miami', 4.2))",
    "    system.add_room(Room('R201', 'H1', 'Ocean View', 2, 30000))",
    "    ",
    "    # First booking: Sep 5-8",
    "    req1 = BookingRequest('USER_A', 'R201', date(2024, 9, 5), date(2024, 9, 8), 'key_A')",
    "    resp1 = system.createBooking(req1)",
    "    print(f'\\nBooking 1 (Sep 5-8): {resp1.status}')",
    "    ",
    "    # Overlapping attempts",
    "    test_cases = [",
    "        ('Sep 4-6 (partial start)', date(2024, 9, 4), date(2024, 9, 6)),",
    "        ('Sep 7-10 (partial end)', date(2024, 9, 7), date(2024, 9, 10)),",
    "        ('Sep 6-7 (fully inside)', date(2024, 9, 6), date(2024, 9, 7)),",
    "        ('Sep 8-10 (starts on checkout)', date(2024, 9, 8), date(2024, 9, 10)),  # Should work!",
    "    ]",
    "    ",
    "    for name, check_in, check_out in test_cases:",
    "        req = BookingRequest('USER_B', 'R201', check_in, check_out, f'key_B_{check_in}')",
    "        resp = system.createBooking(req)",
    "        status = '\u2713 OK' if resp.status == 'CONFIRMED' else f'\u2717 {resp.error}'",
    "        print(f'  {name}: {status}')",
    "    ",
    "    print('\\n\u2713 Note: Sep 8-10 works because checkout is morning, checkin is afternoon')",
    "",
    "",
    "def demo_search_and_book():",
    "    \"\"\"Complete flow: search -> view -> book -> cancel.\"\"\"",
    "    print('\\n' + '=' * 60)",
    "    print('DEMO: Complete Booking Flow')",
    "    print('=' * 60)",
    "    ",
    "    system = HotelBookingSystem()",
    "    ",
    "    # Setup multiple hotels/rooms",
    "    system.add_hotel(Hotel('H1', 'Times Square Hotel', 'New York', 4.5, ['WiFi', 'Pool']))",
    "    system.add_hotel(Hotel('H2', 'Central Park Inn', 'New York', 4.2, ['WiFi']))",
    "    system.add_room(Room('R1', 'H1', 'Standard', 2, 20000, ['WiFi', 'TV']))",
    "    system.add_room(Room('R2', 'H1', 'Deluxe', 4, 35000, ['WiFi', 'TV', 'Minibar']))",
    "    system.add_room(Room('R3', 'H2', 'Suite', 2, 28000, ['WiFi', 'Kitchen']))",
    "    ",
    "    # Step 1: Search",
    "    print('\\n1. SEARCH: NYC, Jun 20-23, 2 guests, max $300/night')",
    "    search_req = SearchRequest('New York', date(2024, 6, 20), date(2024, 6, 23), 2, 300)",
    "    search_resp = system.searchRooms(search_req)",
    "    print(f'   Found {search_resp.total_results} rooms:')",
    "    for room in search_resp.rooms:",
    "        print(f'     - {room[\"hotel\"]}: {room[\"type\"]} @ ${room[\"price_per_night\"]}/night')",
    "    ",
    "    # Step 2: View details",
    "    print('\\n2. VIEW DETAILS: Room R1')",
    "    details = system.getRoomDetails('R1', date(2024, 6, 20), date(2024, 6, 23))",
    "    print(f'   {details[\"hotel\"]} - {details[\"type\"]}')",
    "    print(f'   ${details[\"price_per_night\"]}/night \u00d7 3 nights = ${details[\"total_price\"]}')",
    "    print(f'   Available: {details[\"available\"]}')",
    "    ",
    "    # Step 3: Book",
    "    print('\\n3. CREATE BOOKING')",
    "    book_req = BookingRequest('USER_123', 'R1', date(2024, 6, 20), date(2024, 6, 23), 'order_abc')",
    "    book_resp = system.createBooking(book_req)",
    "    print(f'   Status: {book_resp.status}')",
    "    print(f'   Booking ID: {book_resp.booking_id}')",
    "    print(f'   Total: ${book_resp.total_price}')",
    "    ",
    "    # Step 4: Verify room no longer in search results",
    "    print('\\n4. VERIFY: Search again (R1 should be gone)')",
    "    search_resp2 = system.searchRooms(search_req)",
    "    room_ids = [r['id'] for r in search_resp2.rooms]",
    "    print(f'   Available rooms: {room_ids}')",
    "    assert 'R1' not in room_ids, 'ERROR: Booked room still showing!'",
    "    print('   \u2713 R1 correctly removed from search results')",
    "    ",
    "    # Step 5: Cancel",
    "    print('\\n5. CANCEL BOOKING')",
    "    cancel_resp = system.cancelBooking(book_resp.booking_id, 'USER_123')",
    "    print(f'   Status: {cancel_resp.status}')",
    "    print(f'   {cancel_resp.message}')",
    "    ",
    "    # Step 6: Verify room available again",
    "    print('\\n6. VERIFY: Search after cancel (R1 should be back)')",
    "    search_resp3 = system.searchRooms(search_req)",
    "    room_ids = [r['id'] for r in search_resp3.rooms]",
    "    print(f'   Available rooms: {room_ids}')",
    "    assert 'R1' in room_ids, 'ERROR: Cancelled room not available!'",
    "    print('   \u2713 R1 correctly available after cancellation')",
    "",
    "",
    "if __name__ == '__main__':",
    "    demo_search_and_book()",
    "    demo_overlap_detection()",
    "    demo_concurrent_booking()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.time.LocalDate;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.locks.*;",
    "import java.util.stream.*;",
    "",
    "/**",
    " * Hotel Booking System - Java Implementation",
    " * Demonstrates: Thread-safe booking, pessimistic locking, race condition handling",
    " */",
    "public class HotelBookingSystem {",
    "",
    "    // Domain Models",
    "    enum BookingStatus { PENDING, CONFIRMED, CANCELLED, COMPLETED }",
    "",
    "    record Hotel(String id, String name, String city, double rating) {}",
    "    ",
    "    record Room(String id, String hotelId, String type, int capacity, int priceCents) {}",
    "    ",
    "    record Booking(",
    "        String id, String userId, String roomId,",
    "        LocalDate checkIn, LocalDate checkOut,",
    "        BookingStatus status, int totalPriceCents",
    "    ) {}",
    "",
    "    record SearchRequest(String location, LocalDate checkIn, LocalDate checkOut, ",
    "                         int guests, Integer priceMaxCents) {}",
    "    ",
    "    record SearchResponse(List<Map<String, Object>> rooms, int totalResults) {}",
    "    ",
    "    record BookingRequest(String userId, String roomId, LocalDate checkIn, ",
    "                          LocalDate checkOut, String idempotencyKey) {}",
    "    ",
    "    record BookingResponse(String status, String bookingId, BigDecimal totalPrice,",
    "                           String error, String message) {",
    "        static BookingResponse success(String bookingId, BigDecimal price) {",
    "            return new BookingResponse(\"CONFIRMED\", bookingId, price, null, null);",
    "        }",
    "        static BookingResponse failure(String error, String message) {",
    "            return new BookingResponse(\"FAILED\", null, null, error, message);",
    "        }",
    "    }",
    "",
    "    // Storage (production: PostgreSQL with proper transactions)",
    "    private final Map<String, Hotel> hotels = new ConcurrentHashMap<>();",
    "    private final Map<String, Room> rooms = new ConcurrentHashMap<>();",
    "    private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    ",
    "    // Critical: availability keyed by \"roomId:date\" - mirrors DB UNIQUE constraint",
    "    private final Map<String, String> availability = new ConcurrentHashMap<>();",
    "    ",
    "    // Idempotency tracking",
    "    private final Map<String, String> processedKeys = new ConcurrentHashMap<>();",
    "    ",
    "    // Per-room locks (simulates SELECT FOR UPDATE)",
    "    private final ConcurrentHashMap<String, ReentrantLock> roomLocks = new ConcurrentHashMap<>();",
    "",
    "    private ReentrantLock getRoomLock(String roomId) {",
    "        return roomLocks.computeIfAbsent(roomId, k -> new ReentrantLock());",
    "    }",
    "",
    "    private List<LocalDate> getDateRange(LocalDate checkIn, LocalDate checkOut) {",
    "        return checkIn.datesUntil(checkOut).toList();",
    "    }",
    "",
    "    private String availKey(String roomId, LocalDate date) {",
    "        return roomId + \":\" + date;",
    "    }",
    "",
    "    public void addHotel(Hotel hotel) { hotels.put(hotel.id(), hotel); }",
    "    public void addRoom(Room room) { rooms.put(room.id(), room); }",
    "",
    "    /**",
    "     * Search for available rooms. Production: Elasticsearch with async sync.",
    "     */",
    "    public SearchResponse searchRooms(SearchRequest req) {",
    "        List<LocalDate> nights = getDateRange(req.checkIn(), req.checkOut());",
    "        ",
    "        List<Map<String, Object>> results = rooms.values().stream()",
    "            .filter(room -> {",
    "                Hotel hotel = hotels.get(room.hotelId());",
    "                if (hotel == null) return false;",
    "                if (!hotel.city().equalsIgnoreCase(req.location())) return false;",
    "                if (room.capacity() < req.guests()) return false;",
    "                if (req.priceMaxCents() != null && room.priceCents() > req.priceMaxCents()) return false;",
    "                // Check all nights available",
    "                return nights.stream().noneMatch(d -> availability.containsKey(availKey(room.id(), d)));",
    "            })",
    "            .map(room -> {",
    "                Hotel hotel = hotels.get(room.hotelId());",
    "                int totalCents = room.priceCents() * nights.size();",
    "                return Map.<String, Object>of(",
    "                    \"id\", room.id(),",
    "                    \"hotel\", hotel.name(),",
    "                    \"type\", room.type(),",
    "                    \"pricePerNight\", room.priceCents() / 100.0,",
    "                    \"totalPrice\", totalCents / 100.0",
    "                );",
    "            })",
    "            .toList();",
    "        ",
    "        return new SearchResponse(results, results.size());",
    "    }",
    "",
    "    /**",
    "     * Create booking with concurrency protection.",
    "     * CRITICAL: Prevents double-booking through pessimistic locking.",
    "     */",
    "    public BookingResponse createBooking(BookingRequest req) {",
    "        // Idempotency check",
    "        if (processedKeys.containsKey(req.idempotencyKey())) {",
    "            String existingId = processedKeys.get(req.idempotencyKey());",
    "            Booking existing = bookings.get(existingId);",
    "            if (existing != null) {",
    "                return BookingResponse.success(existingId, ",
    "                    BigDecimal.valueOf(existing.totalPriceCents() / 100.0));",
    "            }",
    "        }",
    "        ",
    "        Room room = rooms.get(req.roomId());",
    "        if (room == null) {",
    "            return BookingResponse.failure(\"ROOM_NOT_FOUND\", \"Room does not exist\");",
    "        }",
    "        ",
    "        List<LocalDate> nights = getDateRange(req.checkIn(), req.checkOut());",
    "        if (nights.isEmpty()) {",
    "            return BookingResponse.failure(\"INVALID_DATES\", \"Invalid date range\");",
    "        }",
    "        ",
    "        // CRITICAL: Acquire room lock (simulates SELECT FOR UPDATE)",
    "        ReentrantLock lock = getRoomLock(req.roomId());",
    "        ",
    "        // NOWAIT behavior - fail immediately if locked",
    "        if (!lock.tryLock()) {",
    "            return BookingResponse.failure(\"ROOM_BUSY\", \"Room being booked, please retry\");",
    "        }",
    "        ",
    "        try {",
    "            // Check availability within lock",
    "            Optional<LocalDate> conflict = nights.stream()",
    "                .filter(d -> availability.containsKey(availKey(req.roomId(), d)))",
    "                .findFirst();",
    "            ",
    "            if (conflict.isPresent()) {",
    "                return BookingResponse.failure(\"ROOM_NOT_AVAILABLE\", ",
    "                    \"Room not available for: \" + conflict.get());",
    "            }",
    "            ",
    "            // Create booking",
    "            String bookingId = \"BK_\" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();",
    "            int totalCents = room.priceCents() * nights.size();",
    "            ",
    "            // Insert availability rows",
    "            for (LocalDate night : nights) {",
    "                availability.put(availKey(req.roomId(), night), bookingId);",
    "            }",
    "            ",
    "            // Create booking record",
    "            Booking booking = new Booking(",
    "                bookingId, req.userId(), req.roomId(),",
    "                req.checkIn(), req.checkOut(),",
    "                BookingStatus.CONFIRMED, totalCents",
    "            );",
    "            bookings.put(bookingId, booking);",
    "            processedKeys.put(req.idempotencyKey(), bookingId);",
    "            ",
    "            return BookingResponse.success(bookingId, BigDecimal.valueOf(totalCents / 100.0));",
    "            ",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    /**",
    "     * Cancel booking and free availability atomically.",
    "     */",
    "    public BookingResponse cancelBooking(String bookingId, String userId) {",
    "        Booking booking = bookings.get(bookingId);",
    "        if (booking == null) {",
    "            return BookingResponse.failure(\"BOOKING_NOT_FOUND\", \"Booking does not exist\");",
    "        }",
    "        if (!booking.userId().equals(userId)) {",
    "            return BookingResponse.failure(\"UNAUTHORIZED\", \"Not your booking\");",
    "        }",
    "        ",
    "        ReentrantLock lock = getRoomLock(booking.roomId());",
    "        lock.lock();",
    "        try {",
    "            // Remove availability rows",
    "            getDateRange(booking.checkIn(), booking.checkOut())",
    "                .forEach(d -> availability.remove(availKey(booking.roomId(), d)));",
    "            ",
    "            // Update status (in real system, would create new record)",
    "            Booking cancelled = new Booking(",
    "                booking.id(), booking.userId(), booking.roomId(),",
    "                booking.checkIn(), booking.checkOut(),",
    "                BookingStatus.CANCELLED, booking.totalPriceCents()",
    "            );",
    "            bookings.put(bookingId, cancelled);",
    "            ",
    "            return new BookingResponse(\"CANCELLED\", bookingId, null, null, ",
    "                \"Refund will be processed within 5-7 days\");",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    // Demo methods",
    "    public static void main(String[] args) throws Exception {",
    "        demoConcurrentBooking();",
    "    }",
    "",
    "    static void demoConcurrentBooking() throws Exception {",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"DEMO: Concurrent Booking (Race Condition Test)\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        HotelBookingSystem system = new HotelBookingSystem();",
    "        system.addHotel(new Hotel(\"H1\", \"Grand Hotel\", \"New York\", 4.5));",
    "        system.addRoom(new Room(\"R101\", \"H1\", \"Deluxe\", 2, 25000));",
    "        ",
    "        LocalDate checkIn = LocalDate.of(2024, 6, 15);",
    "        LocalDate checkOut = LocalDate.of(2024, 6, 18);",
    "        ",
    "        ExecutorService executor = Executors.newFixedThreadPool(5);",
    "        List<Future<BookingResponse>> futures = new ArrayList<>();",
    "        ",
    "        // 5 users try to book simultaneously",
    "        for (int i = 0; i < 5; i++) {",
    "            final int userId = i;",
    "            futures.add(executor.submit(() -> {",
    "                BookingRequest req = new BookingRequest(",
    "                    \"USER_\" + userId, \"R101\", checkIn, checkOut, \"key_\" + userId",
    "                );",
    "                return system.createBooking(req);",
    "            }));",
    "        }",
    "        ",
    "        int successes = 0, failures = 0;",
    "        for (Future<BookingResponse> f : futures) {",
    "            BookingResponse resp = f.get();",
    "            if (\"CONFIRMED\".equals(resp.status())) {",
    "                System.out.println(\"  \u2713 Booking \" + resp.bookingId() + \" confirmed\");",
    "                successes++;",
    "            } else {",
    "                System.out.println(\"  \u2717 Failed: \" + resp.error());",
    "                failures++;",
    "            }",
    "        }",
    "        ",
    "        executor.shutdown();",
    "        System.out.println(\"\\nResults: \" + successes + \" success, \" + failures + \" failures\");",
    "        assert successes == 1 : \"ERROR: Multiple bookings!\";",
    "        System.out.println(\"\u2713 Race condition handled correctly\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "section": "Imports and Enums",
      "explanation": "We import `threading` for locks, `uuid` for ID generation. `BookingStatus` enum defines the booking lifecycle: PENDING \u2192 CONFIRMED | CANCELLED."
    },
    {
      "lines": "17-60",
      "section": "Data Classes (Domain Models)",
      "explanation": "Using `@dataclass` for clean, immutable-ish domain objects. Note `price_cents: int` - we store money as cents to avoid floating point precision issues. `SearchRequest` includes filters that would map to Elasticsearch queries in production."
    },
    {
      "lines": "62-100",
      "section": "HotelBookingSystem.__init__",
      "explanation": "**Key insight**: `self.availability: Dict[tuple, str]` uses composite key `(room_id, date)` - this mirrors the database composite primary key that prevents double-bookings. Each room has its own lock, simulating row-level database locks."
    },
    {
      "lines": "102-115",
      "section": "_get_room_lock and _get_date_range",
      "explanation": "`_get_room_lock` uses double-checked locking pattern. `_get_date_range` generates the nights for a stay - note check_out date is NOT included (guest checks out that morning)."
    },
    {
      "lines": "125-160",
      "section": "searchRooms",
      "explanation": "Search is read-only, no locking needed. In production, this hits Elasticsearch, not the primary DB. We filter by location, capacity, price, AND check availability for ALL nights in range."
    },
    {
      "lines": "175-250",
      "section": "createBooking - THE CRITICAL METHOD",
      "explanation": "**This is where double-bookings are prevented.** (1) Check idempotency key for duplicate requests. (2) Acquire room lock with `blocking=False` (NOWAIT). (3) Check availability INSIDE lock. (4) Insert availability rows. (5) Create booking. (6) Release lock in `finally`. The lock ensures atomic check-then-insert."
    },
    {
      "lines": "252-275",
      "section": "cancelBooking",
      "explanation": "Cancellation also needs the lock to prevent race with concurrent booking. Removes all availability rows atomically, then updates booking status. In production, refund would be async event."
    },
    {
      "lines": "278-320",
      "section": "demo_concurrent_booking",
      "explanation": "**Proof that our locking works**: 5 threads try to book the same room simultaneously. Using `ThreadPoolExecutor` with 5 workers. Exactly 1 succeeds, 4 fail. This is the correct behavior - no double-booking!"
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test search with no rooms \u2192 empty result. 2. Add rooms, test search filters one by one. 3. Test single booking success. 4. Test booking already-booked dates \u2192 fail. 5. Test concurrent bookings with threads.",
    "what_to_print_or_assert": [
      "print(f'Availability before: {len(self.availability)}')",
      "print(f'Lock acquired: {acquired}')",
      "assert len([r for r in results if r.status == 'CONFIRMED']) == 1",
      "print(f'Conflicting dates: {conflicting_dates}')"
    ],
    "common_failure_modes": [
      "**Not acquiring lock**: Forgot to lock before checking availability",
      "**Lock not released**: Missing `finally` block \u2192 deadlock",
      "**Wrong date range**: Including check_out date in occupied nights",
      "**Stale read**: Checking availability outside of lock \u2192 race condition"
    ],
    "how_to_fix_fast": "If you see double-bookings: (1) Check if lock is acquired before availability check. (2) Ensure lock covers BOTH check AND insert. (3) Print thread ID to verify different threads. (4) Add assertion after each booking that availability rows exist."
  },
  "complexity_analysis": {
    "time": {
      "searchRooms": {
        "complexity": "O(R \u00d7 D)",
        "explanation": "R = rooms, D = nights. For each room, check D dates. With Elasticsearch in production: O(D) after index lookup."
      },
      "createBooking": {
        "complexity": "O(D)",
        "explanation": "D = number of nights. Lock acquisition O(1), availability check O(D), insert O(D)."
      },
      "cancelBooking": {
        "complexity": "O(D)",
        "explanation": "Delete D availability rows."
      },
      "getRoomDetails": {
        "complexity": "O(D)",
        "explanation": "Check D dates for availability."
      },
      "overall": "All operations scale with number of nights, not total bookings."
    },
    "space": {
      "complexity": "O(H + R + B \u00d7 D_avg)",
      "breakdown": "- H = hotels\n- R = rooms\n- B = active bookings\n- D_avg = average nights per booking\n- availability table: O(B \u00d7 D_avg) - one row per booked night\n- In production with 365-day window: O(R \u00d7 365) max",
      "note": "Availability table is the space bottleneck. Consider archiving past dates or computing from bookings for historical queries."
    },
    "can_we_do_better": "For search: Use bitmap indices for availability (1 bit per room per day) = O(R/8) bytes per day. For booking: O(D) is optimal since we must reserve D nights. Could batch availability inserts for DB efficiency."
  },
  "dry_run": {
    "example": "User A books Room R101 Jun 15-18, then User B tries Jun 16-20 (overlap)",
    "trace_table": "| Step | Action | availability | Result |\n|------|--------|--------------|--------|\n| 0 | Initial | {} | - |\n| 1 | A: Lock R101 | {} | Lock acquired |\n| 2 | A: Check Jun15,16,17 | {} | All clear \u2713 |\n| 3 | A: Insert availability | {(R101,Jun15): BK_A, (R101,Jun16): BK_A, (R101,Jun17): BK_A} | 3 rows |\n| 4 | A: Create booking | ... | BK_A created |\n| 5 | A: Unlock R101 | - | Lock released |\n| 6 | B: Lock R101 | - | Lock acquired |\n| 7 | B: Check Jun16,17,18,19 | {(R101,Jun15): BK_A, ...} | Jun16,17 CONFLICT |\n| 8 | B: Unlock, return error | - | 'Room not available for Jun16' |",
    "final_answer": "User A: SUCCESS (BK_A confirmed). User B: FAILED (dates Jun 16, 17 already booked by A)"
  },
  "test_cases": [
    {
      "name": "Single booking success",
      "category": "Happy Path",
      "input": "Book R101 Jun 15-18",
      "expected": "CONFIRMED with booking ID",
      "explanation": "Basic booking when room is fully available"
    },
    {
      "name": "Exact same dates conflict",
      "category": "Concurrency",
      "input": "User A and B both try R101 Jun 15-18 simultaneously",
      "expected": "Exactly 1 CONFIRMED, 1 FAILED",
      "explanation": "Lock ensures only one succeeds"
    },
    {
      "name": "Partial overlap conflict",
      "category": "Edge Case",
      "input": "A books Jun 15-18, B tries Jun 17-20",
      "expected": "B FAILED: conflict on Jun 17",
      "explanation": "Even one overlapping night causes failure"
    },
    {
      "name": "Same-day turnover (allowed)",
      "category": "Edge Case",
      "input": "A books Jun 15-18, B books Jun 18-20",
      "expected": "Both CONFIRMED",
      "explanation": "Check-out morning allows same-day check-in"
    },
    {
      "name": "Idempotency - duplicate request",
      "category": "Resilience",
      "input": "Same idempotency_key sent twice",
      "expected": "Same booking ID returned both times",
      "explanation": "Prevents accidental double-booking from retries"
    },
    {
      "name": "Cancel then rebook",
      "category": "Flow",
      "input": "A books Jun 15-18, A cancels, B books Jun 15-18",
      "expected": "B CONFIRMED",
      "explanation": "Cancellation immediately frees inventory"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Application-level availability check without lock",
      "why_wrong": "Classic TOCTOU race: check shows available, but another thread books before your insert",
      "correct_approach": "Acquire lock BEFORE checking, hold through insert",
      "code_wrong": "if self.is_available(room_id, dates):  # No lock!\n    self.create_booking(...)  # Race condition!",
      "code_correct": "with self._get_room_lock(room_id):\n    if self.is_available(room_id, dates):\n        self.create_booking(...)"
    },
    {
      "mistake": "Including check-out date in blocked nights",
      "why_wrong": "Check-out is morning, check-in is afternoon. Same day should be allowed.",
      "correct_approach": "Date range is [check_in, check_out) - exclusive on end",
      "code_wrong": "nights = [check_in, ..., check_out]  # Wrong!",
      "code_correct": "nights = [d for d in range if d < check_out]  # Correct"
    },
    {
      "mistake": "Not handling lock acquisition failure (NOWAIT)",
      "why_wrong": "If lock is held, user waits indefinitely or times out ungracefully",
      "correct_approach": "Use try_lock with timeout, return clear 'busy' error",
      "code_wrong": "lock.acquire()  # Blocks forever",
      "code_correct": "if not lock.acquire(blocking=False):\n    return 'ROOM_BUSY, please retry'"
    },
    {
      "mistake": "Searching against primary database",
      "why_wrong": "100K searches/sec will overwhelm transactional DB",
      "correct_approach": "Search hits read-replica or Elasticsearch, booking hits primary",
      "code_wrong": "# Same DB for search and booking",
      "code_correct": "# Search \u2192 Elasticsearch (eventual consistent)\n# Booking \u2192 PostgreSQL (strongly consistent)"
    }
  ],
  "interview_tips": {
    "opening": "This is a great problem that tests distributed systems fundamentals. Before I dive in, let me clarify a few things about the requirements and constraints...",
    "clarifying_questions_to_ask": [
      "What's the expected ratio of searches to bookings? (This determines read/write optimization strategy)",
      "How critical is the 'no double-booking' requirement? (I assume it's absolute)",
      "Do we need to support multi-room bookings in a single transaction?",
      "What's our payment integration model? Pre-auth then capture, or charge on booking?",
      "Are there overbooking policies like airlines use?"
    ],
    "what_to_mention_proactively": [
      "I'll use database constraints (UNIQUE on room_id+date) as the ultimate safeguard against double-booking",
      "Search and booking have different consistency requirements - I'll use CQRS pattern",
      "I'll implement pessimistic locking for the booking flow given high contention",
      "Let me draw the data model first - it's the foundation of the solution"
    ],
    "communication_during_coding": [
      "I'm using composite key (room_id, date) to make conflicts detectable at DB level",
      "The lock here simulates SELECT FOR UPDATE in production PostgreSQL",
      "Notice I check availability INSIDE the lock - this prevents the race condition",
      "I'm using a finally block to ensure lock release even on exceptions"
    ],
    "if_stuck": [
      "Ask: What causes double-booking? \u2192 Two threads see 'available' and both insert",
      "Ask: How do databases prevent this? \u2192 UNIQUE constraints, transactions, locks",
      "Draw: Timeline showing race condition helps visualize the problem"
    ],
    "time_management": "0-10min: Clarify + draw high-level architecture | 10-25min: Data model + availability strategy | 25-40min: Booking flow with locking | 40-50min: Search optimization | 50-60min: Trade-offs and scaling"
  },
  "pattern_recognition": {
    "pattern_name": "Pessimistic Locking / Inventory Reservation",
    "indicators": [
      "Critical resource (room, seat, ticket) that cannot be double-sold",
      "High concurrent demand for same resource",
      "Need for strong consistency over availability"
    ],
    "similar_problems": [
      "**LC 253 - Meeting Rooms II**: Same overlap detection logic for date ranges",
      "**LC 731/732 - My Calendar**: Calendar booking with conflict detection",
      "**Ticket booking systems**: Concert tickets, flight seats - same inventory problem",
      "**Flash sales**: Limited inventory with massive concurrent demand"
    ],
    "template": "1. Denormalize availability for O(1) conflict check. 2. Use DB-level constraint as ultimate guard. 3. Pessimistic lock for high-contention resources. 4. Separate read path (eventual consistent) from write path (strongly consistent)."
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 will deep-dive into concurrent booking handling. Be prepared to discuss: (1) Different locking strategies (optimistic vs pessimistic), (2) Database isolation levels (READ COMMITTED vs SERIALIZABLE), (3) Distributed locks with Redis/Zookeeper for multi-instance deployment.",
    "part_3_hint": "Part 3 focuses on scaling to handle 100K+ searches/sec and holiday traffic spikes. Key topics: (1) Elasticsearch cluster design, (2) Database sharding by region/hotel, (3) Rate limiting and circuit breakers, (4) Queue-based booking with reservation holds.",
    "data_structure_evolution": "Part 1: In-memory maps + threading locks \u2192 Part 2: PostgreSQL with FOR UPDATE + UNIQUE constraints \u2192 Part 3: Sharded PostgreSQL + Redis distributed locks + Kafka event streaming"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. Hotel booking systems are interesting because they have very strict consistency requirements - a double-booking is unacceptable. Before I start designing, I'd like to understand a few things about scale and constraints...",
    "after_clarification": "Great, so to summarize: we need to handle 10K bookings/sec at peak with 99.99% availability, and double-bookings are never allowed. I'll approach this by first designing the data model with constraints that make double-booking impossible, then add the service layer. Let me draw the architecture...",
    "while_coding": [
      "I'm creating the availability table with composite primary key on room_id and date - this is the key to preventing double-bookings",
      "Here I'm acquiring the lock BEFORE checking availability - this is crucial for atomicity",
      "Notice the finally block ensures lock release even if there's an exception"
    ],
    "after_coding": "Let me trace through a concurrent booking scenario to verify this handles the race condition correctly...",
    "when_stuck_verbatim": "I'm thinking about how to handle the case where two users check availability at the same time... Let me think about what database guarantees we can leverage here...",
    "after_mistake": "Actually, I realize I need to check availability INSIDE the lock, not before acquiring it. Let me fix that - the order is crucial for correctness.",
    "before_moving_on": "This handles the core booking flow with concurrency protection. Time complexity is O(nights) for all operations, space is O(rooms \u00d7 365) for the availability table. Ready to discuss Part 2 - the deep dive into locking strategies?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Understanding of concurrency**: Can they identify the race condition? Do they know why app-level checks fail?",
      "**Database knowledge**: Do they mention transactions, isolation levels, constraints?",
      "**System design**: Do they separate concerns (search vs booking)? Do they consider scale?",
      "**Trade-off discussion**: Can they articulate why they chose pessimistic over optimistic locking?",
      "**Communication**: Do they explain their thought process? Do they draw diagrams?"
    ],
    "bonus_points": [
      "Drawing the race condition timeline before being asked",
      "Mentioning idempotency keys without prompting",
      "Discussing database constraint as the ultimate safeguard",
      "Bringing up CQRS pattern for read/write separation",
      "Considering payment failure scenarios and compensation"
    ],
    "red_flags": [
      "Thinking application-level if-check is sufficient",
      "Not considering concurrent requests at all",
      "Jumping to microservices without solving core problem first",
      "Ignoring the 'no double-booking' requirement",
      "Not being able to explain why their solution works"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize this is a concurrency problem, not just a CRUD problem. They draw the race condition scenario, explain WHY simple checks fail, and propose database-level guarantees. They discuss trade-offs between locking strategies based on contention levels, and they consider the read/write separation naturally. They treat the interviewer as a collaborator, checking assumptions and getting feedback on their approach."
  },
  "time_milestones": {
    "by_5_min": "Understand the problem is about preventing double-bookings. Ask clarifying questions about scale, payment model, and boundaries.",
    "by_10_min": "Draw high-level architecture showing search service, booking service, and database. Identify that search and booking have different consistency needs.",
    "by_20_min": "Design the data model. Explain room_availability table with composite primary key. Discuss how this prevents double-bookings at DB level.",
    "by_30_min": "Explain the booking transaction flow with locking. Draw the timeline showing how lock prevents race condition.",
    "by_40_min": "Discuss search optimization (Elasticsearch, caching). Show how search is eventually consistent but booking is strongly consistent.",
    "by_50_min": "Discuss trade-offs, scaling considerations, and be ready for follow-up questions.",
    "warning_signs": "If at 15 min you haven't identified the concurrency issue, you're missing the core problem. If at 30 min you don't have a data model, you're behind."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "If you realize your solution has a race condition, acknowledge it: 'Actually, I see a problem here - if two threads both pass the availability check before either inserts, we have a race condition. Let me fix that by adding locking...'",
    "when_you_dont_know_syntax": "For system design, syntax matters less. Say: 'The exact SQL syntax for SELECT FOR UPDATE varies by database, but the concept is to acquire an exclusive lock on the rows before reading them.'",
    "when_approach_is_wrong": "If you started with optimistic locking but realize contention is high: 'Actually, given the scale of 10K bookings/sec on potentially popular hotels, pessimistic locking might be better to avoid retry storms. Let me adjust...'",
    "when_completely_stuck": "Ask: 'I'm trying to figure out how to prevent two transactions from both seeing the room as available. Could you give me a hint about what database feature might help here?'",
    "when_running_out_of_time": "Prioritize the booking flow: 'I'm running low on time. Let me focus on explaining how the booking prevents double-bookings, and I can mention the search optimization verbally.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "For system design, AI can help with boilerplate code but the design decisions must be yours.",
    "what_to_do": [
      "Use AI to generate data classes quickly",
      "Use AI for SQL syntax you forgot",
      "Let it autocomplete obvious getter/setter code"
    ],
    "what_not_to_do": [
      "Don't ask AI 'how to prevent double booking' - that's the core problem YOU need to solve",
      "Don't accept architectural suggestions without understanding trade-offs",
      "Don't let AI generate the locking logic without verifying correctness"
    ],
    "how_to_demonstrate_understanding": "After AI generates code, explain: 'This lock.acquire(blocking=False) implements NOWAIT behavior - if someone else holds the lock, we fail fast instead of waiting.'",
    "expectation_adjustment": "With AI assistance, you should complete the full solution faster and have time for deeper trade-off discussions."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing the race condition timeline unprompted",
      "Mentioning that app-level checks are insufficient without being asked",
      "Discussing database isolation levels (SERIALIZABLE, REPEATABLE READ)",
      "Bringing up idempotency keys for safe retries",
      "Suggesting event-driven architecture for notifications and analytics",
      "Mentioning eventual consistency is OK for search, but not for booking"
    ],
    "subtle_signals_of_experience": [
      "Discussing real-world complications (payment timeouts, partial failures)",
      "Mentioning operational concerns (monitoring, alerting on booking failures)",
      "Suggesting reservation timeout patterns (hold for 10 min, then release)",
      "Talking about how to handle hotel operations (mark room out-of-service)",
      "Discussing database replication lag and its impact on stale reads"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Dismissing the concurrency problem as 'we'll handle that later'",
      "Not asking any clarifying questions",
      "Refusing to draw diagrams",
      "Getting defensive when interviewer points out a race condition"
    ],
    "technical": [
      "Suggesting only application-level availability checks",
      "Not mentioning database constraints or transactions",
      "Using eventual consistency for booking confirmations",
      "Suggesting to 'just serialize all requests' without understanding the scale implications"
    ],
    "communication": [
      "Jumping straight to microservices without solving core problem",
      "Using buzzwords without explaining them (saying 'use Kafka' without explaining why)",
      "Not explaining trade-offs between design choices"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I explain how double-bookings are prevented? (DB constraint + locking)",
      "Did I separate read path (search) from write path (booking)?",
      "Did I discuss the data model with composite primary key?",
      "Did I trace through a concurrent booking scenario?",
      "Did I mention time and space complexity?",
      "Did I discuss trade-offs (pessimistic vs optimistic, consistency vs availability)?"
    ],
    "quick_code_review": [
      "Lock acquired BEFORE availability check",
      "Lock released in finally block",
      "Composite key for availability (room_id, date)",
      "Idempotency key handling",
      "Error handling for lock acquisition failure"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Database transactions**: Real PostgreSQL with BEGIN/COMMIT/ROLLBACK",
      "**Monitoring**: Metrics on booking success rate, lock wait times, search latency",
      "**Alerting**: Alert if double-booking somehow occurs (should be impossible)",
      "**Audit logging**: Every booking attempt logged for debugging",
      "**Circuit breakers**: If payment service is down, fail fast",
      "**Reservation timeouts**: Auto-release held rooms after 10-15 minutes",
      "**Distributed tracing**: Track request through search \u2192 booking \u2192 payment"
    ],
    "why_not_in_interview": "Keep the interview focused on the core concurrency problem and data model. Mention these verbally to show production awareness.",
    "how_to_mention": "In production, I'd add monitoring on lock acquisition times and booking success rates, with alerts if we ever detect a double-booking anomaly. I'd also implement circuit breakers for the payment service dependency."
  },
  "generated_at": "2026-01-19T04:01:01.672170",
  "_meta": {
    "problem_id": "booking_reservation_system",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}