{
  "problem_title": "Stack Overflow API Design",
  "difficulty": "hard",
  "category": "LLD/API Design",
  "estimated_time": "60-90 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **Low-Level Design (LLD)** problem testing OOP fundamentals, data modeling, and efficient data retrieval patterns. The core challenge is balancing **fast writes** (creating users, questions, answers) with **fast reads** (queries by user, tag). This pattern appears in almost every real-world system.",
    "pattern_recognition": "**HashMap + Secondary Indexes + OOP Design**. The problem requires:\n1. **Primary Storage**: HashMaps for O(1) entity lookup by ID\n2. **Secondary Indexes**: Inverted indexes for efficient filtering (by tag, by user)\n3. **Relationships**: One-to-many (User\u2192Questions, Question\u2192Answers)\n4. **ID Generation**: Auto-increment counters for question/answer IDs",
    "key_constraints": [
      "Up to 10\u2075 operations - **must be O(1) or O(log n)**, no O(n) scans per operation",
      "Unique IDs required - need proper ID generation strategy",
      "getQuestionsByUser sorted by time (newest first) - need to track creation order",
      "getQuestionsByTag sorted by score (highest first) - need to sort on read or maintain sorted structure",
      "Must validate existence before operations (user exists, question exists)"
    ],
    "clarifying_questions": [
      "**Can a user post multiple questions/answers?** - Yes, typical Q&A platform behavior",
      "**What happens on duplicate userId in createUser?** - Should handle gracefully (return existing or throw)",
      "**What ID format for auto-generated IDs?** - Confirm 'q_1', 'a_1' pattern is acceptable",
      "**Thread-safety required?** - Likely not for Part 1, but good to ask",
      "**Case sensitivity for tags?** - Should 'Java' and 'java' be same tag?",
      "**Empty tags list valid?** - Problem says 0-5 tags, so yes",
      "**What to return for getQuestionsByUser if user doesn't exist?** - Empty list or null?"
    ],
    "edge_cases_to_consider": [
      "Create user with duplicate ID",
      "Post question by non-existent user",
      "Post answer to non-existent question",
      "Get question that doesn't exist",
      "Get questions by user who hasn't asked any",
      "Get questions by tag that no question has",
      "Question with empty tags list",
      "Multiple questions with same score (tie-breaking for sort)"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "createUser(userId, username)",
        "how_met": "Store in users HashMap, validate no duplicate",
        "gotchas": [
          "Must handle duplicate IDs gracefully"
        ]
      },
      {
        "requirement": "postQuestion(userId, title, body, tags)",
        "how_met": "Generate ID, create Question, update indexes",
        "gotchas": [
          "Must validate user exists",
          "Update tag index for each tag"
        ]
      },
      {
        "requirement": "postAnswer(userId, questionId, body)",
        "how_met": "Generate ID, validate question, create Answer",
        "gotchas": [
          "Return null if question doesn't exist"
        ]
      },
      {
        "requirement": "getQuestion(questionId)",
        "how_met": "O(1) HashMap lookup",
        "gotchas": [
          "Should return question WITH its answers"
        ]
      },
      {
        "requirement": "getQuestionsByUser(userId) sorted by time desc",
        "how_met": "Maintain user\u2192questions index, sort on read or insert in order",
        "gotchas": [
          "Newest first, not oldest"
        ]
      },
      {
        "requirement": "getQuestionsByTag(tag) sorted by score desc",
        "how_met": "Maintain tag\u2192questions index, sort by score on read",
        "gotchas": [
          "Highest score first"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "createUser",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion"
      },
      {
        "operation": "postQuestion",
        "target": "O(T)",
        "achieved": "O(T) where T=tags",
        "why": "Update T tag indexes"
      },
      {
        "operation": "postAnswer",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap ops + index update"
      },
      {
        "operation": "getQuestion",
        "target": "O(A)",
        "achieved": "O(A) where A=answers",
        "why": "Lookup O(1), collecting answers O(A)"
      },
      {
        "operation": "getQuestionsByUser",
        "target": "O(Q log Q)",
        "achieved": "O(Q log Q)",
        "why": "Sorting Q questions by time"
      },
      {
        "operation": "getQuestionsByTag",
        "target": "O(Q log Q)",
        "achieved": "O(Q log Q)",
        "why": "Sorting Q questions by score"
      }
    ],
    "non_goals": [
      "Voting system (Part 2)",
      "Search/filtering beyond tag (Part 3)",
      "Concurrency/thread-safety (unless asked)",
      "Persistence/database layer",
      "Authentication/authorization"
    ]
  },
  "assumptions": [
    "User IDs are provided by caller (not auto-generated)",
    "Question and Answer IDs are auto-generated by the system",
    "Tags are case-sensitive (unless interviewer says otherwise)",
    "A user can answer their own question",
    "Timestamps use system time (time.time() or similar)",
    "Empty result lists are returned (not null) for queries with no matches"
  ],
  "tradeoffs": [
    {
      "decision": "Store answers separately vs embed in Question",
      "chosen": "Separate storage with index",
      "why": "Allows O(1) answer updates, independent scaling, easier to add voting per answer",
      "alternative": "Embed List<Answer> in Question",
      "when_to_switch": "If answers are always fetched with question and never independently"
    },
    {
      "decision": "Sort on read vs maintain sorted structure",
      "chosen": "Sort on read (O(Q log Q))",
      "why": "Simpler, scores/times change rarely, read frequency unknown",
      "alternative": "Use TreeMap/SortedList",
      "when_to_switch": "If reads vastly outnumber writes and Q is very large"
    },
    {
      "decision": "Store question references as IDs vs object references",
      "chosen": "Store IDs in indexes",
      "why": "Cleaner separation, easier serialization, no circular references",
      "alternative": "Store actual Question objects",
      "when_to_switch": "In-memory only system where serialization isn't needed"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Single Responsibility**: Each entity class handles its own data",
      "**Open for Extension**: Add voting by extending Answer/Question with vote() method",
      "**Encapsulation**: Private storage, public API methods"
    ],
    "why_this_design_scales": "The index-based design makes adding new query types easy:\n- Add `tag_questions` index for getByTag\n- Add `user_questions` index for getByUser\n- Part 2 voting: Just add score field and update methods\n- Part 3 search: Add full-text index or use same pattern",
    "expected_followup_hooks": [
      "`score` field on Question/Answer ready for voting",
      "`isAccepted` field on Answer ready for accept functionality",
      "`reputation` field on User ready for reputation system",
      "Index pattern easily extended for new query types"
    ],
    "invariants": [
      "Every question_id in indexes exists in questions HashMap",
      "Every answer.question_id references a valid question",
      "Question counters only increase (no ID reuse)"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    STACK OVERFLOW SYSTEM                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502   \u2502  User A  \u2502\u2500\u2500posts\u2500\u2500\u2502  Question 1  \u2502\u25c4\u2500answer\u2500\u2502  User B  \u2502    \u2502\n\u2502   \u2502 \"alice\"  \u2502         \u2502 \"How to...\" \u2502         \u2502  \"bob\"   \u2502    \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502 tags:[py,str]\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502        \u2502               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502         \u2502\n\u2502        \u2502                      \u2502                       \u2502         \u2502\n\u2502        \u2502               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502         \u2502\n\u2502        \u2502               \u25bc             \u25bc                \u2502         \u2502\n\u2502        \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502         \u2502\n\u2502        \u2502         \u2502Answer 1 \u2502   \u2502Answer 2 \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2502        \u2502         \u2502by: u2   \u2502   \u2502by: u3   \u2502                      \u2502\n\u2502        \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2502\n\u2502        \u2502                                                        \u2502\n\u2502        \u2514\u2500\u2500posts\u2500\u2500\u2510                                              \u2502\n\u2502                  \u25bc                                              \u2502\n\u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                      \u2502\n\u2502           \u2502  Question 2  \u2502                                      \u2502\n\u2502           \u2502 tags:[java]  \u2502                                      \u2502\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                      \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURES                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  PRIMARY STORAGE (O(1) lookup by ID):                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 users          \u2502  \u2502 questions      \u2502  \u2502 answers        \u2502     \u2502\n\u2502  \u2502 {              \u2502  \u2502 {              \u2502  \u2502 {              \u2502     \u2502\n\u2502  \u2502  'u1': User    \u2502  \u2502  'q_1': Quest  \u2502  \u2502  'a_1': Ans    \u2502     \u2502\n\u2502  \u2502  'u2': User    \u2502  \u2502  'q_2': Quest  \u2502  \u2502  'a_2': Ans    \u2502     \u2502\n\u2502  \u2502 }              \u2502  \u2502 }              \u2502  \u2502 }              \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                                  \u2502\n\u2502  SECONDARY INDEXES (for efficient queries):                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502  \u2502 user_questions     \u2502  \u2502 tag_questions       \u2502                \u2502\n\u2502  \u2502 {                  \u2502  \u2502 {                  \u2502                 \u2502\n\u2502  \u2502  'u1': ['q_1','q_2']\u2502  \u2502  'python': ['q_1'] \u2502                \u2502\n\u2502  \u2502  'u2': []          \u2502  \u2502  'java': ['q_2']   \u2502                 \u2502\n\u2502  \u2502 }                  \u2502  \u2502 }                  \u2502                 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                         \u2502\n\u2502  \u2502 question_answers   \u2502                                         \u2502\n\u2502  \u2502 {                  \u2502                                         \u2502\n\u2502  \u2502  'q_1': ['a_1','a_2']                                        \u2502\n\u2502  \u2502 }                  \u2502                                         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                         \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "createUser('u1', 'alice')",
        "visualization": "users: {} \u2192 {'u1': User(id='u1', username='alice')}",
        "key_point": "O(1) HashMap insertion, validate no duplicate"
      },
      {
        "step": 2,
        "description": "postQuestion('u1', 'How to...', 'body', ['python', 'strings'])",
        "visualization": "questions: {} \u2192 {'q_1': Question(...)}\nuser_questions['u1']: [] \u2192 ['q_1']\ntag_questions['python']: [] \u2192 ['q_1']\ntag_questions['strings']: [] \u2192 ['q_1']",
        "key_point": "Update ALL indexes atomically"
      },
      {
        "step": 3,
        "description": "postAnswer('u2', 'q_1', 'Use [::-1]')",
        "visualization": "answers: {} \u2192 {'a_1': Answer(...)}\nquestion_answers['q_1']: [] \u2192 ['a_1']",
        "key_point": "Validate question exists FIRST"
      },
      {
        "step": 4,
        "description": "getQuestion('q_1')",
        "visualization": "1. Lookup: questions['q_1'] \u2192 Question\n2. Get answers: question_answers['q_1'] \u2192 ['a_1']\n3. Fetch each: answers['a_1'] \u2192 Answer",
        "key_point": "Question includes its answers"
      }
    ],
    "dry_run_table": "| Step | Operation | users | questions | answers | user_questions | tag_questions | question_answers |\n|------|-----------|-------|-----------|---------|----------------|---------------|------------------|\n| 1 | init | {} | {} | {} | {} | {} | {} |\n| 2 | createUser('u1','alice') | {'u1':User} | {} | {} | {} | {} | {} |\n| 3 | createUser('u2','bob') | {'u1':User,'u2':User} | {} | {} | {} | {} | {} |\n| 4 | postQuestion('u1',...,['py']) | +1 user | {'q_1':Q} | {} | {'u1':['q_1']} | {'py':['q_1']} | {} |\n| 5 | postAnswer('u2','q_1',...) | same | same | {'a_1':A} | same | same | {'q_1':['a_1']} |\n| 6 | getQuestion('q_1') | \u2014 | lookup q_1 | lookup a_1 | \u2014 | \u2014 | lookup ['a_1'] |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'multiple query patterns' (by ID, by user, by tag), I think of **secondary indexes** because scanning all questions would be O(n) per query",
      "When I see 'sorted results', I think: sort on read (simpler) vs maintain sorted (faster reads). With up to 10\u2075 ops, O(Q log Q) per query is acceptable",
      "The key insight is that **write-time indexing** pays off at read-time. When posting a question, update ALL relevant indexes immediately",
      "I should use HashMaps for primary storage because all operations need O(1) entity lookup by ID",
      "For relationships, store IDs in indexes (not object references) for cleaner design and easier serialization",
      "Auto-generated IDs: simple counter with prefix ('q_1', 'a_1') is clean and debuggable"
    ],
    "key_insight": "**The fundamental pattern is: Pay the cost at write-time to get fast reads.**\n\nWhen posting a question with tags ['python', 'java']:\n- Add to `questions` HashMap (for getQuestion)\n- Add to `user_questions[userId]` (for getQuestionsByUser)  \n- Add to `tag_questions['python']` AND `tag_questions['java']` (for getQuestionsByTag)\n\nThis makes all queries O(1) lookup + O(K log K) sort, instead of O(N) scan.",
    "why_this_works": "Every query type has a pre-built index:\n- **getQuestion**: Direct HashMap lookup O(1)\n- **getQuestionsByUser**: user_questions index gives list, sort by time\n- **getQuestionsByTag**: tag_questions index gives list, sort by score\n\nNo query ever scans all questions. Indexes are updated incrementally on writes."
  },
  "approaches": [
    {
      "name": "Brute Force - No Indexes",
      "description": "Store everything in lists, scan through all entities for every query",
      "pseudocode": "postQuestion: append to questions list\ngetQuestionsByTag(tag):\n    result = []\n    for q in questions:  # O(n) scan\n        if tag in q.tags:\n            result.append(q)\n    return sorted(result, by=score)",
      "time_complexity": "O(n) per query where n = total questions",
      "space_complexity": "O(n) - just the entities",
      "pros": [
        "Simplest to implement",
        "Minimal memory"
      ],
      "cons": [
        "O(n) per query fails for 10\u2075 operations",
        "Doesn't scale"
      ],
      "when_to_use": "Never for interview - shows lack of understanding of requirements"
    },
    {
      "name": "Optimal: HashMap + Secondary Indexes",
      "description": "Primary storage in HashMaps, secondary indexes for each query pattern",
      "pseudocode": "postQuestion:\n    q = create Question\n    questions[q.id] = q              # Primary\n    user_questions[userId].append(q.id)  # Index\n    for tag in tags:\n        tag_questions[tag].append(q.id)  # Index\n\ngetQuestionsByTag(tag):\n    ids = tag_questions[tag]         # O(1) lookup\n    qs = [questions[id] for id in ids]  # O(k)\n    return sorted(qs, by=score, desc)   # O(k log k)",
      "time_complexity": "O(1) for writes, O(k log k) for sorted reads where k = result size",
      "space_complexity": "O(n + indexes) - slightly more memory for indexes",
      "pros": [
        "Meets all complexity requirements",
        "Clean separation of concerns",
        "Extensible"
      ],
      "cons": [
        "More complex implementation",
        "Index maintenance on writes"
      ],
      "key_insight": "Pre-compute at write time \u2192 fast reads"
    }
  ],
  "optimal_solution": {
    "name": "HashMap Primary Storage + Secondary Indexes",
    "explanation_md": "## Approach\n\nThe solution uses a **multi-index architecture** common in database systems:\n\n### Primary Storage\nThree HashMaps for O(1) entity lookup:\n- `users`: user_id \u2192 User object\n- `questions`: question_id \u2192 Question object  \n- `answers`: answer_id \u2192 Answer object\n\n### Secondary Indexes\nInverted indexes for efficient queries:\n- `user_questions`: user_id \u2192 [question_ids]\n- `tag_questions`: tag \u2192 [question_ids]\n- `question_answers`: question_id \u2192 [answer_ids]\n\n### Why This Works\n\n1. **All lookups are O(1)** - HashMap by design\n2. **Queries use pre-built indexes** - No scanning\n3. **Sorting is O(k log k)** where k = results, not n = all questions\n4. **Writes update indexes** - Pay cost once, benefit many times",
    "data_structures": [
      {
        "structure": "HashMap<String, User> users",
        "purpose": "O(1) user lookup by ID"
      },
      {
        "structure": "HashMap<String, Question> questions",
        "purpose": "O(1) question lookup by ID"
      },
      {
        "structure": "HashMap<String, Answer> answers",
        "purpose": "O(1) answer lookup by ID"
      },
      {
        "structure": "HashMap<String, List<String>> user_questions",
        "purpose": "Index: user \u2192 their question IDs"
      },
      {
        "structure": "HashMap<String, List<String>> tag_questions",
        "purpose": "Index: tag \u2192 question IDs with that tag"
      },
      {
        "structure": "HashMap<String, List<String>> question_answers",
        "purpose": "Index: question \u2192 its answer IDs"
      },
      {
        "structure": "int question_counter, answer_counter",
        "purpose": "Auto-increment ID generation"
      }
    ],
    "algorithm_steps": [
      "1. **createUser**: Validate unique ID, store in users HashMap",
      "2. **postQuestion**: Generate ID, create Question, update user_questions and tag_questions indexes",
      "3. **postAnswer**: Validate question exists, generate ID, create Answer, update question_answers index",
      "4. **getQuestion**: O(1) lookup, fetch associated answers via question_answers index",
      "5. **getQuestionsByUser**: Get IDs from user_questions, fetch Questions, sort by created_at DESC",
      "6. **getQuestionsByTag**: Get IDs from tag_questions, fetch Questions, sort by score DESC"
    ],
    "why_decimal": "N/A for this problem (no currency)"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 1: Core Operations",
    "Implements user, question, and answer management with efficient indexing.",
    "\"\"\"",
    "import time",
    "from typing import List, Optional, Dict",
    "from collections import defaultdict",
    "",
    "",
    "class User:",
    "    \"\"\"Represents a Stack Overflow user.\"\"\"",
    "    def __init__(self, id: str, username: str):",
    "        self.id = id",
    "        self.username = username",
    "        self.reputation = 0",
    "    ",
    "    def __repr__(self):",
    "        return f\"User(id={self.id}, username={self.username}, rep={self.reputation})\"",
    "",
    "",
    "class Question:",
    "    \"\"\"Represents a question with tags and score.\"\"\"",
    "    def __init__(self, id: str, author_id: str, title: str, body: str, tags: List[str]):",
    "        self.id = id",
    "        self.author_id = author_id",
    "        self.title = title",
    "        self.body = body",
    "        self.tags = tags",
    "        self.score = 0",
    "        self.created_at = time.time()",
    "    ",
    "    def __repr__(self):",
    "        return f\"Question(id={self.id}, title='{self.title[:30]}...', score={self.score})\"",
    "",
    "",
    "class Answer:",
    "    \"\"\"Represents an answer to a question.\"\"\"",
    "    def __init__(self, id: str, question_id: str, author_id: str, body: str):",
    "        self.id = id",
    "        self.question_id = question_id",
    "        self.author_id = author_id",
    "        self.body = body",
    "        self.score = 0",
    "        self.is_accepted = False",
    "        self.created_at = time.time()",
    "    ",
    "    def __repr__(self):",
    "        return f\"Answer(id={self.id}, qid={self.question_id}, score={self.score})\"",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"",
    "    Main API class implementing Stack Overflow operations.",
    "    Uses HashMap for O(1) lookups + secondary indexes for efficient queries.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Primary storage - O(1) lookup by ID",
    "        self.users: Dict[str, User] = {}",
    "        self.questions: Dict[str, Question] = {}",
    "        self.answers: Dict[str, Answer] = {}",
    "        ",
    "        # Secondary indexes for efficient queries",
    "        self.user_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self.tag_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self.question_answers: Dict[str, List[str]] = defaultdict(list)",
    "        ",
    "        # ID generators",
    "        self.question_counter = 1",
    "        self.answer_counter = 1",
    "    ",
    "    def create_user(self, user_id: str, username: str) -> User:",
    "        \"\"\"Create a new user. Returns existing user if ID already exists.\"\"\"",
    "        if user_id in self.users:",
    "            return self.users[user_id]  # Idempotent",
    "        ",
    "        user = User(user_id, username)",
    "        self.users[user_id] = user",
    "        return user",
    "    ",
    "    def post_question(self, user_id: str, title: str, body: str, tags: List[str]) -> Optional[Question]:",
    "        \"\"\"Post a question. Returns None if user doesn't exist.\"\"\"",
    "        if user_id not in self.users:",
    "            return None",
    "        ",
    "        # Generate unique ID",
    "        q_id = f\"q_{self.question_counter}\"",
    "        self.question_counter += 1",
    "        ",
    "        # Create question",
    "        question = Question(q_id, user_id, title, body, tags)",
    "        self.questions[q_id] = question",
    "        ",
    "        # Update indexes",
    "        self.user_questions[user_id].append(q_id)",
    "        for tag in tags:",
    "            self.tag_questions[tag].append(q_id)",
    "        ",
    "        return question",
    "    ",
    "    def post_answer(self, user_id: str, question_id: str, body: str) -> Optional[Answer]:",
    "        \"\"\"Post answer to question. Returns None if question doesn't exist.\"\"\"",
    "        if question_id not in self.questions:",
    "            return None",
    "        if user_id not in self.users:",
    "            return None",
    "        ",
    "        # Generate unique ID",
    "        a_id = f\"a_{self.answer_counter}\"",
    "        self.answer_counter += 1",
    "        ",
    "        # Create answer",
    "        answer = Answer(a_id, question_id, user_id, body)",
    "        self.answers[a_id] = answer",
    "        ",
    "        # Update index",
    "        self.question_answers[question_id].append(a_id)",
    "        ",
    "        return answer",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        \"\"\"Get question with its answers. Returns None if not found.\"\"\"",
    "        return self.questions.get(question_id)",
    "    ",
    "    def get_answers_for_question(self, question_id: str) -> List[Answer]:",
    "        \"\"\"Helper: Get all answers for a question.\"\"\"",
    "        answer_ids = self.question_answers.get(question_id, [])",
    "        return [self.answers[a_id] for a_id in answer_ids]",
    "    ",
    "    def get_questions_by_user(self, user_id: str) -> List[Question]:",
    "        \"\"\"Get all questions by user, sorted by creation time (newest first).\"\"\"",
    "        q_ids = self.user_questions.get(user_id, [])",
    "        questions = [self.questions[q_id] for q_id in q_ids]",
    "        return sorted(questions, key=lambda q: q.created_at, reverse=True)",
    "    ",
    "    def get_questions_by_tag(self, tag: str) -> List[Question]:",
    "        \"\"\"Get all questions with tag, sorted by score (highest first).\"\"\"",
    "        q_ids = self.tag_questions.get(tag, [])",
    "        questions = [self.questions[q_id] for q_id in q_ids]",
    "        return sorted(questions, key=lambda q: q.score, reverse=True)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Stack Overflow API Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    so = StackOverflow()",
    "    ",
    "    # Test 1: Basic user and question flow",
    "    print(\"\\n--- Test 1: Create users and post question ---\")",
    "    alice = so.create_user('u1', 'alice')",
    "    bob = so.create_user('u2', 'bob')",
    "    print(f\"Created: {alice}\")",
    "    print(f\"Created: {bob}\")",
    "    ",
    "    q1 = so.post_question('u1', 'How to reverse a string in Python?',",
    "                          'I need help with string manipulation', ['python', 'strings'])",
    "    print(f\"Posted: {q1}\")",
    "    ",
    "    # Test 2: Post answer",
    "    print(\"\\n--- Test 2: Post answer ---\")",
    "    a1 = so.post_answer('u2', 'q_1', 'Use [::-1] or reversed() function')",
    "    print(f\"Posted: {a1}\")",
    "    ",
    "    # Test 3: Get question with answers",
    "    print(\"\\n--- Test 3: Get question with answers ---\")",
    "    q = so.get_question('q_1')",
    "    answers = so.get_answers_for_question('q_1')",
    "    print(f\"Question: {q}\")",
    "    print(f\"Answers: {answers}\")",
    "    ",
    "    # Test 4: Query by tag",
    "    print(\"\\n--- Test 4: Multiple questions, query by tag ---\")",
    "    so.post_question('u1', 'Java vs Python', 'Which is better?', ['java', 'python', 'comparison'])",
    "    so.post_question('u1', 'Java Collections', 'How to use HashMap?', ['java', 'collections'])",
    "    ",
    "    java_questions = so.get_questions_by_tag('java')",
    "    print(f\"Questions with 'java' tag: {[q.title for q in java_questions]}\")",
    "    ",
    "    # Test 5: Query by user",
    "    print(\"\\n--- Test 5: Query by user (newest first) ---\")",
    "    alice_questions = so.get_questions_by_user('u1')",
    "    print(f\"Alice's questions: {[q.title for q in alice_questions]}\")",
    "    ",
    "    # Test 6: Edge cases",
    "    print(\"\\n--- Test 6: Edge cases ---\")",
    "    print(f\"Get non-existent question: {so.get_question('q_999')}\")",
    "    print(f\"Answer to non-existent question: {so.post_answer('u1', 'q_999', 'test')}\")",
    "    print(f\"Questions by non-existent user: {so.get_questions_by_user('u999')}\")",
    "    print(f\"Questions with unused tag: {so.get_questions_by_tag('ruby')}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed!\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Stack Overflow API - Part 1: Core Operations",
    " * Uses HashMap for O(1) lookups + secondary indexes for efficient queries.",
    " */",
    "public class StackOverflow {",
    "    ",
    "    // Entity classes",
    "    static class User {",
    "        String id;",
    "        String username;",
    "        int reputation;",
    "        ",
    "        User(String id, String username) {",
    "            this.id = id;",
    "            this.username = username;",
    "            this.reputation = 0;",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"User(id=%s, username=%s)\", id, username);",
    "        }",
    "    }",
    "    ",
    "    static class Question {",
    "        String id;",
    "        String authorId;",
    "        String title;",
    "        String body;",
    "        List<String> tags;",
    "        int score;",
    "        long createdAt;",
    "        ",
    "        Question(String id, String authorId, String title, String body, List<String> tags) {",
    "            this.id = id;",
    "            this.authorId = authorId;",
    "            this.title = title;",
    "            this.body = body;",
    "            this.tags = new ArrayList<>(tags);",
    "            this.score = 0;",
    "            this.createdAt = System.currentTimeMillis();",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"Question(id=%s, title='%s', score=%d)\", id, title, score);",
    "        }",
    "    }",
    "    ",
    "    static class Answer {",
    "        String id;",
    "        String questionId;",
    "        String authorId;",
    "        String body;",
    "        int score;",
    "        boolean isAccepted;",
    "        long createdAt;",
    "        ",
    "        Answer(String id, String questionId, String authorId, String body) {",
    "            this.id = id;",
    "            this.questionId = questionId;",
    "            this.authorId = authorId;",
    "            this.body = body;",
    "            this.score = 0;",
    "            this.isAccepted = false;",
    "            this.createdAt = System.currentTimeMillis();",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"Answer(id=%s, questionId=%s)\", id, questionId);",
    "        }",
    "    }",
    "    ",
    "    // Primary storage",
    "    private Map<String, User> users = new HashMap<>();",
    "    private Map<String, Question> questions = new HashMap<>();",
    "    private Map<String, Answer> answers = new HashMap<>();",
    "    ",
    "    // Secondary indexes",
    "    private Map<String, List<String>> userQuestions = new HashMap<>();",
    "    private Map<String, List<String>> tagQuestions = new HashMap<>();",
    "    private Map<String, List<String>> questionAnswers = new HashMap<>();",
    "    ",
    "    // ID generators",
    "    private int questionCounter = 1;",
    "    private int answerCounter = 1;",
    "    ",
    "    public User createUser(String userId, String username) {",
    "        if (users.containsKey(userId)) {",
    "            return users.get(userId);",
    "        }",
    "        User user = new User(userId, username);",
    "        users.put(userId, user);",
    "        return user;",
    "    }",
    "    ",
    "    public Question postQuestion(String userId, String title, String body, List<String> tags) {",
    "        if (!users.containsKey(userId)) return null;",
    "        ",
    "        String qId = \"q_\" + questionCounter++;",
    "        Question question = new Question(qId, userId, title, body, tags);",
    "        questions.put(qId, question);",
    "        ",
    "        // Update indexes",
    "        userQuestions.computeIfAbsent(userId, k -> new ArrayList<>()).add(qId);",
    "        for (String tag : tags) {",
    "            tagQuestions.computeIfAbsent(tag, k -> new ArrayList<>()).add(qId);",
    "        }",
    "        ",
    "        return question;",
    "    }",
    "    ",
    "    public Answer postAnswer(String userId, String questionId, String body) {",
    "        if (!questions.containsKey(questionId)) return null;",
    "        if (!users.containsKey(userId)) return null;",
    "        ",
    "        String aId = \"a_\" + answerCounter++;",
    "        Answer answer = new Answer(aId, questionId, userId, body);",
    "        answers.put(aId, answer);",
    "        ",
    "        questionAnswers.computeIfAbsent(questionId, k -> new ArrayList<>()).add(aId);",
    "        return answer;",
    "    }",
    "    ",
    "    public Question getQuestion(String questionId) {",
    "        return questions.get(questionId);",
    "    }",
    "    ",
    "    public List<Answer> getAnswersForQuestion(String questionId) {",
    "        List<String> answerIds = questionAnswers.getOrDefault(questionId, new ArrayList<>());",
    "        return answerIds.stream().map(answers::get).collect(Collectors.toList());",
    "    }",
    "    ",
    "    public List<Question> getQuestionsByUser(String userId) {",
    "        List<String> qIds = userQuestions.getOrDefault(userId, new ArrayList<>());",
    "        return qIds.stream()",
    "            .map(questions::get)",
    "            .sorted((a, b) -> Long.compare(b.createdAt, a.createdAt))  // Newest first",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    public List<Question> getQuestionsByTag(String tag) {",
    "        List<String> qIds = tagQuestions.getOrDefault(tag, new ArrayList<>());",
    "        return qIds.stream()",
    "            .map(questions::get)",
    "            .sorted((a, b) -> Integer.compare(b.score, a.score))  // Highest score first",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Stack Overflow API Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        ",
    "        // Test 1: Create users",
    "        System.out.println(\"\\n--- Test 1: Create users ---\");",
    "        User alice = so.createUser(\"u1\", \"alice\");",
    "        User bob = so.createUser(\"u2\", \"bob\");",
    "        System.out.println(\"Created: \" + alice);",
    "        System.out.println(\"Created: \" + bob);",
    "        ",
    "        // Test 2: Post question",
    "        System.out.println(\"\\n--- Test 2: Post question ---\");",
    "        Question q1 = so.postQuestion(\"u1\", \"How to reverse string?\",",
    "            \"Need help\", Arrays.asList(\"python\", \"strings\"));",
    "        System.out.println(\"Posted: \" + q1);",
    "        ",
    "        // Test 3: Post answer",
    "        System.out.println(\"\\n--- Test 3: Post answer ---\");",
    "        Answer a1 = so.postAnswer(\"u2\", \"q_1\", \"Use [::-1]\");",
    "        System.out.println(\"Posted: \" + a1);",
    "        ",
    "        // Test 4: Get question with answers",
    "        System.out.println(\"\\n--- Test 4: Get question ---\");",
    "        System.out.println(\"Question: \" + so.getQuestion(\"q_1\"));",
    "        System.out.println(\"Answers: \" + so.getAnswersForQuestion(\"q_1\"));",
    "        ",
    "        // Test 5: Edge cases",
    "        System.out.println(\"\\n--- Test 5: Edge cases ---\");",
    "        System.out.println(\"Non-existent question: \" + so.getQuestion(\"q_999\"));",
    "        System.out.println(\"Answer to invalid Q: \" + so.postAnswer(\"u1\", \"q_999\", \"test\"));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "section": "Imports and Module Docstring",
      "explanation": "We import `time` for timestamps, `typing` for type hints, and `defaultdict` for auto-initializing lists. The docstring explains the module purpose."
    },
    {
      "lines": "11-17",
      "section": "User Class",
      "explanation": "Simple entity class with id, username, and reputation (starts at 0 for Part 1). The `__repr__` makes debugging easier."
    },
    {
      "lines": "20-31",
      "section": "Question Class",
      "explanation": "Contains all question attributes. Note `created_at = time.time()` captures creation timestamp for sorting. Score starts at 0, ready for Part 2 voting."
    },
    {
      "lines": "34-46",
      "section": "Answer Class",
      "explanation": "Similar to Question but links to a question via `question_id`. Includes `is_accepted` boolean ready for future accept feature."
    },
    {
      "lines": "49-66",
      "section": "StackOverflow.__init__",
      "explanation": "**Key design**: Primary storage (3 HashMaps) + Secondary indexes (3 defaultdict of lists) + ID counters. This is the core data structure decision that enables all O(1) operations."
    },
    {
      "lines": "68-75",
      "section": "create_user",
      "explanation": "O(1) HashMap insertion. We handle duplicate IDs gracefully by returning existing user (idempotent design)."
    },
    {
      "lines": "77-95",
      "section": "post_question",
      "explanation": "**Critical method**: Generate unique ID, create Question, then update ALL indexes (user_questions for each user, tag_questions for EACH tag). This write-time cost enables fast reads."
    },
    {
      "lines": "97-115",
      "section": "post_answer",
      "explanation": "Validate both question AND user exist. Generate ID, create Answer, update question_answers index. Returns None for invalid inputs."
    },
    {
      "lines": "117-126",
      "section": "get_question and get_answers_for_question",
      "explanation": "O(1) HashMap lookup for question. Helper method fetches all answers using the index - collects Answer objects from IDs."
    },
    {
      "lines": "128-137",
      "section": "get_questions_by_user",
      "explanation": "Uses user_questions index for O(1) ID lookup, converts to Question objects, sorts by created_at descending (newest first). Overall O(k log k)."
    },
    {
      "lines": "139-148",
      "section": "get_questions_by_tag",
      "explanation": "Same pattern: index lookup \u2192 fetch objects \u2192 sort. Sorts by score descending (highest first). Clean, consistent pattern."
    },
    {
      "lines": "151-195",
      "section": "main() Demo",
      "explanation": "Comprehensive demo covering: basic CRUD, posting answers, querying by tag/user, and edge cases (non-existent entities). Shows the API in action."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. First verify createUser works and stores correctly\n2. Then postQuestion - print the indexes after each post\n3. Then postAnswer - check question_answers index\n4. Finally test query methods one by one\n5. Always print intermediate state when debugging",
    "what_to_print_or_assert": [
      "print(f'After createUser: {self.users}')",
      "print(f'After postQuestion: user_questions={self.user_questions}, tag_questions={self.tag_questions}')",
      "assert question_id in self.questions, f'Question {question_id} not found'",
      "print(f'Sorting by: {[(q.id, q.score) for q in questions]}')"
    ],
    "common_failure_modes": [
      "**Forgot to update an index**: Question created but not added to tag_questions",
      "**Wrong sort order**: Ascending instead of descending",
      "**Not validating existence**: Posting answer to non-existent question",
      "**ID collision**: Not incrementing counter properly",
      "**Empty list handling**: Index returns None instead of empty list"
    ],
    "how_to_fix_fast": "1. Print the data structures after each operation\n2. Trace through manually with example from problem\n3. Check sort key and reverse parameter\n4. Verify index is updated for EVERY relevant key (all tags, not just first)"
  },
  "complexity_analysis": {
    "time": {
      "create_user": {
        "complexity": "O(1)",
        "explanation": "HashMap insertion and lookup"
      },
      "post_question": {
        "complexity": "O(T)",
        "explanation": "O(1) question storage + O(T) for T tags in tag_questions"
      },
      "post_answer": {
        "complexity": "O(1)",
        "explanation": "HashMap operations + single index update"
      },
      "get_question": {
        "complexity": "O(1)",
        "explanation": "Direct HashMap lookup"
      },
      "get_questions_by_user": {
        "complexity": "O(Q log Q)",
        "explanation": "Q = questions by user, sorting dominates"
      },
      "get_questions_by_tag": {
        "complexity": "O(Q log Q)",
        "explanation": "Q = questions with tag, sorting dominates"
      },
      "overall": "All operations meet the O(1) or O(k log k) requirement where k = result size, not total questions"
    },
    "space": {
      "complexity": "O(U + Q + A + I)",
      "breakdown": "- Users HashMap: O(U)\n- Questions HashMap: O(Q)\n- Answers HashMap: O(A)\n- Indexes: O(Q) for user_questions, O(Q*T) for tag_questions, O(A) for question_answers\n- Total: O(U + Q + A + Q*T) where T = avg tags per question",
      "note": "Space is linear in entities plus their relationships. Indexes add overhead but enable O(1) queries."
    },
    "can_we_do_better": "For Part 1, this is optimal. We could:\n- Use sorted containers (TreeMap) to avoid sort-on-read, but adds complexity\n- Store only IDs in indexes (we do this) vs storing objects\n- In production, would paginate results to avoid O(Q log Q) for large Q"
  },
  "dry_run": {
    "example": "createUser('u1','alice'), createUser('u2','bob'), postQuestion('u1','How to...','body',['py','str']), postAnswer('u2','q_1','Use [::-1]'), getQuestion('q_1')",
    "trace_table": "| # | Operation | users | questions | answers | user_questions | tag_questions | question_answers |\n|---|-----------|-------|-----------|---------|----------------|---------------|------------------|\n| 1 | init | {} | {} | {} | {} | {} | {} |\n| 2 | createUser('u1','alice') | {'u1':User(alice)} | {} | {} | {} | {} | {} |\n| 3 | createUser('u2','bob') | {'u1':User,'u2':User} | {} | {} | {} | {} | {} |\n| 4 | postQuestion('u1',...,['py','str']) | same | {'q_1':Q(How to...)} | {} | {'u1':['q_1']} | {'py':['q_1'],'str':['q_1']} | {} |\n| 5 | postAnswer('u2','q_1','Use...') | same | same | {'a_1':A} | same | same | {'q_1':['a_1']} |\n| 6 | getQuestion('q_1') | \u2014 | returns Q | fetches A | \u2014 | \u2014 | ['a_1'] |\n\n**Result**: Question object with id='q_1', can fetch answer 'a_1' via helper",
    "final_answer": "Question(id='q_1', title='How to...', score=0) with Answer(id='a_1')"
  },
  "test_cases": [
    {
      "name": "Basic Q&A Flow",
      "category": "Happy Path",
      "input": "createUser('u1','alice'), createUser('u2','bob'), postQuestion('u1','Q1','body',['tag1']), postAnswer('u2','q_1','answer body'), getQuestion('q_1')",
      "expected": "Question with 1 answer",
      "explanation": "End-to-end flow: users \u2192 question \u2192 answer \u2192 retrieve"
    },
    {
      "name": "Query by Tag - Multiple Matches",
      "category": "Query",
      "input": "3 questions with 'java' tag, 1 with 'python' only, getQuestionsByTag('java')",
      "expected": "Returns 3 questions sorted by score desc",
      "explanation": "Tag index correctly populated for all matching questions"
    },
    {
      "name": "Query by User - Order Check",
      "category": "Ordering",
      "input": "User posts Q1, Q2, Q3, getQuestionsByUser(userId)",
      "expected": "[Q3, Q2, Q1] (newest first)",
      "explanation": "Must sort by created_at descending, not insertion order"
    },
    {
      "name": "Non-existent Question",
      "category": "Edge Case",
      "input": "getQuestion('q_999')",
      "expected": "null / None",
      "explanation": "Graceful handling of missing entities"
    },
    {
      "name": "Answer to Invalid Question",
      "category": "Edge Case",
      "input": "postAnswer('u1', 'invalid_q', 'body')",
      "expected": "null / None",
      "explanation": "Must validate question exists before creating answer"
    },
    {
      "name": "Duplicate User ID",
      "category": "Edge Case",
      "input": "createUser('u1','alice'), createUser('u1','bob')",
      "expected": "Returns first User (alice), not error",
      "explanation": "Idempotent design - don't crash on duplicates"
    },
    {
      "name": "Empty Tag List",
      "category": "Edge Case",
      "input": "postQuestion('u1', 'Q1', 'body', [])",
      "expected": "Question created, no tag index updates",
      "explanation": "Problem allows 0 tags"
    },
    {
      "name": "Query Unused Tag",
      "category": "Edge Case",
      "input": "getQuestionsByTag('nonexistent')",
      "expected": "Empty list []",
      "explanation": "Return empty list, not null"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "O(n) scan for tag/user queries",
      "why_wrong": "Scanning all questions per query fails 10\u2075 operations constraint",
      "correct_approach": "Maintain secondary indexes updated at write time",
      "code_wrong": "def get_questions_by_tag(tag):\n    return [q for q in self.all_questions if tag in q.tags]  # O(n)",
      "code_correct": "def get_questions_by_tag(tag):\n    ids = self.tag_questions.get(tag, [])\n    return [self.questions[id] for id in ids]  # O(k)"
    },
    {
      "mistake": "Not updating tag index for ALL tags",
      "why_wrong": "Question with tags ['java', 'python'] only indexed under 'java'",
      "correct_approach": "Loop through all tags and add to each index",
      "code_wrong": "self.tag_questions[tags[0]].append(q_id)  # Only first tag!",
      "code_correct": "for tag in tags:\n    self.tag_questions[tag].append(q_id)"
    },
    {
      "mistake": "Wrong sort order",
      "why_wrong": "getQuestionsByUser needs newest first (DESC), not oldest first (ASC)",
      "correct_approach": "Use reverse=True for descending order",
      "code_wrong": "sorted(questions, key=lambda q: q.created_at)  # Oldest first",
      "code_correct": "sorted(questions, key=lambda q: q.created_at, reverse=True)"
    },
    {
      "mistake": "Not validating existence before operations",
      "why_wrong": "Posting answer to non-existent question creates orphan data",
      "correct_approach": "Check question exists first, return None if not",
      "code_wrong": "def post_answer(self, uid, qid, body):\n    a = Answer(...)  # No validation!",
      "code_correct": "def post_answer(self, uid, qid, body):\n    if qid not in self.questions:\n        return None"
    },
    {
      "mistake": "Returning None for empty query results",
      "why_wrong": "Inconsistent API - callers must null-check everywhere",
      "correct_approach": "Return empty list for queries with no results",
      "code_wrong": "return None if not found",
      "code_correct": "return []  # Empty list"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start, I'd like to clarify a few things to make sure I understand the requirements correctly...",
    "clarifying_questions_to_ask": [
      "For auto-generated IDs, is 'q_1', 'q_2' pattern acceptable, or do you prefer UUID?",
      "What should happen if createUser is called with duplicate ID? Return existing or error?",
      "For sorting - if two questions have same score, how should ties be broken?",
      "Should getQuestionsByUser for non-existent user return empty list or null?",
      "Are tags case-sensitive? Is 'Java' same as 'java'?"
    ],
    "what_to_mention_proactively": [
      "I'll use HashMaps for O(1) lookups and maintain secondary indexes for efficient queries",
      "This is a classic multi-index design pattern - write-time indexing for read-time efficiency",
      "I'll handle edge cases like non-existent entities gracefully",
      "The design is extensible - score and is_accepted fields are ready for Part 2"
    ],
    "communication_during_coding": [
      "I'm creating the entity classes first - User, Question, Answer",
      "Now the main StackOverflow class with primary storage and indexes",
      "Notice I'm updating ALL tag indexes when posting a question, not just the first",
      "The sort here is reverse=True for newest first..."
    ],
    "if_stuck": [
      "Let me re-read the requirements for this method...",
      "I'll draw out the data flow to visualize what's happening",
      "The key question is: what lookups do I need? That tells me what indexes to maintain"
    ],
    "time_management": "0-8min: Clarify requirements + discuss approach | 8-30min: Implement all 6 methods | 30-40min: Test with examples + edge cases | 40-45min: Discuss complexity + ready for Part 2"
  },
  "pattern_recognition": {
    "pattern_name": "Multi-Index / Inverted Index Pattern",
    "indicators": [
      "Multiple query patterns (by ID, by user, by tag)",
      "Need O(1) or O(log n) operations",
      "Entities with many-to-many relationships (questions \u2194 tags)",
      "CRUD with efficient filtering"
    ],
    "similar_problems": [
      "**LC 380 - Insert Delete GetRandom O(1)**: HashMap + Array for O(1) operations",
      "**LC 146 - LRU Cache**: HashMap + DoublyLinkedList for O(1) get/put",
      "**Design Twitter**: User\u2192Tweets index, feed aggregation",
      "**Design Search Autocomplete**: Trie + frequency index"
    ],
    "template": "1. Primary storage: HashMap<ID, Entity>\n2. Secondary indexes: HashMap<QueryKey, List<IDs>>\n3. Update ALL indexes on write\n4. Use indexes for read, sort if needed"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2 adds voting and reputation**. You'll need:\n- `upvote(userId, postId)` and `downvote(userId, postId)` methods\n- Track who voted on what (prevent double voting)\n- Update score on Question/Answer\n- Update reputation on author User\n- Consider: should users vote on their own posts?",
    "part_3_hint": "**Part 3 adds search and filtering**. Consider:\n- Full-text search on title/body (inverted word index or external search)\n- Filtering by multiple criteria (tag AND score > X)\n- Pagination for large result sets\n- Sorting by multiple fields",
    "data_structure_evolution": "Part 1: HashMap + List indexes \u2192 Part 2: Add Set<userId> for votes \u2192 Part 3: Add full-text index or integrate ElasticSearch"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. I see this is a Stack Overflow API design - essentially a multi-entity system with relationships between users, questions, and answers. Before I start coding, I'd like to clarify a few things and share my high-level approach.",
    "after_clarification": "Great, so to summarize: I need to implement 6 methods for Part 1, with O(1) or O(log n) operations. My approach will be to use HashMaps for primary storage and maintain secondary indexes for the query methods. This is a classic multi-index pattern. Does that sound good?",
    "while_coding": [
      "Starting with the entity classes - User, Question, Answer",
      "Now the StackOverflow class with three HashMaps for entities",
      "Adding secondary indexes - user_questions, tag_questions, question_answers",
      "For postQuestion, I need to update the tag index for EACH tag, not just one",
      "Sort is reverse=True here for newest first..."
    ],
    "after_coding": "Let me trace through Example 1 to verify: createUser alice, createUser bob, postQuestion, postAnswer, getQuestion... [traces through]. All looks correct.",
    "when_stuck_verbatim": "Let me think about this for a moment. The key question is what data structures will give me efficient lookups for this query pattern...",
    "after_mistake": "Actually, I see an issue here - I'm only updating the first tag, but I need to update ALL tags. Let me fix that with a loop.",
    "before_moving_on": "Part 1 is complete. Time complexity is O(1) for most operations, O(k log k) for sorted queries. Space is O(n) for entities plus O(n) for indexes. Ready for Part 2 whenever you are."
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem Decomposition**: Can you break down requirements into data structures?",
      "**Design Decisions**: Do you justify HashMap vs other structures?",
      "**Code Quality**: Clean, readable, follows conventions",
      "**Edge Case Awareness**: Do you handle non-existent entities?",
      "**Communication**: Can you explain your approach clearly?",
      "**Adaptability**: How easily can design extend for Part 2?"
    ],
    "bonus_points": [
      "Mentioning index pattern before being prompted",
      "Discussing time complexity proactively",
      "Drawing data flow diagram",
      "Asking about edge cases like duplicate IDs",
      "Making design extensible (score, is_accepted fields)"
    ],
    "red_flags": [
      "O(n) scan for every query",
      "Not validating existence before operations",
      "Silent coding for 10+ minutes",
      "Hardcoding example values",
      "Not testing after implementation"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize this as a multi-index problem, discuss tradeoffs (sort on read vs write), handle edge cases naturally, and write clean modular code. They treat the problem as a real system design, not just code exercise."
  },
  "time_milestones": {
    "by_5_min": "Understand requirements, ask clarifying questions, identify this as multi-index pattern",
    "by_10_min": "Explain approach with data structures (HashMap + indexes), get interviewer buy-in",
    "by_25_min": "Core implementation done - all 6 methods working",
    "by_35_min": "Edge cases handled, dry run complete, complexity discussed",
    "by_45_min": "Part 1 finished, discussed extensibility, ready for Part 2",
    "warning_signs": "Still designing at 15 min? Speed up. Still coding at 40 min? You're behind."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see an issue here - I'm not updating all the tag indexes. Let me add a loop.' Fix it clearly and move on.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for defaultdict, but I need a dict that auto-initializes empty lists. Let me write it this way...'",
    "when_approach_is_wrong": "Say: 'Actually, I realize a linear scan won't meet the complexity requirement. Let me add an index for this query pattern.'",
    "when_completely_stuck": "Say: 'I'm stuck on how to efficiently query by tag. Could you give me a hint about what data structure would help?'",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on the core methods and explain what I'd add for edge cases.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them strategically, not as a crutch.",
    "what_to_do": [
      "Use AI for class scaffolding (entity classes with fields)",
      "Use for generating test cases in main()",
      "Use for syntax you forgot (defaultdict, sorting with key)",
      "Let it autocomplete obvious boilerplate"
    ],
    "what_not_to_do": [
      "Don't paste entire problem and accept solution blindly",
      "Don't accept suggestions without understanding WHY they work",
      "Don't let AI drive architecture decisions"
    ],
    "how_to_demonstrate_understanding": "If AI suggests an index structure, explain: 'This index maps tags to question IDs, which gives us O(1) lookup for getQuestionsByTag'",
    "expectation_adjustment": "With AI, you should complete MORE parts. If Part 1 takes as long with AI as without, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately identifying multi-index pattern",
      "Drawing data structure diagram before coding",
      "Mentioning extensibility for Part 2 (voting ready)",
      "Proactively discussing complexity for each method",
      "Writing clean, production-quality code first try"
    ],
    "subtle_signals_of_experience": [
      "Using defaultdict for auto-initializing indexes",
      "Returning empty list vs None for queries",
      "Making createUser idempotent",
      "Adding __repr__ for debugging",
      "Considering sort stability for tie-breaking"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Silent coding for more than 2 minutes without explanation",
      "Getting defensive when interviewer suggests improvement",
      "Not asking any clarifying questions",
      "Rushing to code without explaining approach"
    ],
    "technical": [
      "O(n) scan for every query method",
      "Not validating entity existence",
      "Wrong sort order (ascending vs descending)",
      "Only indexing first tag instead of all tags"
    ],
    "communication": [
      "Using jargon without explaining ('inverted index' with no context)",
      "Not summarizing approach before coding",
      "Not tracing through example after coding"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2705 All 6 methods implemented?",
      "\u2705 Traced through at least one example?",
      "\u2705 Edge cases handled (non-existent entities)?",
      "\u2705 Time/space complexity discussed?",
      "\u2705 Code is readable with good names?",
      "\u2705 Indexes updated correctly on writes?"
    ],
    "quick_code_review": [
      "No magic numbers (use constants if needed)",
      "Consistent naming (snake_case in Python)",
      "All paths return appropriate value",
      "No unused variables",
      "Proper indentation"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Input validation**: Check userId format, title length, etc.",
      "**Logging**: Log all operations for debugging and audit",
      "**Thread-safety**: Locks or concurrent collections if multi-threaded",
      "**Persistence**: Database layer instead of in-memory",
      "**Pagination**: Limit results for getQuestionsByTag with many matches",
      "**Caching**: Cache hot questions/users"
    ],
    "why_not_in_interview": "Focus on core logic. Over-engineering wastes time and obscures the algorithm.",
    "how_to_mention": "Say: 'In production, I'd add input validation, logging, and consider thread-safety, but for this interview I'll focus on the core data structures and operations.'"
  },
  "generated_at": "2026-01-19T04:08:52.852195",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}