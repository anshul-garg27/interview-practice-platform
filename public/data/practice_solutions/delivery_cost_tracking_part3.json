{
  "problem_title": "Delivery Cost Tracking System - Part 3: Maximum Active Drivers Analytics",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds analytics capability to find the maximum number of drivers delivering simultaneously within a sliding 24-hour window. This requires tracking delivery intervals (not just costs) and implementing a line sweep algorithm to find maximum overlap.",
    "new_requirements": [
      "Track all deliveries with their start/end times for analytics",
      "Implement get_max_active_drivers_in_last_24_hours(currentTime) method",
      "Handle 24-hour sliding window (86400 seconds)",
      "Clip deliveries to window boundaries for accurate overlap calculation"
    ],
    "new_constraints": [
      "Must efficiently find overlapping intervals within a time window",
      "O(n log n) complexity for the analytics query",
      "Must handle deliveries that partially overlap with the window"
    ],
    "key_insight": "This is a classic Line Sweep / Meeting Rooms II problem! Convert each delivery interval into two events (+1 at start, -1 at end), sort by time, and sweep through tracking the running count of active drivers. The maximum running count is our answer."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Find max concurrent drivers in 24-hour window",
        "how_met": "Line sweep algorithm with event sorting",
        "gotchas": [
          "Forgetting to clip intervals to window",
          "Wrong event ordering at same timestamp"
        ]
      },
      {
        "requirement": "Track delivery intervals for analytics",
        "how_met": "New _deliveries list stores (driver_id, start_time, end_time) tuples",
        "gotchas": [
          "Adding to list but forgetting to use it"
        ]
      },
      {
        "requirement": "Handle deliveries partially in window",
        "how_met": "Clip start/end times to window boundaries using max/min",
        "gotchas": [
          "Off-by-one errors at boundaries"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "get_max_active_drivers_in_last_24_hours",
        "target": "O(n log n)",
        "achieved": "O(n log n)",
        "why": "Dominated by sorting events; n = deliveries in window"
      },
      {
        "operation": "add_delivery",
        "target": "O(log n)",
        "achieved": "O(log n)",
        "why": "Still O(log n) for heap push; list append is O(1) amortized"
      }
    ],
    "non_goals": [
      "Real-time streaming max (would need segment tree)",
      "Historical max over arbitrary ranges",
      "Per-driver analytics"
    ]
  },
  "assumptions": [
    "A driver cannot have two overlapping deliveries (physically impossible)",
    "Each delivery interval represents one active driver",
    "Window is half-open: [currentTime - 86400, currentTime)",
    "Deliveries ending exactly at window_start are excluded (already complete)",
    "Deliveries starting exactly at window_end are excluded (not yet started)"
  ],
  "tradeoffs": [
    {
      "decision": "List vs TreeMap for storing deliveries",
      "chosen": "List",
      "why": "Simple O(1) append; we need full scan anyway for the analytics query",
      "alternative": "TreeMap by start_time",
      "when_to_switch": "If we need range queries by start time"
    },
    {
      "decision": "On-demand computation vs maintained state",
      "chosen": "On-demand line sweep",
      "why": "Simple to implement; analytics queries likely infrequent",
      "alternative": "Segment tree with lazy propagation",
      "when_to_switch": "If analytics queries are very frequent and need sub-linear time"
    },
    {
      "decision": "Store full delivery info vs just intervals",
      "chosen": "Store (driver_id, start, end)",
      "why": "driver_id useful for future per-driver analytics even if not used now",
      "alternative": "Just (start, end)",
      "when_to_switch": "If memory is extremely constrained"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public method signatures from Parts 1-2",
      "SECONDS_PER_HOUR constant",
      "Cost calculation formula",
      "Payment tracking invariants"
    ],
    "what_to_change": [
      "Added _deliveries list for interval tracking",
      "New SECONDS_IN_24_HOURS constant",
      "add_delivery appends to _deliveries"
    ],
    "interfaces_and_boundaries": "Analytics methods read from _deliveries but don't modify it. Payment methods use _unpaid heap. Cost methods use _total_cost/_paid_cost. Clean separation allows Part 4 to add more analytics without affecting payments.",
    "invariants": [
      "total_cost == sum of ALL delivery costs (unchanged)",
      "paid_cost <= total_cost (unchanged)",
      "_deliveries contains all deliveries ever added",
      "len(_deliveries) == number of add_delivery calls"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2):                    AFTER (Part 3):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _drivers: {id: rate}  \u2502          \u2502 _drivers: {id: rate}  \u2502\n\u2502 _total_cost: Decimal  \u2502          \u2502 _total_cost: Decimal  \u2502\n\u2502 _paid_cost: Decimal   \u2502          \u2502 _paid_cost: Decimal   \u2502\n\u2502 _unpaid: heap[(t,c)]  \u2502          \u2502 _unpaid: heap[(t,c)]  \u2502\n\u2502                       \u2502          \u2502 _deliveries: [(d,s,e)]\u2502 \u2190 NEW!\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    LINE SWEEP ALGORITHM                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                               \u2502\n\u2502  Step 1: Filter deliveries overlapping [T-86400, T]          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502    D1: [0, 3000]        \u2713 overlaps                 \u2502      \u2502\n\u2502  \u2502    D2: [1000, 2500]     \u2713 overlaps                 \u2502      \u2502\n\u2502  \u2502    D3: [1500, 4000]     \u2713 overlaps                 \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                               \u2502\n\u2502  Step 2: Create events (clip if needed)                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502  (0, +1)  (1000, +1)  (1500, +1)                   \u2502      \u2502\n\u2502  \u2502  (2500, -1)  (3000, -1)  (4000, -1)               \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                               \u2502\n\u2502  Step 3: Sort by (time, delta) \u2192 ends before starts          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502  (0,+1) (1000,+1) (1500,+1) (2500,-1) (3000,-1)   \u2502      \u2502\n\u2502  \u2502  (4000,-1)                                         \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                               \u2502\n\u2502  Step 4: Sweep and track max                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502  t=0:    active=1, max=1                           \u2502      \u2502\n\u2502  \u2502  t=1000: active=2, max=2                           \u2502      \u2502\n\u2502  \u2502  t=1500: active=3, max=3  \u2605 MAXIMUM               \u2502      \u2502\n\u2502  \u2502  t=2500: active=2                                  \u2502      \u2502\n\u2502  \u2502  t=3000: active=1                                  \u2502      \u2502\n\u2502  \u2502  t=4000: active=0                                  \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                               \u2502\n\u2502  Return: 3                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive: Check every second",
      "description": "For each second in the 24-hour window, count how many deliveries are active at that moment.",
      "time_complexity": "O(86400 * n)",
      "space_complexity": "O(1)",
      "why_not_optimal": "86400 seconds * n deliveries = billions of checks for large n. Way too slow."
    },
    {
      "name": "Better: Check only at event times",
      "description": "The count only changes at start/end times. Check at each unique delivery boundary.",
      "time_complexity": "O(n\u00b2)",
      "space_complexity": "O(n)",
      "why_not_optimal": "For each of 2n events, we scan all n deliveries to count actives. Still quadratic."
    },
    {
      "name": "Optimal: Line Sweep with Events",
      "description": "Create +1 events at starts and -1 events at ends. Sort events by time. Sweep through maintaining running count. Track maximum.",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "key_insight": "By sorting events, we process them in order and maintain a running count. Each event is processed once. The sort dominates at O(n log n)."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Line Sweep Algorithm\n\n**Core Idea**: Instead of checking activity at every moment, we only care about **moments when something changes** - delivery starts and ends.\n\n**Algorithm**:\n1. **Filter**: Keep only deliveries overlapping with 24-hour window\n2. **Clip**: Adjust start/end times to window boundaries\n3. **Create Events**: `(time, +1)` for start, `(time, -1)` for end\n4. **Sort**: By time, with **ends before starts** at same timestamp\n5. **Sweep**: Track running count, record maximum\n\n**Why ends before starts?** If D1 ends at t=100 and D2 starts at t=100, they don't overlap at that instant. Processing end first gives correct count.\n\n**Window Clipping**: A delivery from t=0 to t=5000 with window [1000, 3000] becomes [1000, 3000] for counting purposes.",
    "data_structures": [
      {
        "structure": "List _deliveries",
        "purpose": "Store all deliveries (driver_id, start_time, end_time) for analytics queries"
      },
      {
        "structure": "List events",
        "purpose": "Temporary list of (time, delta) events for line sweep, created per query"
      }
    ],
    "algorithm_steps": [
      "Step 1: Calculate window bounds: window_start = currentTime - 86400, window_end = currentTime",
      "Step 2: Iterate through _deliveries, skip those not overlapping window",
      "Step 3: For overlapping deliveries, clip to window and create two events: (clipped_start, +1), (clipped_end, -1)",
      "Step 4: Sort events by (time, delta) - this puts -1 before +1 at same time",
      "Step 5: Initialize current_active = 0, max_active = 0",
      "Step 6: For each event: current_active += delta, max_active = max(max_active, current_active)",
      "Step 7: Return max_active"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Delivery Cost Tracking System - Part 3: Maximum Active Drivers Analytics",
    "Key insight: Line sweep algorithm for finding max overlapping intervals.",
    "\"\"\"",
    "from decimal import Decimal",
    "from typing import Dict, List, Tuple",
    "import heapq",
    "",
    "",
    "class DeliveryCostTracker:",
    "    \"\"\"Tracks delivery costs with payment settlement and driver analytics.\"\"\"",
    "    ",
    "    SECONDS_PER_HOUR = Decimal('3600')",
    "    SECONDS_IN_24_HOURS = 86400",
    "    ",
    "    def __init__(self):",
    "        self._drivers: Dict[int, Decimal] = {}",
    "        self._total_cost: Decimal = Decimal('0')",
    "        self._paid_cost: Decimal = Decimal('0')",
    "        self._unpaid: List[Tuple[int, Decimal]] = []  # min-heap: (end_time, cost)",
    "        # Part 3: Store deliveries for analytics",
    "        self._deliveries: List[Tuple[int, int, int]] = []  # (driver_id, start, end)",
    "    ",
    "    def add_driver(self, driver_id: int, hourly_rate: Decimal) -> None:",
    "        \"\"\"Register a driver with their hourly rate. O(1)\"\"\"",
    "        self._drivers[driver_id] = hourly_rate",
    "    ",
    "    def add_delivery(self, driver_id: int, start_time: int, end_time: int) -> None:",
    "        \"\"\"Record a delivery. O(log n) for heap push.\"\"\"",
    "        if driver_id not in self._drivers:",
    "            raise ValueError(f\"Driver {driver_id} not registered\")",
    "        ",
    "        rate = self._drivers[driver_id]",
    "        duration = Decimal(end_time - start_time)",
    "        cost = rate * duration / self.SECONDS_PER_HOUR",
    "        ",
    "        self._total_cost += cost",
    "        heapq.heappush(self._unpaid, (end_time, cost))",
    "        self._deliveries.append((driver_id, start_time, end_time))  # Part 3",
    "    ",
    "    def get_total_cost(self) -> Decimal:",
    "        \"\"\"Return total cost of all deliveries. O(1)\"\"\"",
    "        return self._total_cost",
    "    ",
    "    def pay_up_to_time(self, up_to_time: int) -> None:",
    "        \"\"\"Pay all deliveries ending at or before up_to_time. O(k log n)\"\"\"",
    "        while self._unpaid and self._unpaid[0][0] <= up_to_time:",
    "            _, cost = heapq.heappop(self._unpaid)",
    "            self._paid_cost += cost",
    "    ",
    "    def get_cost_to_be_paid(self) -> Decimal:",
    "        \"\"\"Return cost of unpaid deliveries. O(1)\"\"\"",
    "        return self._total_cost - self._paid_cost",
    "    ",
    "    def get_max_active_drivers_in_last_24_hours(self, current_time: int) -> int:",
    "        \"\"\"",
    "        Find max concurrent drivers in last 24 hours using line sweep.",
    "        O(n log n) where n = deliveries overlapping with window.",
    "        \"\"\"",
    "        window_start = current_time - self.SECONDS_IN_24_HOURS",
    "        window_end = current_time",
    "        ",
    "        # Create events: (time, delta) where +1=start, -1=end",
    "        events = []",
    "        for _, start, end in self._deliveries:",
    "            # Skip if no overlap with window",
    "            if end <= window_start or start >= window_end:",
    "                continue",
    "            # Clip to window boundaries",
    "            clipped_start = max(start, window_start)",
    "            clipped_end = min(end, window_end)",
    "            events.append((clipped_start, 1))   # +1 at start",
    "            events.append((clipped_end, -1))    # -1 at end",
    "        ",
    "        if not events:",
    "            return 0",
    "        ",
    "        # Sort by time, then by delta (ends before starts at same time)",
    "        events.sort(key=lambda x: (x[0], x[1]))",
    "        ",
    "        max_active = 0",
    "        current_active = 0",
    "        for _, delta in events:",
    "            current_active += delta",
    "            max_active = max(max_active, current_active)",
    "        ",
    "        return max_active",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"PART 3: MAXIMUM ACTIVE DRIVERS ANALYTICS\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Example 1: Three overlapping drivers",
    "    t = DeliveryCostTracker()",
    "    t.add_driver(1, Decimal('10'))",
    "    t.add_driver(2, Decimal('10'))",
    "    t.add_driver(3, Decimal('10'))",
    "    t.add_delivery(1, 0, 3000)      # D1: 0-3000",
    "    t.add_delivery(2, 1000, 2500)   # D2: 1000-2500",
    "    t.add_delivery(3, 1500, 4000)   # D3: 1500-4000",
    "    result = t.get_max_active_drivers_in_last_24_hours(86400)",
    "    print(f\"Max active (3 overlapping): {result}  (expected: 3)\")",
    "    ",
    "    # Example 2: Non-overlapping deliveries",
    "    print(\"\\n\" + \"-\" * 40)",
    "    t2 = DeliveryCostTracker()",
    "    t2.add_driver(1, Decimal('10'))",
    "    t2.add_driver(2, Decimal('10'))",
    "    t2.add_delivery(1, 0, 1000)     # D1: 0-1000",
    "    t2.add_delivery(2, 2000, 3000)  # D2: 2000-3000 (no overlap)",
    "    result2 = t2.get_max_active_drivers_in_last_24_hours(86400)",
    "    print(f\"Max active (no overlap): {result2}  (expected: 1)\")",
    "    ",
    "    # Example 3: Partial window overlap",
    "    print(\"\\n\" + \"-\" * 40)",
    "    t3 = DeliveryCostTracker()",
    "    t3.add_driver(1, Decimal('10'))",
    "    t3.add_delivery(1, 86000, 87000)  # Starts before window, ends inside",
    "    result3 = t3.get_max_active_drivers_in_last_24_hours(86500)",
    "    print(f\"Max active (partial overlap): {result3}  (expected: 1)\")",
    "    ",
    "    # Example 4: No deliveries in window",
    "    print(\"\\n\" + \"-\" * 40)",
    "    t4 = DeliveryCostTracker()",
    "    t4.add_driver(1, Decimal('10'))",
    "    t4.add_delivery(1, 0, 1000)  # Old delivery",
    "    result4 = t4.get_max_active_drivers_in_last_24_hours(100000)",
    "    print(f\"Max active (outside window): {result4}  (expected: 0)\")",
    "    ",
    "    # Verify Part 2 still works",
    "    print(\"\\n\" + \"-\" * 40)",
    "    print(\"Verifying Part 2 compatibility...\")",
    "    print(f\"Total cost: ${t.get_total_cost():.2f}\")",
    "    t.pay_up_to_time(3000)",
    "    print(f\"After pay(3000): ${t.get_cost_to_be_paid():.2f} unpaid\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 3 tests passed! \u2713\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "",
    "/**",
    " * Delivery Cost Tracking System - Part 3: Maximum Active Drivers Analytics",
    " * Uses line sweep algorithm for O(n log n) max concurrent drivers.",
    " */",
    "public class DeliveryCostTracker {",
    "    ",
    "    private static final BigDecimal SECONDS_PER_HOUR = new BigDecimal(\"3600\");",
    "    private static final long SECONDS_IN_24_HOURS = 86400L;",
    "    ",
    "    private final Map<Integer, BigDecimal> drivers;",
    "    private BigDecimal totalCost;",
    "    private BigDecimal paidCost;",
    "    private final TreeMap<Long, List<BigDecimal>> unpaid;",
    "    // Part 3: Store deliveries for analytics",
    "    private final List<long[]> deliveries; // [driverId, startTime, endTime]",
    "    ",
    "    public DeliveryCostTracker() {",
    "        this.drivers = new HashMap<>();",
    "        this.totalCost = BigDecimal.ZERO;",
    "        this.paidCost = BigDecimal.ZERO;",
    "        this.unpaid = new TreeMap<>();",
    "        this.deliveries = new ArrayList<>();",
    "    }",
    "    ",
    "    public void addDriver(int driverId, BigDecimal hourlyRate) {",
    "        drivers.put(driverId, hourlyRate);",
    "    }",
    "    ",
    "    public void addDelivery(int driverId, long startTime, long endTime) {",
    "        BigDecimal rate = drivers.get(driverId);",
    "        if (rate == null) {",
    "            throw new IllegalArgumentException(\"Driver \" + driverId + \" not registered\");",
    "        }",
    "        ",
    "        BigDecimal duration = new BigDecimal(endTime - startTime);",
    "        BigDecimal cost = rate.multiply(duration).divide(SECONDS_PER_HOUR, 10, BigDecimal.ROUND_HALF_UP);",
    "        totalCost = totalCost.add(cost);",
    "        unpaid.computeIfAbsent(endTime, k -> new ArrayList<>()).add(cost);",
    "        deliveries.add(new long[]{driverId, startTime, endTime}); // Part 3",
    "    }",
    "    ",
    "    public BigDecimal getTotalCost() {",
    "        return totalCost;",
    "    }",
    "    ",
    "    public void payUpToTime(long upToTime) {",
    "        NavigableMap<Long, List<BigDecimal>> toPay = unpaid.headMap(upToTime, true);",
    "        for (List<BigDecimal> costs : toPay.values()) {",
    "            for (BigDecimal cost : costs) {",
    "                paidCost = paidCost.add(cost);",
    "            }",
    "        }",
    "        toPay.clear();",
    "    }",
    "    ",
    "    public BigDecimal getCostToBePaid() {",
    "        return totalCost.subtract(paidCost);",
    "    }",
    "    ",
    "    /** Find max concurrent drivers in last 24 hours. O(n log n) line sweep. */",
    "    public int getMaxActiveDriversInLast24Hours(long currentTime) {",
    "        long windowStart = currentTime - SECONDS_IN_24_HOURS;",
    "        long windowEnd = currentTime;",
    "        ",
    "        // Create events: [time, delta]",
    "        List<long[]> events = new ArrayList<>();",
    "        for (long[] delivery : deliveries) {",
    "            long start = delivery[1];",
    "            long end = delivery[2];",
    "            ",
    "            // Skip if no overlap with window",
    "            if (end <= windowStart || start >= windowEnd) {",
    "                continue;",
    "            }",
    "            ",
    "            // Clip to window",
    "            long clippedStart = Math.max(start, windowStart);",
    "            long clippedEnd = Math.min(end, windowEnd);",
    "            events.add(new long[]{clippedStart, 1});",
    "            events.add(new long[]{clippedEnd, -1});",
    "        }",
    "        ",
    "        if (events.isEmpty()) {",
    "            return 0;",
    "        }",
    "        ",
    "        // Sort by time, then by delta (end before start at same time)",
    "        events.sort((a, b) -> {",
    "            if (a[0] != b[0]) return Long.compare(a[0], b[0]);",
    "            return Long.compare(a[1], b[1]);",
    "        });",
    "        ",
    "        int maxActive = 0;",
    "        int currentActive = 0;",
    "        for (long[] event : events) {",
    "            currentActive += (int) event[1];",
    "            maxActive = Math.max(maxActive, currentActive);",
    "        }",
    "        ",
    "        return maxActive;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"PART 3: MAXIMUM ACTIVE DRIVERS ANALYTICS\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Example 1: Three overlapping drivers",
    "        DeliveryCostTracker t = new DeliveryCostTracker();",
    "        t.addDriver(1, new BigDecimal(\"10\"));",
    "        t.addDriver(2, new BigDecimal(\"10\"));",
    "        t.addDriver(3, new BigDecimal(\"10\"));",
    "        t.addDelivery(1, 0, 3000);",
    "        t.addDelivery(2, 1000, 2500);",
    "        t.addDelivery(3, 1500, 4000);",
    "        System.out.println(\"Max active (3 overlapping): \" + ",
    "            t.getMaxActiveDriversInLast24Hours(86400) + \" (expected: 3)\");",
    "        ",
    "        // Example 2: Non-overlapping",
    "        System.out.println(\"\\n----------------------------------------\");",
    "        DeliveryCostTracker t2 = new DeliveryCostTracker();",
    "        t2.addDriver(1, new BigDecimal(\"10\"));",
    "        t2.addDriver(2, new BigDecimal(\"10\"));",
    "        t2.addDelivery(1, 0, 1000);",
    "        t2.addDelivery(2, 2000, 3000);",
    "        System.out.println(\"Max active (no overlap): \" + ",
    "            t2.getMaxActiveDriversInLast24Hours(86400) + \" (expected: 1)\");",
    "        ",
    "        // Verify Part 2 still works",
    "        System.out.println(\"\\n----------------------------------------\");",
    "        System.out.println(\"Total cost: $\" + t.getTotalCost());",
    "        t.payUpToTime(3000);",
    "        System.out.println(\"After pay(3000): $\" + t.getCostToBePaid() + \" unpaid\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All Part 3 tests passed!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "explanation": "Imports and class setup - same as Part 2 with added typing support"
    },
    {
      "lines": "14-21",
      "explanation": "Constructor now includes _deliveries list to store all delivery intervals for analytics"
    },
    {
      "lines": "27-38",
      "explanation": "add_delivery extended to append (driver_id, start_time, end_time) tuple to _deliveries list"
    },
    {
      "lines": "52-78",
      "explanation": "NEW: get_max_active_drivers_in_last_24_hours implements line sweep - filter to window, create events, sort, sweep and track max"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_max_active_drivers_in_last_24_hours": {
          "complexity": "O(n log n)",
          "explanation": "Where n = deliveries overlapping with window. Filter is O(n), creating events is O(n), sort is O(n log n), sweep is O(n). Sort dominates."
        }
      },
      "modified_methods": {
        "add_delivery": {
          "complexity": "O(log n)",
          "explanation": "Unchanged from Part 2 - heap push is O(log n), list append is O(1) amortized"
        }
      },
      "overall_change": "New analytics query is O(n log n) per call. add_delivery unchanged at O(log n)."
    },
    "space": {
      "additional_space": "O(n) where n = total deliveries",
      "explanation": "_deliveries list stores all delivery tuples. Additionally, each analytics query creates O(k) events temporarily where k = deliveries in window."
    }
  },
  "dry_run": {
    "example_input": "Drivers: 1,2,3. Deliveries: D1[0,3000], D2[1000,2500], D3[1500,4000]. Query at currentTime=86400.",
    "steps": [
      {
        "step": 1,
        "action": "Calculate window",
        "state": "window = [0, 86400]",
        "explanation": "86400 - 86400 = 0, so window covers everything"
      },
      {
        "step": 2,
        "action": "Filter deliveries",
        "state": "All 3 overlap",
        "explanation": "D1[0,3000], D2[1000,2500], D3[1500,4000] all within window"
      },
      {
        "step": 3,
        "action": "Create events",
        "state": "[(0,+1), (3000,-1), (1000,+1), (2500,-1), (1500,+1), (4000,-1)]",
        "explanation": "Each delivery creates start and end event"
      },
      {
        "step": 4,
        "action": "Sort events",
        "state": "[(0,+1), (1000,+1), (1500,+1), (2500,-1), (3000,-1), (4000,-1)]",
        "explanation": "Sort by (time, delta) puts them in chronological order"
      },
      {
        "step": 5,
        "action": "Sweep: t=0",
        "state": "current=1, max=1",
        "explanation": "D1 starts"
      },
      {
        "step": 6,
        "action": "Sweep: t=1000",
        "state": "current=2, max=2",
        "explanation": "D2 starts"
      },
      {
        "step": 7,
        "action": "Sweep: t=1500",
        "state": "current=3, max=3",
        "explanation": "D3 starts - MAXIMUM REACHED"
      },
      {
        "step": 8,
        "action": "Sweep: t=2500",
        "state": "current=2, max=3",
        "explanation": "D2 ends"
      },
      {
        "step": 9,
        "action": "Sweep: t=3000",
        "state": "current=1, max=3",
        "explanation": "D1 ends"
      },
      {
        "step": 10,
        "action": "Sweep: t=4000",
        "state": "current=0, max=3",
        "explanation": "D3 ends"
      }
    ],
    "final_output": "3"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Empty deliveries list \u2192 return 0",
      "Single delivery in window \u2192 return 1",
      "Two non-overlapping \u2192 return 1"
    ],
    "likely_bugs": [
      "Forgetting to clip to window boundaries",
      "Wrong sort order (starts before ends at same time)",
      "Off-by-one in window comparison (< vs <=)"
    ],
    "recommended_logs_or_asserts": [
      "Print events list after sorting",
      "Print current_active after each event",
      "Assert current_active >= 0 after sweep"
    ],
    "how_to_localize": "1. Print window bounds. 2. Print which deliveries pass filter. 3. Print sorted events. 4. Print running count at each step."
  },
  "edge_cases": [
    {
      "case": "No deliveries",
      "handling": "Return 0 (events list empty)",
      "gotcha": "Don't process empty list"
    },
    {
      "case": "All deliveries outside window",
      "handling": "Filter removes all, return 0",
      "gotcha": "Check both boundaries correctly"
    },
    {
      "case": "Delivery ends exactly at window start",
      "handling": "Skip (end <= window_start)",
      "gotcha": "Use <= not < for end boundary"
    },
    {
      "case": "Delivery starts exactly at window end",
      "handling": "Skip (start >= window_end)",
      "gotcha": "Use >= not > for start boundary"
    },
    {
      "case": "Same start and end times for different deliveries",
      "handling": "Sort puts ends before starts, so transitioning drivers count correctly",
      "gotcha": "Sorting by (time, delta) handles this"
    },
    {
      "case": "Delivery spans entire window",
      "handling": "Clip to window, counts for full duration",
      "gotcha": "max/min clipping handles this"
    }
  ],
  "test_cases": [
    {
      "name": "Three overlapping drivers - peak at middle",
      "input": "D1[0,3000], D2[1000,2500], D3[1500,4000], query at 86400",
      "expected": "3",
      "explanation": "All three overlap at t=1500 to t=2500"
    },
    {
      "name": "Non-overlapping deliveries",
      "input": "D1[0,1000], D2[2000,3000], query at 86400",
      "expected": "1",
      "explanation": "D1 ends before D2 starts, never more than 1 active"
    },
    {
      "name": "Partial window overlap",
      "input": "D1[80000,90000], query at 86500",
      "expected": "1",
      "explanation": "Window is [100, 86500], delivery [80000,90000] clipped to [80000, 86500]"
    },
    {
      "name": "All deliveries before window",
      "input": "D1[0,1000], query at 100000",
      "expected": "0",
      "explanation": "Window is [13600, 100000], D1 ends at 1000 which is before window"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not clipping intervals to window",
      "why_wrong": "A delivery from t=0 to t=100000 would count as active for entire window, but we should only consider the portion within window",
      "correct_approach": "Use max(start, window_start) and min(end, window_end)",
      "code_example_wrong": "events.append((start, 1))",
      "code_example_correct": "clipped_start = max(start, window_start)\\nevents.append((clipped_start, 1))"
    },
    {
      "mistake": "Wrong event ordering at same timestamp",
      "why_wrong": "If end and start happen at same time, putting start first overcounts overlap",
      "correct_approach": "Sort by (time, delta) so -1 comes before +1",
      "code_example_wrong": "events.sort(key=lambda x: x[0])",
      "code_example_correct": "events.sort(key=lambda x: (x[0], x[1]))"
    },
    {
      "mistake": "Using wrong comparison for window boundaries",
      "why_wrong": "end <= window_start means delivery ends at or before window starts (no overlap). start >= window_end means delivery starts at or after window ends (no overlap)",
      "correct_approach": "Strict inequality on one side, inclusive on other",
      "code_example_wrong": "if end < window_start or start > window_end:",
      "code_example_correct": "if end <= window_start or start >= window_end:"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by recognizing this as Meeting Rooms II / interval overlap problem. Explain line sweep concept with +1/-1 events before coding. Draw a timeline showing how count changes.",
    "what_to_mention": [
      "This is O(n log n) dominated by sorting",
      "Line sweep is a classic technique for interval problems",
      "Clipping to window is important for correctness",
      "Event ordering at same timestamp matters"
    ],
    "time_allocation": "2 min recognize pattern, 3 min explain approach, 5 min implement, 2 min test",
    "if_stuck": [
      "Think: when does the count change?",
      "Only at start and end of intervals",
      "What if we sorted all those moments?",
      "How do we handle same-time events?"
    ]
  },
  "connection_to_next_part": "Part 4 might add per-driver analytics (cost per driver, busiest driver) or real-time streaming max. The _deliveries list is ready to support per-driver queries by filtering on driver_id. For streaming, we might need a segment tree or different approach.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2's payment tracking is working. For Part 3, I need to find the maximum number of concurrent active drivers in a 24-hour window. This is essentially the Meeting Rooms II problem!",
    "explaining_changes": "The key change is adding a _deliveries list to store all delivery intervals. The line sweep algorithm creates +1 events at starts and -1 at ends, sorts them, and sweeps through tracking the running count.",
    "while_extending_code": [
      "I'm adding _deliveries to store intervals for analytics...",
      "In add_delivery, I append the interval tuple...",
      "The new method filters to window, creates events, sorts by (time, delta), and sweeps..."
    ],
    "after_completing": "This handles Part 3 with O(n log n) for the analytics query. The existing O(log n) operations are unchanged. Ready for Part 4!"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Recognize as interval overlap / Meeting Rooms II problem. Identify need to store intervals.",
    "by_5_min": "Explain line sweep approach. Start modifying add_delivery and adding new method.",
    "by_10_min": "Implementation done. Testing with the overlapping example.",
    "warning_signs": "If still explaining approach at 5 min, start coding. If stuck on event ordering, ask for hint."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 3 is largely independent. If heap from Part 2 has issues, the analytics still works since it uses _deliveries not _unpaid.",
    "if_new_requirement_unclear": "Ask: 'For the 24-hour window, is it [T-86400, T] inclusive on both ends, or half-open?' Usually half-open [start, end).",
    "if_running_behind": "Skip clipping optimization first - it's correct without clipping, just slightly inefficient. Add clipping after core works."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing Meeting Rooms II pattern",
      "Explaining why sort order matters for same-timestamp events",
      "Mentioning the clipping requirement for window boundaries",
      "Discussing O(n log n) vs O(n\u00b2) approaches",
      "Proactively mentioning segment tree for real-time queries"
    ]
  },
  "pattern_recognition": {
    "pattern": "Line Sweep / Event-based Interval Processing",
    "indicators": [
      "Find maximum overlap/concurrent count",
      "Interval data",
      "Questions about 'at any point in time'"
    ],
    "similar_problems": [
      "LC 253 - Meeting Rooms II",
      "LC 56 - Merge Intervals",
      "LC 252 - Meeting Rooms",
      "LC 759 - Employee Free Time",
      "Skyline Problem"
    ],
    "template": "```python\\n# Line Sweep Template\\nevents = []\\nfor start, end in intervals:\\n    events.append((start, +1))  # or START constant\\n    events.append((end, -1))    # or END constant\\nevents.sort(key=lambda x: (x[0], x[1]))  # time, then type\\ncount = max_count = 0\\nfor _, delta in events:\\n    count += delta\\n    max_count = max(max_count, count)\\nreturn max_count\\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'maximum concurrent' or 'maximum overlap', I immediately think of Meeting Rooms II and line sweep.",
      "why": "This is a classic pattern - converting interval queries to event processing."
    },
    {
      "step": 2,
      "thought": "I need to track intervals, not just costs. Part 2 only stored end_time for payment.",
      "why": "Analytics needs start_time too, so I need to add storage."
    },
    {
      "step": 3,
      "thought": "The 24-hour window means I need to filter AND clip intervals.",
      "why": "Some deliveries might partially overlap with the window."
    },
    {
      "step": 4,
      "thought": "Event ordering at same timestamp: ends before starts.",
      "why": "If D1 ends at t=100 and D2 starts at t=100, they shouldn't count as overlapping at that instant."
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you recognize line sweep pattern?",
      "Can you extend Part 2 cleanly?",
      "Do you handle window boundaries correctly?",
      "Can you explain the algorithm clearly?"
    ],
    "bonus_points": [
      "Mentioning the sort order for same-timestamp events",
      "Discussing clipping",
      "Comparing to naive O(n\u00b2)",
      "Noting this is similar to Meeting Rooms II"
    ],
    "red_flags": [
      "Rewriting from scratch instead of extending",
      "Not recognizing the pattern after hints",
      "Incorrect window boundary handling",
      "O(n\u00b2) approach without acknowledging inefficiency"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate the event creation loop",
      "Let it help with sort key syntax"
    ],
    "what_not_to_do": [
      "Don't accept without understanding why -1 comes before +1",
      "Verify the window filtering logic yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Taking too long to recognize the pattern",
      "Not asking about window boundary semantics"
    ],
    "technical": [
      "Forgetting to store intervals in Part 3 addition",
      "Wrong event ordering",
      "Not clipping to window"
    ],
    "communication": [
      "Not explaining line sweep before coding",
      "Not mentioning the complexity improvement over naive"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does line sweep sort events correctly (ends before starts)?",
      "Is window filtering correct (end <= start, start >= end)?",
      "Is clipping applied (max/min)?",
      "Does empty input return 0?",
      "Are Parts 1-2 still working?"
    ],
    "quick_code_review": [
      "_deliveries list added to __init__",
      "add_delivery appends to _deliveries",
      "New method has correct signature from problem",
      "SECONDS_IN_24_HOURS = 86400"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Index on time for faster filtering",
      "Caching recent analytics results",
      "Background computation for large datasets",
      "Metrics on query latency"
    ],
    "why_not_in_interview": "Focus on the algorithm; these are operational concerns",
    "how_to_mention": "Say: 'In production, I'd add caching since this analytics query might be called frequently for dashboards.'"
  },
  "generated_at": "2026-01-19T04:39:56.406749",
  "_meta": {
    "problem_id": "delivery_cost_tracking",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}