{
  "problem_title": "Employee Hierarchy / Org Tree - Part 2: Best Performing Team",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 handled basic org structure with O(1) lookups and direct report counts. Part 2 adds aggregate metrics that require tree traversal - computing team averages across entire subtrees and finding the global best performer.",
    "new_requirements": [
      "Define TeamStats class to hold totalRating, teamSize, and average",
      "get_team_stats(employee_id) - compute aggregate stats for employee's entire subtree",
      "get_best_performing_team_lead() - find employee with highest team average across entire org"
    ],
    "new_constraints": [
      "Team includes employee + ALL subordinates (direct and indirect)",
      "Average must handle division correctly",
      "Must handle empty org gracefully"
    ],
    "key_insight": "Post-order DFS (children first, then parent) allows computing subtree stats in O(n) total - each node aggregates its children's pre-computed stats rather than recomputing from scratch."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "get_team_stats returns correct aggregate",
        "how_met": "DFS accumulates (total, size) from all descendants",
        "gotchas": [
          "Off-by-one: don't forget to include the employee themselves"
        ]
      },
      {
        "requirement": "get_best_performing_team_lead finds global max",
        "how_met": "Single post-order traversal tracks best while computing stats",
        "gotchas": [
          "Leaf nodes often win since team of 1 = their individual rating"
        ]
      },
      {
        "requirement": "Handle empty org",
        "how_met": "Return None/null when ceo is null",
        "gotchas": [
          "Don't assume org is non-empty"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "get_team_stats",
        "target": "O(subtree)",
        "achieved": "O(k) where k = subtree size",
        "why": "Visit each node in subtree exactly once"
      },
      {
        "operation": "get_best_performing_team_lead",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Single post-order DFS visits each node once"
      }
    ],
    "non_goals": [
      "Caching team stats (would complicate Part 1's add_employee)",
      "Tie-breaking rules (any max is acceptable)"
    ]
  },
  "assumptions": [
    "Ratings are always positive integers (affects whether 0 is a valid team average)",
    "No need to handle floating-point precision issues beyond basic division",
    "Ties in average can return any valid employee",
    "Ask interviewer: Should get_team_stats for non-existent ID return null or throw?"
  ],
  "tradeoffs": [
    {
      "decision": "Recompute vs Cache team stats",
      "chosen": "Recompute on demand",
      "why": "Keeps add_employee O(1), avoids cache invalidation complexity",
      "alternative": "Cache and update on add",
      "when_to_switch": "If team stats queried very frequently and org changes rarely"
    },
    {
      "decision": "Single traversal vs separate traversal for best",
      "chosen": "Single post-order DFS",
      "why": "O(n) once vs O(n\u00b2) if we called get_team_stats for each employee",
      "alternative": "Call get_team_stats per employee",
      "when_to_switch": "Never - strictly worse"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Employee class structure",
      "HashMap for O(1) lookup",
      "Bidirectional tree links"
    ],
    "what_to_change": [
      "Added TeamStats class",
      "Added helper _compute_team_stats method"
    ],
    "interfaces_and_boundaries": "DFS helper returns tuple (total, size) making it composable. Could easily extend to track other aggregate metrics.",
    "invariants": [
      "TeamStats.average = total_rating / team_size",
      "Team always includes the root employee",
      "DFS visits each node exactly once"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1):                 AFTER (Part 2):\n+-----------------+              +-----------------+\n| OrgChart        |              | OrgChart        |\n| - employees{}   |              | - employees{}   |\n| - ceo           |              | - ceo           |\n| + add_employee  |              | + add_employee  |\n| + get_direct_   |              | + get_direct_   |\n|   report_count  |      +------>|   report_count  |\n+-----------------+      |       | + get_team_stats|\n                         |       | + get_best_...  |\n                         |       +-----------------+\n                         |       \n                         |       + TeamStats class\n```",
    "algorithm_flow": "```\nPOST-ORDER DFS FOR get_best_performing_team_lead:\n\n        A(5)                Step 1: Go left to B\n       / \\                  Step 2: B is leaf \u2192 (3,1), avg=3.0\n    B(3)  C(2)              Step 3: Go right to C\n          / \\               Step 4: Go to D \u2192 (4,1), avg=4.0\n       D(4) E(10)           Step 5: Go to E \u2192 (10,1), avg=10.0 \u2605 BEST!\n                            Step 6: C combines: 2+4+10=16, size=3, avg=5.33\n                            Step 7: A combines: 5+3+16=24, size=5, avg=4.8\n                            \nResult: E (highest avg 10.0)\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "For get_best_performing_team_lead: iterate all employees, call get_team_stats for each, track max",
      "time_complexity": "O(n\u00b2)",
      "space_complexity": "O(h) recursion depth",
      "why_not_optimal": "Redundant computation: get_team_stats for CEO recomputes entire tree, then we'd call it again for subtrees"
    },
    {
      "name": "Optimal: Single Post-Order DFS",
      "description": "One traversal computes all team stats bottom-up. Each node aggregates children's pre-computed results and compares with running max.",
      "time_complexity": "O(n)",
      "space_complexity": "O(h) recursion stack",
      "key_insight": "Post-order means children are fully processed before parent. Parent just sums children's totals + self.rating, no recomputation."
    }
  ],
  "optimal_solution": {
    "explanation_md": "We use **post-order DFS** traversal where each node:\n1. Recursively processes all children first\n2. Receives `(total_rating, team_size)` tuples from each child\n3. Computes own stats: `(self.rating + \u03a3 child_totals, 1 + \u03a3 child_sizes)`\n4. Compares own average with running maximum\n5. Returns own stats to parent\n\n**Why this works:** Each employee's team stats depend only on their subtree. Post-order ensures subtrees are computed before we need them. The running maximum is tracked during traversal via a mutable container (list/array).\n\n**Edge cases:** Empty org returns `None`. Single employee (CEO only) returns CEO with their individual rating as the team average.",
    "data_structures": [
      {
        "structure": "TeamStats class",
        "purpose": "Encapsulate team metrics for clean return type"
      },
      {
        "structure": "Tuple/Array for DFS return",
        "purpose": "Return (total, size) up the recursion chain"
      },
      {
        "structure": "Mutable container for tracking best",
        "purpose": "Allow nested function to update best during traversal"
      }
    ],
    "algorithm_steps": [
      "1. Check if org is empty (ceo is None), return None if so",
      "2. Initialize tracking variables: best_employee = None, best_average = -\u221e",
      "3. Start post-order DFS from CEO",
      "4. At each node: recursively get (total, size) from each child",
      "5. Aggregate: node_total = self.rating + sum(child_totals), node_size = 1 + sum(child_sizes)",
      "6. Compute average = node_total / node_size, update best if higher",
      "7. Return (node_total, node_size) to parent",
      "8. After DFS completes, return best_employee"
    ]
  },
  "solution_python_lines": [
    "from typing import Optional, List, Dict",
    "",
    "class TeamStats:",
    "    \"\"\"Statistics for a team (employee + all subordinates).\"\"\"",
    "    def __init__(self, total_rating: int, team_size: int):",
    "        self.total_rating = total_rating",
    "        self.team_size = team_size",
    "        self.average = total_rating / team_size if team_size > 0 else 0.0",
    "",
    "",
    "class Employee:",
    "    \"\"\"Employee node in the organizational tree.\"\"\"",
    "    def __init__(self, id: int, name: str, rating: int):",
    "        self.id = id",
    "        self.name = name",
    "        self.rating = rating",
    "        self.manager: Optional['Employee'] = None",
    "        self.subordinates: List['Employee'] = []",
    "    ",
    "    def __repr__(self):",
    "        return f\"Employee({self.id}, '{self.name}', rating={self.rating})\"",
    "",
    "",
    "class OrgChart:",
    "    \"\"\"Org chart with hierarchy queries and team metrics.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.employees: Dict[int, Employee] = {}",
    "        self.ceo: Optional[Employee] = None",
    "    ",
    "    # ========== Part 1 Methods (unchanged) ==========",
    "    ",
    "    def add_employee(self, id: int, name: str, rating: int,",
    "                     manager_id: Optional[int]) -> bool:",
    "        \"\"\"Add employee. Returns False if ID exists or manager not found.\"\"\"",
    "        if id in self.employees:",
    "            return False",
    "        if manager_id is not None:",
    "            if manager_id not in self.employees:",
    "                return False",
    "            manager = self.employees[manager_id]",
    "        else:",
    "            if self.ceo is not None:",
    "                return False",
    "            manager = None",
    "        ",
    "        employee = Employee(id, name, rating)",
    "        employee.manager = manager",
    "        if manager is not None:",
    "            manager.subordinates.append(employee)",
    "        else:",
    "            self.ceo = employee",
    "        self.employees[id] = employee",
    "        return True",
    "    ",
    "    def get_direct_report_count(self, employee_id: int) -> int:",
    "        \"\"\"Returns count of direct reports, -1 if not found.\"\"\"",
    "        if employee_id not in self.employees:",
    "            return -1",
    "        return len(self.employees[employee_id].subordinates)",
    "    ",
    "    def get_employee(self, employee_id: int) -> Optional[Employee]:",
    "        \"\"\"Returns employee or None if not found.\"\"\"",
    "        return self.employees.get(employee_id)",
    "    ",
    "    # ========== Part 2 Methods (new) ==========",
    "    ",
    "    def get_team_stats(self, employee_id: int) -> Optional[TeamStats]:",
    "        \"\"\"Get team stats (total rating, size, average) for subtree.\"\"\"",
    "        if employee_id not in self.employees:",
    "            return None",
    "        total, size = self._compute_subtree_stats(self.employees[employee_id])",
    "        return TeamStats(total, size)",
    "    ",
    "    def _compute_subtree_stats(self, emp: Employee) -> tuple:",
    "        \"\"\"DFS helper: returns (total_rating, team_size) for subtree.\"\"\"",
    "        total, size = emp.rating, 1",
    "        for sub in emp.subordinates:",
    "            sub_total, sub_size = self._compute_subtree_stats(sub)",
    "            total += sub_total",
    "            size += sub_size",
    "        return (total, size)",
    "    ",
    "    def get_best_performing_team_lead(self) -> Optional[Employee]:",
    "        \"\"\"Find employee with highest team average. O(n) single pass.\"\"\"",
    "        if self.ceo is None:",
    "            return None",
    "        ",
    "        # Mutable container to track best during DFS",
    "        best = [None, float('-inf')]  # [employee, average]",
    "        self._find_best_dfs(self.ceo, best)",
    "        return best[0]",
    "    ",
    "    def _find_best_dfs(self, emp: Employee, best: list) -> tuple:",
    "        \"\"\"Post-order DFS: compute stats and track max average.\"\"\"",
    "        total, size = emp.rating, 1",
    "        ",
    "        # Process children first (post-order)",
    "        for sub in emp.subordinates:",
    "            sub_total, sub_size = self._find_best_dfs(sub, best)",
    "            total += sub_total",
    "            size += sub_size",
    "        ",
    "        # Update best if this team has higher average",
    "        avg = total / size",
    "        if avg > best[1]:",
    "            best[0], best[1] = emp, avg",
    "        ",
    "        return (total, size)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"Part 2: Best Performing Team\")",
    "    print(\"=\" * 60)",
    "    ",
    "    org = OrgChart()",
    "    ",
    "    # Build example org: A(5) -> B(3), C(2) -> D(4), E(10)",
    "    print(\"\\n1. Building organization...\")",
    "    org.add_employee(1, 'A', 5, None)   # CEO",
    "    org.add_employee(2, 'B', 3, 1)",
    "    org.add_employee(3, 'C', 2, 1)",
    "    org.add_employee(4, 'D', 4, 3)",
    "    org.add_employee(5, 'E', 10, 3)",
    "    print(\"   Built: A(5) -> B(3), C(2) -> D(4), E(10)\")",
    "    ",
    "    # Test get_team_stats",
    "    print(\"\\n2. Team Statistics:\")",
    "    stats_a = org.get_team_stats(1)",
    "    print(f\"   Team A: total={stats_a.total_rating}, size={stats_a.team_size}, avg={stats_a.average:.2f}\")",
    "    stats_c = org.get_team_stats(3)",
    "    print(f\"   Team C: total={stats_c.total_rating}, size={stats_c.team_size}, avg={stats_c.average:.2f}\")",
    "    stats_e = org.get_team_stats(5)",
    "    print(f\"   Team E: total={stats_e.total_rating}, size={stats_e.team_size}, avg={stats_e.average:.2f}\")",
    "    ",
    "    # Test get_best_performing_team_lead",
    "    print(\"\\n3. Best Performing Team Lead:\")",
    "    best = org.get_best_performing_team_lead()",
    "    print(f\"   Winner: {best.name} (id={best.id}) with team avg = {best.rating}.0\")",
    "    ",
    "    # Edge cases",
    "    print(\"\\n4. Edge Cases:\")",
    "    print(f\"   get_team_stats(999): {org.get_team_stats(999)}\")",
    "    empty_org = OrgChart()",
    "    print(f\"   Empty org best lead: {empty_org.get_best_performing_team_lead()}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 2 tests passed!\")"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "public class OrgChart {",
    "    private Map<Integer, Employee> employees = new HashMap<>();",
    "    private Employee ceo = null;",
    "    ",
    "    /** Employee node in the organizational tree. */",
    "    public static class Employee {",
    "        int id;",
    "        String name;",
    "        int rating;",
    "        Employee manager;",
    "        List<Employee> subordinates = new ArrayList<>();",
    "        ",
    "        Employee(int id, String name, int rating) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.rating = rating;",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return \"Employee(\" + id + \", '\" + name + \"', rating=\" + rating + \")\";",
    "        }",
    "    }",
    "    ",
    "    /** Team statistics for an employee's subtree. */",
    "    public static class TeamStats {",
    "        public int totalRating;",
    "        public int teamSize;",
    "        public double average;",
    "        ",
    "        TeamStats(int totalRating, int teamSize) {",
    "            this.totalRating = totalRating;",
    "            this.teamSize = teamSize;",
    "            this.average = teamSize > 0 ? (double) totalRating / teamSize : 0.0;",
    "        }",
    "    }",
    "    ",
    "    // ========== Part 1 Methods (unchanged) ==========",
    "    ",
    "    public boolean addEmployee(int id, String name, int rating, Integer managerId) {",
    "        if (employees.containsKey(id)) return false;",
    "        ",
    "        Employee manager;",
    "        if (managerId != null) {",
    "            if (!employees.containsKey(managerId)) return false;",
    "            manager = employees.get(managerId);",
    "        } else {",
    "            if (ceo != null) return false;",
    "            manager = null;",
    "        }",
    "        ",
    "        Employee employee = new Employee(id, name, rating);",
    "        employee.manager = manager;",
    "        if (manager != null) {",
    "            manager.subordinates.add(employee);",
    "        } else {",
    "            ceo = employee;",
    "        }",
    "        employees.put(id, employee);",
    "        return true;",
    "    }",
    "    ",
    "    public int getDirectReportCount(int employeeId) {",
    "        if (!employees.containsKey(employeeId)) return -1;",
    "        return employees.get(employeeId).subordinates.size();",
    "    }",
    "    ",
    "    public Employee getEmployee(int employeeId) {",
    "        return employees.get(employeeId);",
    "    }",
    "    ",
    "    // ========== Part 2 Methods (new) ==========",
    "    ",
    "    /** Get team stats for employee's subtree. */",
    "    public TeamStats getTeamStats(int employeeId) {",
    "        if (!employees.containsKey(employeeId)) return null;",
    "        int[] stats = computeSubtreeStats(employees.get(employeeId));",
    "        return new TeamStats(stats[0], stats[1]);",
    "    }",
    "    ",
    "    /** DFS helper: returns [totalRating, teamSize] for subtree. */",
    "    private int[] computeSubtreeStats(Employee emp) {",
    "        int total = emp.rating, size = 1;",
    "        for (Employee sub : emp.subordinates) {",
    "            int[] subStats = computeSubtreeStats(sub);",
    "            total += subStats[0];",
    "            size += subStats[1];",
    "        }",
    "        return new int[]{total, size};",
    "    }",
    "    ",
    "    /** Find employee with highest team average. O(n) single pass. */",
    "    public Employee getBestPerformingTeamLead() {",
    "        if (ceo == null) return null;",
    "        ",
    "        Employee[] best = {null};",
    "        double[] bestAvg = {Double.NEGATIVE_INFINITY};",
    "        findBestDFS(ceo, best, bestAvg);",
    "        return best[0];",
    "    }",
    "    ",
    "    /** Post-order DFS: compute stats and track max average. */",
    "    private int[] findBestDFS(Employee emp, Employee[] best, double[] bestAvg) {",
    "        int total = emp.rating, size = 1;",
    "        ",
    "        for (Employee sub : emp.subordinates) {",
    "            int[] subStats = findBestDFS(sub, best, bestAvg);",
    "            total += subStats[0];",
    "            size += subStats[1];",
    "        }",
    "        ",
    "        double avg = (double) total / size;",
    "        if (avg > bestAvg[0]) {",
    "            best[0] = emp;",
    "            bestAvg[0] = avg;",
    "        }",
    "        return new int[]{total, size};",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Part 2: Best Performing Team\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        OrgChart org = new OrgChart();",
    "        ",
    "        System.out.println(\"\\n1. Building organization...\");",
    "        org.addEmployee(1, \"A\", 5, null);",
    "        org.addEmployee(2, \"B\", 3, 1);",
    "        org.addEmployee(3, \"C\", 2, 1);",
    "        org.addEmployee(4, \"D\", 4, 3);",
    "        org.addEmployee(5, \"E\", 10, 3);",
    "        System.out.println(\"   Built: A(5) -> B(3), C(2) -> D(4), E(10)\");",
    "        ",
    "        System.out.println(\"\\n2. Team Statistics:\");",
    "        TeamStats statsA = org.getTeamStats(1);",
    "        System.out.printf(\"   Team A: total=%d, size=%d, avg=%.2f%n\",",
    "            statsA.totalRating, statsA.teamSize, statsA.average);",
    "        TeamStats statsE = org.getTeamStats(5);",
    "        System.out.printf(\"   Team E: total=%d, size=%d, avg=%.2f%n\",",
    "            statsE.totalRating, statsE.teamSize, statsE.average);",
    "        ",
    "        System.out.println(\"\\n3. Best Performing Team Lead:\");",
    "        Employee best = org.getBestPerformingTeamLead();",
    "        System.out.println(\"   Winner: \" + best.name + \" with team avg = \" + best.rating + \".0\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All Part 2 tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "explanation": "TeamStats class: encapsulates team metrics with computed average"
    },
    {
      "lines": "65-69",
      "explanation": "get_team_stats: lookup employee, call DFS helper, wrap result"
    },
    {
      "lines": "71-78",
      "explanation": "_compute_subtree_stats: classic post-order DFS returning (total, size) tuple"
    },
    {
      "lines": "80-91",
      "explanation": "get_best_performing_team_lead: initializes mutable best tracker, starts DFS from CEO"
    },
    {
      "lines": "93-106",
      "explanation": "_find_best_dfs: processes children first, aggregates their stats, compares with best, returns own stats"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_team_stats": {
          "complexity": "O(k)",
          "explanation": "k = subtree size. Visit each node in subtree once."
        },
        "get_best_performing_team_lead": {
          "complexity": "O(n)",
          "explanation": "Single post-order DFS visits each of n employees exactly once."
        }
      },
      "overall_change": "Part 1 methods remain O(1). New methods add O(n) worst case for tree traversal."
    },
    "space": {
      "additional_space": "O(h)",
      "explanation": "h = tree height. Recursion stack depth. No new persistent data structures. TeamStats created on demand."
    }
  },
  "dry_run": {
    "example_input": "Org: A(5) -> B(3), C(2) -> D(4), E(10). Call get_best_performing_team_lead()",
    "steps": [
      {
        "step": 1,
        "action": "Start DFS at A",
        "state": "best=[None, -\u221e]",
        "explanation": "Begin post-order traversal from CEO"
      },
      {
        "step": 2,
        "action": "Recurse to B (A's first child)",
        "state": "At B",
        "explanation": "Must process children before A"
      },
      {
        "step": 3,
        "action": "B is leaf, compute stats",
        "state": "B: (3,1), avg=3.0",
        "explanation": "No children, stats = (rating, 1)"
      },
      {
        "step": 4,
        "action": "Update best: B",
        "state": "best=[B, 3.0]",
        "explanation": "3.0 > -\u221e"
      },
      {
        "step": 5,
        "action": "Return to A, recurse to C",
        "state": "At C",
        "explanation": "Process A's second child"
      },
      {
        "step": 6,
        "action": "Recurse from C to D",
        "state": "At D",
        "explanation": "Process C's children first"
      },
      {
        "step": 7,
        "action": "D is leaf, compute stats",
        "state": "D: (4,1), avg=4.0",
        "explanation": "Leaf node"
      },
      {
        "step": 8,
        "action": "Update best: D",
        "state": "best=[D, 4.0]",
        "explanation": "4.0 > 3.0"
      },
      {
        "step": 9,
        "action": "Recurse to E",
        "state": "At E",
        "explanation": "C's second child"
      },
      {
        "step": 10,
        "action": "E is leaf, compute stats",
        "state": "E: (10,1), avg=10.0",
        "explanation": "Leaf with high rating"
      },
      {
        "step": 11,
        "action": "Update best: E",
        "state": "best=[E, 10.0]",
        "explanation": "10.0 > 4.0 \u2605"
      },
      {
        "step": 12,
        "action": "Back to C, aggregate",
        "state": "C: (2+4+10, 1+1+1) = (16,3), avg=5.33",
        "explanation": "Sum children's stats + self"
      },
      {
        "step": 13,
        "action": "No update (5.33 < 10.0)",
        "state": "best=[E, 10.0]",
        "explanation": "E still best"
      },
      {
        "step": 14,
        "action": "Back to A, aggregate",
        "state": "A: (5+3+16, 1+1+3) = (24,5), avg=4.8",
        "explanation": "Final aggregation"
      },
      {
        "step": 15,
        "action": "No update (4.8 < 10.0)",
        "state": "best=[E, 10.0]",
        "explanation": "E remains best"
      }
    ],
    "final_output": "Employee E with team average 10.0"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single employee org \u2192 returns that employee",
      "All same ratings \u2192 any employee valid"
    ],
    "likely_bugs": [
      "Forgetting to add 1 for self in team_size",
      "Integer division instead of float",
      "Not handling empty org"
    ],
    "recommended_logs_or_asserts": [
      "Print (total, size, avg) at each node during DFS",
      "Assert team_size > 0 before division"
    ],
    "how_to_localize": "Add print at end of DFS helper showing employee name and computed stats. Compare with manual calculation."
  },
  "edge_cases": [
    {
      "case": "Empty organization",
      "handling": "Return None from get_best_performing_team_lead",
      "gotcha": "Don't call DFS on null CEO"
    },
    {
      "case": "Single employee (CEO only)",
      "handling": "Returns CEO, team of 1 with their own rating",
      "gotcha": "DFS should handle empty subordinates list"
    },
    {
      "case": "All employees have same rating",
      "handling": "Any employee is valid answer (leaf preferred by algorithm)",
      "gotcha": "Doesn't matter which, but be consistent"
    },
    {
      "case": "Non-existent employee ID",
      "handling": "get_team_stats returns None",
      "gotcha": "Check existence before DFS"
    }
  ],
  "test_cases": [
    {
      "name": "Example from problem",
      "input": "A(5)->B(3),C(2)->D(4),E(10)",
      "expected": "Best: E, Team A stats: (24, 5, 4.8)",
      "explanation": "E as leaf has avg=10.0, highest possible"
    },
    {
      "name": "Single employee",
      "input": "CEO only with rating 7",
      "expected": "Best: CEO, stats: (7, 1, 7.0)",
      "explanation": "Team of 1 is just themselves"
    },
    {
      "name": "Linear chain",
      "input": "A(1)->B(2)->C(3)",
      "expected": "Best: C (avg=3.0)",
      "explanation": "Leaf has highest individual rating, wins"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Calling get_team_stats for every employee in a loop",
      "why_wrong": "O(n\u00b2) - recomputes same subtrees multiple times",
      "correct_approach": "Single post-order DFS that computes and compares in one pass",
      "code_example_wrong": "for emp in employees: stats = get_team_stats(emp.id); if stats.avg > max...",
      "code_example_correct": "Single DFS with best tracker passed through recursion"
    },
    {
      "mistake": "Integer division for average",
      "why_wrong": "In Python 2 or Java without cast, 5/2 = 2 not 2.5",
      "correct_approach": "Use float division: Python 3 / operator, Java (double) cast",
      "code_example_wrong": "avg = total / size  # Java: int/int",
      "code_example_correct": "avg = (double) total / size"
    },
    {
      "mistake": "Not including employee in their own team",
      "why_wrong": "Team is employee + subordinates, forgetting +1 for self",
      "correct_approach": "Initialize total=emp.rating, size=1 before processing children",
      "code_example_wrong": "total, size = 0, 0; for sub in subordinates...",
      "code_example_correct": "total, size = emp.rating, 1; for sub in subordinates..."
    }
  ],
  "interview_tips": {
    "how_to_present": "First explain team definition (employee + ALL subordinates). Then identify naive vs optimal approach. Emphasize O(n) single-pass solution.",
    "what_to_mention": [
      "Post-order DFS pattern",
      "Why leaf nodes often win (team of 1)",
      "Avoiding redundant computation"
    ],
    "time_allocation": "2 min understand, 3 min explain approach, 8 min code, 2 min test",
    "if_stuck": [
      "Think about what info you need to pass up the tree",
      "What if you computed stats for leaves first?"
    ]
  },
  "connection_to_next_part": "Part 2's DFS infrastructure could extend to: find highest-rated employee in subtree, count employees below threshold, compute team salary totals. The pattern of aggregating child results + self is reusable.",
  "communication_script": {
    "transition_from_previous": "Part 1 gave us the tree structure. For Part 2, I need to compute aggregate metrics across subtrees. The key insight is using post-order DFS to avoid redundant computation.",
    "explaining_changes": "I'm adding a TeamStats class and two new methods. The critical method uses post-order DFS - process children first, then aggregate their stats with the current node.",
    "while_extending_code": [
      "Adding TeamStats to hold the metrics...",
      "The DFS helper returns (total, size) tuple so parent can aggregate...",
      "Tracking best via mutable container to avoid global state..."
    ],
    "after_completing": "Now get_best_performing_team_lead is O(n) with a single traversal, and get_team_stats is O(subtree size). The existing Part 1 methods are unchanged."
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Understand team definition, identify post-order DFS approach",
    "by_5_min": "TeamStats class done, explaining DFS algorithm",
    "by_10_min": "Both methods implemented, starting to test",
    "warning_signs": "If still designing at 6 min, start coding with basic version"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 2 only reads the tree structure, doesn't modify it. If Part 1 has issues, they're unlikely to affect Part 2 logic.",
    "if_new_requirement_unclear": "Ask: 'Does the team include indirect reports? Just direct?' (Answer: all subordinates)",
    "if_running_behind": "Implement get_team_stats first (simpler DFS), then adapt for best_performing by adding tracking"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing post-order DFS pattern",
      "Explaining why naive is O(n\u00b2) and optimal is O(n)",
      "Noting leaf nodes often win without being asked",
      "Clean separation of helper method for reusability"
    ]
  },
  "pattern_recognition": {
    "pattern": "Post-order DFS with Bottom-up Aggregation",
    "indicators": [
      "Need aggregate stats for subtrees",
      "Children's data needed before parent",
      "Tree structure with queries on subtrees"
    ],
    "similar_problems": [
      "LC 124 - Binary Tree Maximum Path Sum",
      "LC 543 - Diameter of Binary Tree",
      "LC 1448 - Count Good Nodes"
    ],
    "template": "def dfs(node): if not node: return base_case; left = dfs(left); right = dfs(right); result = combine(left, right, node); update_global_if_needed(); return result"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Team includes ALL subordinates, so I need to traverse entire subtree",
      "why": "Can't just use direct reports list"
    },
    {
      "step": 2,
      "thought": "Computing stats for CEO includes computing for all children",
      "why": "Suggests recursive approach"
    },
    {
      "step": 3,
      "thought": "If I compute bottom-up, I can reuse child results",
      "why": "Post-order avoids redundant computation"
    },
    {
      "step": 4,
      "thought": "Track best during traversal instead of separate loop",
      "why": "Reduces from O(n\u00b2) to O(n)"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you identify the O(n\u00b2) vs O(n) distinction?",
      "Do you recognize post-order DFS pattern?",
      "Is your code clean and bug-free?"
    ],
    "bonus_points": [
      "Explaining why leaves often win",
      "Mentioning this pattern applies to many tree problems",
      "Clean helper function design"
    ],
    "red_flags": [
      "Calling get_team_stats in a loop (O(n\u00b2))",
      "Forgetting to include employee in their own team",
      "Not handling empty org"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with TeamStats class boilerplate",
      "Use AI for the DFS structure if familiar with pattern"
    ],
    "what_not_to_do": [
      "Don't let AI generate O(n\u00b2) solution",
      "Verify the aggregation logic yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining approach",
      "Not tracing through example"
    ],
    "technical": [
      "Using global variables instead of passing through recursion",
      "Modifying Part 1 methods unnecessarily"
    ],
    "communication": [
      "Not explaining why post-order matters",
      "Forgetting to state time complexity"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "get_team_stats returns correct stats for CEO (full org)?",
      "get_best_performing_team_lead handles empty org?",
      "Time complexity is O(n) not O(n\u00b2)?",
      "TeamStats has all three fields?"
    ],
    "quick_code_review": [
      "DFS initializes total=rating, size=1",
      "Division uses float not int",
      "Helper returns tuple for aggregation"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Cache team stats with invalidation on employee add",
      "Lazy computation for rarely-used stats",
      "Logging for performance monitoring"
    ],
    "why_not_in_interview": "Caching adds complexity, Part 3 might require different invalidation strategy",
    "how_to_mention": "Say: 'In production, if this is called frequently, I'd cache team stats and invalidate on structural changes.'"
  },
  "generated_at": "2026-01-19T04:20:49.634962",
  "_meta": {
    "problem_id": "employee_hierarchy_org_tree",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}