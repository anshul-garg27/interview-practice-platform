{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 4: Direct Messaging (DMs)",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 adds a complete real-time messaging layer on top of the existing photo-sharing platform. This requires new data models for Messages and Conversations, participant tracking for group chats, read receipt state management, and efficient conversation/message retrieval with pagination.",
    "new_requirements": [
      "Send messages (text/photo/video) to conversations",
      "List user's conversations sorted by recency",
      "Retrieve paginated message history",
      "Track and update read receipts",
      "Support group chats with multiple participants"
    ],
    "new_constraints": [
      "Messages must maintain ordering within conversations",
      "Read receipts track per-user, per-message state",
      "Conversations are discoverable only by participants",
      "Group chats need efficient fan-out to all members"
    ],
    "key_insight": "Decouple conversation metadata from message storage. Conversations track participants and recency, while messages are stored separately and indexed by conversation_id. This enables O(1) message appends and O(page_size) reads."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Send message to conversation",
        "how_met": "send_message() creates Message, appends to conversation_messages, updates last_message_at",
        "gotchas": [
          "Must validate sender is participant",
          "Update conversation preview"
        ]
      },
      {
        "requirement": "List conversations by recency",
        "how_met": "get_conversations() fetches user's conversations, sorts by last_message_at",
        "gotchas": [
          "Empty conversations should still appear",
          "Pagination cursor for large lists"
        ]
      },
      {
        "requirement": "Paginated message history",
        "how_met": "get_messages() uses cursor-based pagination on conversation_messages",
        "gotchas": [
          "Cursor is message index, not ID",
          "Return oldest to newest within page"
        ]
      },
      {
        "requirement": "Read receipts",
        "how_met": "mark_as_read() adds user to read_by set for all messages up to given ID",
        "gotchas": [
          "Mark ALL prior messages as read, not just the one"
        ]
      },
      {
        "requirement": "Group chats",
        "how_met": "create_group_chat() creates Conversation with multiple participants",
        "gotchas": [
          "Creator is auto-added to participants",
          "Need index for all members"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "send_message",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Append to list, update metadata"
      },
      {
        "operation": "get_conversations",
        "target": "O(C log C)",
        "achieved": "O(C log C)",
        "why": "C = user's conversations, sort by recency"
      },
      {
        "operation": "get_messages",
        "target": "O(page_size)",
        "achieved": "O(page_size)",
        "why": "Cursor-based slice from list"
      },
      {
        "operation": "mark_as_read",
        "target": "O(M)",
        "achieved": "O(M)",
        "why": "M = messages to mark, set add is O(1)"
      },
      {
        "operation": "create_group_chat",
        "target": "O(P)",
        "achieved": "O(P)",
        "why": "P = participants, update each user's index"
      }
    ],
    "non_goals": [
      "End-to-end encryption (mentioned verbally)",
      "WebSocket real-time push (simulated in interview)",
      "Message deletion/editing",
      "Typing indicators"
    ]
  },
  "assumptions": [
    "Conversation must exist before sending messages (create via create_conversation or create_group_chat)",
    "1:1 conversations are unique per user pair (no duplicate DM threads)",
    "Read receipts mark all prior messages as read (not just the specified one)",
    "Messages are immutable after creation",
    "User IDs are valid and registered"
  ],
  "tradeoffs": [
    {
      "decision": "Store messages in list vs tree",
      "chosen": "List (append-only)",
      "why": "Messages are always added at end, pagination is by index, O(1) append",
      "alternative": "B-tree for range queries",
      "when_to_switch": "If need complex timestamp range queries or message deletion"
    },
    {
      "decision": "Conversation indexing approach",
      "chosen": "user_conversations mapping for fast lookup",
      "why": "O(1) to get user's conversations, trade space for time",
      "alternative": "Scan all conversations filtering by participant",
      "when_to_switch": "Never - this is strictly better"
    },
    {
      "decision": "Read receipts per-message vs per-conversation",
      "chosen": "Per-message Set of user_ids",
      "why": "Precise tracking of exactly which messages each user has seen",
      "alternative": "Per-conversation 'last_read_message_id' pointer",
      "when_to_switch": "If read tracking overhead is too high at scale"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1-3 public methods unchanged",
      "Message and Conversation dataclass fields",
      "user_conversations index structure"
    ],
    "what_to_change": [
      "Added conversations, messages, conversation_messages, user_conversations dicts",
      "Added MessageType enum, Message, Conversation dataclasses"
    ],
    "interfaces_and_boundaries": "DM functionality is self-contained. Future parts could add reactions (extend Message), message search (index on content), or encryption (wrap content).",
    "invariants": [
      "conversation_messages[conv_id] contains valid message_ids in chronological order",
      "Every participant in conv.participants has conv_id in their user_conversations",
      "Message.sender_id is always in the conversation's participants",
      "Conversation.last_message_at >= all message timestamps in that conversation"
    ]
  },
  "visual_explanation": {
    "before_after": "Before Part 4:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Users \u2192 Posts \u2192 Feed \u2192 Stories    \u2502\n\u2502  Search \u2192 Explore \u2192 Trending        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAfter Part 4:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Users \u2192 Posts \u2192 Feed \u2192 Stories                 \u2502\n\u2502  Search \u2192 Explore \u2192 Trending                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502        DIRECT MESSAGING                 \u2502   \u2502\n\u2502  \u2502  Conversations \u2500\u252c\u2500\u25ba Messages (ordered)  \u2502   \u2502\n\u2502  \u2502                 \u2514\u2500\u25ba Read Receipts       \u2502   \u2502\n\u2502  \u2502  user_conversations (fast lookup)       \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "algorithm_flow": "send_message Flow:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Sender  \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n     \u2502 1. send_message(sender_id, conv_id, msg)\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Validate sender   \u2502\u2500\u2500 Not participant \u2500\u2500\u25ba Error\n\u2502 is participant    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 2. Create Message object\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Store in messages \u2502\n\u2502 dict by msg_id    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 3. Append to conversation_messages[conv_id]\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Update conv       \u2502\n\u2502 last_message_at   \u2502\n\u2502 preview           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 4. Return message_id\n         \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 Done \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Store messages directly in Conversation object, scan all conversations for user lookup",
      "time_complexity": "O(C) for get_conversations where C = total conversations",
      "space_complexity": "O(M) messages stored",
      "why_not_optimal": "Without user_conversations index, finding a user's conversations requires scanning all. Without separate message storage, large conversations become unwieldy."
    },
    {
      "name": "Optimal Approach",
      "description": "Separate indices: user_conversations for O(1) user lookup, conversation_messages for ordered message storage, conversations for metadata only",
      "time_complexity": "O(1) send, O(C log C) get_conversations, O(page) get_messages",
      "space_complexity": "O(M + C + U*avg_convs) for messages, conversations, and user index",
      "key_insight": "Decouple concerns: metadata (Conversation) from content (Messages) from access patterns (user_conversations index)"
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution adds **four key data structures**:\n\n1. **conversations**: Maps conversation_id \u2192 Conversation metadata (participants, name, timestamps)\n2. **messages**: Maps message_id \u2192 Message content and read state\n3. **conversation_messages**: Maps conversation_id \u2192 ordered list of message_ids (chronological)\n4. **user_conversations**: Maps user_id \u2192 set of conversation_ids (for fast lookup)\n\n**Key design decisions:**\n\n- **Conversation uniqueness for 1:1**: `create_conversation` checks for existing conversation between two users using `_get_dm_key()` helper\n- **Read receipts as sets**: Each Message has `read_by: Set[str]` tracking who has seen it\n- **Cursor pagination**: `get_messages` uses integer cursor as index into message list\n- **Automatic preview**: Conversations store `last_message_preview` (first 50 chars) for inbox display",
    "data_structures": [
      {
        "structure": "Dict[str, Conversation]",
        "purpose": "Store conversation metadata by ID"
      },
      {
        "structure": "Dict[str, Message]",
        "purpose": "Store all messages by ID"
      },
      {
        "structure": "Dict[str, List[str]]",
        "purpose": "conversation_messages: ordered message IDs per conversation"
      },
      {
        "structure": "Dict[str, Set[str]]",
        "purpose": "user_conversations: quick lookup of user's conversations"
      }
    ],
    "algorithm_steps": [
      "Step 1: For create_conversation/create_group_chat, generate unique ID, create Conversation, add to all participants' user_conversations index",
      "Step 2: For send_message, validate sender is participant, create Message, append to conversation_messages, update conversation timestamps",
      "Step 3: For get_conversations, fetch user's conversation IDs, load Conversation objects, sort by last_message_at descending",
      "Step 4: For get_messages, slice conversation_messages list using cursor, return Message objects",
      "Step 5: For mark_as_read, iterate messages up to specified ID, add user to each read_by set"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Instagram System Design - Part 4: Direct Messaging (DMs)",
    "Extends Part 3 with messaging and group chat functionality",
    "\"\"\"",
    "from typing import List, Dict, Optional, Set",
    "from dataclasses import dataclass, field",
    "from collections import defaultdict",
    "from datetime import datetime",
    "from enum import Enum",
    "import uuid",
    "import math",
    "",
    "",
    "@dataclass",
    "class Location:",
    "    lat: float",
    "    lng: float",
    "",
    "",
    "@dataclass",
    "class Post:",
    "    post_id: str",
    "    user_id: str",
    "    caption: str",
    "    image_urls: Dict[str, str]",
    "    tags: List[str]",
    "    location: Optional[Location]",
    "    created_at: int",
    "    like_count: int = 0",
    "    comment_count: int = 0",
    "",
    "",
    "@dataclass",
    "class FeedItem:",
    "    post_id: str",
    "    user_id: str",
    "    timestamp: int",
    "    is_celebrity: bool = False",
    "",
    "",
    "@dataclass",
    "class FeedResponse:",
    "    posts: List[Post]",
    "    next_cursor: Optional[str]",
    "",
    "",
    "class StoryType(Enum):",
    "    PHOTO = \"photo\"",
    "    VIDEO = \"video\"",
    "",
    "",
    "@dataclass",
    "class Story:",
    "    story_id: str",
    "    user_id: str",
    "    media_url: str",
    "    story_type: StoryType",
    "    created_at: int",
    "    expires_at: int",
    "    view_count: int = 0",
    "",
    "",
    "@dataclass",
    "class StoryRingUser:",
    "    user_id: str",
    "    has_unviewed: bool",
    "    latest_story_time: int",
    "",
    "",
    "@dataclass",
    "class StoryRing:",
    "    users: List[StoryRingUser]",
    "",
    "",
    "@dataclass",
    "class StoryFeed:",
    "    stories_by_user: Dict[str, List[Story]]",
    "",
    "",
    "@dataclass",
    "class User:",
    "    user_id: str",
    "    username: str",
    "    name: str = \"\"",
    "",
    "",
    "@dataclass",
    "class Hashtag:",
    "    tag: str",
    "    post_count: int",
    "",
    "",
    "@dataclass",
    "class ExploreFeed:",
    "    posts: List[Post]",
    "    next_cursor: Optional[str] = None",
    "",
    "",
    "# Part 4: New dataclasses",
    "class MessageType(Enum):",
    "    TEXT = \"text\"",
    "    PHOTO = \"photo\"",
    "    VIDEO = \"video\"",
    "",
    "",
    "@dataclass",
    "class Message:",
    "    message_id: str",
    "    sender_id: str",
    "    conversation_id: str",
    "    content: str",
    "    message_type: MessageType",
    "    created_at: int",
    "    read_by: Set[str] = field(default_factory=set)",
    "",
    "",
    "@dataclass",
    "class Conversation:",
    "    conversation_id: str",
    "    participants: Set[str]",
    "    name: Optional[str]",
    "    is_group: bool",
    "    created_at: int",
    "    last_message_at: int",
    "    last_message_preview: str = \"\"",
    "",
    "",
    "class Instagram:",
    "    \"\"\"Instagram with DM capabilities.\"\"\"",
    "    CELEBRITY_THRESHOLD = 10000",
    "    FEED_SIZE = 1000",
    "    STORY_TTL_SECONDS = 24 * 60 * 60",
    "    TRENDING_LIMIT = 10",
    "    ",
    "    def __init__(self):",
    "        # Part 1: Core data stores",
    "        self.users: Dict[str, dict] = {}",
    "        self.posts: Dict[str, Post] = {}",
    "        self.followers: Dict[str, Set[str]] = defaultdict(set)",
    "        self.following: Dict[str, Set[str]] = defaultdict(set)",
    "        self.feeds: Dict[str, List[FeedItem]] = defaultdict(list)",
    "        self.celebrity_posts: Dict[str, List[Post]] = defaultdict(list)",
    "        # Part 2: Stories",
    "        self.stories: Dict[str, Story] = {}",
    "        self.user_stories: Dict[str, List[str]] = defaultdict(list)",
    "        self.story_views: Dict[str, Set[str]] = defaultdict(set)",
    "        # Part 3: Search indices",
    "        self.user_index: Dict[str, User] = {}",
    "        self.hashtag_index: Dict[str, List[str]] = defaultdict(list)",
    "        self.hashtag_counts: Dict[str, int] = defaultdict(int)",
    "        # Part 4: Direct Messaging",
    "        self.conversations: Dict[str, Conversation] = {}",
    "        self.messages: Dict[str, Message] = {}",
    "        self.conversation_messages: Dict[str, List[str]] = defaultdict(list)",
    "        self.user_conversations: Dict[str, Set[str]] = defaultdict(set)",
    "        self.dm_index: Dict[str, str] = {}  # \"userA:userB\" -> conv_id for 1:1 lookup",
    "    ",
    "    # === Part 1 methods ===",
    "    def upload_photo(self, user_id: str, photo: bytes, caption: str,",
    "                     tags: List[str], location: Optional[Location]) -> str:",
    "        post_id = f\"post_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        image_urls = {",
    "            'thumbnail': f'cdn.instagram.com/{post_id}_150.jpg',",
    "            'large': f'cdn.instagram.com/{post_id}_1080.jpg'",
    "        }",
    "        post = Post(post_id=post_id, user_id=user_id, caption=caption,",
    "                    image_urls=image_urls, tags=tags, location=location,",
    "                    created_at=timestamp)",
    "        self.posts[post_id] = post",
    "        self._fan_out(user_id, post)",
    "        self._index_hashtags(post_id, tags)",
    "        return post_id",
    "    ",
    "    def _fan_out(self, user_id: str, post: Post) -> None:",
    "        follower_count = len(self.followers.get(user_id, set()))",
    "        if follower_count < self.CELEBRITY_THRESHOLD:",
    "            feed_item = FeedItem(post_id=post.post_id, user_id=user_id,",
    "                                 timestamp=post.created_at)",
    "            for follower_id in self.followers.get(user_id, set()):",
    "                self.feeds[follower_id].insert(0, feed_item)",
    "                if len(self.feeds[follower_id]) > self.FEED_SIZE:",
    "                    self.feeds[follower_id].pop()",
    "        else:",
    "            self.celebrity_posts[user_id].insert(0, post)",
    "    ",
    "    def get_news_feed(self, user_id: str, page_size: int,",
    "                       cursor: Optional[str]) -> FeedResponse:",
    "        start_idx = int(cursor) if cursor else 0",
    "        feed_items = self.feeds.get(user_id, [])[start_idx:start_idx + page_size * 2]",
    "        celeb_posts = []",
    "        for uid in self.following.get(user_id, set()):",
    "            if len(self.followers.get(uid, set())) >= self.CELEBRITY_THRESHOLD:",
    "                celeb_posts.extend(self.celebrity_posts.get(uid, [])[:10])",
    "        all_items = []",
    "        for item in feed_items:",
    "            post = self.posts.get(item.post_id)",
    "            if post:",
    "                all_items.append((item.timestamp, post))",
    "        for post in celeb_posts:",
    "            all_items.append((post.created_at, post))",
    "        all_items.sort(key=lambda x: x[0], reverse=True)",
    "        result_posts = [item[1] for item in all_items[:page_size]]",
    "        next_cursor = str(start_idx + page_size) if len(all_items) > page_size else None",
    "        return FeedResponse(posts=result_posts, next_cursor=next_cursor)",
    "    ",
    "    def follow_user(self, follower_id: str, followee_id: str) -> bool:",
    "        if follower_id == followee_id or followee_id in self.following[follower_id]:",
    "            return False",
    "        self.followers[followee_id].add(follower_id)",
    "        self.following[follower_id].add(followee_id)",
    "        return True",
    "    ",
    "    def like_post(self, user_id: str, post_id: str) -> bool:",
    "        if post_id not in self.posts:",
    "            return False",
    "        self.posts[post_id].like_count += 1",
    "        return True",
    "    ",
    "    # === Part 2: Stories ===",
    "    def post_story(self, user_id: str, media: bytes, story_type: StoryType) -> str:",
    "        story_id = f\"story_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        story = Story(story_id=story_id, user_id=user_id,",
    "                      media_url=f'cdn.instagram.com/stories/{story_id}.jpg',",
    "                      story_type=story_type, created_at=timestamp,",
    "                      expires_at=timestamp + self.STORY_TTL_SECONDS)",
    "        self.stories[story_id] = story",
    "        self.user_stories[user_id].insert(0, story_id)",
    "        return story_id",
    "    ",
    "    def _is_story_active(self, story: Story) -> bool:",
    "        return int(datetime.now().timestamp()) < story.expires_at",
    "    ",
    "    def _get_active_stories(self, user_id: str) -> List[Story]:",
    "        active, new_ids = [], []",
    "        for sid in self.user_stories.get(user_id, []):",
    "            story = self.stories.get(sid)",
    "            if story and self._is_story_active(story):",
    "                active.append(story)",
    "                new_ids.append(sid)",
    "        self.user_stories[user_id] = new_ids",
    "        return active",
    "    ",
    "    def get_story_ring(self, user_id: str) -> StoryRing:",
    "        ring_users, viewed = [], set()",
    "        for sid, viewers in self.story_views.items():",
    "            if user_id in viewers:",
    "                viewed.add(sid)",
    "        for followee in self.following.get(user_id, set()):",
    "            active = self._get_active_stories(followee)",
    "            if active:",
    "                has_unviewed = any(s.story_id not in viewed for s in active)",
    "                ring_users.append(StoryRingUser(followee, has_unviewed, max(s.created_at for s in active)))",
    "        ring_users.sort(key=lambda u: (-u.has_unviewed, -u.latest_story_time))",
    "        return StoryRing(users=ring_users)",
    "    ",
    "    def mark_story_viewed(self, user_id: str, story_id: str) -> bool:",
    "        story = self.stories.get(story_id)",
    "        if not story or not self._is_story_active(story):",
    "            return False",
    "        if user_id not in self.story_views[story_id]:",
    "            self.story_views[story_id].add(user_id)",
    "            story.view_count += 1",
    "        return True",
    "    ",
    "    # === Part 3: Search and Explore ===",
    "    def _index_hashtags(self, post_id: str, tags: List[str]) -> None:",
    "        for tag in tags:",
    "            normalized = tag.lower().lstrip('#')",
    "            if normalized:",
    "                self.hashtag_index[normalized].append(post_id)",
    "                self.hashtag_counts[normalized] += 1",
    "    ",
    "    def register_user(self, user_id: str, username: str, name: str = \"\") -> None:",
    "        self.user_index[user_id] = User(user_id, username, name)",
    "        self.users[user_id] = {\"username\": username, \"name\": name}",
    "    ",
    "    def search_users(self, query: str, limit: int) -> List[User]:",
    "        if not query:",
    "            return []",
    "        q = query.lower()",
    "        results = []",
    "        for user in self.user_index.values():",
    "            uname, name = user.username.lower(), user.name.lower()",
    "            if uname == q:",
    "                results.append((0, user))",
    "            elif uname.startswith(q):",
    "                results.append((1, user))",
    "            elif q in uname:",
    "                results.append((2, user))",
    "            elif q in name:",
    "                results.append((3, user))",
    "        results.sort(key=lambda x: x[0])",
    "        return [r[1] for r in results[:limit]]",
    "    ",
    "    def search_hashtag(self, hashtag: str, limit: int, cursor: Optional[str]) -> List[Post]:",
    "        normalized = hashtag.lower().lstrip('#')",
    "        post_ids = self.hashtag_index.get(normalized, [])",
    "        posts = [self.posts[pid] for pid in post_ids if pid in self.posts]",
    "        posts.sort(key=lambda p: p.created_at, reverse=True)",
    "        start = int(cursor) if cursor else 0",
    "        return posts[start:start + limit]",
    "    ",
    "    def search_location(self, lat: float, lng: float, radius: float) -> List[Post]:",
    "        results = []",
    "        for post in self.posts.values():",
    "            if post.location:",
    "                dist = self._haversine(lat, lng, post.location.lat, post.location.lng)",
    "                if dist <= radius:",
    "                    results.append((dist, post))",
    "        results.sort(key=lambda x: x[0])",
    "        return [r[1] for r in results]",
    "    ",
    "    def _haversine(self, lat1: float, lng1: float, lat2: float, lng2: float) -> float:",
    "        R = 6371",
    "        dlat, dlng = math.radians(lat2 - lat1), math.radians(lng2 - lng1)",
    "        a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlng/2)**2",
    "        return 2 * R * math.asin(math.sqrt(a))",
    "    ",
    "    def get_explore_feed(self, user_id: str, page_size: int) -> ExploreFeed:",
    "        followed = self.following.get(user_id, set())",
    "        candidates = []",
    "        for post in self.posts.values():",
    "            if post.user_id != user_id and post.user_id not in followed:",
    "                score = self._engagement_score(post)",
    "                candidates.append((score, post))",
    "        candidates.sort(key=lambda x: -x[0])",
    "        return ExploreFeed(posts=[c[1] for c in candidates[:page_size]])",
    "    ",
    "    def _engagement_score(self, post: Post) -> float:",
    "        base = post.like_count + 2 * post.comment_count",
    "        age_hours = (datetime.now().timestamp() - post.created_at) / 3600",
    "        recency = max(0, 1 - age_hours / 168)",
    "        return base * (1 + recency)",
    "    ",
    "    def get_trending_hashtags(self, region: str) -> List[Hashtag]:",
    "        hashtags = [Hashtag(t, c) for t, c in self.hashtag_counts.items()]",
    "        hashtags.sort(key=lambda h: h.post_count, reverse=True)",
    "        return hashtags[:self.TRENDING_LIMIT]",
    "    ",
    "    # === Part 4: Direct Messaging ===",
    "    def _get_dm_key(self, user_a: str, user_b: str) -> str:",
    "        \"\"\"Canonical key for 1:1 conversation lookup.\"\"\"",
    "        return ':'.join(sorted([user_a, user_b]))",
    "    ",
    "    def create_conversation(self, user_a: str, user_b: str) -> str:",
    "        \"\"\"Create or return existing 1:1 conversation.\"\"\"",
    "        dm_key = self._get_dm_key(user_a, user_b)",
    "        if dm_key in self.dm_index:",
    "            return self.dm_index[dm_key]",
    "        ",
    "        conv_id = f\"conv_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        conv = Conversation(",
    "            conversation_id=conv_id,",
    "            participants={user_a, user_b},",
    "            name=None,",
    "            is_group=False,",
    "            created_at=timestamp,",
    "            last_message_at=timestamp",
    "        )",
    "        self.conversations[conv_id] = conv",
    "        self.user_conversations[user_a].add(conv_id)",
    "        self.user_conversations[user_b].add(conv_id)",
    "        self.dm_index[dm_key] = conv_id",
    "        return conv_id",
    "    ",
    "    def create_group_chat(self, creator_id: str, member_ids: List[str], name: str) -> str:",
    "        \"\"\"Create group conversation with multiple participants.\"\"\"",
    "        conv_id = f\"group_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        participants = set(member_ids) | {creator_id}",
    "        ",
    "        conv = Conversation(",
    "            conversation_id=conv_id,",
    "            participants=participants,",
    "            name=name,",
    "            is_group=True,",
    "            created_at=timestamp,",
    "            last_message_at=timestamp",
    "        )",
    "        self.conversations[conv_id] = conv",
    "        for user_id in participants:",
    "            self.user_conversations[user_id].add(conv_id)",
    "        return conv_id",
    "    ",
    "    def send_message(self, sender_id: str, conversation_id: str, message: Message) -> str:",
    "        \"\"\"Send message to conversation. Returns message_id.\"\"\"",
    "        conv = self.conversations.get(conversation_id)",
    "        if not conv or sender_id not in conv.participants:",
    "            raise ValueError(\"Invalid conversation or sender not participant\")",
    "        ",
    "        msg_id = f\"msg_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        ",
    "        new_msg = Message(",
    "            message_id=msg_id,",
    "            sender_id=sender_id,",
    "            conversation_id=conversation_id,",
    "            content=message.content,",
    "            message_type=message.message_type,",
    "            created_at=timestamp,",
    "            read_by={sender_id}  # Sender has read their own message",
    "        )",
    "        ",
    "        self.messages[msg_id] = new_msg",
    "        self.conversation_messages[conversation_id].append(msg_id)",
    "        ",
    "        # Update conversation metadata",
    "        conv.last_message_at = timestamp",
    "        conv.last_message_preview = message.content[:50]",
    "        ",
    "        return msg_id",
    "    ",
    "    def get_conversations(self, user_id: str, limit: int) -> List[Conversation]:",
    "        \"\"\"Get user's conversations sorted by recency.\"\"\"",
    "        conv_ids = self.user_conversations.get(user_id, set())",
    "        convs = [self.conversations[cid] for cid in conv_ids if cid in self.conversations]",
    "        convs.sort(key=lambda c: c.last_message_at, reverse=True)",
    "        return convs[:limit]",
    "    ",
    "    def get_messages(self, conversation_id: str, cursor: Optional[str], limit: int) -> List[Message]:",
    "        \"\"\"Get paginated messages from conversation.\"\"\"",
    "        msg_ids = self.conversation_messages.get(conversation_id, [])",
    "        start = int(cursor) if cursor else 0",
    "        end = min(start + limit, len(msg_ids))",
    "        return [self.messages[mid] for mid in msg_ids[start:end] if mid in self.messages]",
    "    ",
    "    def mark_as_read(self, user_id: str, conversation_id: str, message_id: str) -> None:",
    "        \"\"\"Mark all messages up to message_id as read by user.\"\"\"",
    "        msg_ids = self.conversation_messages.get(conversation_id, [])",
    "        for mid in msg_ids:",
    "            msg = self.messages.get(mid)",
    "            if msg:",
    "                msg.read_by.add(user_id)",
    "            if mid == message_id:",
    "                break",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('Instagram Part 4: Direct Messaging Demo')",
    "    print('=' * 60)",
    "    ",
    "    ig = Instagram()",
    "    ",
    "    # Register users",
    "    ig.register_user('alice', 'alice_travels', 'Alice Smith')",
    "    ig.register_user('bob', 'bob_photos', 'Bob Johnson')",
    "    ig.register_user('charlie', 'charlie_adventures', 'Charlie Brown')",
    "    ",
    "    # Test 1: Create 1:1 conversation",
    "    print('\\n--- 1:1 Conversation ---')",
    "    conv1 = ig.create_conversation('alice', 'bob')",
    "    print(f'Created conversation: {conv1}')",
    "    ",
    "    # Test 2: Send messages",
    "    msg1 = Message('', 'alice', conv1, 'Hey Bob!', MessageType.TEXT, 0)",
    "    msg1_id = ig.send_message('alice', conv1, msg1)",
    "    print(f'Alice sent message: {msg1_id}')",
    "    ",
    "    msg2 = Message('', 'bob', conv1, 'Hi Alice! How are you?', MessageType.TEXT, 0)",
    "    msg2_id = ig.send_message('bob', conv1, msg2)",
    "    print(f'Bob sent message: {msg2_id}')",
    "    ",
    "    # Test 3: Get messages",
    "    print('\\n--- Message History ---')",
    "    messages = ig.get_messages(conv1, None, 10)",
    "    for m in messages:",
    "        read_status = 'read by ' + ', '.join(m.read_by)",
    "        print(f'  {m.sender_id}: {m.content} ({read_status})')",
    "    ",
    "    # Test 4: Read receipts",
    "    print('\\n--- Read Receipts ---')",
    "    ig.mark_as_read('bob', conv1, msg1_id)",
    "    msg = ig.messages[msg1_id]",
    "    print(f'After Bob reads: {msg.content} - read by {msg.read_by}')",
    "    ",
    "    # Test 5: Group chat",
    "    print('\\n--- Group Chat ---')",
    "    group_id = ig.create_group_chat('alice', ['bob', 'charlie'], 'Travel Buddies')",
    "    print(f'Created group: {group_id}')",
    "    ",
    "    group_msg = Message('', 'alice', group_id, 'Welcome to the group!', MessageType.TEXT, 0)",
    "    ig.send_message('alice', group_id, group_msg)",
    "    ",
    "    group_msg2 = Message('', 'charlie', group_id, 'Thanks for adding me!', MessageType.TEXT, 0)",
    "    ig.send_message('charlie', group_id, group_msg2)",
    "    ",
    "    # Test 6: List conversations",
    "    print('\\n--- Alice\\'s Conversations ---')",
    "    convs = ig.get_conversations('alice', 10)",
    "    for c in convs:",
    "        name = c.name or 'DM'",
    "        print(f'  {c.conversation_id} ({name}): \"{c.last_message_preview}\"')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('Key: Separate indices for conversations and messages!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.time.Instant;",
    "",
    "public class Instagram {",
    "    private static final int CELEBRITY_THRESHOLD = 10000;",
    "    private static final int FEED_SIZE = 1000;",
    "    private static final long STORY_TTL_SECONDS = 24 * 60 * 60;",
    "    private static final int TRENDING_LIMIT = 10;",
    "    ",
    "    // Part 1: Core data stores",
    "    private final Map<String, Map<String, String>> users = new ConcurrentHashMap<>();",
    "    private final Map<String, Post> posts = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> followers = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> following = new ConcurrentHashMap<>();",
    "    private final Map<String, Deque<FeedItem>> feeds = new ConcurrentHashMap<>();",
    "    private final Map<String, Deque<Post>> celebrityPosts = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2: Stories",
    "    private final Map<String, Story> stories = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> userStories = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> storyViews = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 3: Search indices",
    "    private final Map<String, User> userIndex = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> hashtagIndex = new ConcurrentHashMap<>();",
    "    private final Map<String, Integer> hashtagCounts = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 4: Direct Messaging",
    "    private final Map<String, Conversation> conversations = new ConcurrentHashMap<>();",
    "    private final Map<String, Message> messages = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> conversationMessages = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> userConversations = new ConcurrentHashMap<>();",
    "    private final Map<String, String> dmIndex = new ConcurrentHashMap<>();",
    "    ",
    "    // Inner classes (Parts 1-3)",
    "    static class Location { double lat, lng; Location(double lat, double lng) { this.lat = lat; this.lng = lng; } }",
    "    static class Post {",
    "        String postId, userId, caption;",
    "        Map<String, String> imageUrls;",
    "        List<String> tags;",
    "        Location location;",
    "        long createdAt;",
    "        int likeCount = 0, commentCount = 0;",
    "    }",
    "    static class FeedItem { String postId, userId; long timestamp; }",
    "    static class FeedResponse { List<Post> posts; String nextCursor; FeedResponse(List<Post> p, String c) { posts = p; nextCursor = c; } }",
    "    enum StoryType { PHOTO, VIDEO }",
    "    static class Story { String storyId, userId, mediaUrl; StoryType storyType; long createdAt, expiresAt; int viewCount = 0; }",
    "    static class StoryRingUser { String userId; boolean hasUnviewed; long latestStoryTime; StoryRingUser(String u, boolean h, long t) { userId = u; hasUnviewed = h; latestStoryTime = t; } }",
    "    static class StoryRing { List<StoryRingUser> users; StoryRing(List<StoryRingUser> u) { users = u; } }",
    "    static class User { String userId, username, name; User(String id, String u, String n) { userId = id; username = u; name = n; } }",
    "    static class Hashtag { String tag; int postCount; Hashtag(String t, int c) { tag = t; postCount = c; } }",
    "    static class ExploreFeed { List<Post> posts; String nextCursor; ExploreFeed(List<Post> p) { posts = p; } }",
    "    ",
    "    // Part 4: New inner classes",
    "    enum MessageType { TEXT, PHOTO, VIDEO }",
    "    static class Message {",
    "        String messageId, senderId, conversationId, content;",
    "        MessageType messageType;",
    "        long createdAt;",
    "        Set<String> readBy = ConcurrentHashMap.newKeySet();",
    "        Message(String id, String sender, String conv, String content, MessageType type, long ts) {",
    "            this.messageId = id; this.senderId = sender; this.conversationId = conv;",
    "            this.content = content; this.messageType = type; this.createdAt = ts;",
    "        }",
    "    }",
    "    static class Conversation {",
    "        String conversationId, name, lastMessagePreview = \"\";",
    "        Set<String> participants;",
    "        boolean isGroup;",
    "        long createdAt, lastMessageAt;",
    "        Conversation(String id, Set<String> p, String name, boolean group, long ts) {",
    "            this.conversationId = id; this.participants = p; this.name = name;",
    "            this.isGroup = group; this.createdAt = ts; this.lastMessageAt = ts;",
    "        }",
    "    }",
    "    ",
    "    // === Part 1 methods ===",
    "    public String uploadPhoto(String userId, byte[] photo, String caption, List<String> tags, Location location) {",
    "        String postId = \"post_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Post post = new Post();",
    "        post.postId = postId; post.userId = userId; post.caption = caption;",
    "        post.tags = tags; post.location = location; post.createdAt = timestamp;",
    "        post.imageUrls = Map.of(\"large\", \"cdn/\" + postId + \"_1080.jpg\");",
    "        posts.put(postId, post);",
    "        fanOut(userId, post);",
    "        indexHashtags(postId, tags);",
    "        return postId;",
    "    }",
    "    ",
    "    private void fanOut(String userId, Post post) {",
    "        Set<String> userFollowers = followers.getOrDefault(userId, Set.of());",
    "        if (userFollowers.size() < CELEBRITY_THRESHOLD) {",
    "            FeedItem item = new FeedItem(); item.postId = post.postId; item.userId = userId; item.timestamp = post.createdAt;",
    "            for (String followerId : userFollowers) {",
    "                feeds.computeIfAbsent(followerId, k -> new LinkedList<>()).addFirst(item);",
    "                while (feeds.get(followerId).size() > FEED_SIZE) feeds.get(followerId).removeLast();",
    "            }",
    "        } else { celebrityPosts.computeIfAbsent(userId, k -> new LinkedList<>()).addFirst(post); }",
    "    }",
    "    ",
    "    public boolean followUser(String followerId, String followeeId) {",
    "        if (followerId.equals(followeeId)) return false;",
    "        followers.computeIfAbsent(followeeId, k -> ConcurrentHashMap.newKeySet()).add(followerId);",
    "        following.computeIfAbsent(followerId, k -> ConcurrentHashMap.newKeySet()).add(followeeId);",
    "        return true;",
    "    }",
    "    ",
    "    public boolean likePost(String userId, String postId) {",
    "        Post post = posts.get(postId);",
    "        if (post == null) return false;",
    "        post.likeCount++;",
    "        return true;",
    "    }",
    "    ",
    "    // === Part 2: Stories ===",
    "    public String postStory(String userId, byte[] media, StoryType type) {",
    "        String storyId = \"story_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Story story = new Story();",
    "        story.storyId = storyId; story.userId = userId; story.mediaUrl = \"cdn/stories/\" + storyId;",
    "        story.storyType = type; story.createdAt = timestamp; story.expiresAt = timestamp + STORY_TTL_SECONDS;",
    "        stories.put(storyId, story);",
    "        userStories.computeIfAbsent(userId, k -> new ArrayList<>()).add(0, storyId);",
    "        return storyId;",
    "    }",
    "    ",
    "    private boolean isStoryActive(Story story) { return Instant.now().getEpochSecond() < story.expiresAt; }",
    "    ",
    "    public boolean markStoryViewed(String userId, String storyId) {",
    "        Story story = stories.get(storyId);",
    "        if (story == null || !isStoryActive(story)) return false;",
    "        Set<String> viewers = storyViews.computeIfAbsent(storyId, k -> ConcurrentHashMap.newKeySet());",
    "        if (!viewers.contains(userId)) { viewers.add(userId); story.viewCount++; }",
    "        return true;",
    "    }",
    "    ",
    "    // === Part 3: Search and Explore ===",
    "    private void indexHashtags(String postId, List<String> tags) {",
    "        for (String tag : tags) {",
    "            String normalized = tag.toLowerCase().replaceFirst(\"^#\", \"\");",
    "            if (!normalized.isEmpty()) {",
    "                hashtagIndex.computeIfAbsent(normalized, k -> new ArrayList<>()).add(postId);",
    "                hashtagCounts.merge(normalized, 1, Integer::sum);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    public void registerUser(String userId, String username, String name) {",
    "        userIndex.put(userId, new User(userId, username, name));",
    "        users.put(userId, Map.of(\"username\", username, \"name\", name));",
    "    }",
    "    ",
    "    public List<User> searchUsers(String query, int limit) {",
    "        if (query == null || query.isEmpty()) return List.of();",
    "        String q = query.toLowerCase();",
    "        List<int[]> results = new ArrayList<>();",
    "        List<User> allUsers = new ArrayList<>(userIndex.values());",
    "        for (int i = 0; i < allUsers.size(); i++) {",
    "            User user = allUsers.get(i);",
    "            String uname = user.username.toLowerCase();",
    "            String name = user.name != null ? user.name.toLowerCase() : \"\";",
    "            int score = -1;",
    "            if (uname.equals(q)) score = 0;",
    "            else if (uname.startsWith(q)) score = 1;",
    "            else if (uname.contains(q)) score = 2;",
    "            else if (name.contains(q)) score = 3;",
    "            if (score >= 0) results.add(new int[]{score, i});",
    "        }",
    "        results.sort(Comparator.comparingInt(a -> a[0]));",
    "        List<User> output = new ArrayList<>();",
    "        for (int i = 0; i < Math.min(limit, results.size()); i++) output.add(allUsers.get(results.get(i)[1]));",
    "        return output;",
    "    }",
    "    ",
    "    public List<Post> searchHashtag(String hashtag, int limit, String cursor) {",
    "        String normalized = hashtag.toLowerCase().replaceFirst(\"^#\", \"\");",
    "        List<String> postIds = hashtagIndex.getOrDefault(normalized, List.of());",
    "        List<Post> postList = new ArrayList<>();",
    "        for (String pid : postIds) { Post p = posts.get(pid); if (p != null) postList.add(p); }",
    "        postList.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        int start = cursor != null ? Integer.parseInt(cursor) : 0;",
    "        return postList.subList(start, Math.min(start + limit, postList.size()));",
    "    }",
    "    ",
    "    public List<Post> searchLocation(double lat, double lng, double radius) {",
    "        List<double[]> results = new ArrayList<>();",
    "        List<Post> allPosts = new ArrayList<>(posts.values());",
    "        for (int i = 0; i < allPosts.size(); i++) {",
    "            Post post = allPosts.get(i);",
    "            if (post.location != null) {",
    "                double dist = haversine(lat, lng, post.location.lat, post.location.lng);",
    "                if (dist <= radius) results.add(new double[]{dist, i});",
    "            }",
    "        }",
    "        results.sort(Comparator.comparingDouble(a -> a[0]));",
    "        List<Post> output = new ArrayList<>();",
    "        for (double[] r : results) output.add(allPosts.get((int) r[1]));",
    "        return output;",
    "    }",
    "    ",
    "    private double haversine(double lat1, double lng1, double lat2, double lng2) {",
    "        double R = 6371;",
    "        double dLat = Math.toRadians(lat2 - lat1), dLng = Math.toRadians(lng2 - lng1);",
    "        double a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLng/2) * Math.sin(dLng/2);",
    "        return 2 * R * Math.asin(Math.sqrt(a));",
    "    }",
    "    ",
    "    public ExploreFeed getExploreFeed(String userId, int pageSize) {",
    "        Set<String> followed = following.getOrDefault(userId, Set.of());",
    "        List<double[]> candidates = new ArrayList<>();",
    "        List<Post> allPosts = new ArrayList<>(posts.values());",
    "        for (int i = 0; i < allPosts.size(); i++) {",
    "            Post post = allPosts.get(i);",
    "            if (!post.userId.equals(userId) && !followed.contains(post.userId)) {",
    "                double score = engagementScore(post);",
    "                candidates.add(new double[]{score, i});",
    "            }",
    "        }",
    "        candidates.sort((a, b) -> Double.compare(b[0], a[0]));",
    "        List<Post> result = new ArrayList<>();",
    "        for (int i = 0; i < Math.min(pageSize, candidates.size()); i++) result.add(allPosts.get((int) candidates.get(i)[1]));",
    "        return new ExploreFeed(result);",
    "    }",
    "    ",
    "    private double engagementScore(Post post) {",
    "        double base = post.likeCount + 2 * post.commentCount;",
    "        double ageHours = (Instant.now().getEpochSecond() - post.createdAt) / 3600.0;",
    "        double recency = Math.max(0, 1 - ageHours / 168);",
    "        return base * (1 + recency);",
    "    }",
    "    ",
    "    public List<Hashtag> getTrendingHashtags(String region) {",
    "        List<Hashtag> hashtags = new ArrayList<>();",
    "        for (var entry : hashtagCounts.entrySet()) hashtags.add(new Hashtag(entry.getKey(), entry.getValue()));",
    "        hashtags.sort((a, b) -> Integer.compare(b.postCount, a.postCount));",
    "        return hashtags.subList(0, Math.min(TRENDING_LIMIT, hashtags.size()));",
    "    }",
    "    ",
    "    // === Part 4: Direct Messaging ===",
    "    private String getDmKey(String userA, String userB) {",
    "        return userA.compareTo(userB) < 0 ? userA + \":\" + userB : userB + \":\" + userA;",
    "    }",
    "    ",
    "    public String createConversation(String userA, String userB) {",
    "        String dmKey = getDmKey(userA, userB);",
    "        if (dmIndex.containsKey(dmKey)) return dmIndex.get(dmKey);",
    "        ",
    "        String convId = \"conv_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Set<String> participants = new HashSet<>(Arrays.asList(userA, userB));",
    "        Conversation conv = new Conversation(convId, participants, null, false, timestamp);",
    "        ",
    "        conversations.put(convId, conv);",
    "        userConversations.computeIfAbsent(userA, k -> ConcurrentHashMap.newKeySet()).add(convId);",
    "        userConversations.computeIfAbsent(userB, k -> ConcurrentHashMap.newKeySet()).add(convId);",
    "        dmIndex.put(dmKey, convId);",
    "        return convId;",
    "    }",
    "    ",
    "    public String createGroupChat(String creatorId, List<String> memberIds, String name) {",
    "        String convId = \"group_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Set<String> participants = new HashSet<>(memberIds);",
    "        participants.add(creatorId);",
    "        Conversation conv = new Conversation(convId, participants, name, true, timestamp);",
    "        ",
    "        conversations.put(convId, conv);",
    "        for (String userId : participants) {",
    "            userConversations.computeIfAbsent(userId, k -> ConcurrentHashMap.newKeySet()).add(convId);",
    "        }",
    "        return convId;",
    "    }",
    "    ",
    "    public String sendMessage(String senderId, String conversationId, Message message) {",
    "        Conversation conv = conversations.get(conversationId);",
    "        if (conv == null || !conv.participants.contains(senderId)) {",
    "            throw new IllegalArgumentException(\"Invalid conversation or sender\");",
    "        }",
    "        ",
    "        String msgId = \"msg_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Message newMsg = new Message(msgId, senderId, conversationId, message.content, message.messageType, timestamp);",
    "        newMsg.readBy.add(senderId);",
    "        ",
    "        messages.put(msgId, newMsg);",
    "        conversationMessages.computeIfAbsent(conversationId, k -> new ArrayList<>()).add(msgId);",
    "        ",
    "        conv.lastMessageAt = timestamp;",
    "        conv.lastMessagePreview = message.content.substring(0, Math.min(50, message.content.length()));",
    "        return msgId;",
    "    }",
    "    ",
    "    public List<Conversation> getConversations(String userId, int limit) {",
    "        Set<String> convIds = userConversations.getOrDefault(userId, Set.of());",
    "        List<Conversation> convs = new ArrayList<>();",
    "        for (String cid : convIds) {",
    "            Conversation c = conversations.get(cid);",
    "            if (c != null) convs.add(c);",
    "        }",
    "        convs.sort((a, b) -> Long.compare(b.lastMessageAt, a.lastMessageAt));",
    "        return convs.subList(0, Math.min(limit, convs.size()));",
    "    }",
    "    ",
    "    public List<Message> getMessages(String conversationId, String cursor, int limit) {",
    "        List<String> msgIds = conversationMessages.getOrDefault(conversationId, List.of());",
    "        int start = cursor != null ? Integer.parseInt(cursor) : 0;",
    "        int end = Math.min(start + limit, msgIds.size());",
    "        List<Message> result = new ArrayList<>();",
    "        for (int i = start; i < end; i++) {",
    "            Message m = messages.get(msgIds.get(i));",
    "            if (m != null) result.add(m);",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    public void markAsRead(String userId, String conversationId, String messageId) {",
    "        List<String> msgIds = conversationMessages.getOrDefault(conversationId, List.of());",
    "        for (String mid : msgIds) {",
    "            Message msg = messages.get(mid);",
    "            if (msg != null) msg.readBy.add(userId);",
    "            if (mid.equals(messageId)) break;",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Instagram Part 4: Direct Messaging Demo (Java)\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        Instagram ig = new Instagram();",
    "        ig.registerUser(\"alice\", \"alice_travels\", \"Alice Smith\");",
    "        ig.registerUser(\"bob\", \"bob_photos\", \"Bob Johnson\");",
    "        ig.registerUser(\"charlie\", \"charlie_adventures\", \"Charlie Brown\");",
    "        ",
    "        // Create 1:1 conversation",
    "        System.out.println(\"\\n--- 1:1 Conversation ---\");",
    "        String conv1 = ig.createConversation(\"alice\", \"bob\");",
    "        System.out.println(\"Created: \" + conv1);",
    "        ",
    "        // Send messages",
    "        Message msg1 = new Message(\"\", \"alice\", conv1, \"Hey Bob!\", MessageType.TEXT, 0);",
    "        String msg1Id = ig.sendMessage(\"alice\", conv1, msg1);",
    "        System.out.println(\"Alice sent: \" + msg1Id);",
    "        ",
    "        Message msg2 = new Message(\"\", \"bob\", conv1, \"Hi Alice!\", MessageType.TEXT, 0);",
    "        String msg2Id = ig.sendMessage(\"bob\", conv1, msg2);",
    "        System.out.println(\"Bob sent: \" + msg2Id);",
    "        ",
    "        // Get messages",
    "        System.out.println(\"\\n--- Message History ---\");",
    "        for (Message m : ig.getMessages(conv1, null, 10)) {",
    "            System.out.println(\"  \" + m.senderId + \": \" + m.content);",
    "        }",
    "        ",
    "        // Group chat",
    "        System.out.println(\"\\n--- Group Chat ---\");",
    "        String group = ig.createGroupChat(\"alice\", List.of(\"bob\", \"charlie\"), \"Travel Buddies\");",
    "        System.out.println(\"Created group: \" + group);",
    "        ",
    "        // List conversations",
    "        System.out.println(\"\\n--- Alice's Conversations ---\");",
    "        for (Conversation c : ig.getConversations(\"alice\", 10)) {",
    "            String name = c.name != null ? c.name : \"DM\";",
    "            System.out.println(\"  \" + c.conversationId + \" (\" + name + \")\");",
    "        }",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and class constants unchanged from Parts 1-3"
    },
    {
      "lines": "90-115",
      "explanation": "Part 4 dataclasses: MessageType enum, Message with read_by set, Conversation with participants and metadata"
    },
    {
      "lines": "130-140",
      "explanation": "New data stores: conversations dict, messages dict, conversation_messages for ordering, user_conversations index, dm_index for 1:1 lookup"
    },
    {
      "lines": "280-300",
      "explanation": "create_conversation: Creates or retrieves 1:1 DM using canonical key sorting"
    },
    {
      "lines": "302-320",
      "explanation": "create_group_chat: Creates group with multiple participants, indexes for all members"
    },
    {
      "lines": "322-345",
      "explanation": "send_message: Validates sender is participant, creates Message, updates conversation metadata"
    },
    {
      "lines": "347-355",
      "explanation": "get_conversations: Fetches user's conversations sorted by recency"
    },
    {
      "lines": "357-365",
      "explanation": "get_messages: Cursor-based pagination returning Message objects"
    },
    {
      "lines": "367-375",
      "explanation": "mark_as_read: Adds user to read_by set for all messages up to specified ID"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "create_conversation": {
          "complexity": "O(1)",
          "explanation": "Hash lookups and insertions"
        },
        "create_group_chat": {
          "complexity": "O(P)",
          "explanation": "P = participants, update each user's index"
        },
        "send_message": {
          "complexity": "O(1)",
          "explanation": "Validation, create message, append to list"
        },
        "get_conversations": {
          "complexity": "O(C log C)",
          "explanation": "C = user's conversations, fetch and sort"
        },
        "get_messages": {
          "complexity": "O(page_size)",
          "explanation": "Slice list and fetch messages"
        },
        "mark_as_read": {
          "complexity": "O(M)",
          "explanation": "M = messages up to the specified one"
        }
      },
      "overall_change": "Parts 1-3 unchanged. DM operations are independent - no impact on existing methods."
    },
    "space": {
      "additional_space": "O(C + M + U \u00d7 avg_convs)",
      "explanation": "C = conversations, M = messages, U = users. user_conversations stores set of conv_ids per user. Messages stored once, referenced by ID."
    }
  },
  "dry_run": {
    "example_input": "Alice and Bob exchange messages",
    "steps": [
      {
        "step": 1,
        "action": "create_conversation('alice', 'bob')",
        "state": "dm_index: {'alice:bob': 'conv_1'}, user_conversations: {alice: {conv_1}, bob: {conv_1}}",
        "explanation": "Canonical key 'alice:bob' maps to new conversation"
      },
      {
        "step": 2,
        "action": "send_message('alice', 'conv_1', 'Hello')",
        "state": "messages: {msg_1: Message(...)}, conversation_messages: {conv_1: [msg_1]}",
        "explanation": "Message created, appended to conversation, metadata updated"
      },
      {
        "step": 3,
        "action": "send_message('bob', 'conv_1', 'Hi!')",
        "state": "conversation_messages: {conv_1: [msg_1, msg_2]}",
        "explanation": "Second message appended, ordering preserved"
      },
      {
        "step": 4,
        "action": "get_messages('conv_1', None, 10)",
        "state": "Returns [msg_1, msg_2]",
        "explanation": "Slice from index 0, return both messages"
      },
      {
        "step": 5,
        "action": "mark_as_read('bob', 'conv_1', 'msg_1')",
        "state": "msg_1.read_by = {'alice', 'bob'}",
        "explanation": "Bob added to read_by set for msg_1"
      }
    ],
    "final_output": "Conversation with 2 messages, read receipts tracked"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create conv, send 1 message, retrieve it",
      "Group chat with 3 users, verify all can send"
    ],
    "likely_bugs": [
      "Sender not in participants check missing",
      "Duplicate 1:1 conversations",
      "Read receipts only marking one message"
    ],
    "recommended_logs_or_asserts": [
      "assert sender_id in conv.participants",
      "log len(conversation_messages[conv_id]) after send",
      "assert msg.read_by contains sender after send"
    ],
    "how_to_localize": "1. Print conversation.participants, 2. Verify user_conversations index, 3. Check conversation_messages ordering"
  },
  "edge_cases": [
    {
      "case": "Duplicate 1:1 conversation request",
      "handling": "dm_index returns existing conv_id",
      "gotcha": "Must use canonical key sorting"
    },
    {
      "case": "User tries to send to conversation they're not in",
      "handling": "Raise ValueError",
      "gotcha": "Check participants before creating message"
    },
    {
      "case": "Empty conversation (no messages)",
      "handling": "get_messages returns []",
      "gotcha": "last_message_preview is empty string"
    },
    {
      "case": "Group with only creator",
      "handling": "Valid - creator added to participants",
      "gotcha": "Ensure creator is always included"
    },
    {
      "case": "mark_as_read with invalid message_id",
      "handling": "Marks all messages (no match found)",
      "gotcha": "Could add validation, mentioned as production consideration"
    }
  ],
  "test_cases": [
    {
      "name": "Basic 1:1 messaging",
      "input": "create_conversation(A, B), send_message(A), send_message(B), get_messages",
      "expected": "2 messages in order, both with sender in read_by",
      "explanation": "Core functionality test"
    },
    {
      "name": "Group chat fan-out",
      "input": "create_group_chat(A, [B, C]), get_conversations for each user",
      "expected": "All 3 users have the group in their conversations",
      "explanation": "Verify user_conversations index updated for all"
    },
    {
      "name": "Conversation ordering",
      "input": "Create 2 convs, send message to second, get_conversations",
      "expected": "Second conversation appears first (more recent)",
      "explanation": "Verify last_message_at sorting"
    },
    {
      "name": "Read receipts propagation",
      "input": "Send 3 messages, mark_as_read on 2nd message",
      "expected": "Messages 1 and 2 marked read, message 3 not",
      "explanation": "Verify mark_as_read stops at specified message"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not using canonical key for 1:1 lookup",
      "why_wrong": "create_conversation('a','b') and create_conversation('b','a') would create duplicates",
      "correct_approach": "Sort user IDs to create consistent key: min:max",
      "code_example_wrong": "dm_key = f'{user_a}:{user_b}'",
      "code_example_correct": "dm_key = ':'.join(sorted([user_a, user_b]))"
    },
    {
      "mistake": "Sender not added to read_by on send",
      "why_wrong": "Sender would see their own message as unread",
      "correct_approach": "Initialize read_by with sender_id when creating message",
      "code_example_wrong": "read_by: Set[str] = field(default_factory=set)",
      "code_example_correct": "new_msg.read_by = {sender_id}"
    },
    {
      "mistake": "mark_as_read only marks single message",
      "why_wrong": "Users expect all prior messages to be marked read when scrolling to a point",
      "correct_approach": "Iterate from start and mark all messages up to the specified one",
      "code_example_wrong": "messages[message_id].read_by.add(user_id)",
      "code_example_correct": "for mid in msg_ids: msg.read_by.add(user_id); if mid == message_id: break"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start with data model (Message, Conversation), then explain indices for efficient lookup. Walk through send_message flow showing store-then-push pattern.",
    "what_to_mention": [
      "WebSocket for real-time in production (simulate with callbacks in interview)",
      "Kafka partitioned by conversation_id for ordering",
      "Read receipts as per-message sets vs per-conversation pointers tradeoff",
      "End-to-end encryption as production enhancement"
    ],
    "time_allocation": "3 min design, 10 min coding, 2 min testing",
    "if_stuck": [
      "Start with simplest case: 1:1 text message",
      "Draw the data flow diagram first",
      "Focus on which indices enable which operations"
    ]
  },
  "connection_to_next_part": "Part 5 could add: message reactions (extend Message with reactions map), message search (index on content), typing indicators (presence system), or voice/video calls (signaling layer). The Conversation/Message separation makes all extensions clean.",
  "communication_script": {
    "transition_from_previous": "Part 3 gave us search and explore. For Part 4, I need to add direct messaging - this is a separate domain from feed, so I'll add new data structures rather than modifying existing ones.",
    "explaining_changes": "The key insight is separating conversation metadata from messages. Conversations track who's in the chat and recency. Messages are stored separately and indexed by conversation_id for efficient retrieval.",
    "while_extending_code": [
      "Adding conversations dict for metadata...",
      "user_conversations index enables O(1) lookup of user's chats...",
      "conversation_messages maintains message ordering..."
    ],
    "after_completing": "DM functionality is complete. send_message is O(1), get_conversations is O(C log C) for sorting, get_messages is O(page_size). Ready for Part 5 or questions?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Identify 5 new methods needed, sketch Message and Conversation dataclasses",
    "by_5_min": "Explain data structure choices, start coding create_conversation",
    "by_10_min": "send_message and get_messages implemented",
    "by_15_min": "mark_as_read and create_group_chat done, running demo",
    "warning_signs": "If still designing at 8 min, simplify to just 1:1 messaging first"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "DM is isolated from Parts 1-3, unlikely to break them. If there's an issue, verify user_index is being populated.",
    "if_new_requirement_unclear": "Ask: 'For read receipts, should mark_as_read mark just the specified message or all prior messages?'",
    "if_running_behind": "Implement send_message and get_messages first, mention group chat and read receipts as 'would add next'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Canonical key for 1:1 deduplication without extra lookup",
      "Mentioning Kafka partition by conversation_id for ordering",
      "Store-then-push pattern for reliability",
      "Per-message vs per-conversation read tracking tradeoff"
    ]
  },
  "pattern_recognition": {
    "pattern": "Inverted Index + Event Sourcing",
    "indicators": [
      "Need fast lookup by multiple keys (user, conversation)",
      "Messages are immutable, append-only"
    ],
    "similar_problems": [
      "Slack/Discord messaging",
      "Email inbox",
      "Chat applications"
    ],
    "template": "Store entities by ID, build indices for access patterns, use append-only logs for ordering"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "Messaging is a separate domain from photos/stories, so new data structures needed",
      "why": "Loose coupling, no impact on existing features"
    },
    {
      "step": 2,
      "thought": "Need fast lookup: user's conversations AND messages in a conversation",
      "why": "Two access patterns require two indices"
    },
    {
      "step": 3,
      "thought": "1:1 conversations should be unique per user pair",
      "why": "UX expectation - clicking 'message Bob' always opens same thread"
    },
    {
      "step": 4,
      "thought": "Read receipts need per-message granularity for accuracy",
      "why": "Shows exactly which messages user has seen"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend cleanly without breaking existing code?",
      "Do you understand messaging data model?",
      "Can you design for multiple access patterns?"
    ],
    "bonus_points": [
      "Mentioning WebSocket vs polling tradeoffs",
      "Discussing message ordering guarantees",
      "Bringing up E2EE considerations"
    ],
    "red_flags": [
      "Storing messages inside Conversation object (doesn't scale)",
      "Missing participant validation",
      "No consideration for 1:1 deduplication"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for dataclass boilerplate",
      "Let it help with Set operations syntax"
    ],
    "what_not_to_do": [
      "Don't let AI design the index structure - explain it yourself",
      "Review read_by logic carefully"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Rushing into code without explaining data model",
      "Ignoring the real-time requirement"
    ],
    "technical": [
      "Storing messages in conversation object",
      "Missing sender validation",
      "Not handling existing 1:1 conversation"
    ],
    "communication": [
      "Not explaining why separate indices are needed",
      "Forgetting to mention production considerations (WebSocket, Kafka)"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "All 5 methods implemented: sendMessage, getConversations, getMessages, markAsRead, createGroupChat",
      "1:1 conversations are deduplicated via dm_index",
      "sender_id validated as participant before sending",
      "Conversation metadata updated on each message",
      "Demo shows basic flow working"
    ],
    "quick_code_review": [
      "Type hints on all new methods",
      "Consistent naming with Parts 1-3",
      "No modification to existing Part 1-3 methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "WebSocket layer for real-time push",
      "Message queue (Kafka) for reliable delivery",
      "Offline message queue per user",
      "End-to-end encryption",
      "Message deletion and edit support"
    ],
    "why_not_in_interview": "Focus on data model and core operations. Real-time infra is mentioned verbally.",
    "how_to_mention": "Say: 'In production, I'd use WebSocket for real-time delivery and Kafka partitioned by conversation_id for ordering guarantees.'"
  },
  "generated_at": "2026-01-19T05:08:16.400370",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}