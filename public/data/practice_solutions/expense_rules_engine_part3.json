{
  "problem_title": "Corporate Expense Rules Engine - Part 3: Rule Creation API",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 had hardcoded rules instantiated in code. Part 3 adds dynamic rule creation from JSON config, enabling managers to configure policies at runtime without code changes. We add Factory Pattern (creates rules from config), Registry Pattern (decouples type lookup), and Composite Pattern (AND/OR rule combinations).",
    "new_requirements": [
      "RuleFactory.create_rule(config) - Creates rules from JSON/dict config",
      "RuleRegistry.register(type_name, rule_class) - Registers rule types",
      "CompositeRule - Combines multiple rules with AND/OR logic",
      "Recursive rule creation for nested composites"
    ],
    "new_constraints": [
      "Factory must handle unknown rule types gracefully",
      "CompositeRule must implement Rule interface for seamless integration",
      "Registry enables adding new rule types without modifying factory code"
    ],
    "key_insight": "Use Registry to decouple rule type knowledge from factory. Factory does lookup + instantiation, Registry holds the mapping. This enables open/closed principle - add new rules without modifying existing code."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Create rules from JSON config",
        "how_met": "RuleFactory.create_rule() parses config and instantiates appropriate Rule class",
        "gotchas": [
          "Must handle nested CompositeRule recursively"
        ]
      },
      {
        "requirement": "Register custom rule types",
        "how_met": "RuleRegistry.register() stores mapping of type name to class",
        "gotchas": [
          "CompositeRule handled specially, not via registry"
        ]
      },
      {
        "requirement": "AND/OR rule combinations",
        "how_met": "CompositeRule evaluates children, applies operator logic",
        "gotchas": [
          "AND means ALL must violate; OR means ANY violation triggers composite violation"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "create_rule",
        "target": "O(r) for composite with r rules",
        "achieved": "O(r)",
        "why": "Linear in number of child rules, O(1) registry lookup"
      },
      {
        "operation": "register",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion"
      },
      {
        "operation": "CompositeRule.evaluate",
        "target": "O(r)",
        "achieved": "O(r)",
        "why": "Evaluates each child rule once"
      }
    ],
    "non_goals": [
      "Schema validation for config",
      "Persistence of rules to database",
      "API endpoint implementation (just the engine)"
    ]
  },
  "assumptions": [
    "Config is a valid dict/map with required fields (type, config, etc.)",
    "CompositeRule uses 'rules' key for children, 'operator' for AND/OR",
    "Empty composite returns no violation (edge case)",
    "Config keys match constructor parameter names for standard rules"
  ],
  "tradeoffs": [
    {
      "decision": "Registry stores classes vs factory functions",
      "chosen": "Classes per signature",
      "why": "Matches the required method signature",
      "alternative": "Factory functions for more flexibility",
      "when_to_switch": "If rules need complex initialization logic"
    },
    {
      "decision": "Explicit config mapping vs reflection",
      "chosen": "Explicit mapping in factory",
      "why": "Clearer, no reflection magic, interview-appropriate",
      "alternative": "Use **kwargs or inspect module",
      "when_to_switch": "If adding many rule types"
    },
    {
      "decision": "CompositeRule special-cased vs registered",
      "chosen": "Special-cased in factory",
      "why": "Needs recursive create_rule calls",
      "alternative": "Register with custom factory function",
      "when_to_switch": "If many meta-rules needed"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Rule and AggregationRule interfaces",
      "Existing rule class constructors",
      "evaluate_rules and evaluate_aggregation_rules methods"
    ],
    "what_to_change": [
      "Added RuleRegistry, RuleFactory, CompositeRule classes"
    ],
    "interfaces_and_boundaries": "Factory accepts any config with 'type' field. New rules just need to be registered. Part 4 could add rule versioning, persistence, or more composite operators.",
    "invariants": [
      "Registered rules must implement Rule interface",
      "CompositeRule with 0 children returns None",
      "Factory never modifies passed config"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 2):\\n  rules = [BanRule('expense_type', 'gambling'), MaxAmountRule(100)]\\n  # Hardcoded in application code\\n\\nAFTER (Part 3):\\n  config = {'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}}\\n  rule = factory.create_rule(config)\\n  # Dynamic creation from external config",
    "algorithm_flow": "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502  JSON Config    \u2502\u2500\u2500\u2500\u2500\u25ba\u2502   RuleFactory   \u2502\u2500\u2500\u2500\u2500\u25ba\u2502  Rule Instance  \u2502\\n\u2502  {type, config} \u2502     \u2502  create_rule()  \u2502     \u2502  BanRule(...)   \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n                                 \u2502\\n                                 \u25bc\\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n                        \u2502  RuleRegistry   \u2502\\n                        \u2502  type \u2192 class   \u2502\\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\nCOMPOSITE RULE:\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502           CompositeRule (operator=OR)         \u2502\\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\\n\u2502  \u2502 BanRule    \u2502   OR    \u2502 BanRule    \u2502       \u2502\\n\u2502  \u2502 gambling   \u2502         \u2502 entertain  \u2502       \u2502\\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\\n\u2502        \u25bc                      \u25bc               \u2502\\n\u2502    violation?             violation?          \u2502\\n\u2502        \u2502                      \u2502               \u2502\\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba ANY? \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\\n\u2502                  \u2502                            \u2502\\n\u2502                  \u25bc                            \u2502\\n\u2502         Composite Violation                   \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"
  },
  "approaches": [
    {
      "name": "Naive: Switch Statement Factory",
      "description": "Big switch/if-else in factory matching type strings to instantiation logic",
      "time_complexity": "O(1) lookup, O(r) for composite",
      "space_complexity": "O(1)",
      "why_not_optimal": "Violates Open/Closed - must modify factory code to add new rules. Not extensible."
    },
    {
      "name": "Optimal: Registry + Factory Pattern",
      "description": "Registry stores type\u2192class mapping. Factory does lookup + instantiation. CompositeRule handled recursively.",
      "time_complexity": "O(1) registry lookup, O(r) for composite with r rules",
      "space_complexity": "O(t) where t=registered types",
      "key_insight": "Decouple 'knowing about types' (Registry) from 'creating instances' (Factory). New rules added via register() without changing factory."
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Three-part design:**\n\n1. **RuleRegistry**: HashMap storing `{type_name \u2192 rule_class}`. O(1) registration and lookup. Decouples type knowledge from factory.\n\n2. **RuleFactory**: Given config dict, extracts type, looks up class in registry, maps config to constructor args. Special-cases CompositeRule for recursive child creation.\n\n3. **CompositeRule**: Implements Rule interface, holds list of child rules and operator. On `evaluate()`, runs all children:\n   - **OR**: Returns violation if ANY child returns violation\n   - **AND**: Returns violation only if ALL children return violations\n\n**Why this works:**\n- Adding new rule type = `registry.register(name, Class)` - no factory changes\n- CompositeRule is itself a Rule, enabling arbitrary nesting\n- Factory handles recursion naturally",
    "data_structures": [
      {
        "structure": "Dict/HashMap for registry",
        "purpose": "O(1) lookup of rule class by type name"
      },
      {
        "structure": "List for composite children",
        "purpose": "Store and iterate child rules"
      }
    ],
    "algorithm_steps": [
      "Step 1: Factory receives config dict with 'type' and 'config' keys",
      "Step 2: If type is 'CompositeRule', recursively create_rule() for each child in 'rules', then construct CompositeRule",
      "Step 3: Otherwise, lookup type in registry to get class",
      "Step 4: Extract constructor args from config using known mapping",
      "Step 5: Instantiate and return the rule"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass",
    "from decimal import Decimal",
    "from typing import List, Dict, Optional, Any, Type",
    "from collections import defaultdict",
    "",
    "",
    "@dataclass",
    "class Violation:",
    "    \"\"\"Immutable result when expense fails a rule.\"\"\"",
    "    expense_id: str",
    "    rule_name: str",
    "    reason: str",
    "",
    "",
    "@dataclass",
    "class AggregationViolation:",
    "    \"\"\"Trip-level violation with contributing expenses.\"\"\"",
    "    trip_id: str",
    "    rule_name: str",
    "    reason: str",
    "    contributing_expenses: List[str]",
    "",
    "",
    "class Rule(ABC):",
    "    \"\"\"Strategy interface for individual expense rules.\"\"\"",
    "    @abstractmethod",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        pass",
    "",
    "",
    "class AggregationRule(ABC):",
    "    \"\"\"Interface for rules that aggregate expenses by trip.\"\"\"",
    "    @abstractmethod",
    "    def evaluate(self, trip_id: str,",
    "                 trip_expenses: List[Dict[str, str]]) -> Optional[AggregationViolation]:",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        pass",
    "",
    "",
    "class BanRule(Rule):",
    "    \"\"\"Blocks expenses where field matches banned value.\"\"\"",
    "    def __init__(self, field: str, value: str):",
    "        self.field = field",
    "        self.banned_value = value",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        if expense.get(self.field) == self.banned_value:",
    "            return Violation(expense['expense_id'], self.get_name(),",
    "                           f\"{self.field} '{self.banned_value}' is not allowed\")",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'BanRule'",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"Caps individual expense at max_amount.\"\"\"",
    "    def __init__(self, max_amount: float):",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        amount = Decimal(expense['amount_usd'])",
    "        if amount > self.max_amount:",
    "            return Violation(expense['expense_id'], self.get_name(),",
    "                           f\"amount ${amount:.2f} exceeds max ${self.max_amount:.2f}\")",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'MaxAmountRule'",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"Caps amount for specific vendor_type.\"\"\"",
    "    def __init__(self, vendor_type: str, max_amount: float):",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        if expense.get('vendor_type') != self.vendor_type:",
    "            return None",
    "        amount = Decimal(expense['amount_usd'])",
    "        if amount > self.max_amount:",
    "            return Violation(expense['expense_id'], self.get_name(),",
    "                           f\"{self.vendor_type} ${amount:.2f} exceeds ${self.max_amount:.2f}\")",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'VendorTypeLimitRule'",
    "",
    "",
    "class CompositeRule(Rule):",
    "    \"\"\"Combines rules with AND/OR. OR=any violation, AND=all must violate.\"\"\"",
    "    def __init__(self, operator: str, rules: List[Rule]):",
    "        self.operator = operator.upper()",
    "        self.rules = rules",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        if not self.rules:",
    "            return None",
    "        violations = [r.evaluate(expense) for r in self.rules]",
    "        actual = [v for v in violations if v is not None]",
    "        ",
    "        if self.operator == 'OR' and actual:",
    "            return Violation(expense['expense_id'], self.get_name(),",
    "                           f\"matched {len(actual)}/{len(self.rules)} rules ({self.operator})\")",
    "        elif self.operator == 'AND' and len(actual) == len(self.rules):",
    "            return Violation(expense['expense_id'], self.get_name(),",
    "                           f\"matched all {len(self.rules)} rules ({self.operator})\")",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'CompositeRule'",
    "",
    "",
    "class TripTotalLimitRule(AggregationRule):",
    "    \"\"\"Caps total spending per trip.\"\"\"",
    "    def __init__(self, max_trip_total: float):",
    "        self.max_trip_total = Decimal(str(max_trip_total))",
    "    ",
    "    def evaluate(self, trip_id: str,",
    "                 trip_expenses: List[Dict[str, str]]) -> Optional[AggregationViolation]:",
    "        total = sum(Decimal(e['amount_usd']) for e in trip_expenses)",
    "        if total > self.max_trip_total:",
    "            return AggregationViolation(trip_id, self.get_name(),",
    "                f\"trip total ${total:.2f} exceeds ${self.max_trip_total:.2f}\",",
    "                [e['expense_id'] for e in trip_expenses])",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'TripTotalLimitRule'",
    "",
    "",
    "class ExpenseTypeAggregationRule(AggregationRule):",
    "    \"\"\"Caps total per trip for specific expense type.\"\"\"",
    "    def __init__(self, expense_type: str, max_amount: float):",
    "        self.expense_type = expense_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, trip_id: str,",
    "                 trip_expenses: List[Dict[str, str]]) -> Optional[AggregationViolation]:",
    "        matching = [e for e in trip_expenses if e.get('expense_type') == self.expense_type]",
    "        if not matching:",
    "            return None",
    "        total = sum(Decimal(e['amount_usd']) for e in matching)",
    "        if total > self.max_amount:",
    "            return AggregationViolation(trip_id, self.get_name(),",
    "                f\"{self.expense_type} total ${total:.2f} exceeds ${self.max_amount:.2f}\",",
    "                [e['expense_id'] for e in matching])",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'ExpenseTypeAggregationRule'",
    "",
    "",
    "class RuleRegistry:",
    "    \"\"\"Maps rule type names to classes. Enables adding rules without code changes.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._rules: Dict[str, Type[Rule]] = {}",
    "    ",
    "    def register(self, type_name: str, rule_class: Type[Rule]) -> None:",
    "        self._rules[type_name] = rule_class",
    "    ",
    "    def get(self, type_name: str) -> Optional[Type[Rule]]:",
    "        return self._rules.get(type_name)",
    "    ",
    "    def list_types(self) -> List[str]:",
    "        return list(self._rules.keys())",
    "",
    "",
    "class RuleFactory:",
    "    \"\"\"Creates Rule instances from JSON config using registry lookup.\"\"\"",
    "    ",
    "    def __init__(self, registry: RuleRegistry):",
    "        self.registry = registry",
    "    ",
    "    def create_rule(self, config: Dict[str, Any]) -> Rule:",
    "        \"\"\"Create rule from config. Handles CompositeRule recursively.\"\"\"",
    "        rule_type = config.get('type')",
    "        if not rule_type:",
    "            raise ValueError(\"Config missing 'type' field\")",
    "        ",
    "        # CompositeRule needs special handling for recursive creation",
    "        if rule_type == 'CompositeRule':",
    "            operator = config.get('operator', 'AND')",
    "            children = [self.create_rule(c) for c in config.get('rules', [])]",
    "            return CompositeRule(operator, children)",
    "        ",
    "        # Standard rules: lookup class, instantiate with config",
    "        rule_class = self.registry.get(rule_type)",
    "        if not rule_class:",
    "            raise ValueError(f\"Unknown rule type: {rule_type}\")",
    "        ",
    "        return self._instantiate(rule_type, rule_class, config.get('config', {}))",
    "    ",
    "    def _instantiate(self, type_name: str, cls: Type[Rule], cfg: Dict) -> Rule:",
    "        \"\"\"Map config dict to constructor arguments.\"\"\"",
    "        if type_name == 'BanRule':",
    "            return cls(cfg['field'], cfg['value'])",
    "        elif type_name == 'MaxAmountRule':",
    "            return cls(cfg['max_amount'])",
    "        elif type_name == 'VendorTypeLimitRule':",
    "            return cls(cfg['vendor_type'], cfg['max_amount'])",
    "        else:",
    "            return cls(**cfg)  # Fallback: kwargs",
    "",
    "",
    "def create_default_registry() -> RuleRegistry:",
    "    \"\"\"Factory function to create registry with standard rules.\"\"\"",
    "    registry = RuleRegistry()",
    "    registry.register('BanRule', BanRule)",
    "    registry.register('MaxAmountRule', MaxAmountRule)",
    "    registry.register('VendorTypeLimitRule', VendorTypeLimitRule)",
    "    return registry",
    "",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"Evaluates expenses against individual and aggregation rules.\"\"\"",
    "    ",
    "    def evaluate_rules(self, rules: List[Rule],",
    "                       expenses: List[Dict[str, str]]) -> List[Violation]:",
    "        violations = []",
    "        for expense in expenses:",
    "            for rule in rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "    ",
    "    def evaluate_aggregation_rules(",
    "            self, rules: List[AggregationRule],",
    "            expenses: List[Dict[str, str]]) -> List[AggregationViolation]:",
    "        trips: Dict[str, List[Dict[str, str]]] = defaultdict(list)",
    "        for expense in expenses:",
    "            trip_id = expense.get('trip_id', '')",
    "            if trip_id:",
    "                trips[trip_id].append(expense)",
    "        ",
    "        violations = []",
    "        for trip_id, trip_expenses in trips.items():",
    "            for rule in rules:",
    "                violation = rule.evaluate(trip_id, trip_expenses)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "",
    "",
    "if __name__ == '__main__':",
    "    # Setup: registry + factory",
    "    registry = create_default_registry()",
    "    factory = RuleFactory(registry)",
    "    engine = ExpenseRulesEngine()",
    "    ",
    "    print('=' * 60)",
    "    print('TEST 1: Create BanRule from config')",
    "    print('=' * 60)",
    "    ban_config = {'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}}",
    "    ban_rule = factory.create_rule(ban_config)",
    "    print(f'Created: {ban_rule.get_name()} (field={ban_rule.field}, value={ban_rule.banned_value})')",
    "    ",
    "    expense = {'expense_id': 'E001', 'amount_usd': '50.00', 'expense_type': 'gambling'}",
    "    v = ban_rule.evaluate(expense)",
    "    print(f'Expense E001 (gambling): {v.reason if v else \"PASSED\"}')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('TEST 2: CompositeRule with OR')",
    "    print('=' * 60)",
    "    composite_config = {",
    "        'type': 'CompositeRule',",
    "        'operator': 'OR',",
    "        'rules': [",
    "            {'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}},",
    "            {'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'entertainment'}}",
    "        ]",
    "    }",
    "    or_rule = factory.create_rule(composite_config)",
    "    ",
    "    test_expenses = [",
    "        {'expense_id': 'E001', 'amount_usd': '50', 'expense_type': 'gambling'},",
    "        {'expense_id': 'E002', 'amount_usd': '50', 'expense_type': 'entertainment'},",
    "        {'expense_id': 'E003', 'amount_usd': '50', 'expense_type': 'meals'}",
    "    ]",
    "    for e in test_expenses:",
    "        v = or_rule.evaluate(e)",
    "        print(f\"{e['expense_id']} ({e['expense_type']}): {v.reason if v else 'PASSED'}\")",
    "    # E001 and E002 should fail (gambling OR entertainment), E003 passes",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('TEST 3: CompositeRule with AND')",
    "    print('=' * 60)",
    "    and_config = {",
    "        'type': 'CompositeRule',",
    "        'operator': 'AND',",
    "        'rules': [",
    "            {'type': 'VendorTypeLimitRule', 'config': {'vendor_type': 'restaurant', 'max_amount': 50}},",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 100}}",
    "        ]",
    "    }",
    "    and_rule = factory.create_rule(and_config)",
    "    ",
    "    test_expenses2 = [",
    "        {'expense_id': 'E001', 'amount_usd': '150', 'vendor_type': 'restaurant'},  # Both fail",
    "        {'expense_id': 'E002', 'amount_usd': '60', 'vendor_type': 'restaurant'},   # Only vendor fails",
    "        {'expense_id': 'E003', 'amount_usd': '40', 'vendor_type': 'restaurant'}    # Neither fails",
    "    ]",
    "    for e in test_expenses2:",
    "        v = and_rule.evaluate(e)",
    "        print(f\"{e['expense_id']} (${e['amount_usd']}): {v.reason if v else 'PASSED'}\")",
    "    # Only E001 should fail (violates BOTH rules)",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('TEST 4: Factory with engine integration')",
    "    print('=' * 60)",
    "    rules = [factory.create_rule(ban_config), factory.create_rule(and_config)]",
    "    all_expenses = [",
    "        {'expense_id': 'E001', 'amount_usd': '50', 'expense_type': 'gambling', 'vendor_type': 'casino'},",
    "        {'expense_id': 'E002', 'amount_usd': '150', 'expense_type': 'meals', 'vendor_type': 'restaurant'}",
    "    ]",
    "    violations = engine.evaluate_rules(rules, all_expenses)",
    "    for v in violations:",
    "        print(f'[{v.expense_id}] {v.rule_name}: {v.reason}')"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "import java.util.function.Function;",
    "",
    "class Violation {",
    "    public final String expenseId;",
    "    public final String ruleName;",
    "    public final String reason;",
    "    public Violation(String expenseId, String ruleName, String reason) {",
    "        this.expenseId = expenseId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "    }",
    "}",
    "",
    "class AggregationViolation {",
    "    public final String tripId;",
    "    public final String ruleName;",
    "    public final String reason;",
    "    public final List<String> contributingExpenses;",
    "    public AggregationViolation(String tripId, String ruleName, String reason, List<String> expenses) {",
    "        this.tripId = tripId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "        this.contributingExpenses = expenses;",
    "    }",
    "}",
    "",
    "interface Rule {",
    "    Optional<Violation> evaluate(Map<String, String> expense);",
    "    String getName();",
    "}",
    "",
    "interface AggregationRule {",
    "    Optional<AggregationViolation> evaluate(String tripId, List<Map<String, String>> tripExpenses);",
    "    String getName();",
    "}",
    "",
    "class BanRule implements Rule {",
    "    private final String field;",
    "    private final String bannedValue;",
    "    public BanRule(String field, String value) { this.field = field; this.bannedValue = value; }",
    "    public String getField() { return field; }",
    "    public String getBannedValue() { return bannedValue; }",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (bannedValue.equals(expense.get(field))) {",
    "            return Optional.of(new Violation(expense.get(\"expense_id\"), getName(),",
    "                String.format(\"%s '%s' is not allowed\", field, bannedValue)));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    @Override public String getName() { return \"BanRule\"; }",
    "}",
    "",
    "class MaxAmountRule implements Rule {",
    "    private final BigDecimal maxAmount;",
    "    public MaxAmountRule(double maxAmount) { this.maxAmount = BigDecimal.valueOf(maxAmount); }",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "        if (amount.compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(expense.get(\"expense_id\"), getName(),",
    "                String.format(\"amount $%.2f exceeds max $%.2f\", amount, maxAmount)));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    @Override public String getName() { return \"MaxAmountRule\"; }",
    "}",
    "",
    "class VendorTypeLimitRule implements Rule {",
    "    private final String vendorType;",
    "    private final BigDecimal maxAmount;",
    "    public VendorTypeLimitRule(String vendorType, double maxAmount) {",
    "        this.vendorType = vendorType;",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (!vendorType.equals(expense.get(\"vendor_type\"))) return Optional.empty();",
    "        BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "        if (amount.compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(expense.get(\"expense_id\"), getName(),",
    "                String.format(\"%s $%.2f exceeds $%.2f\", vendorType, amount, maxAmount)));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    @Override public String getName() { return \"VendorTypeLimitRule\"; }",
    "}",
    "",
    "class CompositeRule implements Rule {",
    "    private final String operator;",
    "    private final List<Rule> rules;",
    "    public CompositeRule(String operator, List<Rule> rules) {",
    "        this.operator = operator.toUpperCase();",
    "        this.rules = rules;",
    "    }",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (rules.isEmpty()) return Optional.empty();",
    "        List<Violation> violations = new ArrayList<>();",
    "        for (Rule rule : rules) {",
    "            rule.evaluate(expense).ifPresent(violations::add);",
    "        }",
    "        if (\"OR\".equals(operator) && !violations.isEmpty()) {",
    "            return Optional.of(new Violation(expense.get(\"expense_id\"), getName(),",
    "                String.format(\"matched %d/%d rules (OR)\", violations.size(), rules.size())));",
    "        } else if (\"AND\".equals(operator) && violations.size() == rules.size()) {",
    "            return Optional.of(new Violation(expense.get(\"expense_id\"), getName(),",
    "                String.format(\"matched all %d rules (AND)\", rules.size())));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    @Override public String getName() { return \"CompositeRule\"; }",
    "}",
    "",
    "class TripTotalLimitRule implements AggregationRule {",
    "    private final BigDecimal maxTripTotal;",
    "    public TripTotalLimitRule(double maxTripTotal) { this.maxTripTotal = BigDecimal.valueOf(maxTripTotal); }",
    "    @Override",
    "    public Optional<AggregationViolation> evaluate(String tripId, List<Map<String, String>> tripExpenses) {",
    "        BigDecimal total = tripExpenses.stream().map(e -> new BigDecimal(e.get(\"amount_usd\")))",
    "            .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "        if (total.compareTo(maxTripTotal) > 0) {",
    "            List<String> ids = new ArrayList<>();",
    "            tripExpenses.forEach(e -> ids.add(e.get(\"expense_id\")));",
    "            return Optional.of(new AggregationViolation(tripId, getName(),",
    "                String.format(\"trip total $%.2f exceeds $%.2f\", total, maxTripTotal), ids));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    @Override public String getName() { return \"TripTotalLimitRule\"; }",
    "}",
    "",
    "class RuleRegistry {",
    "    private final Map<String, Class<? extends Rule>> registry = new HashMap<>();",
    "    public void register(String typeName, Class<? extends Rule> ruleClass) {",
    "        registry.put(typeName, ruleClass);",
    "    }",
    "    public Class<? extends Rule> get(String typeName) { return registry.get(typeName); }",
    "    public boolean has(String typeName) { return registry.containsKey(typeName); }",
    "}",
    "",
    "@SuppressWarnings(\"unchecked\")",
    "class RuleFactory {",
    "    private final RuleRegistry registry;",
    "    public RuleFactory(RuleRegistry registry) { this.registry = registry; }",
    "    ",
    "    public Rule createRule(Map<String, Object> config) {",
    "        String type = (String) config.get(\"type\");",
    "        if (type == null) throw new IllegalArgumentException(\"Missing 'type' in config\");",
    "        ",
    "        if (\"CompositeRule\".equals(type)) {",
    "            String operator = (String) config.getOrDefault(\"operator\", \"AND\");",
    "            List<Map<String, Object>> childConfigs = (List<Map<String, Object>>) config.get(\"rules\");",
    "            List<Rule> children = new ArrayList<>();",
    "            if (childConfigs != null) {",
    "                for (Map<String, Object> cc : childConfigs) children.add(createRule(cc));",
    "            }",
    "            return new CompositeRule(operator, children);",
    "        }",
    "        ",
    "        Class<? extends Rule> cls = registry.get(type);",
    "        if (cls == null) throw new IllegalArgumentException(\"Unknown rule type: \" + type);",
    "        Map<String, Object> cfg = (Map<String, Object>) config.getOrDefault(\"config\", new HashMap<>());",
    "        return instantiate(type, cfg);",
    "    }",
    "    ",
    "    private Rule instantiate(String type, Map<String, Object> cfg) {",
    "        switch (type) {",
    "            case \"BanRule\": return new BanRule((String) cfg.get(\"field\"), (String) cfg.get(\"value\"));",
    "            case \"MaxAmountRule\": return new MaxAmountRule(((Number) cfg.get(\"max_amount\")).doubleValue());",
    "            case \"VendorTypeLimitRule\":",
    "                return new VendorTypeLimitRule((String) cfg.get(\"vendor_type\"),",
    "                    ((Number) cfg.get(\"max_amount\")).doubleValue());",
    "            default: throw new IllegalArgumentException(\"Cannot instantiate: \" + type);",
    "        }",
    "    }",
    "}",
    "",
    "public class ExpenseRulesEngine {",
    "    public List<Violation> evaluateRules(List<Rule> rules, List<Map<String, String>> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        for (Map<String, String> expense : expenses) {",
    "            for (Rule rule : rules) {",
    "                rule.evaluate(expense).ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "    ",
    "    public List<AggregationViolation> evaluateAggregationRules(",
    "            List<AggregationRule> rules, List<Map<String, String>> expenses) {",
    "        Map<String, List<Map<String, String>>> trips = new HashMap<>();",
    "        for (Map<String, String> expense : expenses) {",
    "            String tripId = expense.get(\"trip_id\");",
    "            if (tripId != null && !tripId.isEmpty()) {",
    "                trips.computeIfAbsent(tripId, k -> new ArrayList<>()).add(expense);",
    "            }",
    "        }",
    "        List<AggregationViolation> violations = new ArrayList<>();",
    "        for (var entry : trips.entrySet()) {",
    "            for (AggregationRule rule : rules) {",
    "                rule.evaluate(entry.getKey(), entry.getValue()).ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        RuleRegistry registry = new RuleRegistry();",
    "        registry.register(\"BanRule\", BanRule.class);",
    "        registry.register(\"MaxAmountRule\", MaxAmountRule.class);",
    "        registry.register(\"VendorTypeLimitRule\", VendorTypeLimitRule.class);",
    "        RuleFactory factory = new RuleFactory(registry);",
    "        ExpenseRulesEngine engine = new ExpenseRulesEngine();",
    "        ",
    "        System.out.println(\"TEST 1: Create BanRule from config\");",
    "        Map<String, Object> banConfig = new HashMap<>();",
    "        banConfig.put(\"type\", \"BanRule\");",
    "        Map<String, Object> banCfg = new HashMap<>();",
    "        banCfg.put(\"field\", \"expense_type\"); banCfg.put(\"value\", \"gambling\");",
    "        banConfig.put(\"config\", banCfg);",
    "        Rule banRule = factory.createRule(banConfig);",
    "        System.out.printf(\"Created: %s%n\", banRule.getName());",
    "        ",
    "        System.out.println(\"\\nTEST 2: CompositeRule with OR\");",
    "        Map<String, Object> orConfig = new HashMap<>();",
    "        orConfig.put(\"type\", \"CompositeRule\");",
    "        orConfig.put(\"operator\", \"OR\");",
    "        List<Map<String, Object>> orRules = new ArrayList<>();",
    "        Map<String, Object> r1 = new HashMap<>();",
    "        r1.put(\"type\", \"BanRule\");",
    "        Map<String, Object> r1cfg = new HashMap<>(); r1cfg.put(\"field\", \"expense_type\"); r1cfg.put(\"value\", \"gambling\");",
    "        r1.put(\"config\", r1cfg); orRules.add(r1);",
    "        Map<String, Object> r2 = new HashMap<>();",
    "        r2.put(\"type\", \"BanRule\");",
    "        Map<String, Object> r2cfg = new HashMap<>(); r2cfg.put(\"field\", \"expense_type\"); r2cfg.put(\"value\", \"entertainment\");",
    "        r2.put(\"config\", r2cfg); orRules.add(r2);",
    "        orConfig.put(\"rules\", orRules);",
    "        Rule orRule = factory.createRule(orConfig);",
    "        ",
    "        Map<String, String> exp1 = new HashMap<>(); exp1.put(\"expense_id\", \"E001\");",
    "        exp1.put(\"expense_type\", \"gambling\"); exp1.put(\"amount_usd\", \"50\");",
    "        Optional<Violation> v1 = orRule.evaluate(exp1);",
    "        System.out.printf(\"E001 (gambling): %s%n\", v1.isPresent() ? v1.get().reason : \"PASSED\");",
    "        ",
    "        Map<String, String> exp2 = new HashMap<>(); exp2.put(\"expense_id\", \"E002\");",
    "        exp2.put(\"expense_type\", \"meals\"); exp2.put(\"amount_usd\", \"50\");",
    "        Optional<Violation> v2 = orRule.evaluate(exp2);",
    "        System.out.printf(\"E002 (meals): %s%n\", v2.isPresent() ? v2.get().reason : \"PASSED\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and existing dataclasses (Violation, AggregationViolation) unchanged from Part 2"
    },
    {
      "lines": "17-35",
      "explanation": "Rule and AggregationRule abstract interfaces unchanged"
    },
    {
      "lines": "37-75",
      "explanation": "Existing individual rules (BanRule, MaxAmountRule, VendorTypeLimitRule) unchanged"
    },
    {
      "lines": "77-95",
      "explanation": "NEW: CompositeRule implements Rule, holds operator and child rules list. evaluate() collects all child violations, returns based on operator logic"
    },
    {
      "lines": "97-130",
      "explanation": "Existing aggregation rules unchanged"
    },
    {
      "lines": "132-148",
      "explanation": "NEW: RuleRegistry - simple HashMap wrapper with register/get methods"
    },
    {
      "lines": "150-175",
      "explanation": "NEW: RuleFactory - create_rule handles CompositeRule specially for recursion, otherwise uses registry lookup + _instantiate helper"
    },
    {
      "lines": "177-185",
      "explanation": "NEW: create_default_registry helper function pre-registers standard rules"
    },
    {
      "lines": "187-210",
      "explanation": "ExpenseRulesEngine unchanged from Part 2"
    },
    {
      "lines": "213-270",
      "explanation": "Demo showing: simple rule creation, OR composite, AND composite, engine integration"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "RuleRegistry.register": {
          "complexity": "O(1)",
          "explanation": "HashMap put"
        },
        "RuleRegistry.get": {
          "complexity": "O(1)",
          "explanation": "HashMap get"
        },
        "RuleFactory.create_rule": {
          "complexity": "O(r) for composite, O(1) for simple",
          "explanation": "Recursively creates r child rules for composite"
        },
        "CompositeRule.evaluate": {
          "complexity": "O(r)",
          "explanation": "Evaluates each of r child rules"
        }
      },
      "overall_change": "Part 2 was O(E*R). With composites, a composite with r children counts as r evaluations. So O(E * total_rule_evaluations)"
    },
    "space": {
      "additional_space": "O(T) for registry with T types, O(R) for composite with R nested rules",
      "explanation": "Registry stores class references (constant per type). Composite stores references to child rules."
    }
  },
  "dry_run": {
    "example_input": "CompositeRule(OR, [BanRule(gambling), BanRule(entertainment)]) with expense {expense_type: 'entertainment'}",
    "steps": [
      {
        "step": 1,
        "action": "factory.create_rule(composite_config)",
        "state": "Parse type='CompositeRule', operator='OR'",
        "explanation": "Detected composite, enter special handling"
      },
      {
        "step": 2,
        "action": "Recursively create child rules",
        "state": "Call create_rule for each child config",
        "explanation": "Creates BanRule(gambling) and BanRule(entertainment)"
      },
      {
        "step": 3,
        "action": "Return CompositeRule(OR, [ban1, ban2])",
        "state": "Composite rule ready",
        "explanation": "Factory returns composite with children"
      },
      {
        "step": 4,
        "action": "compositeRule.evaluate(expense)",
        "state": "expense={expense_type: 'entertainment'}",
        "explanation": "Evaluate expense against composite"
      },
      {
        "step": 5,
        "action": "ban1.evaluate -> None",
        "state": "gambling != entertainment",
        "explanation": "First child passes (no violation)"
      },
      {
        "step": 6,
        "action": "ban2.evaluate -> Violation",
        "state": "entertainment == entertainment",
        "explanation": "Second child finds violation"
      },
      {
        "step": 7,
        "action": "Check OR logic: any violation?",
        "state": "violations = [Violation]",
        "explanation": "Yes, 1 violation found"
      },
      {
        "step": 8,
        "action": "Return composite violation",
        "state": "Violation('E001', 'CompositeRule', 'matched 1/2 rules (OR)')",
        "explanation": "OR triggered by any child violation"
      }
    ],
    "final_output": "Violation indicating expense failed composite rule"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create simple BanRule from config, verify field/value",
      "Empty composite should return None"
    ],
    "likely_bugs": [
      "Forgetting to handle CompositeRule recursion",
      "AND/OR logic inverted",
      "Missing 'config' key access"
    ],
    "recommended_logs_or_asserts": [
      "assert created_rule.get_name() == expected",
      "Log child violations before operator check"
    ],
    "how_to_localize": "Add print in _instantiate to see what args are passed. Check registry.get returns correct class."
  },
  "edge_cases": [
    {
      "case": "Empty composite rules list",
      "handling": "Return None (no violation)",
      "gotcha": "Don't fail on empty list"
    },
    {
      "case": "Unknown rule type",
      "handling": "Raise ValueError",
      "gotcha": "Check registry.get result before using"
    },
    {
      "case": "Missing config key",
      "handling": "KeyError bubbles up or provide defaults",
      "gotcha": "Document required config fields"
    },
    {
      "case": "Nested composites",
      "handling": "Recursion handles naturally",
      "gotcha": "Stack depth for deeply nested rules"
    }
  ],
  "test_cases": [
    {
      "name": "Simple rule creation",
      "input": "{'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}}",
      "expected": "BanRule instance that blocks gambling expenses",
      "explanation": "Factory looks up BanRule in registry, passes field/value to constructor"
    },
    {
      "name": "OR composite - any violation triggers",
      "input": "CompositeRule(OR, [BanGambling, BanEntertainment]) with entertainment expense",
      "expected": "Violation (matched entertainment ban)",
      "explanation": "Only second child violates, but OR means any=violation"
    },
    {
      "name": "AND composite - all must violate",
      "input": "CompositeRule(AND, [VendorLimit(restaurant,50), MaxAmount(100)]) with $60 restaurant expense",
      "expected": "No violation (only vendor limit violated)",
      "explanation": "Vendor limit violated ($60>$50) but max amount passes ($60<$100), AND needs all"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "AND/OR logic inverted",
      "why_wrong": "AND should mean 'all must violate', OR means 'any violation triggers'",
      "correct_approach": "Think of it as: OR = union of failures, AND = intersection of failures",
      "code_example_wrong": "if operator == 'AND' and any_violation: return violation",
      "code_example_correct": "if operator == 'AND' and len(violations) == len(rules): return violation"
    },
    {
      "mistake": "Not handling recursive CompositeRule",
      "why_wrong": "Nested composites need recursive create_rule calls",
      "correct_approach": "Check for CompositeRule type first, recursively create children",
      "code_example_wrong": "rule_class = registry.get('CompositeRule')  # Wrong - no such registration",
      "code_example_correct": "if type == 'CompositeRule': children = [create_rule(c) for c in config['rules']]"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the three patterns: Registry (type lookup), Factory (instantiation), Composite (rule combination). Draw the flow diagram showing config -> factory -> registry lookup -> rule instance.",
    "what_to_mention": [
      "Open/Closed principle - add rules without modifying factory",
      "CompositeRule is itself a Rule - seamless nesting",
      "Registry decouples type knowledge"
    ],
    "time_allocation": "2 min: explain patterns, 6 min: implement registry+factory+composite, 2 min: test",
    "if_stuck": [
      "Start with just Registry and Factory for simple rules",
      "Add CompositeRule after basic factory works",
      "AND/OR logic can be simplified to counting violations"
    ]
  },
  "connection_to_next_part": "Part 4 could add: rule versioning/history, persistence to database, rule priority/ordering, more operators (NOT, XOR), validation schemas for config, or dynamic AggregationRule creation.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 handles trip-level aggregation. For Part 3, we need dynamic rule creation from config. This is a classic Factory + Registry pattern. Let me explain...",
    "explaining_changes": "The key change is we're adding three classes: RuleRegistry stores type-to-class mapping, RuleFactory creates rules from config using that registry, and CompositeRule enables AND/OR combinations by implementing Rule interface with child rules.",
    "while_extending_code": [
      "I'm adding RuleRegistry with a simple HashMap...",
      "Factory handles CompositeRule specially because it needs recursion...",
      "CompositeRule collects all child violations then applies operator logic..."
    ],
    "after_completing": "Now managers can create rules at runtime via JSON config. Factory creates any registered rule type in O(1), composites in O(r). The patterns make adding new rule types trivial - just register them."
  },
  "time_milestones": {
    "time_budget": "10-15 minutes for this part",
    "by_2_min": "Explain Factory + Registry + Composite patterns, draw the flow",
    "by_5_min": "RuleRegistry implemented, start on RuleFactory",
    "by_8_min": "Factory working for simple rules, start CompositeRule",
    "by_12_min": "CompositeRule done, testing with examples",
    "warning_signs": "If still designing at 5 min, just start coding. Factory pattern is standard."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Registry and Factory are independent of Part 2. You can add them even if Part 2 has bugs.",
    "if_new_requirement_unclear": "Ask: 'For CompositeRule, AND means all children must violate for a composite violation, correct?'",
    "if_running_behind": "Skip the create_default_registry helper. Focus on Registry, Factory, and CompositeRule core logic."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning Open/Closed principle explicitly",
      "Noting CompositeRule enables arbitrary nesting",
      "Discussing how to add validation schemas for config",
      "Suggesting rule versioning for audit trails"
    ]
  },
  "pattern_recognition": {
    "pattern": "Factory + Registry + Composite Pattern combination",
    "indicators": [
      "Dynamic object creation from config",
      "Type lookup by string name",
      "Combining objects with operators"
    ],
    "similar_problems": [
      "LC 297 - Serialize/Deserialize Tree (uses factory-like creation)",
      "Expression parsers",
      "Query builders"
    ],
    "template": "Registry stores mapping, Factory does lookup+instantiate, Composite wraps children with operator"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'create objects from config', I immediately think Factory Pattern",
      "why": "Factory encapsulates object creation logic, hides which concrete class is instantiated"
    },
    {
      "step": 2,
      "thought": "The 'type' field in config suggests we need type -> class mapping",
      "why": "This is exactly what Registry Pattern provides - decoupled type lookup"
    },
    {
      "step": 3,
      "thought": "AND/OR combinations of rules means Composite Pattern",
      "why": "Composite lets you treat individual objects and compositions uniformly"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Knowledge of design patterns",
      "Clean separation of concerns",
      "Ability to handle recursion naturally",
      "Understanding of AND/OR semantics"
    ],
    "bonus_points": [
      "Mentioning Open/Closed",
      "Discussing validation",
      "Noting testability improvements",
      "Suggesting config schema"
    ],
    "red_flags": [
      "Giant switch statement instead of registry",
      "Not handling nested composites",
      "Confusing AND/OR semantics"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate boilerplate for Registry class",
      "Let it help with recursive create_rule structure"
    ],
    "what_not_to_do": [
      "Don't let AI decide the AND/OR semantics - clarify with interviewer",
      "Understand the factory-registry relationship yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not explaining why patterns are used",
      "Rushing without mentioning trade-offs"
    ],
    "technical": [
      "Hardcoding rule types in factory switch statement",
      "Not implementing Rule interface on CompositeRule"
    ],
    "communication": [
      "Not drawing the config -> factory -> rule flow",
      "Forgetting to test composite rules"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Registry.register and Registry.get work correctly",
      "Factory creates simple rules from config",
      "Factory handles CompositeRule with recursion",
      "CompositeRule AND/OR logic is correct",
      "CompositeRule implements Rule interface"
    ],
    "quick_code_review": [
      "All new classes have appropriate type hints",
      "Error handling for unknown rule type",
      "Demo covers simple rule, OR composite, AND composite"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "JSON schema validation for configs",
      "Logging rule creation for audit",
      "Config persistence to database",
      "Rule versioning for rollback"
    ],
    "why_not_in_interview": "Focus on core patterns; these are mentioned but not implemented",
    "how_to_mention": "Say: 'In production, I'd add JSON schema validation so invalid configs fail fast, plus logging for audit trails.'"
  },
  "generated_at": "2026-01-19T04:41:13.070379",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}