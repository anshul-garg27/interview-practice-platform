{
  "problem_title": "Corporate Expense Rules Engine",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **Strategy Pattern** problem disguised as an expense validation system. The core challenge is designing an extensible rule evaluation framework where each rule type is independent, self-contained, and easy to add without modifying existing code.",
    "pattern_recognition": "**Strategy Pattern** + **Polymorphism** + **Open/Closed Principle**. Each rule is a strategy that implements a common interface. The engine orchestrates rule evaluation without knowing rule specifics.",
    "key_constraints": [
      "Amounts are **strings** - must parse to Decimal for comparison (float precision issues)",
      "One expense can violate **multiple rules** - don't short-circuit on first violation",
      "Rules must be **extensible** - new rule types shouldn't require modifying existing code",
      "Return detailed violations - expense_id, rule_name, and reason"
    ],
    "clarifying_questions": [
      "Should rules be evaluated in order, or can violations be returned in any order? - Affects output consistency",
      "How should we handle invalid expense data (missing fields)? - Defensive programming needs",
      "Is $75.00 exactly at the limit a violation or allowed? - Boundary condition clarity (examples show it's allowed)",
      "Can the same rule type be applied multiple times with different values? - e.g., multiple BanRules",
      "Should violation messages follow a specific format? - Output standardization",
      "Are all expense fields guaranteed to be present? - Input validation requirements"
    ],
    "edge_cases_to_consider": [
      "Expense exactly at limit ($75.00 with $75 limit) - should PASS",
      "Expense just over limit ($75.01 with $75 limit) - should FAIL",
      "Same expense violating multiple rules - return ALL violations",
      "No violations at all - return empty list",
      "BanRule on non-existent field - should not match",
      "Very large amounts as strings ('99999.99')",
      "Zero amount expenses"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Design flexible Rule interface/base class",
        "how_met": "Abstract Rule class with evaluate() method returning Optional[Violation]",
        "gotchas": [
          "Don't forget get_name() for identifying which rule triggered"
        ]
      },
      {
        "requirement": "evaluateRules(rules, expenses) -> violations",
        "how_met": "ExpenseRulesEngine.evaluate_rules() iterates all expenses \u00d7 all rules",
        "gotchas": [
          "Don't short-circuit - one expense can have multiple violations"
        ]
      },
      {
        "requirement": "BanRule blocks by field value",
        "how_met": "BanRule checks if expense[field] == banned_value",
        "gotchas": [
          "Field name is configurable - can ban expense_type, vendor_type, or vendor_name"
        ]
      },
      {
        "requirement": "MaxAmountRule caps individual expense",
        "how_met": "MaxAmountRule compares parsed amount against max_amount",
        "gotchas": [
          "Use Decimal for precision, boundary is > not >="
        ]
      },
      {
        "requirement": "VendorTypeLimitRule caps amount for specific vendor type",
        "how_met": "VendorTypeLimitRule checks vendor_type match THEN amount",
        "gotchas": [
          "Only applies if vendor_type matches - skip otherwise"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "evaluate_rules",
        "target": "O(E \u00d7 R)",
        "achieved": "O(E \u00d7 R)",
        "why": "Must check each expense against each rule"
      }
    ],
    "non_goals": [
      "Persisting rules or expenses to database",
      "Async rule evaluation",
      "Rule priority or ordering",
      "Combining rules with AND/OR logic (Part 2+)",
      "Trip-level aggregation (Part 2)"
    ]
  },
  "assumptions": [
    "All expenses have required fields: expense_id, amount_usd, expense_type, vendor_type",
    "Amounts are valid decimal strings (no currency symbols)",
    "Limit comparisons use > (strictly greater than) - exactly at limit passes",
    "Violations can be returned in any order",
    "Same rule type can appear multiple times with different parameters"
  ],
  "tradeoffs": [
    {
      "decision": "Abstract class vs Interface for Rule",
      "chosen": "Abstract class (Python ABC)",
      "why": "Allows shared helper methods if needed, clear contract",
      "alternative": "Pure interface (Protocol in Python)",
      "when_to_switch": "If rules need multiple inheritance"
    },
    {
      "decision": "Return type for evaluate()",
      "chosen": "Optional[Violation]",
      "why": "Clean API - None means pass, Violation means fail",
      "alternative": "List[Violation] per rule",
      "when_to_switch": "If a single rule could produce multiple violations"
    },
    {
      "decision": "Decimal vs float for amounts",
      "chosen": "Decimal",
      "why": "Financial precision - 0.1 + 0.1 + 0.1 must equal 0.3",
      "alternative": "Float with rounding",
      "when_to_switch": "Never for financial systems"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Open/Closed Principle**: Add new rules by creating new classes, not modifying engine",
      "**Single Responsibility**: Each rule handles one type of validation",
      "**Strategy Pattern**: Rules are interchangeable strategies with common interface",
      "**Dependency Inversion**: Engine depends on Rule abstraction, not concrete implementations"
    ],
    "why_this_design_scales": "Adding a new rule type (e.g., TripTotalRule) requires ONLY creating a new class that implements Rule. The ExpenseRulesEngine doesn't change at all. This is the power of polymorphism.",
    "expected_followup_hooks": [
      "Rule.evaluate() signature will need modification for trip-level rules (needs all expenses)",
      "May need RuleContext object to pass additional state",
      "Violation class might need severity levels or auto-approval flags"
    ],
    "invariants": [
      "Every rule must return a Violation with expense_id matching the input expense",
      "Rules are pure functions - same input always produces same output",
      "Violations preserve original expense_id for traceability"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    EXPENSE RULES ENGINE                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502   RULES (Strategies)                                                \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502   \u2502  BanRule    \u2502  \u2502 MaxAmount   \u2502  \u2502 VendorTypeLimit       \u2502      \u2502\n\u2502   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502      \u2502\n\u2502   \u2502field:       \u2502  \u2502max: $250    \u2502  \u2502vendor: restaurant     \u2502      \u2502\n\u2502   \u2502expense_type \u2502  \u2502             \u2502  \u2502max: $75               \u2502      \u2502\n\u2502   \u2502value:       \u2502  \u2502             \u2502  \u2502                       \u2502      \u2502\n\u2502   \u2502entertainment\u2502  \u2502             \u2502  \u2502                       \u2502      \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502          \u2502                \u2502                     \u2502                   \u2502\n\u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2502                           \u2502                                         \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2502\n\u2502                    \u2502 evaluate()  \u2502                                  \u2502\n\u2502                    \u2502  interface  \u2502                                  \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2502\n\u2502                           \u2502                                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   EXPENSES               \u25bc                                          \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502 E001 \u2502 $49.99  \u2502 client_hosting \u2502 restaurant \u2502 Outback    \u2502   \u2502\n\u2502   \u2502 E002 \u2502 $150.00 \u2502 entertainment  \u2502 theater    \u2502 AMC        \u2502\u25c4\u2500\u2500\u253c\u2500\u2500 Violates BanRule\n\u2502   \u2502 E003 \u2502 $85.00  \u2502 meals          \u2502 restaurant \u2502 Subway     \u2502\u25c4\u2500\u2500\u253c\u2500\u2500 Violates VendorLimit\n\u2502   \u2502 E004 \u2502 $350.00 \u2502 airfare        \u2502 airline    \u2502 Delta      \u2502\u25c4\u2500\u2500\u253c\u2500\u2500 Violates MaxAmount\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   VIOLATIONS                                                        \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502 E002 \u2502 BanRule        \u2502 expense_type 'entertainment' banned \u2502   \u2502\n\u2502   \u2502 E003 \u2502 VendorLimit    \u2502 restaurant $85 > limit $75          \u2502   \u2502\n\u2502   \u2502 E004 \u2502 MaxAmountRule  \u2502 $350 exceeds max $250               \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\nCLASS HIERARCHY (Strategy Pattern)\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502   <<abstract>>    \u2502\n         \u2502       Rule        \u2502\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502+ evaluate(expense)\u2502\n         \u2502+ get_name()       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502           \u2502               \u2502\n   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502BanRule\u2502   \u2502MaxAmount  \u2502   \u2502VendorTypeLimit\u2502\n   \u2502       \u2502   \u2502Rule       \u2502   \u2502Rule           \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502-field \u2502   \u2502-max_amount\u2502   \u2502-vendor_type   \u2502\n   \u2502-value \u2502   \u2502           \u2502   \u2502-max_amount    \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                    \u2502\n                    \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  ExpenseRulesEngine    \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n       \u2502+ evaluate_rules(       \u2502\n       \u2502    rules, expenses     \u2502\n       \u2502  ) -> List[Violation]  \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Initialize empty violations list",
        "visualization": "violations = []",
        "key_point": "We collect ALL violations, not just first one"
      },
      {
        "step": 2,
        "description": "Outer loop: iterate through each expense",
        "visualization": "for expense in expenses:  # E001, E002, ...",
        "key_point": "Process one expense at a time"
      },
      {
        "step": 3,
        "description": "Inner loop: check expense against each rule",
        "visualization": "  for rule in rules:  # BanRule, MaxRule, ...",
        "key_point": "Every expense is checked against every rule"
      },
      {
        "step": 4,
        "description": "Evaluate and collect violations",
        "visualization": "    violation = rule.evaluate(expense)\n    if violation: violations.append(violation)",
        "key_point": "None means pass, Violation object means fail"
      },
      {
        "step": 5,
        "description": "Return all collected violations",
        "visualization": "return violations",
        "key_point": "Could be empty if all expenses pass all rules"
      }
    ],
    "dry_run_table": "| Step | Expense | Rule | Amount Check | Result | Violation |\n|------|---------|------|--------------|--------|----------|\n| 1 | E001 ($49.99, restaurant, client_hosting) | BanRule(entertainment) | N/A | PASS | - |\n| 2 | E001 | MaxAmountRule($250) | $49.99 \u2264 $250 | PASS | - |\n| 3 | E001 | VendorTypeLimitRule(restaurant, $75) | $49.99 \u2264 $75 | PASS | - |\n| 4 | E002 ($150, theater, entertainment) | BanRule(entertainment) | Match! | **FAIL** | \u2713 |\n| 5 | E002 | MaxAmountRule($250) | $150 \u2264 $250 | PASS | - |\n| 6 | E002 | VendorTypeLimitRule(restaurant, $75) | vendor\u2260restaurant | SKIP | - |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see 'rules engine' with multiple rule types, I immediately think **Strategy Pattern** - each rule type is a strategy with a common evaluate interface",
      "The requirement 'easy to add new rule types' screams **Open/Closed Principle** - I need an abstraction that allows extension without modification",
      "One expense can violate multiple rules means I must NOT short-circuit - iterate ALL rules for EACH expense",
      "Amounts as strings + financial context = I MUST use Decimal, not float, for precision",
      "The key insight: polymorphism lets the engine call evaluate() without knowing which rule type it is"
    ],
    "key_insight": "The engine doesn't need to know anything about specific rules. It just calls `rule.evaluate(expense)` on each rule. This is the power of polymorphism and the Strategy Pattern - the complexity of 'which rule does what' is encapsulated in each rule class.",
    "why_this_works": "By defining a common Rule interface with `evaluate(expense) -> Optional[Violation]`, we achieve:\n1. **Extensibility**: New rules just implement the interface\n2. **Testability**: Each rule can be tested in isolation\n3. **Maintainability**: Changing BanRule logic doesn't affect MaxAmountRule\n4. **Clean separation**: Engine orchestrates, rules decide"
  },
  "approaches": [
    {
      "name": "Brute Force (Procedural)",
      "description": "Giant if-else chain checking rule types in main function",
      "pseudocode": "def evaluate(rules, expenses):\n  violations = []\n  for expense in expenses:\n    for rule in rules:\n      if rule.type == 'ban':\n        # ban logic\n      elif rule.type == 'max':\n        # max logic\n      elif rule.type == 'vendor':\n        # vendor logic\n  return violations",
      "time_complexity": "O(E \u00d7 R)",
      "space_complexity": "O(V) for violations",
      "pros": [
        "Quick to write for simple cases"
      ],
      "cons": [
        "Violates Open/Closed - adding new rule requires modifying main function",
        "Hard to test individual rules",
        "Code becomes spaghetti quickly",
        "Doesn't meet extensibility requirement"
      ],
      "when_to_use": "Never in a real interview asking for OOP design"
    },
    {
      "name": "Optimal: Strategy Pattern with Polymorphism",
      "description": "Abstract Rule interface with concrete implementations. Engine uses polymorphic evaluate() calls.",
      "pseudocode": "class Rule:\n  def evaluate(expense) -> Violation?\n\nclass BanRule(Rule):  # Implements evaluate\nclass MaxAmountRule(Rule):  # Implements evaluate\nclass VendorTypeLimitRule(Rule):  # Implements evaluate\n\ndef evaluate_rules(rules, expenses):\n  violations = []\n  for expense in expenses:\n    for rule in rules:  # Polymorphism!\n      violation = rule.evaluate(expense)\n      if violation: violations.append(violation)\n  return violations",
      "time_complexity": "O(E \u00d7 R) where E=expenses, R=rules",
      "space_complexity": "O(V) where V=violations",
      "pros": [
        "Clean separation of concerns",
        "Easy to add new rules (Open/Closed)",
        "Each rule testable in isolation",
        "Interviewer-friendly design"
      ],
      "cons": [
        "Slightly more code upfront"
      ],
      "key_insight": "The engine calls evaluate() on each rule without knowing the rule type - that's polymorphism at work"
    }
  ],
  "optimal_solution": {
    "name": "Strategy Pattern with Decimal Precision",
    "explanation_md": "## Approach\n\nWe implement the **Strategy Pattern** where each rule type is a concrete strategy implementing a common `Rule` interface.\n\n### Core Components\n\n1. **Violation dataclass** - Immutable result object with expense_id, rule_name, reason\n2. **Rule abstract class** - Defines `evaluate(expense)` and `get_name()` contract\n3. **Concrete rules** - BanRule, MaxAmountRule, VendorTypeLimitRule\n4. **ExpenseRulesEngine** - Orchestrates evaluation without knowing rule specifics\n\n### Why This Works\n\nThe engine's `evaluate_rules()` method iterates through all expenses and all rules, calling `rule.evaluate(expense)` polymorphically. Each rule:\n- Receives an expense dict\n- Decides if it applies (VendorTypeLimitRule only applies to matching vendor_type)\n- Returns `None` (pass) or `Violation` (fail)\n\n### Precision Matters\n\nWe use `Decimal` for all monetary comparisons because:\n```python\n# Float fails:\nfloat(0.1) + float(0.1) + float(0.1) == 0.30000000000000004\n\n# Decimal works:\nDecimal('0.1') + Decimal('0.1') + Decimal('0.1') == Decimal('0.3')\n```",
    "data_structures": [
      {
        "structure": "ABC Rule class",
        "purpose": "Define contract for all rule types"
      },
      {
        "structure": "Violation dataclass",
        "purpose": "Immutable violation result with context"
      },
      {
        "structure": "Decimal",
        "purpose": "Precise monetary comparisons"
      },
      {
        "structure": "List[Violation]",
        "purpose": "Collect all violations"
      }
    ],
    "algorithm_steps": [
      "1. Define Violation dataclass with expense_id, rule_name, reason",
      "2. Define abstract Rule class with evaluate() and get_name()",
      "3. Implement BanRule: check if expense[field] matches banned value",
      "4. Implement MaxAmountRule: check if amount > max_amount",
      "5. Implement VendorTypeLimitRule: if vendor matches, check amount",
      "6. Engine iterates all expenses \u00d7 all rules, collecting violations"
    ],
    "why_decimal": "Financial systems must never use float. `0.1 + 0.1 + 0.1 != 0.3` in IEEE 754 floating point. Decimal ensures exact decimal arithmetic."
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass",
    "from decimal import Decimal",
    "from typing import List, Dict, Optional",
    "",
    "",
    "@dataclass",
    "class Violation:",
    "    \"\"\"Immutable result when expense fails a rule.\"\"\"",
    "    expense_id: str",
    "    rule_name: str",
    "    reason: str",
    "",
    "",
    "class Rule(ABC):",
    "    \"\"\"Strategy interface - all rule types implement this.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        \"\"\"Returns Violation if expense fails, None if passes.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        \"\"\"Rule type identifier for violation reporting.\"\"\"",
    "        pass",
    "",
    "",
    "class BanRule(Rule):",
    "    \"\"\"Blocks expenses where field matches banned value.\"\"\"",
    "    ",
    "    def __init__(self, field: str, value: str):",
    "        self.field = field",
    "        self.banned_value = value",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        if expense.get(self.field) == self.banned_value:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.field} '{self.banned_value}' is not allowed\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'BanRule'",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"Caps individual expense at max_amount.\"\"\"",
    "    ",
    "    def __init__(self, max_amount: float):",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        amount = Decimal(expense['amount_usd'])",
    "        if amount > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"amount ${amount:.2f} exceeds maximum ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'MaxAmountRule'",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"Caps amount for specific vendor_type.\"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: float):",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        # Rule only applies to matching vendor type",
    "        if expense.get('vendor_type') != self.vendor_type:",
    "            return None",
    "        ",
    "        amount = Decimal(expense['amount_usd'])",
    "        if amount > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.vendor_type} expense ${amount:.2f} exceeds limit ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'VendorTypeLimitRule'",
    "",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"Evaluates expenses against rules, returns all violations.\"\"\"",
    "    ",
    "    def evaluate_rules(self, rules: List[Rule], ",
    "                       expenses: List[Dict[str, str]]) -> List[Violation]:",
    "        violations = []",
    "        for expense in expenses:",
    "            for rule in rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "",
    "",
    "if __name__ == '__main__':",
    "    # Demo: Basic expense evaluation",
    "    engine = ExpenseRulesEngine()",
    "    ",
    "    rules = [",
    "        BanRule('expense_type', 'entertainment'),",
    "        BanRule('expense_type', 'airfare'),",
    "        MaxAmountRule(250),",
    "        VendorTypeLimitRule('restaurant', 75)",
    "    ]",
    "    ",
    "    expenses = [",
    "        {'expense_id': 'E001', 'amount_usd': '49.99', ",
    "         'expense_type': 'client_hosting', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E002', 'amount_usd': '150.00',",
    "         'expense_type': 'entertainment', 'vendor_type': 'theater'},",
    "        {'expense_id': 'E003', 'amount_usd': '85.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant'},",
    "        {'expense_id': 'E004', 'amount_usd': '350.00',",
    "         'expense_type': 'airfare', 'vendor_type': 'airline'}",
    "    ]",
    "    ",
    "    violations = engine.evaluate_rules(rules, expenses)",
    "    ",
    "    print('=' * 60)",
    "    print('EXPENSE RULES ENGINE - VIOLATION REPORT')",
    "    print('=' * 60)",
    "    ",
    "    if not violations:",
    "        print('No violations found!')",
    "    else:",
    "        for v in violations:",
    "            print(f'[{v.expense_id}] {v.rule_name}: {v.reason}')",
    "    ",
    "    # Expected output:",
    "    # [E002] BanRule: expense_type 'entertainment' is not allowed",
    "    # [E003] VendorTypeLimitRule: restaurant expense $85.00 exceeds limit $75.00",
    "    # [E004] BanRule: expense_type 'airfare' is not allowed",
    "    # [E004] MaxAmountRule: amount $350.00 exceeds maximum $250.00"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "",
    "// Immutable violation result",
    "class Violation {",
    "    public final String expenseId;",
    "    public final String ruleName;",
    "    public final String reason;",
    "    ",
    "    public Violation(String expenseId, String ruleName, String reason) {",
    "        this.expenseId = expenseId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "    }",
    "}",
    "",
    "// Strategy interface",
    "interface Rule {",
    "    Optional<Violation> evaluate(Map<String, String> expense);",
    "    String getName();",
    "}",
    "",
    "class BanRule implements Rule {",
    "    private final String field;",
    "    private final String bannedValue;",
    "    ",
    "    public BanRule(String field, String value) {",
    "        this.field = field;",
    "        this.bannedValue = value;",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (bannedValue.equals(expense.get(field))) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                String.format(\"%s '%s' is not allowed\", field, bannedValue)",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"BanRule\"; }",
    "}",
    "",
    "class MaxAmountRule implements Rule {",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public MaxAmountRule(double maxAmount) {",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "        if (amount.compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                String.format(\"amount $%.2f exceeds maximum $%.2f\", amount, maxAmount)",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"MaxAmountRule\"; }",
    "}",
    "",
    "class VendorTypeLimitRule implements Rule {",
    "    private final String vendorType;",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public VendorTypeLimitRule(String vendorType, double maxAmount) {",
    "        this.vendorType = vendorType;",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        if (!vendorType.equals(expense.get(\"vendor_type\"))) {",
    "            return Optional.empty();  // Rule doesn't apply",
    "        }",
    "        ",
    "        BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "        if (amount.compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                String.format(\"%s expense $%.2f exceeds limit $%.2f\", ",
    "                              vendorType, amount, maxAmount)",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"VendorTypeLimitRule\"; }",
    "}",
    "",
    "public class ExpenseRulesEngine {",
    "    ",
    "    public List<Violation> evaluateRules(List<Rule> rules, ",
    "                                         List<Map<String, String>> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        for (Map<String, String> expense : expenses) {",
    "            for (Rule rule : rules) {",
    "                rule.evaluate(expense).ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        ExpenseRulesEngine engine = new ExpenseRulesEngine();",
    "        ",
    "        List<Rule> rules = Arrays.asList(",
    "            new BanRule(\"expense_type\", \"entertainment\"),",
    "            new MaxAmountRule(250),",
    "            new VendorTypeLimitRule(\"restaurant\", 75)",
    "        );",
    "        ",
    "        List<Map<String, String>> expenses = new ArrayList<>();",
    "        Map<String, String> e1 = new HashMap<>();",
    "        e1.put(\"expense_id\", \"E001\");",
    "        e1.put(\"amount_usd\", \"49.99\");",
    "        e1.put(\"expense_type\", \"client_hosting\");",
    "        e1.put(\"vendor_type\", \"restaurant\");",
    "        expenses.add(e1);",
    "        ",
    "        Map<String, String> e2 = new HashMap<>();",
    "        e2.put(\"expense_id\", \"E002\");",
    "        e2.put(\"amount_usd\", \"150.00\");",
    "        e2.put(\"expense_type\", \"entertainment\");",
    "        e2.put(\"vendor_type\", \"theater\");",
    "        expenses.add(e2);",
    "        ",
    "        List<Violation> violations = engine.evaluateRules(rules, expenses);",
    "        ",
    "        System.out.println(\"VIOLATION REPORT\");",
    "        for (Violation v : violations) {",
    "            System.out.printf(\"[%s] %s: %s%n\", v.expenseId, v.ruleName, v.reason);",
    "        }",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-4",
      "section": "Imports",
      "explanation": "We import `ABC` for abstract class, `dataclass` for clean data containers, `Decimal` for precise financial math, and typing hints. **Critical**: Using Decimal prevents float precision bugs like `0.1 + 0.1 + 0.1 \u2260 0.3`"
    },
    {
      "lines": "7-12",
      "section": "Violation dataclass",
      "explanation": "Immutable result object capturing: **which expense** failed, **which rule** caught it, and **why**. Using dataclass gives us `__init__`, `__repr__`, and `__eq__` for free."
    },
    {
      "lines": "15-26",
      "section": "Rule abstract class",
      "explanation": "This is the **Strategy interface**. All concrete rules must implement:\n- `evaluate()`: Returns `None` if expense passes, `Violation` if it fails\n- `get_name()`: Returns rule type for violation reporting\n\nThis abstraction is what enables extensibility - the engine doesn't need to know about specific rule implementations."
    },
    {
      "lines": "29-46",
      "section": "BanRule implementation",
      "explanation": "Checks if `expense[field]` matches `banned_value`. Uses `expense.get(field)` to safely handle missing fields (returns `None`, won't match). The field is configurable - can ban by `expense_type`, `vendor_type`, or `vendor_name`."
    },
    {
      "lines": "49-66",
      "section": "MaxAmountRule implementation",
      "explanation": "Parses amount string to Decimal, compares with `>` (strictly greater - exactly at limit passes). Note we convert `max_amount` to Decimal in `__init__` once, not in every `evaluate()` call."
    },
    {
      "lines": "69-90",
      "section": "VendorTypeLimitRule implementation",
      "explanation": "**Two-step check**: First verifies vendor_type matches (returns `None` early if not), then checks amount. This is a good example of a rule that only applies conditionally."
    },
    {
      "lines": "93-102",
      "section": "ExpenseRulesEngine.evaluate_rules",
      "explanation": "The **orchestrator** that doesn't know rule specifics. It simply:\n1. Iterates all expenses\n2. For each expense, iterates all rules\n3. Calls `rule.evaluate()` polymorphically\n4. Collects non-None results\n\n**Key**: We don't short-circuit - one expense can have multiple violations."
    },
    {
      "lines": "105-140",
      "section": "Demo with test cases",
      "explanation": "Demonstrates:\n- E001: $49.99 restaurant passes all rules\n- E002: $150 entertainment fails BanRule\n- E003: $85 restaurant fails VendorTypeLimitRule\n- E004: $350 airfare fails BanRule AND MaxAmountRule (multiple violations)"
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test each rule in isolation first: create one BanRule, one expense, verify violation\n2. Test edge cases: exactly at limit ($75.00), just over ($75.01)\n3. Test multiple rules on one expense\n4. Test expense that passes all rules (should return empty list)",
    "what_to_print_or_assert": [
      "print(f'Evaluating {rule.get_name()} on {expense[\"expense_id\"]}')",
      "print(f'Amount: {amount}, Max: {self.max_amount}, Exceeds: {amount > self.max_amount}')",
      "assert len(violations) == expected_count",
      "assert violations[0].expense_id == 'E002'"
    ],
    "common_failure_modes": [
      "String amount not parsed to Decimal - comparison fails silently",
      "Using >= instead of > for limit check (boundary condition)",
      "Short-circuiting on first violation per expense",
      "Typo in field name ('expenseType' vs 'expense_type')"
    ],
    "how_to_fix_fast": "Add a print inside each rule's evaluate() showing the comparison values. If amount shows as string or comparisons seem wrong, check Decimal conversion. If violations missing, check if evaluate() returns None when it shouldn't."
  },
  "complexity_analysis": {
    "time": {
      "evaluate_rules": {
        "complexity": "O(E \u00d7 R)",
        "explanation": "Each expense checked against each rule"
      },
      "BanRule.evaluate": {
        "complexity": "O(1)",
        "explanation": "Dictionary lookup + string comparison"
      },
      "MaxAmountRule.evaluate": {
        "complexity": "O(1)",
        "explanation": "Parse amount + decimal comparison"
      },
      "VendorTypeLimitRule.evaluate": {
        "complexity": "O(1)",
        "explanation": "Two string comparisons + decimal comparison"
      },
      "overall": "O(E \u00d7 R) where E=number of expenses, R=number of rules"
    },
    "space": {
      "complexity": "O(V)",
      "breakdown": "- Rules storage: O(R)\n- Expenses storage: O(E) (passed in, not owned)\n- Violations list: O(V) where V \u2264 E \u00d7 R worst case",
      "note": "In practice, violations are sparse - most expenses pass most rules"
    },
    "can_we_do_better": "For this problem, O(E \u00d7 R) is necessary - we must check each expense against each rule. Could optimize with rule indexing if many rules exist (e.g., HashMap from field->BanRules), but unnecessary for given constraints (\u226450 rules, \u22641000 expenses)."
  },
  "dry_run": {
    "example": "Rules: [BanRule(entertainment), MaxAmountRule($250), VendorTypeLimitRule(restaurant, $75)]\nExpenses: [E001: $49.99 restaurant, E002: $150 entertainment, E003: $85 restaurant]",
    "trace_table": "| Expense | Rule | Check | Result | Violation Added |\n|---------|------|-------|--------|----------------|\n| E001 ($49.99, restaurant) | BanRule(entertainment) | expense_type='client_hosting' \u2260 'entertainment' | PASS | - |\n| E001 | MaxAmountRule($250) | $49.99 > $250? No | PASS | - |\n| E001 | VendorTypeLimitRule(restaurant, $75) | vendor=restaurant \u2713, $49.99 > $75? No | PASS | - |\n| E002 ($150, theater, entertainment) | BanRule(entertainment) | expense_type='entertainment' = 'entertainment' | **FAIL** | \u2705 |\n| E002 | MaxAmountRule($250) | $150 > $250? No | PASS | - |\n| E002 | VendorTypeLimitRule(restaurant, $75) | vendor='theater' \u2260 'restaurant' | SKIP | - |\n| E003 ($85, restaurant, meals) | BanRule(entertainment) | expense_type='meals' \u2260 'entertainment' | PASS | - |\n| E003 | MaxAmountRule($250) | $85 > $250? No | PASS | - |\n| E003 | VendorTypeLimitRule(restaurant, $75) | vendor=restaurant \u2713, $85 > $75? Yes | **FAIL** | \u2705 |",
    "final_answer": "2 violations: [E002 BanRule, E003 VendorTypeLimitRule]"
  },
  "test_cases": [
    {
      "name": "Basic - Single expense passes single rule",
      "category": "Happy Path",
      "input": "rules=[MaxAmountRule(100)], expenses=[{id:E001, amount:50}]",
      "expected": "[]",
      "explanation": "$50 < $100 limit, no violation"
    },
    {
      "name": "Basic - Single expense fails single rule",
      "category": "Happy Path",
      "input": "rules=[MaxAmountRule(100)], expenses=[{id:E001, amount:150}]",
      "expected": "[Violation(E001, MaxAmountRule, ...)]",
      "explanation": "$150 > $100 limit"
    },
    {
      "name": "One expense, multiple violations",
      "category": "Core Logic",
      "input": "rules=[BanRule(airfare), MaxAmountRule(250)], expenses=[{id:E001, amount:350, type:airfare}]",
      "expected": "2 violations for E001",
      "explanation": "Same expense triggers BanRule AND MaxAmountRule"
    },
    {
      "name": "Boundary - Exactly at limit",
      "category": "Edge Case",
      "input": "rules=[MaxAmountRule(75)], expenses=[{id:E001, amount:75.00}]",
      "expected": "[] (passes)",
      "explanation": "Limit is > not >=, so exactly $75.00 passes"
    },
    {
      "name": "Boundary - Just over limit",
      "category": "Edge Case",
      "input": "rules=[MaxAmountRule(75)], expenses=[{id:E001, amount:75.01}]",
      "expected": "[Violation(E001, MaxAmountRule, ...)]",
      "explanation": "$75.01 > $75 triggers violation"
    },
    {
      "name": "VendorTypeLimitRule - Non-matching vendor",
      "category": "Rule Logic",
      "input": "rules=[VendorTypeLimitRule(restaurant, 75)], expenses=[{id:E001, amount:100, vendor:hotel}]",
      "expected": "[]",
      "explanation": "Rule only applies to restaurant vendors, hotel expense skipped"
    },
    {
      "name": "No violations - All pass",
      "category": "Edge Case",
      "input": "Multiple rules, multiple expenses, all compliant",
      "expected": "[]",
      "explanation": "Empty list when no violations found"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not parsing string amounts",
      "why_wrong": "expense['amount_usd'] is '49.99' (string), not 49.99 (number)",
      "correct_approach": "Parse with Decimal(expense['amount_usd'])",
      "code_wrong": "if expense['amount_usd'] > self.max_amount:  # Compares strings!",
      "code_correct": "amount = Decimal(expense['amount_usd'])\nif amount > self.max_amount:"
    },
    {
      "mistake": "Short-circuiting on first violation",
      "why_wrong": "An expense can violate multiple rules - must report ALL",
      "correct_approach": "Continue checking all rules even after finding a violation",
      "code_wrong": "for rule in rules:\n    violation = rule.evaluate(expense)\n    if violation:\n        return [violation]  # WRONG - stops too early!",
      "code_correct": "for rule in rules:\n    violation = rule.evaluate(expense)\n    if violation:\n        violations.append(violation)  # Continue checking"
    },
    {
      "mistake": "Using float for currency",
      "why_wrong": "0.1 + 0.1 + 0.1 = 0.30000000000000004 in float",
      "correct_approach": "Use Decimal for exact decimal arithmetic",
      "code_wrong": "amount = float(expense['amount_usd'])",
      "code_correct": "amount = Decimal(expense['amount_usd'])"
    },
    {
      "mistake": "Hardcoding rule logic in engine",
      "why_wrong": "Violates Open/Closed Principle, can't add new rules without modification",
      "correct_approach": "Rules implement common interface, engine uses polymorphism",
      "code_wrong": "if rule.type == 'ban': # check ban\nelif rule.type == 'max': # check max",
      "code_correct": "violation = rule.evaluate(expense)  # Polymorphism!"
    },
    {
      "mistake": "Wrong boundary condition (>= instead of >)",
      "why_wrong": "Examples show $75.00 exactly at $75 limit passes",
      "correct_approach": "Use > for comparison, not >=",
      "code_wrong": "if amount >= self.max_amount:",
      "code_correct": "if amount > self.max_amount:"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to clarify a few things and share my initial thoughts on the design approach.",
    "clarifying_questions_to_ask": [
      "For limits like $75, should exactly $75.00 pass or fail? (Looking at examples, it seems to pass)",
      "Are amounts always valid decimal strings, or should I handle parsing errors?",
      "Can multiple rules of the same type exist? e.g., two BanRules with different values",
      "Should violations be returned in any particular order?",
      "For VendorTypeLimitRule, what if an expense doesn't have a vendor_type field?"
    ],
    "what_to_mention_proactively": [
      "I'll use the Strategy Pattern - each rule type implements a common interface",
      "This follows Open/Closed Principle - we can add new rules without modifying the engine",
      "I'll use Decimal for monetary precision, not float",
      "I'll make sure to collect ALL violations, not short-circuit on the first one"
    ],
    "communication_during_coding": [
      "I'm defining an abstract Rule class as my strategy interface",
      "Each concrete rule will implement evaluate() which returns None for pass, Violation for fail",
      "The engine just iterates and calls evaluate() - it doesn't know rule specifics",
      "Let me trace through an example to verify..."
    ],
    "if_stuck": [
      "Think: What's the key pattern here? Rules engine = Strategy Pattern",
      "Draw the class hierarchy on paper",
      "Focus on one rule type first, then generalize"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Design classes on paper | 10-25min: Implement | 25-35min: Test/trace | 35-45min: Follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Strategy Pattern + Polymorphism",
    "indicators": [
      "Multiple types of 'things' that do similar operations (rules evaluating expenses)",
      "Need to be easily extensible (add new rule types)",
      "Same interface, different implementations"
    ],
    "similar_problems": [
      "Notification System: EmailNotifier, SMSNotifier, PushNotifier all implement Notifier.send()",
      "Payment Processing: CreditCard, PayPal, Crypto all implement PaymentMethod.process()",
      "File Parser: JSONParser, XMLParser, CSVParser all implement Parser.parse()"
    ],
    "template": "1. Define interface with operation method\n2. Create concrete implementations\n3. Client code uses interface, unaware of concrete types\n4. Easy to add new implementations without changing client"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 adds **Trip-Level Aggregation Rules** like 'total restaurant spend per trip \u2264 $200'. You'll need to:\n- Group expenses by trip_id\n- Aggregate amounts before comparison\n- Consider passing all expenses to rule.evaluate() instead of one at a time",
    "part_3_hint": "Part 3 adds a **Rule Creation API** - parsing rule definitions from JSON/config. You'll need:\n- Rule factory pattern\n- Validation of rule parameters\n- Possibly a rule DSL",
    "data_structure_evolution": "Part 1: Rule interface + concrete classes \u2192 Part 2: Add TripAggregationRule that needs expense grouping \u2192 Part 3: Add RuleFactory to create rules from config"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. I see this is a rules engine for expense validation. Before I start coding, let me confirm a few things and share my design approach.",
    "after_clarification": "Great, so to summarize: I need to design an extensible rule system where each rule evaluates expenses independently, and one expense can have multiple violations. I'll use the Strategy Pattern for this. Sound good?",
    "while_coding": [
      "I'm creating a Violation dataclass to capture the three pieces of info we need: expense_id, rule_name, and reason",
      "This Rule abstract class is my strategy interface - all rule types will implement evaluate()",
      "Notice I'm using Decimal here for the amount comparison to avoid float precision issues",
      "The engine's job is simple - just iterate and call evaluate() on each rule polymorphically"
    ],
    "after_coding": "Let me trace through Example 1 to verify this works correctly...",
    "when_stuck_verbatim": "Let me step back and think about what pattern fits here. Multiple rule types with the same interface... this is a classic Strategy Pattern scenario.",
    "after_mistake": "Good catch - I see the issue. The boundary should be > not >=. Let me fix that.",
    "before_moving_on": "This solution handles all three rule types and properly collects all violations. Time complexity is O(E\u00d7R), space is O(V) for violations. Ready for Part 2?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "OOP design skills - proper use of abstraction and polymorphism",
      "Understanding of SOLID principles, especially Open/Closed",
      "Attention to detail - boundary conditions, decimal precision",
      "Communication - explaining design decisions clearly",
      "Testing instinct - tracing through examples"
    ],
    "bonus_points": [
      "Mentioning Strategy Pattern by name",
      "Proactively bringing up Decimal for currency",
      "Drawing class diagram before coding",
      "Identifying that one expense can have multiple violations",
      "Asking about boundary conditions (> vs >=)"
    ],
    "red_flags": [
      "Giant if-else chain in main function",
      "Hardcoding rule types instead of using polymorphism",
      "Using float for currency without mentioning precision concerns",
      "Only returning first violation per expense",
      "Not asking any clarifying questions"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize the Strategy Pattern, discuss design tradeoffs before coding, use proper types for currency, and systematically verify their solution with examples. They treat the problem as a collaboration, explaining their reasoning as they go."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions, identify Strategy Pattern",
    "by_10_min": "Explain design approach, sketch class hierarchy, get interviewer buy-in",
    "by_20_min": "Violation class + Rule interface + at least one concrete rule done",
    "by_30_min": "All three rule types + engine implemented",
    "by_35_min": "Dry run through example complete, bugs fixed",
    "by_40_min": "Complexity discussed, ready for Part 2",
    "warning_signs": "If you're still discussing design at 15 min or still implementing rules at 35 min, you need to speed up"
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Say: 'Actually, I see an issue - I'm using >= when I should use >. Let me fix that.' Fix it, verify with a quick trace, move on.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for Python ABC, but I need an abstract method. Let me write it as I remember and we can adjust.' This is fine.",
    "when_approach_is_wrong": "Say: 'Actually, if I hardcode rule types in the engine, I can't easily add new rules. Let me use polymorphism instead.' Pivoting shows adaptability.",
    "when_completely_stuck": "Say: 'I'm thinking about how to make this extensible. Could you confirm if I'm on the right track with using an interface for rules?'",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on getting the core working and explain what I'd add.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them strategically but demonstrate understanding.",
    "what_to_do": [
      "Let AI generate boilerplate (imports, dataclass structure)",
      "Use AI for test case generation",
      "Accept obvious autocompletes for repetitive code",
      "Use AI to check syntax you're unsure about"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and accept the solution",
      "Don't accept complex suggestions without understanding them",
      "Don't let AI design your class hierarchy",
      "Don't use AI-generated code you can't explain"
    ],
    "how_to_demonstrate_understanding": "When AI suggests something, say: 'This uses the Strategy Pattern, which is exactly what I wanted because...' The interviewer evaluates YOUR understanding.",
    "expectation_adjustment": "With AI, you should complete more parts. If you're slower with AI than without, turn it off."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing a UML-style class diagram before coding",
      "Naming Strategy Pattern explicitly",
      "Mentioning Open/Closed Principle",
      "Using Decimal and explaining why",
      "Proactively identifying the 'multiple violations per expense' requirement"
    ],
    "subtle_signals_of_experience": [
      "Checking boundary conditions with examples",
      "Using Optional return type instead of null",
      "Making Violation immutable (dataclass)",
      "Good variable names (banned_value not val)",
      "Comments explaining 'why' not 'what'"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Coding silently for more than 60 seconds",
      "Getting defensive when interviewer questions design",
      "Rushing to code without confirming approach",
      "Ignoring interviewer hints"
    ],
    "technical": [
      "Using float for money",
      "If-else chain instead of polymorphism",
      "Returning only first violation",
      "Hardcoding field names in base class",
      "Not handling missing fields safely"
    ],
    "communication": [
      "Not explaining design decisions",
      "Using jargon without explanation",
      "Not testing with examples",
      "Not discussing complexity"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2713 Rule interface with evaluate() method defined",
      "\u2713 All three rule types implemented (Ban, MaxAmount, VendorTypeLimit)",
      "\u2713 Engine collects ALL violations, not just first",
      "\u2713 Amounts parsed from strings to Decimal",
      "\u2713 Boundary condition is > not >=",
      "\u2713 Traced through at least one example",
      "\u2713 Discussed time/space complexity"
    ],
    "quick_code_review": [
      "No magic numbers",
      "Consistent naming (snake_case for Python)",
      "Proper imports",
      "Type hints present",
      "Readable variable names"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation - check required fields exist",
      "Custom exceptions for parsing failures",
      "Logging for debugging and audit trail",
      "Rule priority/ordering if needed",
      "Configuration-driven rule loading",
      "Async evaluation for large expense volumes"
    ],
    "why_not_in_interview": "Interview code should focus on core logic. Mention these verbally: 'In production I'd also add logging and validation, but for now I'll focus on the rule logic.'",
    "how_to_mention": "After completing core implementation, say: 'In a production system, I'd add input validation, logging for the audit trail, and potentially async evaluation if we're processing thousands of expenses. But for this interview, let's focus on the core design.'"
  },
  "generated_at": "2026-01-19T04:02:11.805001",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}