{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 3: Search and Explore",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds content discovery capabilities: user search, hashtag search, location-based search, personalized explore feed, and trending hashtags. This transforms Instagram from a follower-only feed into a discovery platform.",
    "new_requirements": [
      "Search users by username/name with relevance ranking",
      "Find posts by hashtag with pagination",
      "Geo-spatial search for posts near a location",
      "Personalized explore feed with engagement-based ranking",
      "Trending hashtags computation"
    ],
    "new_constraints": [
      "Search must handle partial matches and rank by relevance",
      "Location search needs distance calculation within radius",
      "Explore feed must exclude followed users and own posts",
      "Trending must be time-aware (recent activity matters)"
    ],
    "key_insight": "Build inverted indices during write (upload_photo) to enable fast reads. User search uses relevance scoring (exact > prefix > contains), explore uses engagement scoring with recency decay."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "User Search",
        "how_met": "search_users() with prefix/substring matching and relevance scoring",
        "gotchas": [
          "Case-insensitive matching",
          "Empty query returns empty"
        ]
      },
      {
        "requirement": "Hashtag Search",
        "how_met": "hashtag_index inverted index built on upload, search_hashtag() with pagination",
        "gotchas": [
          "Normalize hashtags (lowercase, strip #)",
          "Sort by recency"
        ]
      },
      {
        "requirement": "Location Search",
        "how_met": "search_location() with Haversine distance formula",
        "gotchas": [
          "Posts without location are skipped",
          "Results sorted by distance"
        ]
      },
      {
        "requirement": "Explore Feed",
        "how_met": "get_explore_feed() excludes followed users, ranks by engagement + recency",
        "gotchas": [
          "Exclude own posts",
          "Cold start for new users"
        ]
      },
      {
        "requirement": "Trending Hashtags",
        "how_met": "hashtag_counts updated on post, get_trending_hashtags() returns top K",
        "gotchas": [
          "Region param is placeholder for future geo-filtering"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "search_users",
        "target": "O(U)",
        "achieved": "O(U)",
        "why": "Linear scan of user index; production uses Elasticsearch O(log n)"
      },
      {
        "operation": "search_hashtag",
        "target": "O(P log P)",
        "achieved": "O(P log P)",
        "why": "Sort posts by recency; production uses pre-sorted index"
      },
      {
        "operation": "search_location",
        "target": "O(P)",
        "achieved": "O(P)",
        "why": "Linear scan with distance calc; production uses PostGIS O(log n)"
      },
      {
        "operation": "get_explore_feed",
        "target": "O(P log P)",
        "achieved": "O(P log P)",
        "why": "Sort by engagement; production pre-computes candidates"
      },
      {
        "operation": "get_trending_hashtags",
        "target": "O(H log H)",
        "achieved": "O(H log H)",
        "why": "Sort all hashtags; production uses Redis sorted set"
      }
    ],
    "non_goals": [
      "Full-text search within captions",
      "ML-based personalized ranking",
      "Real-time trending with sliding windows",
      "Explore stories (only posts)"
    ]
  },
  "assumptions": [
    "Users must be registered via register_user() before they appear in search",
    "Hashtags are extracted from tags list (not parsed from caption)",
    "Location radius is in kilometers",
    "Trending is global (region param is placeholder)",
    "Explore shows all non-followed posts (no content moderation)"
  ],
  "tradeoffs": [
    {
      "decision": "Inverted index vs. linear scan for hashtags",
      "chosen": "Inverted index",
      "why": "O(1) lookup vs O(P) per search",
      "alternative": "Filter posts on each search",
      "when_to_switch": "Never - index is essential at scale"
    },
    {
      "decision": "Relevance ranking strategy",
      "chosen": "Exact > Prefix > Contains scoring",
      "why": "Simple, interpretable, handles common queries well",
      "alternative": "TF-IDF or BM25",
      "when_to_switch": "When need sophisticated ranking"
    },
    {
      "decision": "Explore scoring formula",
      "chosen": "Engagement + recency decay",
      "why": "Balances popularity with freshness",
      "alternative": "ML ranking model",
      "when_to_switch": "When have user interaction data for training"
    },
    {
      "decision": "Haversine distance vs. geohash",
      "chosen": "Haversine",
      "why": "Exact distance, simple to implement",
      "alternative": "Geohash prefix matching",
      "when_to_switch": "At scale with PostGIS or similar"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1 & 2 methods unchanged",
      "Existing data structure names",
      "Post, Story, FeedItem dataclasses"
    ],
    "what_to_change": [
      "Added User, Hashtag, ExploreFeed dataclasses",
      "Added user_index, hashtag_index, hashtag_counts",
      "Modified upload_photo to index hashtags"
    ],
    "interfaces_and_boundaries": "Search operations return dataclasses. All indices are separate from core data stores. Easy to swap implementations (e.g., Elasticsearch) without changing API.",
    "invariants": [
      "hashtag_index[tag] always contains valid post_ids",
      "hashtag_counts[tag] >= len(hashtag_index[tag]) (counts may lag cleanup)",
      "Explore feed never shows followed users' posts",
      "Search results always sorted by relevance/distance/engagement"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 2):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 User follows \u2192 Feed \u2502\\n\u2502 No discovery    \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\nAFTER (Part 3):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 User follows \u2192 Feed                 \u2502\\n\u2502 Search users \u2192 Discovery            \u2502\\n\u2502 Search #tags \u2192 Topic exploration    \u2502\\n\u2502 Search location \u2192 Geo discovery     \u2502\\n\u2502 Explore \u2192 Personalized recommendations \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "algorithm_flow": "SEARCH FLOW:\\nQuery \u2192 Normalize \u2192 Index Lookup \u2192 Score/Rank \u2192 Return Top K\\n\\nEXPLORE FLOW:\\nUser \u2192 Get Following \u2192 Filter Posts (not followed) \u2192 Score Each \u2192 Sort \u2192 Top N\\n\\nINDEXING FLOW (on upload):\\nPost \u2192 Extract Tags \u2192 Normalize \u2192 Add to hashtag_index \u2192 Increment counts"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Linear scan all posts/users for every search, no indexing",
      "time_complexity": "O(P) or O(U) per search",
      "space_complexity": "O(1) additional",
      "why_not_optimal": "Acceptable for interview but slow at scale. Every hashtag search scans all posts."
    },
    {
      "name": "Optimal Approach (Interview)",
      "description": "Inverted index for hashtags, user index with relevance scoring, engagement-based explore",
      "time_complexity": "Search: O(P log P), Explore: O(P log P)",
      "space_complexity": "O(P \u00d7 T_avg) for hashtag index, O(U) for user index",
      "key_insight": "Index on write to enable fast reads. Hashtag index trades O(T) write for O(1) lookup. Relevance scoring is simple: exact > prefix > substring."
    },
    {
      "name": "Production Approach",
      "description": "Elasticsearch for text search, PostGIS for geo, ML pipeline for explore",
      "time_complexity": "O(log n) searches, O(1) explore with pre-computation",
      "space_complexity": "Significant - separate search cluster, feature store",
      "key_insight": "Separate search infrastructure from primary storage. Pre-compute explore candidates offline."
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Core Strategy**: Build indices during writes to enable fast reads.\n\n1. **User Search**: Store User objects in `user_index`. On search, score each user by match quality (exact=0, prefix=1, contains=2, name=3). Sort and return top K.\n\n2. **Hashtag Search**: Build `hashtag_index` mapping normalized tags to post_ids during `upload_photo`. Search is O(1) lookup + sort by recency.\n\n3. **Location Search**: Use **Haversine formula** to calculate great-circle distance. Filter posts within radius, sort by proximity.\n\n4. **Explore Feed**: Candidate generation excludes followed users and self. **Engagement score** = likes + 2\u00d7comments + recency_bonus. Recency decays linearly over 7 days.\n\n5. **Trending**: Simple count of posts per hashtag. Return top 10.",
    "data_structures": [
      {
        "structure": "Dict[str, User] user_index",
        "purpose": "User objects for search, keyed by user_id"
      },
      {
        "structure": "Dict[str, List[str]] hashtag_index",
        "purpose": "Inverted index: tag \u2192 list of post_ids"
      },
      {
        "structure": "Dict[str, int] hashtag_counts",
        "purpose": "Post count per hashtag for trending"
      },
      {
        "structure": "ExploreFeed dataclass",
        "purpose": "Container for explore results with pagination support"
      }
    ],
    "algorithm_steps": [
      "1. On upload_photo: extract and normalize tags, update hashtag_index and hashtag_counts",
      "2. search_users: iterate user_index, score by match type, sort, return top K",
      "3. search_hashtag: lookup in hashtag_index, get Post objects, sort by created_at desc, paginate",
      "4. search_location: iterate all posts, calculate Haversine distance, filter by radius, sort by distance",
      "5. get_explore_feed: filter posts not from self or followed, calculate engagement score, sort, return top N",
      "6. get_trending_hashtags: sort hashtag_counts by value desc, return top 10 as Hashtag objects"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Instagram System Design - Part 3: Search and Explore",
    "Extends Part 2 with search functionality and personalized explore feed",
    "\"\"\"",
    "from typing import List, Dict, Optional, Set",
    "from dataclasses import dataclass, field",
    "from collections import defaultdict",
    "from datetime import datetime",
    "from enum import Enum",
    "import uuid",
    "import math",
    "",
    "",
    "@dataclass",
    "class Location:",
    "    lat: float",
    "    lng: float",
    "",
    "",
    "@dataclass",
    "class Post:",
    "    post_id: str",
    "    user_id: str",
    "    caption: str",
    "    image_urls: Dict[str, str]",
    "    tags: List[str]",
    "    location: Optional[Location]",
    "    created_at: int",
    "    like_count: int = 0",
    "    comment_count: int = 0",
    "",
    "",
    "@dataclass",
    "class FeedItem:",
    "    post_id: str",
    "    user_id: str",
    "    timestamp: int",
    "    is_celebrity: bool = False",
    "",
    "",
    "@dataclass",
    "class FeedResponse:",
    "    posts: List[Post]",
    "    next_cursor: Optional[str]",
    "",
    "",
    "class StoryType(Enum):",
    "    PHOTO = \"photo\"",
    "    VIDEO = \"video\"",
    "",
    "",
    "@dataclass",
    "class Story:",
    "    story_id: str",
    "    user_id: str",
    "    media_url: str",
    "    story_type: StoryType",
    "    created_at: int",
    "    expires_at: int",
    "    view_count: int = 0",
    "",
    "",
    "@dataclass",
    "class StoryRingUser:",
    "    user_id: str",
    "    has_unviewed: bool",
    "    latest_story_time: int",
    "",
    "",
    "@dataclass",
    "class StoryRing:",
    "    users: List[StoryRingUser]",
    "",
    "",
    "@dataclass",
    "class StoryFeed:",
    "    stories_by_user: Dict[str, List[Story]]",
    "",
    "",
    "# Part 3: New dataclasses",
    "@dataclass",
    "class User:",
    "    user_id: str",
    "    username: str",
    "    name: str = \"\"",
    "",
    "",
    "@dataclass",
    "class Hashtag:",
    "    tag: str",
    "    post_count: int",
    "",
    "",
    "@dataclass",
    "class ExploreFeed:",
    "    posts: List[Post]",
    "    next_cursor: Optional[str] = None",
    "",
    "",
    "class Instagram:",
    "    \"\"\"Instagram with search and explore capabilities.\"\"\"",
    "    CELEBRITY_THRESHOLD = 10000",
    "    FEED_SIZE = 1000",
    "    STORY_TTL_SECONDS = 24 * 60 * 60",
    "    TRENDING_LIMIT = 10",
    "    ",
    "    def __init__(self):",
    "        # Part 1: Core data stores",
    "        self.users: Dict[str, dict] = {}",
    "        self.posts: Dict[str, Post] = {}",
    "        self.followers: Dict[str, Set[str]] = defaultdict(set)",
    "        self.following: Dict[str, Set[str]] = defaultdict(set)",
    "        self.feeds: Dict[str, List[FeedItem]] = defaultdict(list)",
    "        self.celebrity_posts: Dict[str, List[Post]] = defaultdict(list)",
    "        # Part 2: Stories",
    "        self.stories: Dict[str, Story] = {}",
    "        self.user_stories: Dict[str, List[str]] = defaultdict(list)",
    "        self.story_views: Dict[str, Set[str]] = defaultdict(set)",
    "        # Part 3: Search indices",
    "        self.user_index: Dict[str, User] = {}",
    "        self.hashtag_index: Dict[str, List[str]] = defaultdict(list)",
    "        self.hashtag_counts: Dict[str, int] = defaultdict(int)",
    "    ",
    "    # === Part 1 methods ===",
    "    def upload_photo(self, user_id: str, photo: bytes, caption: str,",
    "                     tags: List[str], location: Optional[Location]) -> str:",
    "        post_id = f\"post_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        image_urls = {",
    "            'thumbnail': f'cdn.instagram.com/{post_id}_150.jpg',",
    "            'large': f'cdn.instagram.com/{post_id}_1080.jpg'",
    "        }",
    "        post = Post(post_id=post_id, user_id=user_id, caption=caption,",
    "                    image_urls=image_urls, tags=tags, location=location,",
    "                    created_at=timestamp)",
    "        self.posts[post_id] = post",
    "        self._fan_out(user_id, post)",
    "        self._index_hashtags(post_id, tags)  # Part 3 addition",
    "        return post_id",
    "    ",
    "    def _fan_out(self, user_id: str, post: Post) -> None:",
    "        follower_count = len(self.followers.get(user_id, set()))",
    "        if follower_count < self.CELEBRITY_THRESHOLD:",
    "            feed_item = FeedItem(post_id=post.post_id, user_id=user_id,",
    "                                 timestamp=post.created_at)",
    "            for follower_id in self.followers.get(user_id, set()):",
    "                self.feeds[follower_id].insert(0, feed_item)",
    "                if len(self.feeds[follower_id]) > self.FEED_SIZE:",
    "                    self.feeds[follower_id].pop()",
    "        else:",
    "            self.celebrity_posts[user_id].insert(0, post)",
    "    ",
    "    def get_news_feed(self, user_id: str, page_size: int,",
    "                       cursor: Optional[str]) -> FeedResponse:",
    "        start_idx = int(cursor) if cursor else 0",
    "        feed_items = self.feeds.get(user_id, [])[start_idx:start_idx + page_size * 2]",
    "        celeb_posts = []",
    "        for uid in self.following.get(user_id, set()):",
    "            if len(self.followers.get(uid, set())) >= self.CELEBRITY_THRESHOLD:",
    "                celeb_posts.extend(self.celebrity_posts.get(uid, [])[:10])",
    "        all_items = []",
    "        for item in feed_items:",
    "            post = self.posts.get(item.post_id)",
    "            if post:",
    "                all_items.append((item.timestamp, post))",
    "        for post in celeb_posts:",
    "            all_items.append((post.created_at, post))",
    "        all_items.sort(key=lambda x: x[0], reverse=True)",
    "        result_posts = [item[1] for item in all_items[:page_size]]",
    "        next_cursor = str(start_idx + page_size) if len(all_items) > page_size else None",
    "        return FeedResponse(posts=result_posts, next_cursor=next_cursor)",
    "    ",
    "    def follow_user(self, follower_id: str, followee_id: str) -> bool:",
    "        if follower_id == followee_id or followee_id in self.following[follower_id]:",
    "            return False",
    "        self.followers[followee_id].add(follower_id)",
    "        self.following[follower_id].add(followee_id)",
    "        return True",
    "    ",
    "    def like_post(self, user_id: str, post_id: str) -> bool:",
    "        if post_id not in self.posts:",
    "            return False",
    "        self.posts[post_id].like_count += 1",
    "        return True",
    "    ",
    "    # === Part 2: Stories methods ===",
    "    def post_story(self, user_id: str, media: bytes, story_type: StoryType) -> str:",
    "        story_id = f\"story_{uuid.uuid4().hex[:8]}\"",
    "        timestamp = int(datetime.now().timestamp())",
    "        story = Story(story_id=story_id, user_id=user_id,",
    "                      media_url=f'cdn.instagram.com/stories/{story_id}.jpg',",
    "                      story_type=story_type, created_at=timestamp,",
    "                      expires_at=timestamp + self.STORY_TTL_SECONDS)",
    "        self.stories[story_id] = story",
    "        self.user_stories[user_id].insert(0, story_id)",
    "        return story_id",
    "    ",
    "    def _is_story_active(self, story: Story) -> bool:",
    "        return int(datetime.now().timestamp()) < story.expires_at",
    "    ",
    "    def _get_active_stories(self, user_id: str) -> List[Story]:",
    "        active, new_ids = [], []",
    "        for sid in self.user_stories.get(user_id, []):",
    "            story = self.stories.get(sid)",
    "            if story and self._is_story_active(story):",
    "                active.append(story)",
    "                new_ids.append(sid)",
    "        self.user_stories[user_id] = new_ids",
    "        return active",
    "    ",
    "    def get_story_ring(self, user_id: str) -> StoryRing:",
    "        ring_users, viewed = [], set()",
    "        for sid, viewers in self.story_views.items():",
    "            if user_id in viewers:",
    "                viewed.add(sid)",
    "        for followee in self.following.get(user_id, set()):",
    "            active = self._get_active_stories(followee)",
    "            if active:",
    "                has_unviewed = any(s.story_id not in viewed for s in active)",
    "                ring_users.append(StoryRingUser(followee, has_unviewed, max(s.created_at for s in active)))",
    "        ring_users.sort(key=lambda u: (-u.has_unviewed, -u.latest_story_time))",
    "        return StoryRing(users=ring_users)",
    "    ",
    "    def mark_story_viewed(self, user_id: str, story_id: str) -> bool:",
    "        story = self.stories.get(story_id)",
    "        if not story or not self._is_story_active(story):",
    "            return False",
    "        if user_id not in self.story_views[story_id]:",
    "            self.story_views[story_id].add(user_id)",
    "            story.view_count += 1",
    "        return True",
    "    ",
    "    # === Part 3: Search and Explore ===",
    "    def _index_hashtags(self, post_id: str, tags: List[str]) -> None:",
    "        \"\"\"Build inverted index for hashtag search.\"\"\"",
    "        for tag in tags:",
    "            normalized = tag.lower().lstrip('#')",
    "            if normalized:",
    "                self.hashtag_index[normalized].append(post_id)",
    "                self.hashtag_counts[normalized] += 1",
    "    ",
    "    def register_user(self, user_id: str, username: str, name: str = \"\") -> None:",
    "        \"\"\"Register user for search indexing.\"\"\"",
    "        self.user_index[user_id] = User(user_id, username, name)",
    "        self.users[user_id] = {\"username\": username, \"name\": name}",
    "    ",
    "    def search_users(self, query: str, limit: int) -> List[User]:",
    "        \"\"\"Search by username/name. Ranked: exact > prefix > contains.\"\"\"",
    "        if not query:",
    "            return []",
    "        q = query.lower()",
    "        results = []",
    "        for user in self.user_index.values():",
    "            uname, name = user.username.lower(), user.name.lower()",
    "            if uname == q:",
    "                results.append((0, user))",
    "            elif uname.startswith(q):",
    "                results.append((1, user))",
    "            elif q in uname:",
    "                results.append((2, user))",
    "            elif q in name:",
    "                results.append((3, user))",
    "        results.sort(key=lambda x: x[0])",
    "        return [r[1] for r in results[:limit]]",
    "    ",
    "    def search_hashtag(self, hashtag: str, limit: int, cursor: Optional[str]) -> List[Post]:",
    "        \"\"\"Find posts with hashtag, sorted by recency.\"\"\"",
    "        normalized = hashtag.lower().lstrip('#')",
    "        post_ids = self.hashtag_index.get(normalized, [])",
    "        posts = [self.posts[pid] for pid in post_ids if pid in self.posts]",
    "        posts.sort(key=lambda p: p.created_at, reverse=True)",
    "        start = int(cursor) if cursor else 0",
    "        return posts[start:start + limit]",
    "    ",
    "    def search_location(self, lat: float, lng: float, radius: float) -> List[Post]:",
    "        \"\"\"Find posts within radius km using Haversine distance.\"\"\"",
    "        results = []",
    "        for post in self.posts.values():",
    "            if post.location:",
    "                dist = self._haversine(lat, lng, post.location.lat, post.location.lng)",
    "                if dist <= radius:",
    "                    results.append((dist, post))",
    "        results.sort(key=lambda x: x[0])",
    "        return [r[1] for r in results]",
    "    ",
    "    def _haversine(self, lat1: float, lng1: float, lat2: float, lng2: float) -> float:",
    "        \"\"\"Great-circle distance in km.\"\"\"",
    "        R = 6371",
    "        dlat, dlng = math.radians(lat2 - lat1), math.radians(lng2 - lng1)",
    "        a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlng/2)**2",
    "        return 2 * R * math.asin(math.sqrt(a))",
    "    ",
    "    def get_explore_feed(self, user_id: str, page_size: int) -> ExploreFeed:",
    "        \"\"\"Personalized recommendations: non-followed, high-engagement posts.\"\"\"",
    "        followed = self.following.get(user_id, set())",
    "        candidates = []",
    "        for post in self.posts.values():",
    "            if post.user_id != user_id and post.user_id not in followed:",
    "                score = self._engagement_score(post)",
    "                candidates.append((score, post))",
    "        candidates.sort(key=lambda x: -x[0])",
    "        return ExploreFeed(posts=[c[1] for c in candidates[:page_size]])",
    "    ",
    "    def _engagement_score(self, post: Post) -> float:",
    "        \"\"\"Score = engagement + recency bonus (decays over 7 days).\"\"\"",
    "        base = post.like_count + 2 * post.comment_count",
    "        age_hours = (datetime.now().timestamp() - post.created_at) / 3600",
    "        recency = max(0, 1 - age_hours / 168)",
    "        return base * (1 + recency)",
    "    ",
    "    def get_trending_hashtags(self, region: str) -> List[Hashtag]:",
    "        \"\"\"Top hashtags by post count. Region is placeholder for geo-filtering.\"\"\"",
    "        hashtags = [Hashtag(t, c) for t, c in self.hashtag_counts.items()]",
    "        hashtags.sort(key=lambda h: h.post_count, reverse=True)",
    "        return hashtags[:self.TRENDING_LIMIT]",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('Instagram Part 3: Search and Explore Demo')",
    "    print('=' * 60)",
    "    ",
    "    ig = Instagram()",
    "    ",
    "    # Register users for search",
    "    ig.register_user('alice', 'alice_travels', 'Alice Smith')",
    "    ig.register_user('bob', 'bob_photos', 'Bob Johnson')",
    "    ig.register_user('charlie', 'charlie_adventures', 'Charlie Brown')",
    "    ig.register_user('alice2', 'alice_cooks', 'Alice Wong')",
    "    ",
    "    # Setup relationships",
    "    ig.follow_user('alice', 'bob')",
    "    ",
    "    # Posts with hashtags and locations",
    "    p1 = ig.upload_photo('bob', b'', 'Beach day! #travel #beach',",
    "                         ['travel', 'beach'], Location(34.0, -118.5))",
    "    p2 = ig.upload_photo('charlie', b'', 'Mountain hike #travel #nature',",
    "                         ['travel', 'nature'], Location(36.5, -118.0))",
    "    p3 = ig.upload_photo('alice2', b'', 'Cooking time! #food',",
    "                         ['food'], Location(40.7, -74.0))",
    "    ",
    "    # Add engagement for explore ranking",
    "    for _ in range(10): ig.like_post('x', p2)",
    "    for _ in range(5): ig.like_post('x', p1)",
    "    ",
    "    # Test user search",
    "    print('\\n--- User Search ---')",
    "    results = ig.search_users('alice', 10)",
    "    for u in results:",
    "        print(f\"  {u.username} ({u.name})\")",
    "    ",
    "    # Test hashtag search",
    "    print('\\n--- Hashtag Search: #travel ---')",
    "    posts = ig.search_hashtag('travel', 10, None)",
    "    for p in posts:",
    "        print(f\"  {p.post_id}: {p.caption[:30]}\")",
    "    ",
    "    # Test location search (LA area)",
    "    print('\\n--- Location Search: Los Angeles (100km radius) ---')",
    "    posts = ig.search_location(34.05, -118.25, 100)",
    "    for p in posts:",
    "        print(f\"  {p.post_id} at ({p.location.lat}, {p.location.lng})\")",
    "    ",
    "    # Test explore feed (Alice follows Bob, should see Charlie and Alice2)",
    "    print('\\n--- Explore Feed for Alice ---')",
    "    explore = ig.get_explore_feed('alice', 10)",
    "    for p in explore.posts:",
    "        print(f\"  {p.post_id} by {p.user_id} (likes: {p.like_count})\")",
    "    ",
    "    # Test trending",
    "    print('\\n--- Trending Hashtags ---')",
    "    trending = ig.get_trending_hashtags('US')",
    "    for h in trending:",
    "        print(f\"  #{h.tag}: {h.post_count} posts\")",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('Key: Search uses inverted indices, Explore ranks by engagement!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.time.Instant;",
    "",
    "public class Instagram {",
    "    private static final int CELEBRITY_THRESHOLD = 10000;",
    "    private static final int FEED_SIZE = 1000;",
    "    private static final long STORY_TTL_SECONDS = 24 * 60 * 60;",
    "    private static final int TRENDING_LIMIT = 10;",
    "    ",
    "    // Part 1: Core data stores",
    "    private final Map<String, Map<String, String>> users = new ConcurrentHashMap<>();",
    "    private final Map<String, Post> posts = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> followers = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> following = new ConcurrentHashMap<>();",
    "    private final Map<String, Deque<FeedItem>> feeds = new ConcurrentHashMap<>();",
    "    private final Map<String, Deque<Post>> celebrityPosts = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2: Stories",
    "    private final Map<String, Story> stories = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> userStories = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> storyViews = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 3: Search indices",
    "    private final Map<String, User> userIndex = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> hashtagIndex = new ConcurrentHashMap<>();",
    "    private final Map<String, Integer> hashtagCounts = new ConcurrentHashMap<>();",
    "    ",
    "    // Inner classes",
    "    static class Location { double lat, lng; Location(double lat, double lng) { this.lat = lat; this.lng = lng; } }",
    "    static class Post {",
    "        String postId, userId, caption;",
    "        Map<String, String> imageUrls;",
    "        List<String> tags;",
    "        Location location;",
    "        long createdAt;",
    "        int likeCount = 0, commentCount = 0;",
    "    }",
    "    static class FeedItem { String postId, userId; long timestamp; }",
    "    static class FeedResponse { List<Post> posts; String nextCursor; FeedResponse(List<Post> p, String c) { posts = p; nextCursor = c; } }",
    "    enum StoryType { PHOTO, VIDEO }",
    "    static class Story { String storyId, userId, mediaUrl; StoryType storyType; long createdAt, expiresAt; int viewCount = 0; }",
    "    static class StoryRingUser { String userId; boolean hasUnviewed; long latestStoryTime; StoryRingUser(String u, boolean h, long t) { userId = u; hasUnviewed = h; latestStoryTime = t; } }",
    "    static class StoryRing { List<StoryRingUser> users; StoryRing(List<StoryRingUser> u) { users = u; } }",
    "    ",
    "    // Part 3: New classes",
    "    static class User { String userId, username, name; User(String id, String u, String n) { userId = id; username = u; name = n; } }",
    "    static class Hashtag { String tag; int postCount; Hashtag(String t, int c) { tag = t; postCount = c; } }",
    "    static class ExploreFeed { List<Post> posts; String nextCursor; ExploreFeed(List<Post> p) { posts = p; } }",
    "    ",
    "    // === Part 1 methods ===",
    "    public String uploadPhoto(String userId, byte[] photo, String caption, List<String> tags, Location location) {",
    "        String postId = \"post_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Post post = new Post();",
    "        post.postId = postId; post.userId = userId; post.caption = caption;",
    "        post.tags = tags; post.location = location; post.createdAt = timestamp;",
    "        post.imageUrls = Map.of(\"large\", \"cdn/\" + postId + \"_1080.jpg\");",
    "        posts.put(postId, post);",
    "        fanOut(userId, post);",
    "        indexHashtags(postId, tags);",
    "        return postId;",
    "    }",
    "    ",
    "    private void fanOut(String userId, Post post) {",
    "        Set<String> userFollowers = followers.getOrDefault(userId, Set.of());",
    "        if (userFollowers.size() < CELEBRITY_THRESHOLD) {",
    "            FeedItem item = new FeedItem(); item.postId = post.postId; item.userId = userId; item.timestamp = post.createdAt;",
    "            for (String followerId : userFollowers) {",
    "                feeds.computeIfAbsent(followerId, k -> new LinkedList<>()).addFirst(item);",
    "                while (feeds.get(followerId).size() > FEED_SIZE) feeds.get(followerId).removeLast();",
    "            }",
    "        } else { celebrityPosts.computeIfAbsent(userId, k -> new LinkedList<>()).addFirst(post); }",
    "    }",
    "    ",
    "    public boolean followUser(String followerId, String followeeId) {",
    "        if (followerId.equals(followeeId)) return false;",
    "        followers.computeIfAbsent(followeeId, k -> ConcurrentHashMap.newKeySet()).add(followerId);",
    "        following.computeIfAbsent(followerId, k -> ConcurrentHashMap.newKeySet()).add(followeeId);",
    "        return true;",
    "    }",
    "    ",
    "    public boolean likePost(String userId, String postId) {",
    "        Post post = posts.get(postId);",
    "        if (post == null) return false;",
    "        post.likeCount++;",
    "        return true;",
    "    }",
    "    ",
    "    // === Part 2: Stories ===",
    "    public String postStory(String userId, byte[] media, StoryType type) {",
    "        String storyId = \"story_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        long timestamp = Instant.now().getEpochSecond();",
    "        Story story = new Story();",
    "        story.storyId = storyId; story.userId = userId; story.mediaUrl = \"cdn/stories/\" + storyId;",
    "        story.storyType = type; story.createdAt = timestamp; story.expiresAt = timestamp + STORY_TTL_SECONDS;",
    "        stories.put(storyId, story);",
    "        userStories.computeIfAbsent(userId, k -> new ArrayList<>()).add(0, storyId);",
    "        return storyId;",
    "    }",
    "    ",
    "    private boolean isStoryActive(Story story) { return Instant.now().getEpochSecond() < story.expiresAt; }",
    "    ",
    "    public boolean markStoryViewed(String userId, String storyId) {",
    "        Story story = stories.get(storyId);",
    "        if (story == null || !isStoryActive(story)) return false;",
    "        Set<String> viewers = storyViews.computeIfAbsent(storyId, k -> ConcurrentHashMap.newKeySet());",
    "        if (!viewers.contains(userId)) { viewers.add(userId); story.viewCount++; }",
    "        return true;",
    "    }",
    "    ",
    "    // === Part 3: Search and Explore ===",
    "    private void indexHashtags(String postId, List<String> tags) {",
    "        for (String tag : tags) {",
    "            String normalized = tag.toLowerCase().replaceFirst(\"^#\", \"\");",
    "            if (!normalized.isEmpty()) {",
    "                hashtagIndex.computeIfAbsent(normalized, k -> new ArrayList<>()).add(postId);",
    "                hashtagCounts.merge(normalized, 1, Integer::sum);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    public void registerUser(String userId, String username, String name) {",
    "        userIndex.put(userId, new User(userId, username, name));",
    "        users.put(userId, Map.of(\"username\", username, \"name\", name));",
    "    }",
    "    ",
    "    public List<User> searchUsers(String query, int limit) {",
    "        if (query == null || query.isEmpty()) return List.of();",
    "        String q = query.toLowerCase();",
    "        List<int[]> results = new ArrayList<>(); // [score, index]",
    "        List<User> allUsers = new ArrayList<>(userIndex.values());",
    "        ",
    "        for (int i = 0; i < allUsers.size(); i++) {",
    "            User user = allUsers.get(i);",
    "            String uname = user.username.toLowerCase();",
    "            String name = user.name != null ? user.name.toLowerCase() : \"\";",
    "            int score = -1;",
    "            if (uname.equals(q)) score = 0;",
    "            else if (uname.startsWith(q)) score = 1;",
    "            else if (uname.contains(q)) score = 2;",
    "            else if (name.contains(q)) score = 3;",
    "            if (score >= 0) results.add(new int[]{score, i});",
    "        }",
    "        results.sort(Comparator.comparingInt(a -> a[0]));",
    "        List<User> output = new ArrayList<>();",
    "        for (int i = 0; i < Math.min(limit, results.size()); i++) {",
    "            output.add(allUsers.get(results.get(i)[1]));",
    "        }",
    "        return output;",
    "    }",
    "    ",
    "    public List<Post> searchHashtag(String hashtag, int limit, String cursor) {",
    "        String normalized = hashtag.toLowerCase().replaceFirst(\"^#\", \"\");",
    "        List<String> postIds = hashtagIndex.getOrDefault(normalized, List.of());",
    "        List<Post> postList = new ArrayList<>();",
    "        for (String pid : postIds) {",
    "            Post p = posts.get(pid);",
    "            if (p != null) postList.add(p);",
    "        }",
    "        postList.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        int start = cursor != null ? Integer.parseInt(cursor) : 0;",
    "        int end = Math.min(start + limit, postList.size());",
    "        return postList.subList(start, end);",
    "    }",
    "    ",
    "    public List<Post> searchLocation(double lat, double lng, double radius) {",
    "        List<double[]> results = new ArrayList<>(); // [distance, index]",
    "        List<Post> allPosts = new ArrayList<>(posts.values());",
    "        for (int i = 0; i < allPosts.size(); i++) {",
    "            Post post = allPosts.get(i);",
    "            if (post.location != null) {",
    "                double dist = haversine(lat, lng, post.location.lat, post.location.lng);",
    "                if (dist <= radius) results.add(new double[]{dist, i});",
    "            }",
    "        }",
    "        results.sort(Comparator.comparingDouble(a -> a[0]));",
    "        List<Post> output = new ArrayList<>();",
    "        for (double[] r : results) output.add(allPosts.get((int) r[1]));",
    "        return output;",
    "    }",
    "    ",
    "    private double haversine(double lat1, double lng1, double lat2, double lng2) {",
    "        double R = 6371;",
    "        double dLat = Math.toRadians(lat2 - lat1), dLng = Math.toRadians(lng2 - lng1);",
    "        double a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * Math.sin(dLng/2) * Math.sin(dLng/2);",
    "        return 2 * R * Math.asin(Math.sqrt(a));",
    "    }",
    "    ",
    "    public ExploreFeed getExploreFeed(String userId, int pageSize) {",
    "        Set<String> followed = following.getOrDefault(userId, Set.of());",
    "        List<double[]> candidates = new ArrayList<>();",
    "        List<Post> allPosts = new ArrayList<>(posts.values());",
    "        for (int i = 0; i < allPosts.size(); i++) {",
    "            Post post = allPosts.get(i);",
    "            if (!post.userId.equals(userId) && !followed.contains(post.userId)) {",
    "                double score = engagementScore(post);",
    "                candidates.add(new double[]{score, i});",
    "            }",
    "        }",
    "        candidates.sort((a, b) -> Double.compare(b[0], a[0]));",
    "        List<Post> result = new ArrayList<>();",
    "        for (int i = 0; i < Math.min(pageSize, candidates.size()); i++) {",
    "            result.add(allPosts.get((int) candidates.get(i)[1]));",
    "        }",
    "        return new ExploreFeed(result);",
    "    }",
    "    ",
    "    private double engagementScore(Post post) {",
    "        double base = post.likeCount + 2 * post.commentCount;",
    "        double ageHours = (Instant.now().getEpochSecond() - post.createdAt) / 3600.0;",
    "        double recency = Math.max(0, 1 - ageHours / 168);",
    "        return base * (1 + recency);",
    "    }",
    "    ",
    "    public List<Hashtag> getTrendingHashtags(String region) {",
    "        List<Hashtag> hashtags = new ArrayList<>();",
    "        for (var entry : hashtagCounts.entrySet()) {",
    "            hashtags.add(new Hashtag(entry.getKey(), entry.getValue()));",
    "        }",
    "        hashtags.sort((a, b) -> Integer.compare(b.postCount, a.postCount));",
    "        return hashtags.subList(0, Math.min(TRENDING_LIMIT, hashtags.size()));",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Instagram Part 3: Search and Explore Demo (Java)\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        Instagram ig = new Instagram();",
    "        ig.registerUser(\"alice\", \"alice_travels\", \"Alice Smith\");",
    "        ig.registerUser(\"bob\", \"bob_photos\", \"Bob Johnson\");",
    "        ig.registerUser(\"charlie\", \"charlie_adventures\", \"Charlie Brown\");",
    "        ",
    "        ig.followUser(\"alice\", \"bob\");",
    "        ",
    "        String p1 = ig.uploadPhoto(\"bob\", new byte[0], \"Beach day!\", List.of(\"travel\", \"beach\"), new Location(34.0, -118.5));",
    "        String p2 = ig.uploadPhoto(\"charlie\", new byte[0], \"Mountain hike!\", List.of(\"travel\", \"nature\"), new Location(36.5, -118.0));",
    "        ",
    "        for (int i = 0; i < 10; i++) ig.likePost(\"x\", p2);",
    "        ",
    "        System.out.println(\"\\n--- User Search: 'alice' ---\");",
    "        for (User u : ig.searchUsers(\"alice\", 10)) System.out.println(\"  \" + u.username);",
    "        ",
    "        System.out.println(\"\\n--- Hashtag Search: #travel ---\");",
    "        for (Post p : ig.searchHashtag(\"travel\", 10, null)) System.out.println(\"  \" + p.postId);",
    "        ",
    "        System.out.println(\"\\n--- Explore Feed for Alice ---\");",
    "        for (Post p : ig.getExploreFeed(\"alice\", 10).posts) System.out.println(\"  \" + p.postId + \" (likes: \" + p.likeCount + \")\");",
    "        ",
    "        System.out.println(\"\\n--- Trending Hashtags ---\");",
    "        for (Hashtag h : ig.getTrendingHashtags(\"US\")) System.out.println(\"  #\" + h.tag + \": \" + h.postCount);",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-90",
      "explanation": "All existing dataclasses from Parts 1 & 2, plus new User, Hashtag, ExploreFeed for Part 3"
    },
    {
      "lines": "91-110",
      "explanation": "Class initialization with Part 3 additions: user_index, hashtag_index, hashtag_counts"
    },
    {
      "lines": "111-130",
      "explanation": "upload_photo now calls _index_hashtags() to build inverted index on write"
    },
    {
      "lines": "190-210",
      "explanation": "_index_hashtags() normalizes tags and updates both index and counts"
    },
    {
      "lines": "215-235",
      "explanation": "search_users() scores matches (exact=0, prefix=1, contains=2, name=3) and sorts"
    },
    {
      "lines": "240-250",
      "explanation": "search_hashtag() does O(1) index lookup, sorts by recency, paginates"
    },
    {
      "lines": "255-270",
      "explanation": "search_location() calculates Haversine distance for each post, filters by radius"
    },
    {
      "lines": "275-295",
      "explanation": "get_explore_feed() excludes followed users, scores by engagement+recency, returns top K"
    },
    {
      "lines": "300-310",
      "explanation": "get_trending_hashtags() sorts hashtag_counts descending, returns top 10"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "_index_hashtags": {
          "complexity": "O(T)",
          "explanation": "T = number of tags on post, each insert is O(1) amortized"
        },
        "search_users": {
          "complexity": "O(U)",
          "explanation": "U = total users, linear scan with string comparisons"
        },
        "search_hashtag": {
          "complexity": "O(P log P)",
          "explanation": "P = posts with hashtag, O(1) lookup + sort by recency"
        },
        "search_location": {
          "complexity": "O(P)",
          "explanation": "P = total posts, linear scan with distance calculation"
        },
        "get_explore_feed": {
          "complexity": "O(P log P)",
          "explanation": "P = total posts, filter + score + sort"
        },
        "get_trending_hashtags": {
          "complexity": "O(H log H)",
          "explanation": "H = unique hashtags, sort all hashtags"
        }
      },
      "overall_change": "Part 1 & 2 operations unchanged. upload_photo adds O(T) for indexing. Search operations are O(P) or O(U) - acceptable for interview, production uses specialized indices."
    },
    "space": {
      "additional_space": "O(P \u00d7 T_avg + U) where P=posts, T_avg=avg tags per post, U=users",
      "explanation": "hashtag_index stores each post_id once per tag it has. user_index stores User objects. hashtag_counts has one entry per unique tag."
    }
  },
  "dry_run": {
    "example_input": "Register users alice, bob, charlie. Bob posts with #travel #beach. Charlie posts with #travel #nature. Alice follows Bob. Search for 'alice', search #travel, get explore feed for Alice.",
    "steps": [
      {
        "step": 1,
        "action": "register_user('alice', 'alice_travels', 'Alice')",
        "state": "user_index has alice",
        "explanation": "User added to search index"
      },
      {
        "step": 2,
        "action": "upload_photo('bob', ..., ['travel', 'beach'])",
        "state": "hashtag_index['travel']=[p1], hashtag_index['beach']=[p1]",
        "explanation": "Hashtags indexed on upload"
      },
      {
        "step": 3,
        "action": "upload_photo('charlie', ..., ['travel', 'nature'])",
        "state": "hashtag_index['travel']=[p1,p2]",
        "explanation": "p2 added to travel index"
      },
      {
        "step": 4,
        "action": "follow_user('alice', 'bob')",
        "state": "following['alice']={'bob'}",
        "explanation": "Alice follows Bob"
      },
      {
        "step": 5,
        "action": "search_users('alice', 10)",
        "state": "Match alice_travels (exact=0)",
        "explanation": "Returns alice with best score"
      },
      {
        "step": 6,
        "action": "search_hashtag('travel', 10, None)",
        "state": "Lookup hashtag_index['travel']=[p1,p2]",
        "explanation": "Returns p2, p1 sorted by recency"
      },
      {
        "step": 7,
        "action": "get_explore_feed('alice', 10)",
        "state": "Filter: skip bob (followed). Include charlie.",
        "explanation": "Charlie's post appears in explore since Alice doesn't follow Charlie"
      }
    ],
    "final_output": "User search returns alice, hashtag search returns [p2, p1], explore shows charlie's post"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Empty query returns empty list",
      "Unknown hashtag returns empty list",
      "User with no posts still appears in user search"
    ],
    "likely_bugs": [
      "Forgetting to normalize hashtags (case-sensitive)",
      "Not excluding self in explore",
      "Sort order reversed (oldest first instead of newest)"
    ],
    "recommended_logs_or_asserts": [
      "assert len(hashtag_index[tag]) == hashtag_counts[tag]",
      "log user_index.keys() after registration",
      "assert all posts in explore are from non-followed users"
    ],
    "how_to_localize": "1. Check if hashtags are being indexed (print hashtag_index after upload). 2. Verify search query normalization. 3. Trace explore scoring for specific posts."
  },
  "edge_cases": [
    {
      "case": "Empty search query",
      "handling": "Return empty list immediately",
      "gotcha": "Don't iterate all users with empty query"
    },
    {
      "case": "Hashtag with # prefix",
      "handling": "lstrip('#') normalizes input",
      "gotcha": "User might type '#travel' or 'travel'"
    },
    {
      "case": "Post without location",
      "handling": "Skip in location search (check post.location is not None)",
      "gotcha": "Don't crash on None.lat"
    },
    {
      "case": "User follows no one",
      "handling": "Explore shows all posts except own",
      "gotcha": "Empty following set is valid"
    },
    {
      "case": "Cold start (no engagement)",
      "handling": "Recency bonus still provides ranking",
      "gotcha": "New posts with 0 likes should still appear"
    },
    {
      "case": "No posts with searched hashtag",
      "handling": "Return empty list",
      "gotcha": "hashtag_index.get() with default empty list"
    }
  ],
  "test_cases": [
    {
      "name": "User search relevance ordering",
      "input": "Register 'alice', 'alice2', 'malice'. Search 'alice'",
      "expected": "['alice', 'alice2', 'malice'] - exact first, then prefix, then contains",
      "explanation": "Relevance scoring ensures exact matches rank highest"
    },
    {
      "name": "Hashtag case insensitivity",
      "input": "Post with tags ['Travel', 'BEACH']. Search 'travel'",
      "expected": "Post found",
      "explanation": "Both index and search normalize to lowercase"
    },
    {
      "name": "Explore excludes followed",
      "input": "Alice follows Bob. Bob and Charlie post. Get explore for Alice",
      "expected": "Only Charlie's post in explore",
      "explanation": "Explore filters out followed users for discovery"
    },
    {
      "name": "Location radius filtering",
      "input": "Post at (0, 0). Search at (0, 0.1) with radius 15km",
      "expected": "Post found (distance ~11km)",
      "explanation": "Haversine correctly calculates Earth distance"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Case-sensitive hashtag matching",
      "why_wrong": "User might search 'Travel' but posts use 'travel'",
      "correct_approach": "Normalize to lowercase on both index and search",
      "code_example_wrong": "self.hashtag_index[tag].append(post_id)",
      "code_example_correct": "self.hashtag_index[tag.lower().lstrip('#')].append(post_id)"
    },
    {
      "mistake": "Including self in explore feed",
      "why_wrong": "Users shouldn't see their own posts in discovery",
      "correct_approach": "Filter: post.user_id != user_id",
      "code_example_wrong": "if post.user_id not in followed:",
      "code_example_correct": "if post.user_id != user_id and post.user_id not in followed:"
    },
    {
      "mistake": "Not handling empty hashtag index",
      "why_wrong": "KeyError if hashtag never used",
      "correct_approach": "Use .get() with default empty list",
      "code_example_wrong": "post_ids = self.hashtag_index[normalized]",
      "code_example_correct": "post_ids = self.hashtag_index.get(normalized, [])"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the index-on-write strategy for search. Then walk through each search type: user (relevance scoring), hashtag (inverted index), location (geo distance), explore (engagement ranking).",
    "what_to_mention": [
      "Inverted index trades write time for read performance",
      "Relevance scoring is simple but effective: exact > prefix > contains",
      "Haversine formula for accurate Earth distance",
      "Engagement scoring combines likes, comments, and recency",
      "Production would use Elasticsearch, PostGIS, ML ranking"
    ],
    "time_allocation": "2 min understanding, 3 min design discussion, 8-10 min coding, 2 min testing",
    "if_stuck": [
      "Start with the simplest search (user prefix match)",
      "Remember inverted index pattern from full-text search",
      "Engagement score = likes + comments + time decay"
    ]
  },
  "connection_to_next_part": "Part 3 establishes content discovery infrastructure. Part 4 might add: notifications (when someone follows you, likes your post), direct messages, or comments with threading. The user_index and engagement scoring can be reused for notification prioritization.",
  "communication_script": {
    "transition_from_previous": "Part 2 added ephemeral stories. Now for Part 3, I need to add search and explore - this transforms Instagram from a follower-only feed into a discovery platform. Let me walk through my approach...",
    "explaining_changes": "The key insight is index-on-write: when a photo is uploaded, I'll build an inverted index for hashtags. This makes search O(1) lookup instead of O(P) scan. For explore, I'll score posts by engagement with a recency decay.",
    "while_extending_code": [
      "Adding hashtag_index and hashtag_counts to __init__...",
      "Modifying upload_photo to call _index_hashtags...",
      "User search scores by match type: exact gets 0, prefix gets 1..."
    ],
    "after_completing": "Search and explore are now working. User search is O(U), hashtag search is O(1) lookup + O(P log P) sort, explore is O(P log P). In production, these would use Elasticsearch and ML ranking. Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Understand requirements: 5 new methods, need inverted index for hashtags",
    "by_5_min": "Design complete: index-on-write strategy, relevance scoring, engagement formula",
    "by_10_min": "Core methods implemented: search_users, search_hashtag, get_explore_feed",
    "warning_signs": "If still designing at 6 min, start coding with basic implementation and iterate"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Check that upload_photo calls _index_hashtags. Verify hashtag normalization is consistent between index and search.",
    "if_new_requirement_unclear": "Ask: 'For search_location, should I return posts sorted by distance or by engagement?'",
    "if_running_behind": "Skip search_location (most complex), implement simpler methods first. Mention geo-spatial verbally."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Explaining inverted index trade-off (write cost vs read performance)",
      "Discussing production alternatives (Elasticsearch, PostGIS, ML ranking)",
      "Noting that engagement scoring can be pre-computed for hot posts",
      "Mentioning bloom filters for 'has user seen this' in explore deduplication"
    ]
  },
  "pattern_recognition": {
    "pattern": "Inverted Index + Scoring/Ranking",
    "indicators": [
      "Search by attribute (hashtag, location)",
      "Need to rank results",
      "Write-heavy data that needs fast reads"
    ],
    "similar_problems": [
      "Design Twitter Search",
      "Design Yelp (location search)",
      "Implement Autocomplete"
    ],
    "template": "1. Build index on write (upload). 2. Lookup in index on read (search). 3. Score results. 4. Sort and paginate."
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'search by hashtag', I immediately think inverted index",
      "why": "Classic information retrieval pattern - map term to document list"
    },
    {
      "step": 2,
      "thought": "User search needs relevance ranking, not just filtering",
      "why": "'alice' should rank higher than 'alice123' for query 'alice'"
    },
    {
      "step": 3,
      "thought": "Explore is candidate generation + ranking",
      "why": "Two-stage approach: filter candidates, then score and sort"
    },
    {
      "step": 4,
      "thought": "Location search needs distance calculation",
      "why": "Haversine formula for great-circle distance on Earth's surface"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend without breaking existing code?",
      "Do you understand inverted index pattern?",
      "Can you design a simple but effective ranking function?"
    ],
    "bonus_points": [
      "Mentioning Elasticsearch/PostGIS for production",
      "Discussing recency decay in scoring",
      "Noting cold start problem for new users"
    ],
    "red_flags": [
      "Linear scan for every search without indexing",
      "Forgetting to normalize search terms",
      "Including followed users in explore"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with Haversine formula syntax",
      "Use AI for dataclass boilerplate"
    ],
    "what_not_to_do": [
      "Don't let AI choose the indexing strategy",
      "Verify the scoring formula makes sense"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not explaining the index-on-write trade-off",
      "Implementing without discussing design first"
    ],
    "technical": [
      "O(P) scan on every search without indexing",
      "Case-sensitive hashtag matching",
      "Including self in explore"
    ],
    "communication": [
      "Not mentioning production alternatives",
      "Forgetting to test with empty results"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does search_users return results in relevance order?",
      "Does search_hashtag handle case-insensitive matching?",
      "Does get_explore_feed exclude followed users AND self?",
      "Is the hashtag index updated on upload_photo?"
    ],
    "quick_code_review": [
      "hashtag normalization consistent (lowercase, strip #)",
      "Haversine formula correct (radians, Earth radius)",
      "Engagement score includes recency factor"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Elasticsearch for text search with fuzzy matching",
      "PostGIS for spatial indexing",
      "Redis sorted sets for trending with time decay",
      "ML ranking model trained on user interactions",
      "Rate limiting on search endpoints"
    ],
    "why_not_in_interview": "Focus on core algorithm; production infrastructure is separate concern",
    "how_to_mention": "Say: 'In production, I'd use Elasticsearch for user/hashtag search - O(log n) with relevance scoring built in. For location, PostGIS provides spatial indices.'"
  },
  "generated_at": "2026-01-19T04:54:55.859460",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}