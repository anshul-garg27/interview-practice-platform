{
  "problem_title": "Travel Expense Calculation System - Part 2: Multi-Currency Support",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "The system now supports expenses in multiple currencies (EUR, GBP, JPY, etc.) with configurable exchange rates. All calculations must convert to USD first, then apply the existing reimbursement policies. This requires: (1) storing exchange rates, (2) modifying expense creation to accept currency and convert to USD, (3) ensuring all downstream calculations work seamlessly with USD-converted amounts.",
    "new_requirements": [
      "Support setting/updating exchange rates for any currency",
      "Accept expenses in any supported currency",
      "Convert expenses to USD at time of creation (not calculation time)",
      "Maintain precision through currency conversion",
      "Backward compatibility with Part 1 API (expenses default to USD)"
    ],
    "new_constraints": [
      "Exchange rate must exist when adding non-USD expense",
      "USD rate is implicitly 1.0",
      "Conversion happens BEFORE policy caps are applied",
      "Must store both original and converted amounts for audit"
    ],
    "key_insight": "Convert to USD immediately upon expense creation, storing the USD amount in the expense's `amount` field. This means ALL existing strategy calculations work unchanged - they already operate on `expense.amount` which is now guaranteed to be in USD. The original currency and amount are stored separately for audit/display purposes."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Set exchange rates dynamically",
        "how_met": "_exchange_rates dict with set_exchange_rate() method",
        "gotchas": [
          "Don't forget USD defaults to 1.0",
          "Rate updates don't affect existing expenses"
        ]
      },
      {
        "requirement": "Accept multi-currency expenses",
        "how_met": "Modified add_expense() with currency parameter and conversion logic",
        "gotchas": [
          "Must detect old vs new signature for backward compat",
          "Validate currency exists before conversion"
        ]
      },
      {
        "requirement": "Convert before policy application",
        "how_met": "Conversion in add_expense() stores USD in amount field, strategies unchanged",
        "gotchas": [
          "Don't convert twice",
          "Store original for audit trail"
        ]
      },
      {
        "requirement": "Maintain calculation precision",
        "how_met": "All conversion uses Decimal arithmetic",
        "gotchas": [
          "float\u2192Decimal conversion via str to avoid precision loss"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "set_exchange_rate",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Simple dict insertion"
      },
      {
        "operation": "add_expense with currency",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Rate lookup O(1), multiply O(1), same as before"
      },
      {
        "operation": "calculate_reimbursement",
        "target": "O(E)",
        "achieved": "O(E)",
        "why": "Unchanged - strategies work on pre-converted USD amounts"
      }
    ],
    "non_goals": [
      "Historical exchange rate tracking",
      "Real-time rate fetching",
      "Currency display formatting",
      "Multi-currency reimbursement (always USD)"
    ]
  },
  "assumptions": [
    "Exchange rate is always currency\u2192USD (multiply to convert)",
    "Missing currency code should raise ValueError or use USD as fallback",
    "Rates are set before expenses using that currency are added",
    "USD exchange rate is always 1.0 (implicit, not stored)",
    "Backward compatibility: old add_expense(id, type, amt, date, details) still works"
  ],
  "tradeoffs": [
    {
      "decision": "Convert at creation vs calculation time",
      "chosen": "Creation time",
      "why": "Captures the rate at transaction time (financially correct), simplifies calculations, strategies remain unchanged",
      "alternative": "Calculation time",
      "when_to_switch": "If you need historical re-calculation with updated rates"
    },
    {
      "decision": "Store USD amount vs conversion factor",
      "chosen": "Store USD amount",
      "why": "Simpler calculations, strategies work unchanged, O(1) vs O(E) for multi-expense queries",
      "alternative": "Store factor and convert on-demand",
      "when_to_switch": "If original currency display is frequent"
    },
    {
      "decision": "Extend Expense dataclass vs separate storage",
      "chosen": "Extend dataclass",
      "why": "All expense info in one place, immutable record of transaction",
      "alternative": "Separate currency mapping",
      "when_to_switch": "If Expense class is in external library you can't modify"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All strategy interfaces",
      "calculate_reimbursement signature",
      "ExpenseType enum values",
      "Expense ID format"
    ],
    "what_to_change": [
      "Expense dataclass gets original_currency/original_amount fields",
      "ExpenseFactory.create gets currency/usd_amount params",
      "ExpenseManager gets _exchange_rates dict and set_exchange_rate method",
      "add_expense signature extended with currency param"
    ],
    "interfaces_and_boundaries": "Strategies remain decoupled - they only see USD amounts. Currency conversion is isolated in ExpenseManager.add_expense(). This allows Part 3 to add features like expense approval, reports by currency, etc. without touching calculation logic.",
    "invariants": [
      "expense.amount is ALWAYS in USD",
      "original_amount + original_currency preserve the original submission",
      "Reimbursement \u2264 Policy limit still holds (limits are in USD)",
      "Exchange rate at submission time is captured, not re-fetched"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 1):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  add_expense($450, date, details)                       \u2502\n\u2502           \u2502                                              \u2502\n\u2502           \u25bc                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502 Expense         \u2502     \u2502 Strategy         \u2502           \u2502\n\u2502  \u2502 amount: $450    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 calculate($450)  \u2502\u2500\u2500\u25b6 $450   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 2):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  setExchangeRate(\"EUR\", 1.10)                           \u2502\n\u2502  add_expense(\u20ac180, \"EUR\", date, details)                \u2502\n\u2502           \u2502                                              \u2502\n\u2502           \u25bc                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                   \u2502\n\u2502  \u2502 Currency Convert \u2502  \u20ac180 \u00d7 1.10 = $198               \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                   \u2502\n\u2502           \u25bc                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 Expense                 \u2502     \u2502 Strategy        \u2502    \u2502\n\u2502  \u2502 amount: $198 (USD)      \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 calculate($198) \u2502\u2500\u2500\u25b6 \u2502\n\u2502  \u2502 original_amount: \u20ac180   \u2502     \u2502 (unchanged!)    \u2502    \u2502\n\u2502  \u2502 original_currency: EUR  \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "algorithm_flow": "MULTI-CURRENCY EXPENSE FLOW:\n\n1. SET RATE:       _exchange_rates[\"EUR\"] = 1.10\n                   _exchange_rates[\"GBP\"] = 1.27\n\n2. ADD EXPENSE:    Input: \u20ac180 HOTEL, 2 nights\n                        \u2502\n                        \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502 Lookup: rates[\"EUR\"]   \u2502\n                   \u2502 Convert: \u20ac180 \u00d7 1.10   \u2502\n                   \u2502 Result: $198           \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502 Create Expense:        \u2502\n                   \u2502   amount = $198        \u2502\n                   \u2502   original_amount=\u20ac180 \u2502\n                   \u2502   original_currency=EUR\u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n                   Store in _employee_expenses\n\n3. CALCULATE:      Strategy sees expense.amount = $198\n                   HotelStrategy: min($198, $200) \u00d7 2 = $396\n                   (Strategies UNCHANGED from Part 1!)"
  },
  "approaches": [
    {
      "name": "Naive Extension - Convert at Calculation Time",
      "description": "Store original currency/amount, convert to USD during calculate_reimbursement()",
      "time_complexity": "O(E) per calculation (unchanged)",
      "space_complexity": "O(N\u00d7E) (unchanged)",
      "why_not_optimal": "Violates financial best practice: rate at transaction time should be captured. If rates change between expense submission and calculation, reimbursement would be incorrect. Also requires all strategies to know about currency conversion."
    },
    {
      "name": "Optimal Approach - Convert at Creation Time",
      "description": "Convert to USD immediately when expense is created, store USD in amount field, keep original for audit. Strategies operate on USD amount unchanged.",
      "time_complexity": "O(1) for add_expense (one multiplication added), O(E) for calculate unchanged",
      "space_complexity": "O(N\u00d7E) with small constant increase (2 extra fields per expense)",
      "key_insight": "By making expense.amount always USD, the entire downstream pipeline (strategies, calculations, totals) works without modification. Currency conversion is isolated to the entry point."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Solution Strategy\n\n**Core Insight**: Convert currency to USD at the **moment of expense creation** and store the USD amount in `expense.amount`. This means:\n\n1. **Strategies remain unchanged** - they already use `expense.amount` which is now guaranteed to be USD\n2. **Financially correct** - captures the exchange rate at transaction time\n3. **Clean separation** - currency handling isolated in `add_expense()`\n\n### Implementation Steps\n\n1. **Add exchange rate storage**: `_exchange_rates: Dict[str, Decimal]` with USD=1.0 default\n\n2. **Add `set_exchange_rate()`**: Simple dict insertion with Decimal precision\n\n3. **Extend Expense dataclass**: Add `original_currency` and `original_amount` fields (with defaults for backward compat)\n\n4. **Modify `add_expense()`**: \n   - Detect old vs new signature (for backward compat)\n   - Look up exchange rate\n   - Convert: `usd_amount = original_amount \u00d7 rate`\n   - Create expense with USD amount\n\n5. **Factory update**: Accept currency and usd_amount parameters\n\n### Why This Works\n```\n\u20ac180/night \u00d7 1.10 rate = $198/night (USD)\nHotelStrategy sees $198: min($198, $200/night cap) = $198 \u2713\n$198 \u00d7 2 nights = $396 reimbursement\n```\n\nAll the **policy limits are in USD**, and now all **amounts are in USD**. Perfect alignment!",
    "data_structures": [
      {
        "structure": "Dict[str, Decimal] for exchange rates",
        "purpose": "O(1) rate lookup by currency code, Decimal for precision"
      },
      {
        "structure": "Extended Expense dataclass",
        "purpose": "Store original_currency and original_amount for audit trail while keeping amount in USD"
      },
      {
        "structure": "Same Dict[str, List[Expense]] for storage",
        "purpose": "Unchanged from Part 1 - already optimal"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize _exchange_rates with USD=1.0",
      "Step 2: set_exchange_rate() stores Decimal(rate) in _exchange_rates[currency]",
      "Step 3: add_expense() detects if new signature (currency param) or old (defaults to USD)",
      "Step 4: Look up rate: rate = _exchange_rates.get(currency, 1.0)",
      "Step 5: Convert: usd_amount = Decimal(amount) \u00d7 rate",
      "Step 6: Create Expense with amount=usd_amount, store original_currency and original_amount",
      "Step 7: All existing methods work unchanged - they see USD amounts"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from decimal import Decimal, ROUND_HALF_UP",
    "from typing import Dict, List, Any, Optional, Union",
    "from enum import Enum",
    "from dataclasses import dataclass",
    "",
    "",
    "class ExpenseType(Enum):",
    "    FLIGHT = \"FLIGHT\"",
    "    HOTEL = \"HOTEL\"",
    "    MEAL = \"MEAL\"",
    "    TRANSPORT = \"TRANSPORT\"",
    "",
    "",
    "@dataclass",
    "class Expense:",
    "    \"\"\"Expense record with multi-currency support.\"\"\"",
    "    id: str",
    "    expense_type: ExpenseType",
    "    amount: Decimal          # USD amount (used for all calculations)",
    "    date: str",
    "    details: Dict[str, Any]",
    "    original_currency: str = \"USD\"",
    "    original_amount: Optional[Decimal] = None  # Original amount before conversion",
    "",
    "",
    "class ReimbursementStrategy(ABC):",
    "    @abstractmethod",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        pass",
    "",
    "",
    "class FlightReimbursementStrategy(ReimbursementStrategy):",
    "    LIMIT = Decimal('1000')",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return min(expense.amount, self.LIMIT)",
    "",
    "",
    "class HotelReimbursementStrategy(ReimbursementStrategy):",
    "    NIGHTLY_CAP = Decimal('200')",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        nights = Decimal(str(expense.details.get('nights', 1)))",
    "        capped_rate = min(expense.amount, self.NIGHTLY_CAP)",
    "        return capped_rate * nights",
    "",
    "",
    "class MealReimbursementStrategy(ReimbursementStrategy):",
    "    DAILY_CAP = Decimal('50')",
    "    REIMBURSEMENT_RATE = Decimal('0.5')",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        days = Decimal(str(expense.details.get('days', 1)))",
    "        per_day = min(expense.amount * self.REIMBURSEMENT_RATE, self.DAILY_CAP)",
    "        return per_day * days",
    "",
    "",
    "class TransportReimbursementStrategy(ReimbursementStrategy):",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return expense.amount",
    "",
    "",
    "class ExpenseFactory:",
    "    \"\"\"Factory with currency conversion support.\"\"\"",
    "    _counter = 0",
    "",
    "    @classmethod",
    "    def create(cls, expense_type: str, amount: float, date: str,",
    "               details: Dict[str, Any], currency: str = \"USD\",",
    "               usd_amount: Optional[Decimal] = None) -> Expense:",
    "        cls._counter += 1",
    "        original = Decimal(str(amount))",
    "        converted = usd_amount if usd_amount is not None else original",
    "        return Expense(",
    "            id=f\"exp_{cls._counter}\",",
    "            expense_type=ExpenseType(expense_type),",
    "            amount=converted,",
    "            date=date,",
    "            details=details or {},",
    "            original_currency=currency,",
    "            original_amount=original",
    "        )",
    "",
    "",
    "class ExpenseManager:",
    "    \"\"\"Expense manager with multi-currency support.\"\"\"",
    "",
    "    def __init__(self) -> None:",
    "        self._employee_expenses: Dict[str, List[Expense]] = {}",
    "        self._strategies: Dict[ExpenseType, ReimbursementStrategy] = {",
    "            ExpenseType.FLIGHT: FlightReimbursementStrategy(),",
    "            ExpenseType.HOTEL: HotelReimbursementStrategy(),",
    "            ExpenseType.MEAL: MealReimbursementStrategy(),",
    "            ExpenseType.TRANSPORT: TransportReimbursementStrategy(),",
    "        }",
    "        # Part 2: Exchange rates storage (USD is implicit 1.0)",
    "        self._exchange_rates: Dict[str, Decimal] = {}",
    "",
    "    def set_exchange_rate(self, currency: str, rate_to_usd: float) -> None:",
    "        \"\"\"Set or update exchange rate for currency to USD.\"\"\"",
    "        self._exchange_rates[currency] = Decimal(str(rate_to_usd))",
    "",
    "    def _get_rate(self, currency: str) -> Decimal:",
    "        \"\"\"Get exchange rate, USD defaults to 1.0.\"\"\"",
    "        if currency == \"USD\":",
    "            return Decimal(\"1.0\")",
    "        if currency not in self._exchange_rates:",
    "            raise ValueError(f\"Unknown currency: {currency}\")",
    "        return self._exchange_rates[currency]",
    "",
    "    def add_expense(self, employee_id: str, expense_type: str, amount: float,",
    "                    arg4: str, arg5: Union[str, dict] = None,",
    "                    arg6: dict = None) -> str:",
    "        \"\"\"Add expense with optional currency. Backward compatible with Part 1.\"\"\"",
    "        # Detect signature: new has 6 args (currency between amount and date)",
    "        # Old: (emp_id, type, amount, date, details)",
    "        # New: (emp_id, type, amount, currency, date, details)",
    "        if arg6 is not None or (arg5 is not None and isinstance(arg5, str)):",
    "            currency, date = arg4, arg5",
    "            details = arg6 or {}",
    "        else:",
    "            currency, date = \"USD\", arg4",
    "            details = arg5 if isinstance(arg5, dict) else {}",
    "",
    "        # Convert to USD",
    "        rate = self._get_rate(currency)",
    "        usd_amount = Decimal(str(amount)) * rate",
    "",
    "        # Create expense with USD amount",
    "        expense = ExpenseFactory.create(",
    "            expense_type, amount, date, details,",
    "            currency=currency, usd_amount=usd_amount",
    "        )",
    "",
    "        if employee_id not in self._employee_expenses:",
    "            self._employee_expenses[employee_id] = []",
    "        self._employee_expenses[employee_id].append(expense)",
    "        return expense.id",
    "",
    "    def calculate_reimbursement(self, employee_id: str) -> float:",
    "        \"\"\"Calculate total reimbursable amount (all in USD).\"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        total = Decimal('0')",
    "        for expense in expenses:",
    "            strategy = self._strategies[expense.expense_type]",
    "            total += strategy.calculate(expense)",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "",
    "    def get_expenses_by_type(self, employee_id: str, expense_type: str) -> List[Expense]:",
    "        target_type = ExpenseType(expense_type)",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        return [e for e in expenses if e.expense_type == target_type]",
    "",
    "    def get_total_expenses(self, employee_id: str) -> float:",
    "        \"\"\"Get raw expense total in USD before policy application.\"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        total = Decimal('0')",
    "        for expense in expenses:",
    "            if expense.expense_type == ExpenseType.HOTEL:",
    "                nights = Decimal(str(expense.details.get('nights', 1)))",
    "                total += expense.amount * nights",
    "            elif expense.expense_type == ExpenseType.MEAL:",
    "                days = Decimal(str(expense.details.get('days', 1)))",
    "                total += expense.amount * days",
    "            else:",
    "                total += expense.amount",
    "        return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"=\" * 60)",
    "    print(\"PART 2: Multi-Currency Support Demo\")",
    "    print(\"=\" * 60)",
    "",
    "    ExpenseFactory._counter = 0",
    "    manager = ExpenseManager()",
    "",
    "    # Set exchange rates",
    "    manager.set_exchange_rate(\"EUR\", 1.10)",
    "    manager.set_exchange_rate(\"GBP\", 1.27)",
    "    manager.set_exchange_rate(\"JPY\", 0.0067)",
    "",
    "    # Demo 1: Multi-currency expenses (from problem example)",
    "    print(\"\\n--- Example from Problem ---\")",
    "    id1 = manager.add_expense(\"emp001\", \"HOTEL\", 180, \"EUR\", \"2024-03-15\", {\"nights\": 2})",
    "    id2 = manager.add_expense(\"emp001\", \"TRANSPORT\", 50, \"GBP\", \"2024-03-16\", {})",
    "    print(f\"Hotel (EUR): {id1}, Transport (GBP): {id2}\")",
    "    print(f\"Reimbursement: ${manager.calculate_reimbursement('emp001'):.2f}\")",
    "    print(\"Expected: $459.50 (Hotel: \u20ac180\u00d71.10\u00d72=$396, Transport: \u00a350\u00d71.27=$63.50)\")",
    "",
    "    # Demo 2: Backward compatibility - USD expenses without currency param",
    "    print(\"\\n--- Backward Compatibility (USD default) ---\")",
    "    ExpenseFactory._counter = 0",
    "    manager2 = ExpenseManager()",
    "    manager2.add_expense(\"emp002\", \"FLIGHT\", 450.00, \"2024-03-15\", {})",
    "    print(f\"USD Flight (old API): ${manager2.calculate_reimbursement('emp002'):.2f}\")",
    "",
    "    # Demo 3: Currency conversion with policy cap",
    "    print(\"\\n--- EUR Hotel Over Cap ---\")",
    "    ExpenseFactory._counter = 0",
    "    manager3 = ExpenseManager()",
    "    manager3.set_exchange_rate(\"EUR\", 1.10)",
    "    manager3.add_expense(\"emp003\", \"HOTEL\", 250, \"EUR\", \"2024-03-15\", {\"nights\": 2})",
    "    print(f\"\u20ac250/night \u00d7 1.10 = $275/night, capped at $200/night\")",
    "    print(f\"Reimbursement: ${manager3.calculate_reimbursement('emp003'):.2f} (expected: $400)\")",
    "",
    "    # Demo 4: JPY conversion (small rate)",
    "    print(\"\\n--- JPY Conversion ---\")",
    "    manager3.add_expense(\"emp003\", \"TRANSPORT\", 5000, \"JPY\", \"2024-03-16\", {})",
    "    print(f\"\u00a55000 \u00d7 0.0067 = ${5000 * 0.0067:.2f} USD\")",
    "    print(f\"Total reimbursement: ${manager3.calculate_reimbursement('emp003'):.2f}\")",
    "",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Multi-currency support working!\")"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "enum ExpenseType {",
    "    FLIGHT, HOTEL, MEAL, TRANSPORT",
    "}",
    "",
    "class Expense {",
    "    private final String id;",
    "    private final ExpenseType type;",
    "    private final BigDecimal amount;  // USD amount",
    "    private final String date;",
    "    private final Map<String, Object> details;",
    "    private final String originalCurrency;",
    "    private final BigDecimal originalAmount;",
    "",
    "    public Expense(String id, ExpenseType type, BigDecimal amount, String date,",
    "                   Map<String, Object> details, String currency, BigDecimal original) {",
    "        this.id = id;",
    "        this.type = type;",
    "        this.amount = amount;",
    "        this.date = date;",
    "        this.details = details != null ? details : new HashMap<>();",
    "        this.originalCurrency = currency;",
    "        this.originalAmount = original;",
    "    }",
    "",
    "    public String getId() { return id; }",
    "    public ExpenseType getType() { return type; }",
    "    public BigDecimal getAmount() { return amount; }",
    "    public Map<String, Object> getDetails() { return details; }",
    "    public String getOriginalCurrency() { return originalCurrency; }",
    "    public BigDecimal getOriginalAmount() { return originalAmount; }",
    "}",
    "",
    "interface ReimbursementStrategy {",
    "    BigDecimal calculate(Expense expense);",
    "}",
    "",
    "class FlightReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal LIMIT = new BigDecimal(\"1000\");",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount().min(LIMIT);",
    "    }",
    "}",
    "",
    "class HotelReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal NIGHTLY_CAP = new BigDecimal(\"200\");",
    "    public BigDecimal calculate(Expense expense) {",
    "        int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "        BigDecimal capped = expense.getAmount().min(NIGHTLY_CAP);",
    "        return capped.multiply(BigDecimal.valueOf(nights));",
    "    }",
    "}",
    "",
    "class MealReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal DAILY_CAP = new BigDecimal(\"50\");",
    "    private static final BigDecimal RATE = new BigDecimal(\"0.5\");",
    "    public BigDecimal calculate(Expense expense) {",
    "        int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "        BigDecimal perDay = expense.getAmount().multiply(RATE).min(DAILY_CAP);",
    "        return perDay.multiply(BigDecimal.valueOf(days));",
    "    }",
    "}",
    "",
    "class TransportReimbursementStrategy implements ReimbursementStrategy {",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount();",
    "    }",
    "}",
    "",
    "class ExpenseFactory {",
    "    private static int counter = 0;",
    "",
    "    public static Expense create(String type, double amount, String date,",
    "                                  Map<String, Object> details, String currency,",
    "                                  BigDecimal usdAmount) {",
    "        counter++;",
    "        BigDecimal original = BigDecimal.valueOf(amount);",
    "        BigDecimal converted = usdAmount != null ? usdAmount : original;",
    "        return new Expense(\"exp_\" + counter, ExpenseType.valueOf(type),",
    "                          converted, date, details, currency, original);",
    "    }",
    "",
    "    public static void resetCounter() { counter = 0; }",
    "}",
    "",
    "public class ExpenseManager {",
    "    private Map<String, List<Expense>> employeeExpenses = new HashMap<>();",
    "    private Map<ExpenseType, ReimbursementStrategy> strategies = new HashMap<>();",
    "    private Map<String, BigDecimal> exchangeRates = new HashMap<>();",
    "",
    "    public ExpenseManager() {",
    "        strategies.put(ExpenseType.FLIGHT, new FlightReimbursementStrategy());",
    "        strategies.put(ExpenseType.HOTEL, new HotelReimbursementStrategy());",
    "        strategies.put(ExpenseType.MEAL, new MealReimbursementStrategy());",
    "        strategies.put(ExpenseType.TRANSPORT, new TransportReimbursementStrategy());",
    "    }",
    "",
    "    public void setExchangeRate(String currency, double rateToUSD) {",
    "        exchangeRates.put(currency, BigDecimal.valueOf(rateToUSD));",
    "    }",
    "",
    "    private BigDecimal getRate(String currency) {",
    "        if (\"USD\".equals(currency)) return BigDecimal.ONE;",
    "        BigDecimal rate = exchangeRates.get(currency);",
    "        if (rate == null) throw new IllegalArgumentException(\"Unknown currency: \" + currency);",
    "        return rate;",
    "    }",
    "",
    "    // Part 1 backward compatible overload",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String date, Map<String, Object> details) {",
    "        return addExpense(employeeId, type, amount, \"USD\", date, details);",
    "    }",
    "",
    "    // Part 2 with currency support",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String currency, String date, Map<String, Object> details) {",
    "        BigDecimal rate = getRate(currency);",
    "        BigDecimal usdAmount = BigDecimal.valueOf(amount).multiply(rate);",
    "        Expense expense = ExpenseFactory.create(type, amount, date, details, currency, usdAmount);",
    "        employeeExpenses.computeIfAbsent(employeeId, k -> new ArrayList<>()).add(expense);",
    "        return expense.getId();",
    "    }",
    "",
    "    public double calculateReimbursement(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            total = total.add(strategies.get(expense.getType()).calculate(expense));",
    "        }",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "",
    "    public List<Expense> getExpensesByType(String employeeId, String type) {",
    "        ExpenseType expType = ExpenseType.valueOf(type);",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        List<Expense> result = new ArrayList<>();",
    "        for (Expense e : expenses) {",
    "            if (e.getType() == expType) result.add(e);",
    "        }",
    "        return result;",
    "    }",
    "",
    "    public double getTotalExpenses(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(employeeId, new ArrayList<>());",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            if (expense.getType() == ExpenseType.HOTEL) {",
    "                int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "                total = total.add(expense.getAmount().multiply(BigDecimal.valueOf(nights)));",
    "            } else if (expense.getType() == ExpenseType.MEAL) {",
    "                int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "                total = total.add(expense.getAmount().multiply(BigDecimal.valueOf(days)));",
    "            } else {",
    "                total = total.add(expense.getAmount());",
    "            }",
    "        }",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"PART 2: Multi-Currency Support Demo (Java)\");",
    "        System.out.println(\"=\".repeat(60));",
    "",
    "        ExpenseManager manager = new ExpenseManager();",
    "        manager.setExchangeRate(\"EUR\", 1.10);",
    "        manager.setExchangeRate(\"GBP\", 1.27);",
    "",
    "        String id1 = manager.addExpense(\"emp001\", \"HOTEL\", 180, \"EUR\", \"2024-03-15\",",
    "                                         Map.of(\"nights\", 2));",
    "        String id2 = manager.addExpense(\"emp001\", \"TRANSPORT\", 50, \"GBP\", \"2024-03-16\",",
    "                                         new HashMap<>());",
    "",
    "        System.out.printf(\"\\nExpenses: %s, %s%n\", id1, id2);",
    "        System.out.printf(\"Reimbursement: $%.2f%n\", manager.calculateReimbursement(\"emp001\"));",
    "        System.out.println(\"Expected: $459.50\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-12",
      "explanation": "Imports and ExpenseType enum - unchanged from Part 1"
    },
    {
      "lines": "14-26",
      "explanation": "Extended Expense dataclass with original_currency and original_amount fields. The amount field now stores USD-converted value, while original fields preserve the submission data for audit."
    },
    {
      "lines": "29-53",
      "explanation": "All ReimbursementStrategy classes - UNCHANGED from Part 1. They operate on expense.amount which is now guaranteed to be USD."
    },
    {
      "lines": "56-72",
      "explanation": "Extended ExpenseFactory with currency and usd_amount parameters. Creates expense with both original and converted amounts."
    },
    {
      "lines": "75-82",
      "explanation": "ExpenseManager initialization - adds _exchange_rates dict. USD rate is implicit (handled in _get_rate method)."
    },
    {
      "lines": "84-86",
      "explanation": "set_exchange_rate() - Simple O(1) dict insertion with Decimal precision."
    },
    {
      "lines": "88-93",
      "explanation": "_get_rate() helper - Returns 1.0 for USD, looks up rate for other currencies, raises ValueError if unknown."
    },
    {
      "lines": "95-117",
      "explanation": "Modified add_expense() - Detects old vs new signature for backward compatibility, converts to USD, creates expense with USD amount. The key insight: conversion happens HERE, not in strategies."
    },
    {
      "lines": "119-126",
      "explanation": "calculate_reimbursement() - UNCHANGED from Part 1. Works because expense.amount is now always in USD."
    },
    {
      "lines": "128-145",
      "explanation": "get_expenses_by_type() and get_total_expenses() - Unchanged logic, now operates on USD amounts."
    },
    {
      "lines": "148-180",
      "explanation": "Demo showing: (1) multi-currency expenses from problem example, (2) backward compatibility with USD default, (3) policy caps with converted amounts, (4) JPY conversion with small rate."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "set_exchange_rate": {
          "complexity": "O(1)",
          "explanation": "Simple dict insertion"
        },
        "add_expense (modified)": {
          "complexity": "O(1)",
          "explanation": "Rate lookup O(1), multiplication O(1), unchanged from Part 1 otherwise"
        }
      },
      "overall_change": "No change to overall complexity. All operations remain O(1) or O(E) where E = expenses for one employee."
    },
    "space": {
      "additional_space": "O(C + N\u00d7E\u00d72)",
      "explanation": "C = number of distinct currencies (typically <10). Each Expense now has 2 extra Decimal fields (original_currency str is negligible). In practice, the added space is minimal - about 32 extra bytes per expense."
    }
  },
  "dry_run": {
    "example_input": "setExchangeRate(EUR,1.1), setExchangeRate(GBP,1.27), addExpense(emp001,HOTEL,180,EUR,date,{nights:2}), addExpense(emp001,TRANSPORT,50,GBP,date,{}), calculateReimbursement(emp001)",
    "steps": [
      {
        "step": 1,
        "action": "set_exchange_rate('EUR', 1.1)",
        "state": "_exchange_rates = {'EUR': Decimal('1.1')}",
        "explanation": "Store EUR rate"
      },
      {
        "step": 2,
        "action": "set_exchange_rate('GBP', 1.27)",
        "state": "_exchange_rates = {'EUR': 1.1, 'GBP': 1.27}",
        "explanation": "Add GBP rate"
      },
      {
        "step": 3,
        "action": "add_expense(..., 180, 'EUR', ...)",
        "state": "rate=1.1, usd=180\u00d71.1=198",
        "explanation": "Convert \u20ac180 to $198 USD per night"
      },
      {
        "step": 4,
        "action": "Create Expense exp_1",
        "state": "Expense(amount=198, original_amount=180, original_currency='EUR')",
        "explanation": "Store both original and converted"
      },
      {
        "step": 5,
        "action": "add_expense(..., 50, 'GBP', ...)",
        "state": "rate=1.27, usd=50\u00d71.27=63.5",
        "explanation": "Convert \u00a350 to $63.50 USD"
      },
      {
        "step": 6,
        "action": "Create Expense exp_2",
        "state": "Expense(amount=63.5, original_currency='GBP')",
        "explanation": "Store transport expense"
      },
      {
        "step": 7,
        "action": "calculate_reimbursement('emp001')",
        "state": "Processing 2 expenses",
        "explanation": "Iterate through stored USD amounts"
      },
      {
        "step": 8,
        "action": "HotelStrategy.calculate(exp_1)",
        "state": "min(198, 200)\u00d72 = 396",
        "explanation": "$198/night under $200 cap, \u00d72 nights"
      },
      {
        "step": 9,
        "action": "TransportStrategy.calculate(exp_2)",
        "state": "63.5 (100% no limit)",
        "explanation": "Full transport amount"
      },
      {
        "step": 10,
        "action": "Sum and return",
        "state": "396 + 63.5 = 459.5",
        "explanation": "Total reimbursement"
      }
    ],
    "final_output": "459.5"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "EUR expense with rate 1.0 should equal USD expense",
      "USD expense should work without setting rate"
    ],
    "likely_bugs": [
      "Forgetting to convert before policy cap (cap applied to original, not USD)",
      "Using float instead of Decimal for rates",
      "Wrong signature detection in backward compat",
      "Multiplying rate twice (in add and in strategy)"
    ],
    "recommended_logs_or_asserts": [
      "assert expense.amount == original_amount * rate",
      "log f'Converting {currency} {amount} to USD {usd_amount}'",
      "assert 'USD' not in _exchange_rates (implicit)"
    ],
    "how_to_localize": "1. Check if rate is stored correctly (print _exchange_rates). 2. Check if conversion happened (print expense.amount vs original_amount). 3. Verify strategy sees correct USD amount (print inside calculate method)."
  },
  "edge_cases": [
    {
      "case": "USD expense (no conversion)",
      "handling": "Rate defaults to 1.0, no multiplication needed",
      "gotcha": "Don't require USD to be in _exchange_rates"
    },
    {
      "case": "Unknown currency",
      "handling": "Raise ValueError with clear message",
      "gotcha": "Don't silently default to 1.0 for unknown currencies"
    },
    {
      "case": "Very small rate (JPY)",
      "handling": "Decimal handles precision, test with \u00a55000 \u00d7 0.0067",
      "gotcha": "Float would lose precision"
    },
    {
      "case": "Backward compatible call",
      "handling": "Detect old signature (no currency param), default to USD",
      "gotcha": "Must handle both 5-arg and 6-arg calls"
    },
    {
      "case": "Rate update after expense",
      "handling": "No effect - rate captured at creation time",
      "gotcha": "This is correct behavior per problem requirements"
    }
  ],
  "test_cases": [
    {
      "name": "Problem example - multi-currency",
      "input": "setRate(EUR,1.1), setRate(GBP,1.27), add(HOTEL,180,EUR,nights=2), add(TRANSPORT,50,GBP), calculate()",
      "expected": "459.5",
      "explanation": "Hotel: \u20ac180\u00d71.10=$198, cap $200, \u00d72=$396. Transport: \u00a350\u00d71.27=$63.50. Total: $459.50"
    },
    {
      "name": "Backward compatibility",
      "input": "add(FLIGHT, 450, '2024-03-15', {}) using old signature",
      "expected": "450.0",
      "explanation": "Without currency param, defaults to USD, no conversion needed"
    },
    {
      "name": "Conversion hits policy cap",
      "input": "setRate(EUR,1.1), add(HOTEL,250,EUR,nights=1)",
      "expected": "200.0",
      "explanation": "\u20ac250\u00d71.10=$275, but hotel cap is $200/night, so reimbursement is $200"
    },
    {
      "name": "JPY small rate",
      "input": "setRate(JPY,0.0067), add(TRANSPORT,10000,JPY)",
      "expected": "67.0",
      "explanation": "\u00a510000\u00d70.0067=$67 USD, transport has no cap"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Converting after policy cap is applied",
      "why_wrong": "If you cap \u20ac180 at $200/night first, then convert, you get wrong result. Policies are defined in USD.",
      "correct_approach": "Convert to USD first (\u20ac180\u2192$198), then apply cap (min($198,$200)=$198)",
      "code_example_wrong": "capped = min(amount, 200)  # Wrong: cap on EUR\nreimbursement = capped * rate",
      "code_example_correct": "usd_amount = amount * rate  # Convert first\nreimbursement = min(usd_amount, 200)  # Then cap"
    },
    {
      "mistake": "Modifying strategy classes to handle currency",
      "why_wrong": "Violates Open/Closed principle. Strategies should not know about currencies.",
      "correct_approach": "Convert in add_expense(), strategies see only USD amounts",
      "code_example_wrong": "class HotelStrategy:\n    def calculate(self, expense):\n        usd = expense.amount * expense.rate  # Wrong!",
      "code_example_correct": "# Strategies unchanged - they see expense.amount in USD"
    },
    {
      "mistake": "Not storing original amount for audit",
      "why_wrong": "Loses traceability. Accountants need to see original receipt amount.",
      "correct_approach": "Store both original_currency/original_amount AND converted amount",
      "code_example_wrong": "expense.amount = converted_amount  # Only USD stored",
      "code_example_correct": "expense.amount = converted  # USD for calculations\nexpense.original_amount = original  # For audit"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the key insight: 'I'll convert to USD at expense creation time, so all downstream calculations work unchanged.' Then show the minimal changes needed: add rate storage, modify add_expense, extend Expense dataclass.",
    "what_to_mention": [
      "Financial best practice: capture rate at transaction time",
      "Strategies remain unchanged - good OOP design",
      "Backward compatibility for existing API",
      "Decimal precision for financial calculations"
    ],
    "time_allocation": "2 min understanding, 3 min explaining approach, 5 min coding, 2 min testing",
    "if_stuck": [
      "Think about WHERE the conversion should happen - at input or output?",
      "What does 'capture rate at creation time' mean?",
      "How can you make strategies work without modification?"
    ]
  },
  "connection_to_next_part": "This solution stores original_currency and original_amount, enabling Part 3 features like: expense reports grouped by currency, currency breakdown analytics, or reimbursement in employee's preferred currency. The clean separation of conversion from calculation also allows adding features like historical rate lookup or rate source tracking.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 is working with USD expenses. For Part 2, I need to support multiple currencies. The key insight is to convert to USD at expense creation time, so all our existing strategies work unchanged.",
    "explaining_changes": "I'll make three changes: (1) Add a dict to store exchange rates, (2) Modify add_expense to accept currency and convert to USD, (3) Extend the Expense class to store both original and converted amounts for audit.",
    "while_extending_code": [
      "Adding _exchange_rates dict to store currency rates...",
      "The set_exchange_rate method is just a dict insertion...",
      "In add_expense, I detect the signature and convert amount * rate..."
    ],
    "after_completing": "This handles Part 2. Strategies are unchanged because expense.amount is always USD now. The new operations are O(1). Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Understand requirement: convert at creation, not calculation time",
    "by_5_min": "Explain approach, identify the 3 changes needed (rate storage, conversion in add_expense, extended Expense)",
    "by_10_min": "Implementation done, running the problem example",
    "warning_signs": "If still deciding where to convert at 4 min, quickly say 'I'll convert at creation for correct financial behavior'"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has a bug affecting calculations, fix it first. The strategies should work on any amount - if they don't, the issue is in Part 1.",
    "if_new_requirement_unclear": "Ask: 'Just to confirm, the exchange rate at submission time should be used, even if the rate changes later?'",
    "if_running_behind": "Focus on: (1) set_exchange_rate method, (2) conversion line in add_expense. Skip original_amount storage if needed - mention it verbally."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing: 'Convert at entry point, strategies unchanged'",
      "Mentioning: 'This is like the Adapter pattern - converting at the boundary'",
      "Proactively: 'I'll store original amount for audit compliance'",
      "Testing edge: 'What about unknown currencies? I'll raise ValueError.'"
    ]
  },
  "pattern_recognition": {
    "pattern": "Adapter/Gateway Pattern - Convert at system boundary",
    "indicators": [
      "Multiple input formats (currencies)",
      "Single internal format (USD)",
      "Don't want to modify core business logic (strategies)"
    ],
    "similar_problems": [
      "LC Currency Exchange - graph traversal for rates",
      "Unit conversion systems",
      "Internationalization adapters"
    ],
    "template": "def process_input(external_data):\n    internal_format = convert(external_data)  # <-- conversion at boundary\n    return core_logic(internal_format)  # core unchanged"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'expenses in multiple currencies but policies in USD', I think...",
      "why": "I need to normalize to USD somewhere. Question is WHERE."
    },
    {
      "step": 2,
      "thought": "The hint says 'at creation time, not lookup time'...",
      "why": "This captures the exchange rate at transaction time, which is financially correct."
    },
    {
      "step": 3,
      "thought": "If I convert in add_expense, expense.amount becomes USD...",
      "why": "Then ALL strategies work unchanged! They already use expense.amount."
    },
    {
      "step": 4,
      "thought": "I need backward compatibility with old add_expense signature...",
      "why": "Problem says keep existing methods working. Detect based on parameter pattern."
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend without rewriting?",
      "Do you recognize the 'convert at boundary' pattern?",
      "Do you maintain backward compatibility?",
      "Is your solution clean and minimal?"
    ],
    "bonus_points": [
      "Mentioning audit trail (original amount)",
      "Discussing precision (Decimal)",
      "Recognizing strategies stay unchanged",
      "Testing edge cases proactively"
    ],
    "red_flags": [
      "Modifying strategy classes to handle currency",
      "Converting at calculation time (wrong financial behavior)",
      "Breaking old API without backward compat",
      "Using float for currency math"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI help with boilerplate like dict initialization",
      "Use AI for Decimal syntax if unfamiliar"
    ],
    "what_not_to_do": [
      "Don't let AI put conversion in strategies",
      "Verify AI maintains backward compatibility",
      "Check AI uses Decimal not float for rates"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Diving into code without explaining WHY convert at creation",
      "Not asking about edge cases like unknown currency"
    ],
    "technical": [
      "Modifying strategy.calculate() signatures",
      "Converting in calculate_reimbursement instead of add_expense",
      "Using float for exchange rates"
    ],
    "communication": [
      "Not explaining the 'convert at boundary' insight",
      "Forgetting to test backward compatibility"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does set_exchange_rate store rate correctly?",
      "Does add_expense convert to USD before creating Expense?",
      "Do strategies remain UNCHANGED?",
      "Does backward compat work (old 5-arg add_expense)?",
      "Did I trace through \u20ac180 HOTEL example?"
    ],
    "quick_code_review": [
      "Decimal used for rates and amounts, not float",
      "_exchange_rates initialized in __init__",
      "expense.amount contains USD value",
      "Type hints on new methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging currency conversion events",
      "Rate source tracking (which API provided the rate)",
      "Rate staleness check (warn if rate not updated in 24h)",
      "Currency validation against ISO 4217 codes"
    ],
    "why_not_in_interview": "Focus on core algorithm - currency conversion logic. Mention these verbally.",
    "how_to_mention": "Say: 'In production, I'd add rate source tracking and staleness alerts for compliance.'"
  },
  "generated_at": "2026-01-19T04:52:40.470648",
  "_meta": {
    "problem_id": "travel_expense_calculation",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}