{
  "problem_title": "Stack Overflow API Design - Part 3: Search and Filtering",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds full-text search and multi-criteria filtering capabilities. Instead of just retrieving questions by user or single tag, users can now search across title/body text with partial matching, filter by multiple tags with AND/OR logic, and get sorted results by score, recency, or relevance.",
    "new_requirements": [
      "Full-text search with case-insensitive partial word matching",
      "Multi-tag filtering with AND (match_all=true) and OR (match_all=false) logic",
      "Get top N questions by score",
      "Get N most recent questions",
      "Get all unanswered questions",
      "Relevance-based sorting for search results"
    ],
    "new_constraints": [
      "Search must support partial matching ('java' matches 'JavaScript')",
      "Results sorted by relevance (number of query word matches)",
      "Case-insensitive matching required"
    ],
    "key_insight": "Build an inverted index (word \u2192 question_ids) at insert time for O(1) word lookups during search. Partial matching requires iterating index keys, but this is still faster than scanning all documents."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Full-text search in title and body",
        "how_met": "word_index maps lowercase words to question IDs, populated in post_question",
        "gotchas": [
          "Must tokenize consistently",
          "Remember to index BOTH title and body"
        ]
      },
      {
        "requirement": "Partial word matching",
        "how_met": "During search, check if query_word is substring of index_word",
        "gotchas": [
          "'java' in 'javascript' is True, not 'javascript'.startswith('java')"
        ]
      },
      {
        "requirement": "Multi-tag AND/OR filtering",
        "how_met": "Use set intersection for AND, union for OR on tag_questions sets",
        "gotchas": [
          "Empty tags list should return empty results",
          "AND with non-existent tag returns empty"
        ]
      },
      {
        "requirement": "Sort by relevance",
        "how_met": "Count distinct query words matched per question, sort descending",
        "gotchas": [
          "Relevance = distinct matches, not total occurrences"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "search_questions",
        "target": "O(k*W + R log R)",
        "achieved": "O(k*W + R log R)",
        "why": "k query words \u00d7 W index words for matching, then sort R results"
      },
      {
        "operation": "search_by_tags",
        "target": "O(T*Q)",
        "achieved": "O(T*Q)",
        "why": "T tags, Q questions per tag for set operations"
      },
      {
        "operation": "get_top_questions",
        "target": "O(Q log Q)",
        "achieved": "O(Q log Q)",
        "why": "Sort all Q questions"
      },
      {
        "operation": "get_unanswered_questions",
        "target": "O(Q log Q)",
        "achieved": "O(Q log Q)",
        "why": "Filter + sort all Q questions"
      }
    ],
    "non_goals": [
      "Fuzzy/typo-tolerant search",
      "Stemming (run/running)",
      "TF-IDF ranking",
      "Pagination"
    ]
  },
  "assumptions": [
    "Partial match means substring match (query word appears anywhere in indexed word)",
    "Relevance = count of distinct query words that matched (not frequency)",
    "Secondary sort by score when relevance ties",
    "Empty query returns empty results",
    "Tags are exact match (no partial tag matching)",
    "Unanswered means zero answers (not zero accepted answers)"
  ],
  "tradeoffs": [
    {
      "decision": "Inverted index vs full scan",
      "chosen": "Inverted index",
      "why": "O(1) word lookup vs O(Q) document scan for each search",
      "alternative": "Full scan",
      "when_to_switch": "If questions are rarely searched or index memory is constrained"
    },
    {
      "decision": "Index at insert vs index at search",
      "chosen": "Index at insert",
      "why": "Amortize indexing cost; searches are more frequent than inserts",
      "alternative": "Lazy indexing",
      "when_to_switch": "If bulk loading many questions"
    },
    {
      "decision": "Substring match iteration vs prefix trie",
      "chosen": "Substring iteration",
      "why": "Simpler implementation, acceptable for interview scope",
      "alternative": "Suffix array or n-gram index",
      "when_to_switch": "Production system with millions of words"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "All Part 1 and Part 2 method signatures",
      "Data model classes (User, Question, Answer)",
      "Existing indexes (tag_questions, user_questions)"
    ],
    "what_to_change": [
      "Added word_index for text search",
      "Modified post_question to update word_index"
    ],
    "interfaces_and_boundaries": "Search methods return Question objects directly (not IDs), maintaining consistency with existing retrieval methods. New methods follow same pattern as get_questions_by_tag.",
    "invariants": [
      "word_index contains all words from all question titles and bodies",
      "word_index keys are lowercase",
      "tag_questions correctly reflects all tags for all questions",
      "question_answers accurately tracks answer counts"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2):                    AFTER (Part 3):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 questions: {q_1: Q} \u2502             \u2502 questions: {q_1: Q} \u2502\n\u2502 tag_questions:      \u2502             \u2502 tag_questions:      \u2502\n\u2502   java -> [q_1]     \u2502             \u2502   java -> [q_1]     \u2502\n\u2502 question_votes: ... \u2502             \u2502 question_votes: ... \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502 word_index:         \u2502\n                                    \u2502   java -> {q_1}     \u2502\n                                    \u2502   help -> {q_1}     \u2502\n                                    \u2502   arrays -> {q_1}   \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nSearch 'java spring':\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n1. Tokenize query: ['java', 'spring']\n\n2. For each query word, find partial matches:\n   'java' \u2192 scan word_index keys:\n     'java' contains 'java' \u2713 \u2192 {q_1, q_3}\n     'javascript' contains 'java' \u2713 \u2192 {q_5}\n   Matched for 'java': {q_1, q_3, q_5}\n\n   'spring' \u2192 scan word_index keys:\n     'spring' contains 'spring' \u2713 \u2192 {q_3}\n     'springframework' contains 'spring' \u2713 \u2192 {q_3}\n   Matched for 'spring': {q_3}\n\n3. Count matches per question:\n   q_1: 1 (matched 'java')\n   q_3: 2 (matched 'java' AND 'spring')\n   q_5: 1 (matched 'java')\n\n4. Sort by relevance desc: [q_3, q_1, q_5]\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n```"
  },
  "approaches": [
    {
      "name": "Naive Full Scan",
      "description": "For each search, iterate all questions and check if query words appear in title/body",
      "time_complexity": "O(Q * D) per search where Q=questions, D=avg document length",
      "space_complexity": "O(1) additional",
      "why_not_optimal": "Linear scan for every search is too slow with many questions. A site like Stack Overflow has millions of questions."
    },
    {
      "name": "Optimal: Inverted Index",
      "description": "Pre-build word\u2192question_ids mapping at insert time. Search by looking up query words and counting matches.",
      "time_complexity": "O(k*W + R log R) where k=query words, W=index size, R=results",
      "space_complexity": "O(W*Q) for index where W=unique words across all questions",
      "key_insight": "Trading space for time. Index building is O(D) per insert, but search avoids scanning documents."
    }
  ],
  "optimal_solution": {
    "explanation_md": "**Core Insight**: Build an **inverted index** mapping each word to the set of questions containing it.\n\n**Data Structure**:\n```\nword_index = {\n  'java': {'q_1', 'q_3'},\n  'spring': {'q_3'},\n  'python': {'q_2'}\n}\n```\n\n**Search Algorithm**:\n1. **Tokenize** query into lowercase words\n2. For each query word, find all index keys containing it (**partial match**)\n3. **Count** how many query words match each question (relevance score)\n4. **Sort** by relevance descending, then by score\n\n**Tag Search**:\n- **AND logic**: Set intersection of all tag question sets\n- **OR logic**: Set union of all tag question sets\n\n**Key Trade-off**: Partial matching requires iterating all index keys O(W), but this is still much better than scanning all document content.",
    "data_structures": [
      {
        "structure": "Dict[str, Set[str]] word_index",
        "purpose": "Inverted index: word \u2192 set of question IDs for O(1) word lookup"
      },
      {
        "structure": "Existing tag_questions",
        "purpose": "Reused for tag-based filtering with set operations"
      }
    ],
    "algorithm_steps": [
      "Step 1: In post_question, tokenize title+body into lowercase words and add q_id to word_index[word] for each word",
      "Step 2: For search_questions, tokenize query, find matching index keys via substring check, count matches per question",
      "Step 3: For search_by_tags, convert tag lists to question ID sets, apply intersection (AND) or union (OR)",
      "Step 4: For ranking queries, sort questions list by appropriate key (score, created_at)"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 3: Search and Filtering",
    "Extends Part 2 with text search and multi-criteria filtering.",
    "\"\"\"",
    "import time",
    "import re",
    "from typing import List, Optional, Dict, Set",
    "from collections import defaultdict",
    "",
    "",
    "class User:",
    "    def __init__(self, id: str, username: str):",
    "        self.id = id",
    "        self.username = username",
    "        self.reputation = 0",
    "",
    "",
    "class Question:",
    "    def __init__(self, id: str, author_id: str, title: str, body: str, tags: List[str]):",
    "        self.id = id",
    "        self.author_id = author_id",
    "        self.title = title",
    "        self.body = body",
    "        self.tags = tags",
    "        self.score = 0",
    "        self.created_at = time.time()",
    "",
    "",
    "class Answer:",
    "    def __init__(self, id: str, question_id: str, author_id: str, body: str):",
    "        self.id = id",
    "        self.question_id = question_id",
    "        self.author_id = author_id",
    "        self.body = body",
    "        self.score = 0",
    "        self.is_accepted = False",
    "        self.created_at = time.time()",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"Stack Overflow API with search and filtering capabilities.\"\"\"",
    "    ",
    "    REP_UPVOTE = 10",
    "    REP_DOWNVOTE = -2",
    "    REP_ACCEPTED = 15",
    "    ",
    "    def __init__(self):",
    "        self.users: Dict[str, User] = {}",
    "        self.questions: Dict[str, Question] = {}",
    "        self.answers: Dict[str, Answer] = {}",
    "        self.user_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self.tag_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self.question_answers: Dict[str, List[str]] = defaultdict(list)",
    "        self.question_votes: Dict[str, Dict[str, int]] = defaultdict(dict)",
    "        self.answer_votes: Dict[str, Dict[str, int]] = defaultdict(dict)",
    "        # NEW: Inverted index for text search",
    "        self.word_index: Dict[str, Set[str]] = defaultdict(set)",
    "        self.question_counter = 1",
    "        self.answer_counter = 1",
    "    ",
    "    def _tokenize(self, text: str) -> Set[str]:",
    "        \"\"\"Extract lowercase words from text.\"\"\"",
    "        return set(re.findall(r'[a-zA-Z0-9]+', text.lower()))",
    "    ",
    "    # ============ Part 1 Methods ============",
    "    ",
    "    def create_user(self, user_id: str, username: str) -> User:",
    "        if user_id in self.users:",
    "            return self.users[user_id]",
    "        user = User(user_id, username)",
    "        self.users[user_id] = user",
    "        return user",
    "    ",
    "    def post_question(self, user_id: str, title: str, body: str, tags: List[str]) -> Optional[Question]:",
    "        if user_id not in self.users:",
    "            return None",
    "        q_id = f\"q_{self.question_counter}\"",
    "        self.question_counter += 1",
    "        question = Question(q_id, user_id, title, body, tags)",
    "        self.questions[q_id] = question",
    "        self.user_questions[user_id].append(q_id)",
    "        for tag in tags:",
    "            self.tag_questions[tag].append(q_id)",
    "        # NEW: Update inverted index",
    "        for word in self._tokenize(title + ' ' + body):",
    "            self.word_index[word].add(q_id)",
    "        return question",
    "    ",
    "    def post_answer(self, user_id: str, question_id: str, body: str) -> Optional[Answer]:",
    "        if question_id not in self.questions or user_id not in self.users:",
    "            return None",
    "        a_id = f\"a_{self.answer_counter}\"",
    "        self.answer_counter += 1",
    "        answer = Answer(a_id, question_id, user_id, body)",
    "        self.answers[a_id] = answer",
    "        self.question_answers[question_id].append(a_id)",
    "        return answer",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        return self.questions.get(question_id)",
    "    ",
    "    def get_answers_for_question(self, question_id: str) -> List[Answer]:",
    "        return [self.answers[aid] for aid in self.question_answers.get(question_id, [])]",
    "    ",
    "    def get_questions_by_user(self, user_id: str) -> List[Question]:",
    "        qids = self.user_questions.get(user_id, [])",
    "        return sorted([self.questions[qid] for qid in qids], key=lambda q: q.created_at, reverse=True)",
    "    ",
    "    def get_questions_by_tag(self, tag: str) -> List[Question]:",
    "        qids = self.tag_questions.get(tag, [])",
    "        return sorted([self.questions[qid] for qid in qids], key=lambda q: q.score, reverse=True)",
    "    ",
    "    # ============ Part 2: Voting System ============",
    "    ",
    "    def _apply_vote(self, voter_id: str, item_id: str, new_vote: int,",
    "                    votes_map: Dict, items_map: Dict) -> int:",
    "        if item_id not in items_map or voter_id not in self.users:",
    "            return -1",
    "        item = items_map[item_id]",
    "        if voter_id == item.author_id:",
    "            return -1",
    "        prev_vote = votes_map[item_id].get(voter_id, 0)",
    "        if prev_vote == new_vote:",
    "            return item.score",
    "        item.score += (new_vote - prev_vote)",
    "        author = self.users[item.author_id]",
    "        if prev_vote == 1:",
    "            author.reputation -= self.REP_UPVOTE",
    "        elif prev_vote == -1:",
    "            author.reputation -= self.REP_DOWNVOTE",
    "        if new_vote == 1:",
    "            author.reputation += self.REP_UPVOTE",
    "        elif new_vote == -1:",
    "            author.reputation += self.REP_DOWNVOTE",
    "        votes_map[item_id][voter_id] = new_vote",
    "        return item.score",
    "    ",
    "    def upvote_question(self, voter_id: str, question_id: str) -> int:",
    "        return self._apply_vote(voter_id, question_id, 1, self.question_votes, self.questions)",
    "    ",
    "    def downvote_question(self, voter_id: str, question_id: str) -> int:",
    "        return self._apply_vote(voter_id, question_id, -1, self.question_votes, self.questions)",
    "    ",
    "    def upvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        return self._apply_vote(voter_id, answer_id, 1, self.answer_votes, self.answers)",
    "    ",
    "    def downvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        return self._apply_vote(voter_id, answer_id, -1, self.answer_votes, self.answers)",
    "    ",
    "    def accept_answer(self, question_author_id: str, answer_id: str) -> bool:",
    "        if answer_id not in self.answers:",
    "            return False",
    "        answer = self.answers[answer_id]",
    "        question = self.questions.get(answer.question_id)",
    "        if not question or question.author_id != question_author_id:",
    "            return False",
    "        if answer.is_accepted:",
    "            return True",
    "        answer.is_accepted = True",
    "        self.users[answer.author_id].reputation += self.REP_ACCEPTED",
    "        return True",
    "    ",
    "    def get_user_reputation(self, user_id: str) -> int:",
    "        return self.users[user_id].reputation if user_id in self.users else 0",
    "    ",
    "    # ============ Part 3: Search and Filtering ============",
    "    ",
    "    def search_questions(self, query: str) -> List[Question]:",
    "        \"\"\"Search questions by text. Returns results sorted by relevance.\"\"\"",
    "        query_words = self._tokenize(query)",
    "        if not query_words:",
    "            return []",
    "        # Count how many query words match each question",
    "        match_counts: Dict[str, int] = defaultdict(int)",
    "        for qw in query_words:",
    "            matched: Set[str] = set()",
    "            for idx_word, q_ids in self.word_index.items():",
    "                if qw in idx_word:  # Partial match",
    "                    matched.update(q_ids)",
    "            for q_id in matched:",
    "                match_counts[q_id] += 1",
    "        results = [self.questions[q_id] for q_id in match_counts]",
    "        results.sort(key=lambda q: (-match_counts[q.id], -q.score))",
    "        return results",
    "    ",
    "    def search_by_tags(self, tags: List[str], match_all: bool) -> List[Question]:",
    "        \"\"\"Filter by tags: match_all=True for AND, False for OR.\"\"\"",
    "        if not tags:",
    "            return []",
    "        tag_sets = [set(self.tag_questions.get(t, [])) for t in tags]",
    "        if match_all:",
    "            result_ids = tag_sets[0].copy()",
    "            for s in tag_sets[1:]:",
    "                result_ids &= s",
    "        else:",
    "            result_ids = set()",
    "            for s in tag_sets:",
    "                result_ids |= s",
    "        results = [self.questions[q_id] for q_id in result_ids]",
    "        results.sort(key=lambda q: -q.score)",
    "        return results",
    "    ",
    "    def get_top_questions(self, limit: int) -> List[Question]:",
    "        \"\"\"Get top questions by score.\"\"\"",
    "        all_qs = list(self.questions.values())",
    "        all_qs.sort(key=lambda q: (-q.score, -q.created_at))",
    "        return all_qs[:limit]",
    "    ",
    "    def get_recent_questions(self, limit: int) -> List[Question]:",
    "        \"\"\"Get most recent questions.\"\"\"",
    "        all_qs = list(self.questions.values())",
    "        all_qs.sort(key=lambda q: -q.created_at)",
    "        return all_qs[:limit]",
    "    ",
    "    def get_unanswered_questions(self) -> List[Question]:",
    "        \"\"\"Get questions with no answers.\"\"\"",
    "        unanswered = [q for q in self.questions.values()",
    "                      if not self.question_answers.get(q.id)]",
    "        unanswered.sort(key=lambda q: -q.created_at)",
    "        return unanswered",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('Part 3: Search and Filtering Demo')",
    "    print('=' * 60)",
    "    ",
    "    so = StackOverflow()",
    "    so.create_user('u1', 'alice')",
    "    so.create_user('u2', 'bob')",
    "    ",
    "    # Create test questions",
    "    q1 = so.post_question('u1', 'Java Help', 'Need help with Java arrays', ['java'])",
    "    q2 = so.post_question('u1', 'Python Help', 'Python list comprehension', ['python'])",
    "    q3 = so.post_question('u2', 'Java Spring Guide', 'Spring Boot with Java', ['java', 'spring'])",
    "    ",
    "    # Test 1: Text search with partial match",
    "    print('\\n--- Test 1: search_questions(\"java\") ---')",
    "    results = so.search_questions('java')",
    "    print(f'Found: {[q.title for q in results]}')",
    "    ",
    "    # Test 2: Multi-word search (relevance ranking)",
    "    print('\\n--- Test 2: search_questions(\"java spring\") ---')",
    "    results = so.search_questions('java spring')",
    "    print(f'Found (by relevance): {[q.title for q in results]}')",
    "    ",
    "    # Test 3: Tag search with AND logic",
    "    print('\\n--- Test 3: search_by_tags([java,spring], match_all=True) ---')",
    "    results = so.search_by_tags(['java', 'spring'], True)",
    "    print(f'AND result: {[q.title for q in results]}')",
    "    ",
    "    # Test 4: Tag search with OR logic",
    "    print('\\n--- Test 4: search_by_tags([java,python], match_all=False) ---')",
    "    results = so.search_by_tags(['java', 'python'], False)",
    "    print(f'OR result: {[q.title for q in results]}')",
    "    ",
    "    # Test 5: Top questions by score",
    "    print('\\n--- Test 5: get_top_questions(2) after voting ---')",
    "    so.upvote_question('u2', 'q_1')",
    "    so.upvote_question('u1', 'q_3')",
    "    so.upvote_question('u2', 'q_3')",
    "    results = so.get_top_questions(2)",
    "    print(f'Top 2: {[(q.title, q.score) for q in results]}')",
    "    ",
    "    # Test 6: Unanswered questions",
    "    print('\\n--- Test 6: get_unanswered_questions() ---')",
    "    so.post_answer('u2', 'q_1', 'Use Arrays.sort()')",
    "    results = so.get_unanswered_questions()",
    "    print(f'Unanswered: {[q.title for q in results]}')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('All Part 3 tests passed!')"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.regex.*;",
    "import java.util.stream.*;",
    "",
    "public class StackOverflow {",
    "    ",
    "    private static final int REP_UPVOTE = 10;",
    "    private static final int REP_DOWNVOTE = -2;",
    "    private static final int REP_ACCEPTED = 15;",
    "    ",
    "    static class User {",
    "        String id, username;",
    "        int reputation = 0;",
    "        User(String id, String username) { this.id = id; this.username = username; }",
    "    }",
    "    ",
    "    static class Question {",
    "        String id, authorId, title, body;",
    "        List<String> tags;",
    "        int score = 0;",
    "        long createdAt;",
    "        Question(String id, String authorId, String title, String body, List<String> tags) {",
    "            this.id = id; this.authorId = authorId; this.title = title;",
    "            this.body = body; this.tags = new ArrayList<>(tags); this.createdAt = System.currentTimeMillis();",
    "        }",
    "    }",
    "    ",
    "    static class Answer {",
    "        String id, questionId, authorId, body;",
    "        int score = 0;",
    "        boolean isAccepted = false;",
    "        long createdAt;",
    "        Answer(String id, String questionId, String authorId, String body) {",
    "            this.id = id; this.questionId = questionId; this.authorId = authorId;",
    "            this.body = body; this.createdAt = System.currentTimeMillis();",
    "        }",
    "    }",
    "    ",
    "    private Map<String, User> users = new HashMap<>();",
    "    private Map<String, Question> questions = new HashMap<>();",
    "    private Map<String, Answer> answers = new HashMap<>();",
    "    private Map<String, List<String>> userQuestions = new HashMap<>();",
    "    private Map<String, List<String>> tagQuestions = new HashMap<>();",
    "    private Map<String, List<String>> questionAnswers = new HashMap<>();",
    "    private Map<String, Map<String, Integer>> questionVotes = new HashMap<>();",
    "    private Map<String, Map<String, Integer>> answerVotes = new HashMap<>();",
    "    // NEW: Inverted index for text search",
    "    private Map<String, Set<String>> wordIndex = new HashMap<>();",
    "    private int questionCounter = 1, answerCounter = 1;",
    "    ",
    "    private Set<String> tokenize(String text) {",
    "        Set<String> words = new HashSet<>();",
    "        Matcher m = Pattern.compile(\"[a-zA-Z0-9]+\").matcher(text.toLowerCase());",
    "        while (m.find()) words.add(m.group());",
    "        return words;",
    "    }",
    "    ",
    "    public User createUser(String userId, String username) {",
    "        return users.computeIfAbsent(userId, k -> new User(userId, username));",
    "    }",
    "    ",
    "    public Question postQuestion(String userId, String title, String body, List<String> tags) {",
    "        if (!users.containsKey(userId)) return null;",
    "        String qId = \"q_\" + questionCounter++;",
    "        Question q = new Question(qId, userId, title, body, tags);",
    "        questions.put(qId, q);",
    "        userQuestions.computeIfAbsent(userId, k -> new ArrayList<>()).add(qId);",
    "        for (String tag : tags) tagQuestions.computeIfAbsent(tag, k -> new ArrayList<>()).add(qId);",
    "        // NEW: Update word index",
    "        for (String word : tokenize(title + \" \" + body)) {",
    "            wordIndex.computeIfAbsent(word, k -> new HashSet<>()).add(qId);",
    "        }",
    "        return q;",
    "    }",
    "    ",
    "    public Answer postAnswer(String userId, String questionId, String body) {",
    "        if (!questions.containsKey(questionId) || !users.containsKey(userId)) return null;",
    "        String aId = \"a_\" + answerCounter++;",
    "        Answer a = new Answer(aId, questionId, userId, body);",
    "        answers.put(aId, a);",
    "        questionAnswers.computeIfAbsent(questionId, k -> new ArrayList<>()).add(aId);",
    "        return a;",
    "    }",
    "    ",
    "    public Question getQuestion(String questionId) { return questions.get(questionId); }",
    "    ",
    "    public List<Answer> getAnswersForQuestion(String questionId) {",
    "        List<String> ids = questionAnswers.getOrDefault(questionId, new ArrayList<>());",
    "        List<Answer> result = new ArrayList<>();",
    "        for (String id : ids) result.add(answers.get(id));",
    "        return result;",
    "    }",
    "    ",
    "    public List<Question> getQuestionsByUser(String userId) {",
    "        List<String> ids = userQuestions.getOrDefault(userId, new ArrayList<>());",
    "        List<Question> result = new ArrayList<>();",
    "        for (String id : ids) result.add(questions.get(id));",
    "        result.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        return result;",
    "    }",
    "    ",
    "    public List<Question> getQuestionsByTag(String tag) {",
    "        List<String> ids = tagQuestions.getOrDefault(tag, new ArrayList<>());",
    "        List<Question> result = new ArrayList<>();",
    "        for (String id : ids) result.add(questions.get(id));",
    "        result.sort((a, b) -> Integer.compare(b.score, a.score));",
    "        return result;",
    "    }",
    "    ",
    "    private int applyVote(String voterId, String itemId, int newVote,",
    "                          Map<String, Map<String, Integer>> votesMap,",
    "                          Map<String, ?> itemsMap, boolean isQuestion) {",
    "        if (!itemsMap.containsKey(itemId) || !users.containsKey(voterId)) return -1;",
    "        String authorId = isQuestion ? ((Question)itemsMap.get(itemId)).authorId",
    "                                     : ((Answer)itemsMap.get(itemId)).authorId;",
    "        if (voterId.equals(authorId)) return -1;",
    "        Map<String, Integer> votes = votesMap.computeIfAbsent(itemId, k -> new HashMap<>());",
    "        int prevVote = votes.getOrDefault(voterId, 0);",
    "        if (prevVote == newVote) {",
    "            return isQuestion ? ((Question)itemsMap.get(itemId)).score : ((Answer)itemsMap.get(itemId)).score;",
    "        }",
    "        int scoreDelta = newVote - prevVote;",
    "        if (isQuestion) ((Question)itemsMap.get(itemId)).score += scoreDelta;",
    "        else ((Answer)itemsMap.get(itemId)).score += scoreDelta;",
    "        User author = users.get(authorId);",
    "        if (prevVote == 1) author.reputation -= REP_UPVOTE;",
    "        else if (prevVote == -1) author.reputation -= REP_DOWNVOTE;",
    "        if (newVote == 1) author.reputation += REP_UPVOTE;",
    "        else if (newVote == -1) author.reputation += REP_DOWNVOTE;",
    "        votes.put(voterId, newVote);",
    "        return isQuestion ? ((Question)itemsMap.get(itemId)).score : ((Answer)itemsMap.get(itemId)).score;",
    "    }",
    "    ",
    "    public int upvoteQuestion(String voterId, String qId) { return applyVote(voterId, qId, 1, questionVotes, questions, true); }",
    "    public int downvoteQuestion(String voterId, String qId) { return applyVote(voterId, qId, -1, questionVotes, questions, true); }",
    "    public int upvoteAnswer(String voterId, String aId) { return applyVote(voterId, aId, 1, answerVotes, answers, false); }",
    "    public int downvoteAnswer(String voterId, String aId) { return applyVote(voterId, aId, -1, answerVotes, answers, false); }",
    "    ",
    "    public void acceptAnswer(String questionAuthorId, String answerId) {",
    "        if (!answers.containsKey(answerId)) return;",
    "        Answer answer = answers.get(answerId);",
    "        Question question = questions.get(answer.questionId);",
    "        if (question == null || !question.authorId.equals(questionAuthorId)) return;",
    "        if (answer.isAccepted) return;",
    "        answer.isAccepted = true;",
    "        users.get(answer.authorId).reputation += REP_ACCEPTED;",
    "    }",
    "    ",
    "    public int getUserReputation(String userId) {",
    "        return users.containsKey(userId) ? users.get(userId).reputation : 0;",
    "    }",
    "    ",
    "    // ============ Part 3: Search and Filtering ============",
    "    ",
    "    public List<Question> searchQuestions(String query) {",
    "        Set<String> queryWords = tokenize(query);",
    "        if (queryWords.isEmpty()) return new ArrayList<>();",
    "        Map<String, Integer> matchCounts = new HashMap<>();",
    "        for (String qw : queryWords) {",
    "            Set<String> matched = new HashSet<>();",
    "            for (Map.Entry<String, Set<String>> e : wordIndex.entrySet()) {",
    "                if (e.getKey().contains(qw)) matched.addAll(e.getValue());",
    "            }",
    "            for (String qId : matched) matchCounts.merge(qId, 1, Integer::sum);",
    "        }",
    "        List<Question> results = new ArrayList<>();",
    "        for (String qId : matchCounts.keySet()) results.add(questions.get(qId));",
    "        results.sort((a, b) -> {",
    "            int cmp = Integer.compare(matchCounts.get(b.id), matchCounts.get(a.id));",
    "            return cmp != 0 ? cmp : Integer.compare(b.score, a.score);",
    "        });",
    "        return results;",
    "    }",
    "    ",
    "    public List<Question> searchByTags(List<String> tags, boolean matchAll) {",
    "        if (tags.isEmpty()) return new ArrayList<>();",
    "        List<Set<String>> tagSets = new ArrayList<>();",
    "        for (String t : tags) tagSets.add(new HashSet<>(tagQuestions.getOrDefault(t, new ArrayList<>())));",
    "        Set<String> resultIds;",
    "        if (matchAll) {",
    "            resultIds = new HashSet<>(tagSets.get(0));",
    "            for (int i = 1; i < tagSets.size(); i++) resultIds.retainAll(tagSets.get(i));",
    "        } else {",
    "            resultIds = new HashSet<>();",
    "            for (Set<String> s : tagSets) resultIds.addAll(s);",
    "        }",
    "        List<Question> results = new ArrayList<>();",
    "        for (String qId : resultIds) results.add(questions.get(qId));",
    "        results.sort((a, b) -> Integer.compare(b.score, a.score));",
    "        return results;",
    "    }",
    "    ",
    "    public List<Question> getTopQuestions(int limit) {",
    "        List<Question> all = new ArrayList<>(questions.values());",
    "        all.sort((a, b) -> b.score != a.score ? Integer.compare(b.score, a.score) : Long.compare(b.createdAt, a.createdAt));",
    "        return all.subList(0, Math.min(limit, all.size()));",
    "    }",
    "    ",
    "    public List<Question> getRecentQuestions(int limit) {",
    "        List<Question> all = new ArrayList<>(questions.values());",
    "        all.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        return all.subList(0, Math.min(limit, all.size()));",
    "    }",
    "    ",
    "    public List<Question> getUnansweredQuestions() {",
    "        List<Question> result = new ArrayList<>();",
    "        for (Question q : questions.values()) {",
    "            if (questionAnswers.getOrDefault(q.id, new ArrayList<>()).isEmpty()) result.add(q);",
    "        }",
    "        result.sort((a, b) -> Long.compare(b.createdAt, a.createdAt));",
    "        return result;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Part 3: Search and Filtering Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        so.createUser(\"u1\", \"alice\");",
    "        so.createUser(\"u2\", \"bob\");",
    "        ",
    "        so.postQuestion(\"u1\", \"Java Help\", \"Need help with Java arrays\", Arrays.asList(\"java\"));",
    "        so.postQuestion(\"u1\", \"Python Help\", \"Python list comprehension\", Arrays.asList(\"python\"));",
    "        so.postQuestion(\"u2\", \"Java Spring Guide\", \"Spring Boot with Java\", Arrays.asList(\"java\", \"spring\"));",
    "        ",
    "        System.out.println(\"\\n--- Test 1: searchQuestions(\\\"java\\\") ---\");",
    "        List<Question> results = so.searchQuestions(\"java\");",
    "        System.out.println(\"Found: \" + results.stream().map(q -> q.title).collect(Collectors.toList()));",
    "        ",
    "        System.out.println(\"\\n--- Test 2: searchByTags([java,spring], matchAll=true) ---\");",
    "        results = so.searchByTags(Arrays.asList(\"java\", \"spring\"), true);",
    "        System.out.println(\"AND: \" + results.stream().map(q -> q.title).collect(Collectors.toList()));",
    "        ",
    "        System.out.println(\"\\n--- Test 3: getTopQuestions(2) ---\");",
    "        so.upvoteQuestion(\"u2\", \"q_3\");",
    "        results = so.getTopQuestions(2);",
    "        System.out.println(\"Top 2: \" + results.stream().map(q -> q.title + \"(\" + q.score + \")\").collect(Collectors.toList()));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "explanation": "Imports including regex for tokenization"
    },
    {
      "lines": "55-57",
      "explanation": "NEW: word_index data structure - inverted index mapping word \u2192 set of question IDs"
    },
    {
      "lines": "59-61",
      "explanation": "_tokenize helper: extracts alphanumeric words, lowercases them, returns as set"
    },
    {
      "lines": "74-77",
      "explanation": "MODIFIED post_question: after creating question, tokenize title+body and add q_id to word_index for each word"
    },
    {
      "lines": "128-143",
      "explanation": "search_questions: tokenize query, find partial matches in index, count matches per question, sort by relevance"
    },
    {
      "lines": "145-160",
      "explanation": "search_by_tags: convert tags to question ID sets, apply intersection (AND) or union (OR), sort by score"
    },
    {
      "lines": "162-172",
      "explanation": "get_top_questions and get_recent_questions: simple sort by score or created_at"
    },
    {
      "lines": "174-179",
      "explanation": "get_unanswered_questions: filter questions with empty answer list, sort by recency"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "search_questions": {
          "complexity": "O(k*W + R log R)",
          "explanation": "k query words \u00d7 W index entries for partial matching, plus sorting R results"
        },
        "search_by_tags": {
          "complexity": "O(T*Q + R log R)",
          "explanation": "T tags \u00d7 Q questions per tag for set operations, plus sorting"
        },
        "get_top_questions": {
          "complexity": "O(Q log Q)",
          "explanation": "Sort all Q questions by score"
        },
        "get_recent_questions": {
          "complexity": "O(Q log Q)",
          "explanation": "Sort all Q questions by time"
        },
        "get_unanswered_questions": {
          "complexity": "O(Q log Q)",
          "explanation": "Filter O(Q) + sort O(Q log Q)"
        },
        "post_question (modified)": {
          "complexity": "O(D)",
          "explanation": "D = words in title+body, added to indexing cost"
        }
      },
      "overall_change": "Search operations are O(k*W) for matching, O(Q log Q) for sorting. Part 1 and 2 operations unchanged."
    },
    "space": {
      "additional_space": "O(W*Q) where W = unique words, Q = questions",
      "explanation": "word_index stores each (word, question_id) pair at most once. In practice, limited by vocabulary size."
    }
  },
  "dry_run": {
    "example_input": "search_questions('java spring') with q_1='Java Help', q_3='Java Spring Guide'",
    "steps": [
      {
        "step": 1,
        "action": "Tokenize query",
        "state": "query_words = {'java', 'spring'}",
        "explanation": "Split and lowercase"
      },
      {
        "step": 2,
        "action": "Process 'java'",
        "state": "Check each index word for 'java' substring",
        "explanation": "'java' in 'java' \u2713, 'java' in 'javascript' \u2713"
      },
      {
        "step": 3,
        "action": "Collect matches for 'java'",
        "state": "matched_for_java = {q_1, q_3}",
        "explanation": "Both questions contain 'java'"
      },
      {
        "step": 4,
        "action": "Increment counts",
        "state": "match_counts = {q_1: 1, q_3: 1}",
        "explanation": "Each matched question gets +1"
      },
      {
        "step": 5,
        "action": "Process 'spring'",
        "state": "matched_for_spring = {q_3}",
        "explanation": "Only q_3 has 'spring'"
      },
      {
        "step": 6,
        "action": "Increment counts",
        "state": "match_counts = {q_1: 1, q_3: 2}",
        "explanation": "q_3 matched both words"
      },
      {
        "step": 7,
        "action": "Sort by relevance",
        "state": "[q_3, q_1]",
        "explanation": "q_3 has higher match count (2 > 1)"
      }
    ],
    "final_output": "[Question(id='q_3', title='Java Spring Guide'), Question(id='q_1', title='Java Help')]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Search 'java' should match question with 'Java' in title (case-insensitive)",
      "Empty query should return empty list"
    ],
    "likely_bugs": [
      "Forgetting to lowercase query words",
      "Not handling empty results",
      "Set mutation during iteration",
      "Off-by-one in limit slicing"
    ],
    "recommended_logs_or_asserts": [
      "assert len(tokenize('Hello World')) == 2",
      "print(f'word_index keys: {list(word_index.keys())[:5]}')",
      "print(f'match_counts: {match_counts}')"
    ],
    "how_to_localize": "1. Check tokenization output. 2. Verify word_index was populated. 3. Check partial matching logic. 4. Verify sorting comparator."
  },
  "edge_cases": [
    {
      "case": "Empty query string",
      "handling": "Return empty list immediately",
      "gotcha": "Don't crash on empty tokenization"
    },
    {
      "case": "Query with no matches",
      "handling": "Return empty list",
      "gotcha": "match_counts will be empty, iteration is safe"
    },
    {
      "case": "AND search with non-existent tag",
      "handling": "Set intersection gives empty result",
      "gotcha": "tag_questions.get returns [] for unknown tag"
    },
    {
      "case": "limit > total questions",
      "handling": "Return all questions",
      "gotcha": "Use min(limit, len(questions))"
    },
    {
      "case": "All questions have answers",
      "handling": "get_unanswered_questions returns empty list",
      "gotcha": "Filter correctly checks answer count"
    }
  ],
  "test_cases": [
    {
      "name": "Partial word matching",
      "input": "Question: 'JavaScript tutorial', Search: 'java'",
      "expected": "Question is returned",
      "explanation": "'java' is substring of 'javascript'"
    },
    {
      "name": "Relevance ranking",
      "input": "Q1 has 'java', Q2 has 'java spring', Search: 'java spring'",
      "expected": "Q2 ranked first (2 matches), Q1 second (1 match)",
      "explanation": "More query words matched = higher relevance"
    },
    {
      "name": "Tag AND vs OR",
      "input": "Q1: tags=[java], Q2: tags=[java, spring], search tags=[java, spring]",
      "expected": "AND returns [Q2], OR returns [Q1, Q2]",
      "explanation": "AND requires all tags, OR requires any"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using exact word match instead of substring",
      "why_wrong": "Problem requires 'java' to match 'JavaScript'",
      "correct_approach": "Check if query_word is IN index_word",
      "code_example_wrong": "if query_word == index_word:",
      "code_example_correct": "if query_word in index_word:"
    },
    {
      "mistake": "Not building index at insert time",
      "why_wrong": "O(Q*D) scan per search is too slow",
      "correct_approach": "Build inverted index in post_question",
      "code_example_wrong": "# In search: for q in questions.values(): if word in q.title...",
      "code_example_correct": "# In post_question: for word in tokenize(title): word_index[word].add(q_id)"
    },
    {
      "mistake": "Counting total word occurrences instead of distinct matches",
      "why_wrong": "Relevance should be count of distinct query words matched",
      "correct_approach": "Use set for each query word's matches before counting",
      "code_example_wrong": "for word in words: count += 1  # counts 'java' twice if in multiple index words",
      "code_example_correct": "matched = set(); for idx_word: if qw in idx_word: matched.update(...); count += len(matched)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying search requirements (partial match? case-insensitive?). Draw the inverted index structure. Explain why we build at insert time vs search time.",
    "what_to_mention": [
      "Inverted index is the classic search pattern",
      "Time-space tradeoff: more storage for faster queries",
      "Set operations for tag filtering are O(n)"
    ],
    "time_allocation": "2 min clarify requirements, 3 min explain inverted index approach, 10 min implement, 2 min test",
    "if_stuck": [
      "Think about how Google indexes web pages",
      "What data structure gives O(1) word lookup?",
      "How would you combine results from multiple search terms?"
    ]
  },
  "connection_to_next_part": "Part 4 might add pagination to search results, more complex ranking (TF-IDF), or real-time indexing updates. The inverted index structure is extensible to support these.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 voting is working. For Part 3, I need to add search functionality. The key insight is building an inverted index at insert time.",
    "explaining_changes": "I'll add a word_index that maps each word to the questions containing it. When posting a question, I tokenize the title and body and update the index. For search, I look up query words and rank by match count.",
    "while_extending_code": [
      "Adding word_index as Dict[str, Set[str]]",
      "Modifying post_question to update the index",
      "The partial match requires checking if query word is substring of index keys"
    ],
    "after_completing": "Search now works with O(k*W) matching where k=query words, W=index size. Tag filtering uses set intersection/union for AND/OR. Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_3_min": "Clarify requirements: partial match, case-insensitive, relevance sorting",
    "by_7_min": "Explain inverted index approach, start implementing word_index and tokenizer",
    "by_12_min": "Complete search_questions, start tag filtering methods",
    "by_17_min": "Complete all methods, testing",
    "warning_signs": "If still designing at 8 min, simplify. Focus on search_questions first."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If word_index isn't being populated, check that post_question calls tokenize. Test tokenizer separately.",
    "if_new_requirement_unclear": "Ask: 'Does partial match mean substring? Should \"java\" match \"java\" in \"I love java\" AND \"javascript\"?'",
    "if_running_behind": "Implement search_questions first (most important). get_top_questions and get_unanswered are trivial sorts - mention verbally if running out of time."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing inverted index pattern",
      "Discussing index update cost vs query cost tradeoff",
      "Mentioning that production systems use Elasticsearch/Lucene",
      "Noting that partial matching is O(W) per query word - could optimize with trie"
    ]
  },
  "pattern_recognition": {
    "pattern": "Inverted Index / Precomputed Lookup Tables",
    "indicators": [
      "'Search' or 'find' in requirements",
      "Need to match text against multiple documents",
      "Query frequency >> insert frequency"
    ],
    "similar_problems": [
      "LC 588 - Design In-Memory File System (path lookup)",
      "Design Twitter search",
      "Implement autocomplete"
    ],
    "template": "word_index = defaultdict(set); on_insert: for word in tokenize(text): word_index[word].add(id); on_search: return union/intersection of word_index[query_word] for each word"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'search', I think inverted index",
      "why": "It's the standard pattern for text search - used by Lucene, Elasticsearch"
    },
    {
      "step": 2,
      "thought": "Partial matching complicates things",
      "why": "Can't do O(1) lookup, need to iterate index keys"
    },
    {
      "step": 3,
      "thought": "Relevance = count distinct matches",
      "why": "Simple but effective - more matching words = more relevant"
    },
    {
      "step": 4,
      "thought": "Tag filtering is just set operations",
      "why": "AND = intersection, OR = union, very clean"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you know inverted index pattern?",
      "Can you extend existing code cleanly?",
      "Do you handle the partial match requirement correctly?"
    ],
    "bonus_points": [
      "Discussing space-time tradeoffs",
      "Mentioning index update cost",
      "Noting production would use Elasticsearch"
    ],
    "red_flags": [
      "Full scan for every search",
      "Breaking existing Part 2 functionality",
      "Ignoring partial match requirement"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for regex pattern for tokenization",
      "Let it generate sort comparator boilerplate"
    ],
    "what_not_to_do": [
      "Don't let AI design the inverted index structure",
      "Understand the partial matching logic yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about partial match semantics",
      "Diving into code without explaining inverted index"
    ],
    "technical": [
      "O(Q*D) scan per search",
      "Forgetting to lowercase",
      "Modifying existing methods unnecessarily"
    ],
    "communication": [
      "Not explaining why inverted index is the right choice",
      "Not mentioning complexity tradeoffs"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does search handle partial matching?",
      "Is search case-insensitive?",
      "Are results sorted by relevance?",
      "Does tag AND/OR work correctly?",
      "Do all Part 1/2 methods still work?"
    ],
    "quick_code_review": [
      "word_index initialized in __init__",
      "post_question updates word_index",
      "tokenize is consistent everywhere",
      "No mutation of shared data structures"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Stemming (run/running \u2192 run)",
      "Stop word filtering (the, a, is)",
      "TF-IDF scoring",
      "Pagination",
      "Elasticsearch integration"
    ],
    "why_not_in_interview": "These are optimizations; core algorithm is what matters",
    "how_to_mention": "Say: 'In production, I'd use Elasticsearch for search. This shows the fundamental algorithm.'"
  },
  "generated_at": "2026-01-19T05:11:27.201491",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}