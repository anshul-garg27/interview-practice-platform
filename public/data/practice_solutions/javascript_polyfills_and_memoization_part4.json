{
  "problem_title": "JavaScript Polyfills & Memoization - Part 4: Array.isArray Polyfill",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "easy",
  "problem_understanding": {
    "what_changes": "Part 4 adds a utility function for type checking that's independent of the previous memoization and bind implementations. This is a standalone polyfill that demonstrates understanding of JavaScript's type system quirks and the reliable Object.prototype.toString technique.",
    "new_requirements": [
      "Implement isArray() that returns true only for actual arrays",
      "Handle null, undefined, and array-like objects correctly",
      "Use the Object.prototype.toString technique for cross-realm safety"
    ],
    "new_constraints": [
      "Must work across iframes (instanceof fails)",
      "Must not be fooled by array-like objects ({length: 0})",
      "Must handle null/undefined without throwing"
    ],
    "key_insight": "Object.prototype.toString.call(value) returns '[object Array]' for arrays - this internal [[Class]] tag cannot be forged and works across JavaScript realms."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Return true for actual arrays",
        "how_met": "Object.prototype.toString.call returns '[object Array]' only for true arrays",
        "gotchas": [
          "Don't use typeof which returns 'object' for arrays"
        ]
      },
      {
        "requirement": "Return false for array-like objects",
        "how_met": "toString returns '[object Object]' for plain objects regardless of length property",
        "gotchas": [
          "NodeList, arguments object, strings have length but aren't arrays"
        ]
      },
      {
        "requirement": "Handle null/undefined safely",
        "how_met": "toString.call(null) returns '[object Null]', not '[object Array]'",
        "gotchas": [
          "typeof null === 'object' is a JavaScript quirk"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "isArray",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Single method call and string comparison"
      }
    ],
    "non_goals": [
      "Type narrowing for TypeScript (bonus)",
      "Supporting subclasses of Array differently"
    ]
  },
  "assumptions": [
    "We're implementing the ES5+ Array.isArray behavior",
    "Cross-realm arrays should return true (main use case for this polyfill)",
    "We don't need to handle proxied arrays specially"
  ],
  "tradeoffs": [
    {
      "decision": "toString vs instanceof",
      "chosen": "Object.prototype.toString.call()",
      "why": "Works across iframes/realms where instanceof fails",
      "alternative": "instanceof Array",
      "when_to_switch": "Never for polyfill; instanceof is simpler but broken for cross-realm"
    },
    {
      "decision": "Constructor check vs toString",
      "chosen": "toString",
      "why": "Constructor can be overwritten",
      "alternative": "arr.constructor === Array",
      "when_to_switch": "Never; constructor can be modified"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Function signature isArray(obj)",
      "Return type boolean"
    ],
    "what_to_change": [
      "This is a simple standalone function, unlikely to need extension"
    ],
    "interfaces_and_boundaries": "isArray is a pure function with no side effects, can be used anywhere",
    "invariants": [
      "Always returns boolean",
      "Never throws for any input"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (typeof check - BROKEN):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 typeof []     \u2192 'object' \u274c   \u2502\n\u2502 typeof {}     \u2192 'object'      \u2502\n\u2502 typeof null   \u2192 'object'      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nAll return 'object'! Can't distinguish.\n\nAFTER (toString check - CORRECT):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 toString.call([])   \u2192 '[object Array]' \u2713  \u2502\n\u2502 toString.call({})   \u2192 '[object Object]'   \u2502\n\u2502 toString.call(null) \u2192 '[object Null]'     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nEach type has unique string!\n```",
    "algorithm_flow": "```\nisArray(value):\n  1. Call Object.prototype.toString with value as 'this'\n  2. Get internal [[Class]] tag as string\n  3. Compare with '[object Array]'\n  4. Return true/false\n\nExample:\n  isArray([1,2,3])\n  \u2514\u2500> toString.call([1,2,3])\n      \u2514\u2500> '[object Array]'\n          \u2514\u2500> === '[object Array]' \u2192 true\n\n  isArray({length: 0})\n  \u2514\u2500> toString.call({length:0})\n      \u2514\u2500> '[object Object]'\n          \u2514\u2500> === '[object Array]' \u2192 false\n```"
  },
  "approaches": [
    {
      "name": "typeof Check (Broken)",
      "description": "Check if typeof value === 'object' && typeof value.length === 'number'",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "why_not_optimal": "Returns true for strings, NodeList, arguments, and array-like objects. Also fails for null."
    },
    {
      "name": "instanceof Check (Partially Broken)",
      "description": "Check value instanceof Array",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "why_not_optimal": "Fails across iframes - each iframe has its own Array constructor."
    },
    {
      "name": "Object.prototype.toString (Optimal)",
      "description": "Use Object.prototype.toString.call(value) === '[object Array]'",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "key_insight": "The internal [[Class]] tag is reliable, cannot be forged, and works across realms."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The **Object.prototype.toString** method returns a string like `'[object Type]'` where Type is the internal `[[Class]]` of the value. For arrays, this is always `'[object Array]'`.\n\n**Why this works:**\n1. The `[[Class]]` internal slot is set when the object is created\n2. It cannot be changed or spoofed\n3. It's the same regardless of which realm created the array\n\n**Key Point:** We must use `.call(value)` to set the `this` context, otherwise toString would be called on the prototype object itself.",
    "data_structures": [],
    "algorithm_steps": [
      "Step 1: Call Object.prototype.toString.call(value) to get the type string",
      "Step 2: Compare result with '[object Array]'",
      "Step 3: Return true if match, false otherwise"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Part 4: Array.isArray Polyfill - Python Conceptual Equivalent",
    "",
    "Note: Python doesn't have cross-realm issues like JavaScript.",
    "The JavaScript implementation is the canonical solution.",
    "\"\"\"",
    "from functools import wraps, partial",
    "from typing import Callable, Any, Tuple",
    "",
    "",
    "# ============ Part 1 & 2: Previous implementations (unchanged) ============",
    "# (memoize and memoize_async from previous parts remain here)",
    "",
    "",
    "# ============ Part 3: Bind Polyfill Concept (unchanged) ============",
    "def my_bind(fn: Callable, this_arg: Any, *bound_args) -> Callable:",
    "    \"\"\"Python equivalent of JavaScript's Function.prototype.bind.\"\"\"",
    "    @wraps(fn)",
    "    def bound(*new_args):",
    "        all_args = bound_args + new_args",
    "        return fn(this_arg, *all_args)",
    "    return bound",
    "",
    "",
    "class MethodBinder:",
    "    \"\"\"Class-based binder simulating constructor behavior.\"\"\"",
    "    ",
    "    def __init__(self, fn: Callable, this_arg: Any, *bound_args):",
    "        self.fn = fn",
    "        self.this_arg = this_arg",
    "        self.bound_args = bound_args",
    "    ",
    "    def __call__(self, *new_args):",
    "        all_args = self.bound_args + new_args",
    "        return self.fn(self.this_arg, *all_args)",
    "    ",
    "    def construct(self, *new_args):",
    "        all_args = self.bound_args + new_args",
    "        return self.fn(None, *all_args)",
    "",
    "",
    "# ============ Part 4: Array.isArray Polyfill ============",
    "def is_array(obj: Any) -> bool:",
    "    \"\"\"",
    "    Check if obj is an array (list in Python).",
    "    ",
    "    Python equivalent of JavaScript's Array.isArray().",
    "    Uses isinstance() since Python doesn't have cross-realm issues.",
    "    \"\"\"",
    "    return isinstance(obj, list)",
    "",
    "",
    "# JavaScript canonical solution",
    "JAVASCRIPT_IS_ARRAY = '''",
    "/**",
    " * Part 4: Array.isArray Polyfill",
    " * ",
    " * Why different approaches fail:",
    " * - typeof: returns 'object' for arrays, objects, and null",
    " * - instanceof: fails across iframes (different Array constructors)",
    " * - constructor check: can be overwritten",
    " * ",
    " * Object.prototype.toString returns internal [[Class]] tag",
    " * that cannot be forged and works across realms.",
    " */",
    "function isArray(value) {",
    "    return Object.prototype.toString.call(value) === '[object Array]';",
    "}",
    "",
    "// Alternative: Attach to Array if not present",
    "if (!Array.isArray) {",
    "    Array.isArray = function(value) {",
    "        return Object.prototype.toString.call(value) === '[object Array]';",
    "    };",
    "}",
    "'''",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('ARRAY.ISARRAY POLYFILL (Python Equivalent)')",
    "    print('=' * 60)",
    "    ",
    "    # Test 1: Actual arrays",
    "    print('\\n[Test 1] Actual arrays:')",
    "    print(f'  is_array([])         = {is_array([])}')",
    "    print(f'  is_array([1, 2, 3])  = {is_array([1, 2, 3])}')",
    "    print(f'  is_array(list())     = {is_array(list())}')",
    "    ",
    "    # Test 2: Array-like objects (should be False)",
    "    print('\\n[Test 2] Array-like objects:')",
    "    print(f'  is_array(\"array\")        = {is_array(\"array\")}')",
    "    print(f'  is_array({{\"length\": 0}}) = {is_array({\"length\": 0})}')",
    "    print(f'  is_array((1, 2, 3))      = {is_array((1, 2, 3))}')",
    "    ",
    "    # Test 3: Edge cases",
    "    print('\\n[Test 3] Edge cases:')",
    "    print(f'  is_array(None)      = {is_array(None)}')",
    "    print(f'  is_array(42)        = {is_array(42)}')",
    "    print(f'  is_array({{}})        = {is_array({})}')",
    "    ",
    "    # Test 4: Demonstrating why typeof fails in JS",
    "    print('\\n[Test 4] Why typeof fails in JavaScript:')",
    "    print('  typeof []     -> \"object\"  (not useful!)')",
    "    print('  typeof {}     -> \"object\"')",
    "    print('  typeof null   -> \"object\"')",
    "    print('\\n  But Object.prototype.toString.call():')",
    "    print('  toString([])     -> \"[object Array]\"   \u2713')",
    "    print('  toString({})     -> \"[object Object]\"')",
    "    print('  toString(null)   -> \"[object Null]\"')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('JavaScript canonical solution:')",
    "    print(JAVASCRIPT_IS_ARRAY)",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.function.*;",
    "",
    "/**",
    " * Part 4: Array.isArray Polyfill - Java Conceptual Equivalent",
    " * ",
    " * Java has proper array types, so instanceof works fine.",
    " * The JavaScript implementation is the canonical solution.",
    " */",
    "public class ArrayIsArrayPolyfill {",
    "    ",
    "    // ============ Part 3: Bind Polyfill (unchanged) ============",
    "    @FunctionalInterface",
    "    public interface VarArgsFunction<R> {",
    "        R apply(Object... args);",
    "    }",
    "    ",
    "    @FunctionalInterface",
    "    public interface BoundMethod<T, R> {",
    "        R apply(T thisArg, Object... args);",
    "    }",
    "    ",
    "    public static <R> VarArgsFunction<R> bind(",
    "            VarArgsFunction<R> fn, Object... boundArgs) {",
    "        return (Object... newArgs) -> {",
    "            Object[] allArgs = new Object[boundArgs.length + newArgs.length];",
    "            System.arraycopy(boundArgs, 0, allArgs, 0, boundArgs.length);",
    "            System.arraycopy(newArgs, 0, allArgs, boundArgs.length, newArgs.length);",
    "            return fn.apply(allArgs);",
    "        };",
    "    }",
    "    ",
    "    // ============ Part 4: Array.isArray Polyfill ============",
    "    ",
    "    /**",
    "     * Check if obj is an array.",
    "     * Java equivalent of JavaScript's Array.isArray().",
    "     * ",
    "     * In Java, Class.isArray() reliably detects array types.",
    "     * Works for Object[], int[], String[], etc.",
    "     */",
    "    public static boolean isArray(Object obj) {",
    "        return obj != null && obj.getClass().isArray();",
    "    }",
    "    ",
    "    /**",
    "     * Check if obj is specifically an Object array (not primitive).",
    "     * Closer to JavaScript arrays which are always Object arrays.",
    "     */",
    "    public static boolean isObjectArray(Object obj) {",
    "        return obj instanceof Object[];",
    "    }",
    "    ",
    "    // JavaScript canonical solution",
    "    public static final String JAVASCRIPT_SOLUTION = \"\"\"",
    "        /**",
    "         * Part 4: Array.isArray Polyfill",
    "         */",
    "        function isArray(value) {",
    "            return Object.prototype.toString.call(value) === '[object Array]';",
    "        }",
    "        ",
    "        // Attach to Array if not present",
    "        if (!Array.isArray) {",
    "            Array.isArray = function(value) {",
    "                return Object.prototype.toString.call(value) === '[object Array]';",
    "            };",
    "        }",
    "        \"\"\";",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"ARRAY.ISARRAY POLYFILL (Java Equivalent)\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Test 1: Actual arrays",
    "        System.out.println(\"\\n[Test 1] Actual arrays:\");",
    "        System.out.println(\"  isArray(new int[0])       = \" + isArray(new int[0]));",
    "        System.out.println(\"  isArray(new Object[]{1})  = \" + isArray(new Object[]{1, 2}));",
    "        System.out.println(\"  isArray(new String[]{})   = \" + isArray(new String[]{}));",
    "        ",
    "        // Test 2: Non-arrays (should be False)",
    "        System.out.println(\"\\n[Test 2] Non-arrays:\");",
    "        System.out.println(\"  isArray(\\\"array\\\")       = \" + isArray(\"array\"));",
    "        System.out.println(\"  isArray(new ArrayList()) = \" + isArray(new ArrayList<>()));",
    "        System.out.println(\"  isArray(new HashMap())   = \" + isArray(new HashMap<>()));",
    "        ",
    "        // Test 3: Edge cases",
    "        System.out.println(\"\\n[Test 3] Edge cases:\");",
    "        System.out.println(\"  isArray(null)    = \" + isArray(null));",
    "        System.out.println(\"  isArray(42)      = \" + isArray(42));",
    "        System.out.println(\"  isArray(3.14)    = \" + isArray(3.14));",
    "        ",
    "        // Test 4: Object arrays vs primitive arrays",
    "        System.out.println(\"\\n[Test 4] Object vs primitive arrays:\");",
    "        System.out.println(\"  isObjectArray(new int[]{1})    = \" + isObjectArray(new int[]{1}));",
    "        System.out.println(\"  isObjectArray(new Integer[]{}) = \" + isObjectArray(new Integer[]{}));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"JavaScript canonical solution:\");",
    "        System.out.println(JAVASCRIPT_SOLUTION);",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-5",
      "explanation": "Imports and class declaration with documentation"
    },
    {
      "lines": "38-48",
      "explanation": "isArray method: null check + Class.isArray() for reliable detection"
    },
    {
      "lines": "50-58",
      "explanation": "isObjectArray variant: specifically checks Object[] using instanceof"
    },
    {
      "lines": "60-75",
      "explanation": "JavaScript canonical solution using Object.prototype.toString"
    },
    {
      "lines": "77-110",
      "explanation": "Comprehensive tests covering arrays, non-arrays, and edge cases"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "isArray": {
          "complexity": "O(1)",
          "explanation": "Single null check and type introspection call"
        }
      },
      "overall_change": "No change to previous parts. isArray is independent O(1) operation."
    },
    "space": {
      "additional_space": "O(1)",
      "explanation": "Pure function with no data storage. Only returns boolean."
    }
  },
  "dry_run": {
    "example_input": "isArray([1, 2, 3]), isArray({length: 0}), isArray(null)",
    "steps": [
      {
        "step": 1,
        "action": "isArray([1, 2, 3])",
        "state": "value = [1,2,3]",
        "explanation": "toString.call returns '[object Array]', matches target string"
      },
      {
        "step": 2,
        "action": "Return comparison result",
        "state": "'[object Array]' === '[object Array]'",
        "explanation": "Returns true"
      },
      {
        "step": 3,
        "action": "isArray({length: 0})",
        "state": "value = {length: 0}",
        "explanation": "toString.call returns '[object Object]', not Array"
      },
      {
        "step": 4,
        "action": "Return comparison result",
        "state": "'[object Object]' === '[object Array]'",
        "explanation": "Returns false"
      },
      {
        "step": 5,
        "action": "isArray(null)",
        "state": "value = null",
        "explanation": "toString.call returns '[object Null]'"
      },
      {
        "step": 6,
        "action": "Return comparison result",
        "state": "'[object Null]' === '[object Array]'",
        "explanation": "Returns false"
      }
    ],
    "final_output": "[true, false, false]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "isArray([]) should be true",
      "isArray({}) should be false"
    ],
    "likely_bugs": [
      "Using instanceof instead of toString (fails cross-realm)",
      "Forgetting .call() - would check prototype not value"
    ],
    "recommended_logs_or_asserts": [
      "console.log(Object.prototype.toString.call(value)) to see actual type string"
    ],
    "how_to_localize": "If wrong result, log the toString output to see what type string is returned"
  },
  "edge_cases": [
    {
      "case": "Empty array []",
      "handling": "Returns true - still an array",
      "gotcha": "Some might think empty = falsy"
    },
    {
      "case": "null",
      "handling": "Returns false - toString returns '[object Null]'",
      "gotcha": "typeof null === 'object' trap"
    },
    {
      "case": "undefined",
      "handling": "Returns false - toString returns '[object Undefined]'",
      "gotcha": "Must handle gracefully"
    },
    {
      "case": "Array-like objects",
      "handling": "Returns false - {length: 0} is Object not Array",
      "gotcha": "NodeList, arguments are NOT arrays"
    },
    {
      "case": "Strings",
      "handling": "Returns false - toString returns '[object String]'",
      "gotcha": "Strings have length, are iterable, but not arrays"
    },
    {
      "case": "new Array()",
      "handling": "Returns true - same as []",
      "gotcha": "Constructor or literal, both are arrays"
    }
  ],
  "test_cases": [
    {
      "name": "Basic array detection",
      "input": "isArray([1, 2, 3])",
      "expected": "true",
      "explanation": "Standard array literal returns true"
    },
    {
      "name": "Empty array",
      "input": "isArray([])",
      "expected": "true",
      "explanation": "Empty array is still an array"
    },
    {
      "name": "Array-like object",
      "input": "isArray({length: 0})",
      "expected": "false",
      "explanation": "Object with length property is NOT an array"
    },
    {
      "name": "String (iterable but not array)",
      "input": "isArray('array')",
      "expected": "false",
      "explanation": "Strings have length and are iterable but are not arrays"
    },
    {
      "name": "null handling",
      "input": "isArray(null)",
      "expected": "false",
      "explanation": "null is not an array, even though typeof null === 'object'"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using typeof check",
      "why_wrong": "typeof [] returns 'object', same as {}, null",
      "correct_approach": "Use Object.prototype.toString.call()",
      "code_example_wrong": "function isArray(v) { return typeof v === 'object'; }",
      "code_example_correct": "function isArray(v) { return Object.prototype.toString.call(v) === '[object Array]'; }"
    },
    {
      "mistake": "Using instanceof",
      "why_wrong": "Fails across iframes - each has own Array constructor",
      "correct_approach": "Use Object.prototype.toString.call()",
      "code_example_wrong": "function isArray(v) { return v instanceof Array; }",
      "code_example_correct": "function isArray(v) { return Object.prototype.toString.call(v) === '[object Array]'; }"
    },
    {
      "mistake": "Forgetting .call()",
      "why_wrong": "Without .call(), toString is called on prototype, not value",
      "correct_approach": "Always use .call(value) to set the 'this' context",
      "code_example_wrong": "Object.prototype.toString(value)",
      "code_example_correct": "Object.prototype.toString.call(value)"
    },
    {
      "mistake": "Checking constructor property",
      "why_wrong": "Constructor can be overwritten: arr.constructor = Object",
      "correct_approach": "toString [[Class]] cannot be forged",
      "code_example_wrong": "function isArray(v) { return v && v.constructor === Array; }",
      "code_example_correct": "function isArray(v) { return Object.prototype.toString.call(v) === '[object Array]'; }"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining WHY typeof and instanceof fail, then present the toString solution as the reliable alternative.",
    "what_to_mention": [
      "Cross-realm/iframe issue with instanceof",
      "typeof [] === 'object' JavaScript quirk",
      "Internal [[Class]] tag concept",
      "This is how lodash, jQuery, and native Array.isArray work"
    ],
    "time_allocation": "5-8 minutes: 2 min explaining the problem, 3 min implementation, 2 min edge cases",
    "if_stuck": [
      "Think about what makes arrays unique internally",
      "Consider how typeof fails for multiple types"
    ]
  },
  "connection_to_next_part": "Part 4 demonstrates type introspection techniques. Future parts might involve implementing other type checking utilities like isObject, isFunction, or exploring the Reflect API.",
  "communication_script": {
    "transition_from_previous": "Great, Part 3's bind polyfill is complete. Part 4 asks for Array.isArray. This is actually tricky because JavaScript's typeof returns 'object' for arrays, objects, AND null!",
    "explaining_changes": "The key insight is using Object.prototype.toString.call() which returns an internal [[Class]] tag like '[object Array]'. This can't be forged and works across iframes.",
    "while_extending_code": [
      "I'm adding isArray as a standalone utility function",
      "This doesn't depend on previous parts, but fits the polyfills theme"
    ],
    "after_completing": "isArray is O(1) - just one method call and string comparison. It handles all edge cases including null, undefined, and array-like objects."
  },
  "time_milestones": {
    "time_budget": "5-10 minutes for this easy part",
    "by_2_min": "Explain why typeof and instanceof fail",
    "by_5_min": "Implementation complete with toString approach",
    "by_8_min": "Edge cases discussed and tested",
    "warning_signs": "If spending more than 3 min on implementation, move faster - this is a one-liner"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 4 is independent, so Part 3 bugs don't affect it",
    "if_new_requirement_unclear": "Ask: 'Should this detect typed arrays like Int8Array, or just regular arrays?'",
    "if_running_behind": "Just write the one-liner: Object.prototype.toString.call(v) === '[object Array]'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning the cross-realm/iframe issue without prompting",
      "Knowing this is how ES5's Array.isArray was polyfilled",
      "Explaining [[Class]] internal slot concept",
      "Mentioning typeof null === 'object' JavaScript bug"
    ]
  },
  "pattern_recognition": {
    "pattern": "Type Introspection via toString",
    "indicators": [
      "Need to distinguish arrays from objects",
      "typeof returns same value for different types",
      "Cross-realm compatibility needed"
    ],
    "similar_problems": [
      "isObject implementation",
      "isFunction implementation",
      "getType utility",
      "Deep equality with type checking"
    ],
    "template": "Object.prototype.toString.call(value) === '[object TypeName]'"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'typeof returns object for arrays', I immediately think about the toString hack",
      "why": "Because typeof is famously unreliable for distinguishing objects"
    },
    {
      "step": 2,
      "thought": "The cross-realm issue with instanceof is classic interview knowledge",
      "why": "It's why libraries like lodash exist"
    },
    {
      "step": 3,
      "thought": "Object.prototype.toString is the canonical solution",
      "why": "It accesses the internal [[Class]] slot that cannot be modified"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you know JavaScript's type system quirks?",
      "Can you explain why simpler approaches fail?",
      "Do you know the standard solution?"
    ],
    "bonus_points": [
      "Mentioning iframe/cross-realm issues",
      "Knowing this is how native Array.isArray works",
      "Discussing [[Class]] internal slot"
    ],
    "red_flags": [
      "Using typeof === 'object'",
      "Using instanceof without acknowledging its limits",
      "Not knowing about toString approach"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI autocomplete the toString string '[object Array]'"
    ],
    "what_not_to_do": [
      "Don't accept instanceof-based solutions without discussion"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to implementation without explaining why typeof fails"
    ],
    "technical": [
      "Using broken approaches like instanceof or typeof"
    ],
    "communication": [
      "Not explaining the cross-realm issue"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does it handle null and undefined?",
      "Does it return false for array-like objects?",
      "Did I use .call() not just .toString()?",
      "Did I explain why simpler approaches fail?"
    ],
    "quick_code_review": [
      "String comparison is exact: '[object Array]'",
      "No null check needed - toString handles it"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "TypeScript type guard: obj is any[]",
      "Support for typed arrays if needed"
    ],
    "why_not_in_interview": "Core algorithm is the focus",
    "how_to_mention": "Say: 'In TypeScript, I'd add type narrowing so after isArray check, TypeScript knows it's an array.'"
  },
  "generated_at": "2026-01-19T05:04:27.892232",
  "_meta": {
    "problem_id": "javascript_polyfills_and_memoization",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}